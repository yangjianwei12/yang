<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Trap API: BLUESTACK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__trapset__bluestack.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLUESTACK<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10725ea9d3d838056f05bdb533b3986d"><td class="memItemLeft" align="right" valign="top">InquiryPriority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga10725ea9d3d838056f05bdb533b3986d">InquiryGetPriority</a> (void)</td></tr>
<tr class="memdesc:ga10725ea9d3d838056f05bdb533b3986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return 0.  <a href="#ga10725ea9d3d838056f05bdb533b3986d">More...</a><br/></td></tr>
<tr class="separator:ga10725ea9d3d838056f05bdb533b3986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga65db1eff3aadbff0b93ea396cc0e81b0">InquirySetPriority</a> (InquiryPriority priority)</td></tr>
<tr class="memdesc:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Bluetooth inquiry procedure.  <a href="#ga65db1eff3aadbff0b93ea396cc0e81b0">More...</a><br/></td></tr>
<tr class="separator:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga95b9d502d69a5d4e42cc3b9334c94b32">MessageBlueStackTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a task to handle BlueStack primitives.  <a href="#ga95b9d502d69a5d4e42cc3b9334c94b32">More...</a><br/></td></tr>
<tr class="separator:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42258c3f94266def6c7c6e0276813179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga42258c3f94266def6c7c6e0276813179">MessageLinkStatusTrackingTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga42258c3f94266def6c7c6e0276813179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register Link Status Tracking events task. Register a task to receive periodic MESSAGE_LINK_STATUS messages.  <a href="#ga42258c3f94266def6c7c6e0276813179">More...</a><br/></td></tr>
<tr class="separator:ga42258c3f94266def6c7c6e0276813179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378f5ea324518f9151ef99afff6bbe62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga378f5ea324518f9151ef99afff6bbe62">SinkEnableLinkStatusTracking</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, bool enable, uint16 period)</td></tr>
<tr class="memdesc:ga378f5ea324518f9151ef99afff6bbe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the A2DP link quality status tracking and update the evaluation period for quality assessment. On supported devices this will enable the periodic MESSAGE_LINK_STATUS to be sent to the task registered with <a class="el" href="group__trapset__bluestack.html#ga42258c3f94266def6c7c6e0276813179" title="Register Link Status Tracking events task. Register a task to receive periodic MESSAGE_LINK_STATUS me...">MessageLinkStatusTrackingTask()</a>. The traps works for an Audio Source application taking the L2CAP stream sink ID to identify the ACL connection for which status events are required. Link Status Messages can only be enabled on one link at a time. A second request for a different sink ID will fail unless the initial request is disabled. The supported periodicity for these events is 50-1000ms.  <a href="#ga378f5ea324518f9151ef99afff6bbe62">More...</a><br/></td></tr>
<tr class="separator:ga378f5ea324518f9151ef99afff6bbe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5789ebdfd7814f743c051b45289b58b6"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5789ebdfd7814f743c051b45289b58b6">SinkGetL2capCid</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga5789ebdfd7814f743c051b45289b58b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the L2CAP channel id corresponding to a sink.  <a href="#ga5789ebdfd7814f743c051b45289b58b6">More...</a><br/></td></tr>
<tr class="separator:ga5789ebdfd7814f743c051b45289b58b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8993b3833971180e7154a9d8e100832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gad8993b3833971180e7154a9d8e100832">SinkPollAwayTime</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 *msec)</td></tr>
<tr class="memdesc:gad8993b3833971180e7154a9d8e100832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the away time on the underlying ACL. The away time is the time since any packet was received on that ACL and is reported in milliseconds. If the time exceeds 0xFFFF, 0xFFFF will be returned (this is unlikely with sensible link supervision timeouts.)  <a href="#gad8993b3833971180e7154a9d8e100832">More...</a><br/></td></tr>
<tr class="separator:gad8993b3833971180e7154a9d8e100832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302ee1d73c8e58128243c763a3c77234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga302ee1d73c8e58128243c763a3c77234">StreamHciTapSource</a> (void)</td></tr>
<tr class="memdesc:ga302ee1d73c8e58128243c763a3c77234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Stream HCI TAP object and return the source.  <a href="#ga302ee1d73c8e58128243c763a3c77234">More...</a><br/></td></tr>
<tr class="separator:ga302ee1d73c8e58128243c763a3c77234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382089ef9cc353b61de31b31c47ceae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga382089ef9cc353b61de31b31c47ceae3">StreamL2capSink</a> (uint16 cid)</td></tr>
<tr class="memdesc:ga382089ef9cc353b61de31b31c47ceae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Sink corresponding to an L2CAP connection.  <a href="#ga382089ef9cc353b61de31b31c47ceae3">More...</a><br/></td></tr>
<tr class="separator:ga382089ef9cc353b61de31b31c47ceae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1fcd189669b92707329c3cfadb37d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gaae1fcd189669b92707329c3cfadb37d5">VmBdAddrGetRssi</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr, int16 *rssi)</td></tr>
<tr class="memdesc:gaae1fcd189669b92707329c3cfadb37d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RSSI for the ACL with given remote device.  <a href="#gaae1fcd189669b92707329c3cfadb37d5">More...</a><br/></td></tr>
<tr class="separator:gaae1fcd189669b92707329c3cfadb37d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b">VmCisConnGetRssi</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpbdaddr, uint16 handle, int16 *rssi)</td></tr>
<tr class="memdesc:ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RSSI for the CIS handle with the remote device.  <a href="#ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b">More...</a><br/></td></tr>
<tr class="separator:ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cf7f61ce5b649757798909457ab52a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gaf1cf7f61ce5b649757798909457ab52a">VmGetAclLinkQuality</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address, uint16 *link_quality)</td></tr>
<tr class="memdesc:gaf1cf7f61ce5b649757798909457ab52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the ACL rx link quality. This trap is intended to support 'wireless' debugging of link issues for example as a 'quantitative' metric to compare the quality of the primary's and secondary's receptions from the remote Bluetooth device. Only EDR ACL links are supported and not LE links. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices as their radios don't implement this feature.  <a href="#gaf1cf7f61ce5b649757798909457ab52a">More...</a><br/></td></tr>
<tr class="separator:gaf1cf7f61ce5b649757798909457ab52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga4eb51076a93f160ca1ae2ba1db45681a">VmGetAclMode</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address)</td></tr>
<tr class="memdesc:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mode of the defined ACL connection.  <a href="#ga4eb51076a93f160ca1ae2ba1db45681a">More...</a><br/></td></tr>
<tr class="separator:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga9576d235fcdbdfed5df63c8e79e490b3">VmGetAclRole</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address)</td></tr>
<tr class="memdesc:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the role of the defined ACL connection.  <a href="#ga9576d235fcdbdfed5df63c8e79e490b3">More...</a><br/></td></tr>
<tr class="separator:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e104a1dc884af12dbccd18a608018fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga6e104a1dc884af12dbccd18a608018fa">VmGetBdAddrtFromCid</a> (uint16 cid, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:ga6e104a1dc884af12dbccd18a608018fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value.  <a href="#ga6e104a1dc884af12dbccd18a608018fa">More...</a><br/></td></tr>
<tr class="separator:ga6e104a1dc884af12dbccd18a608018fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29e1496922249cd04d17dd64558faab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab">VmGetHandleFromPointer</a> (void *pointer)</td></tr>
<tr class="memdesc:gac29e1496922249cd04d17dd64558faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must:  <a href="#gac29e1496922249cd04d17dd64558faab">More...</a><br/></td></tr>
<tr class="separator:gac29e1496922249cd04d17dd64558faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga64c8a83677acdc389f0b3454c4ea7b7f">VmGetLocalIrk</a> (<a class="el" href="structpacked__irk.html">packed_irk</a> *irk)</td></tr>
<tr class="memdesc:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves local IRK (Identity Resolving Key) of the device.  <a href="#ga64c8a83677acdc389f0b3454c4ea7b7f">More...</a><br/></td></tr>
<tr class="separator:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7">VmGetPointerFromHandle</a> (void *handle)</td></tr>
<tr class="memdesc:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS.  <a href="#ga5caccd8ae3cfa1246373caffe1d218b7">More...</a><br/></td></tr>
<tr class="separator:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1258d4e01d5cec00dd9a21ae73ed9966">VmGetPublicAddress</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *random_addr, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *public_addr)</td></tr>
<tr class="memdesc:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves public device address or static random address for a given resolvable random address. Note: To be used only on an established link.  <a href="#ga1258d4e01d5cec00dd9a21ae73ed9966">More...</a><br/></td></tr>
<tr class="separator:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5d78960f4bdd7bc5a00f305650964ba4">VmGetScoStatistics</a> (uint16 handle, sco_statistics_t *sco_stats)</td></tr>
<tr class="memdesc:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read SCO statistics for the given SCO connection. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices.  <a href="#ga5d78960f4bdd7bc5a00f305650964ba4">More...</a><br/></td></tr>
<tr class="separator:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga2f6a871c7336b62f171fa4302c24e00e">VmOverrideL2capConnContext</a> (uint16 cid, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga2f6a871c7336b62f171fa4302c24e00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override L2CAP connecton context.  <a href="#ga2f6a871c7336b62f171fa4302c24e00e">More...</a><br/></td></tr>
<tr class="separator:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717489e28b88057dde0c6e96c1137dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga717489e28b88057dde0c6e96c1137dce">VmOverrideRfcommConnContext</a> (uint16 conn_id, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga717489e28b88057dde0c6e96c1137dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override RFCOMM connecton context.  <a href="#ga717489e28b88057dde0c6e96c1137dce">More...</a><br/></td></tr>
<tr class="separator:ga717489e28b88057dde0c6e96c1137dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga25d4e01659e990ebc0b77ceb832869c8">VmOverrideSyncConnContext</a> (uint16 handle, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga25d4e01659e990ebc0b77ceb832869c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override DM Sync connecton context.  <a href="#ga25d4e01659e990ebc0b77ceb832869c8">More...</a><br/></td></tr>
<tr class="separator:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e6971ddeacbee25ef2b7b6a5cdebdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga85e6971ddeacbee25ef2b7b6a5cdebdc">VmReadNextSniffClock</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr, next_sniff_clock_t *next_sniff)</td></tr>
<tr class="memdesc:ga85e6971ddeacbee25ef2b7b6a5cdebdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system clock values for the next Sniff instant and the next Sniff Subrating instant on the connection for the given bluetooth address. The next_sniff_clock values give the time in microseconds for the next sniff instant.  <a href="#ga85e6971ddeacbee25ef2b7b6a5cdebdc">More...</a><br/></td></tr>
<tr class="separator:ga85e6971ddeacbee25ef2b7b6a5cdebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7349b61ec91e3078739b24c9832f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga0c7349b61ec91e3078739b24c9832f64">VmSendDmPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga0c7349b61ec91e3078739b24c9832f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a DM Bluestack primitive.  <a href="#ga0c7349b61ec91e3078739b24c9832f64">More...</a><br/></td></tr>
<tr class="separator:ga0c7349b61ec91e3078739b24c9832f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623628caf10541c84058d562a909b329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga623628caf10541c84058d562a909b329">VmSendL2capPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga623628caf10541c84058d562a909b329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an L2CAP Bluestack primitive.  <a href="#ga623628caf10541c84058d562a909b329">More...</a><br/></td></tr>
<tr class="separator:ga623628caf10541c84058d562a909b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2a62ea647b44972a997650ffb74938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1b2a62ea647b44972a997650ffb74938">VmSendSdpPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga1b2a62ea647b44972a997650ffb74938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an SDP Bluestack primitive.  <a href="#ga1b2a62ea647b44972a997650ffb74938">More...</a><br/></td></tr>
<tr class="separator:ga1b2a62ea647b44972a997650ffb74938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaffd14325353278ea2e684f06b14c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gacbaffd14325353278ea2e684f06b14c1">VmUpdateRootKeys</a> (<a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *root_keys)</td></tr>
<tr class="memdesc:gacbaffd14325353278ea2e684f06b14c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap.  <a href="#gacbaffd14325353278ea2e684f06b14c1">More...</a><br/></td></tr>
<tr class="separator:gacbaffd14325353278ea2e684f06b14c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga10725ea9d3d838056f05bdb533b3986d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InquiryPriority InquiryGetPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The current priority level. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65db1eff3aadbff0b93ea396cc0e81b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool InquirySetPriority </td>
          <td>(</td>
          <td class="paramtype">InquiryPriority&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Bluetooth inquiry procedure. </p>
<pre class="fragment">fileThese functions can be used to change the details of how BlueCore
</pre><p> schedules Bluetooth inquiry relative to other Bluetooth activity. They are equivalent to the Inquiry_Priority BCCMD. Sets the priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired priority level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the level was successfully set, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95b9d502d69a5d4e42cc3b9334c94b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageBlueStackTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a task to handle BlueStack primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This task will receive MESSAGE_BLUESTACK_*_PRIM, except #MESSAGE_BLUESTACK_ATT_PRIM that are handled by the <a class="el" href="group__trapset__att.html#gabcdbacb41dd8edf00d78888bbc8469c8" title="Register a task to handle BlueStack ATT primitives. ">MessageAttTask()</a> and #MESSAGE_BLUESTACK_MDM_PRIM that are handled by the <a class="el" href="group__trapset__mirroring.html#gab215a7e45af8240428971e5c3e55c988" title="Register a task to handle BlueStack Mirroring Manager(MDM) primitives. ">MessageMdmTask()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero). </dd></dl>

</div>
</div>
<a class="anchor" id="ga42258c3f94266def6c7c6e0276813179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageLinkStatusTrackingTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register Link Status Tracking events task. Register a task to receive periodic MESSAGE_LINK_STATUS messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task which will receive the messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero). </dd></dl>

</div>
</div>
<a class="anchor" id="ga378f5ea324518f9151ef99afff6bbe62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkEnableLinkStatusTracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the A2DP link quality status tracking and update the evaluation period for quality assessment. On supported devices this will enable the periodic MESSAGE_LINK_STATUS to be sent to the task registered with <a class="el" href="group__trapset__bluestack.html#ga42258c3f94266def6c7c6e0276813179" title="Register Link Status Tracking events task. Register a task to receive periodic MESSAGE_LINK_STATUS me...">MessageLinkStatusTrackingTask()</a>. The traps works for an Audio Source application taking the L2CAP stream sink ID to identify the ACL connection for which status events are required. Link Status Messages can only be enabled on one link at a time. A second request for a different sink ID will fail unless the initial request is disabled. The supported periodicity for these events is 50-1000ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>L2CAP Stream sink handle used to identifies the ACL connection. </td></tr>
    <tr><td class="paramname">enable</td><td>Flag to enable or disable events </td></tr>
    <tr><td class="paramname">period</td><td>The time period for which link evaluation is to be done before sending a quality report as a message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sink identifies an ACL and link status is supported, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5789ebdfd7814f743c051b45289b58b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SinkGetL2capCid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the L2CAP channel id corresponding to a sink. </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get L2CAP channel id from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to get the connection identifier for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8993b3833971180e7154a9d8e100832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkPollAwayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the away time on the underlying ACL. The away time is the time since any packet was received on that ACL and is reported in milliseconds. If the time exceeds 0xFFFF, 0xFFFF will be returned (this is unlikely with sensible link supervision timeouts.) </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get ACL connections from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>identifies the underlying ACL </td></tr>
    <tr><td class="paramname">msec</td><td>receives the away time if the call succeeds (unmodified otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sink identifies an ACL and the away time on that link could be read, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga302ee1d73c8e58128243c763a3c77234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> StreamHciTapSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Stream HCI TAP object and return the source. </p>
<p>Create a Stream HCI TAP object and return the associated source. This is used for HCI TAP Logging from P0.</p>
<dl class="section return"><dt>Returns</dt><dd>The source handle for the HCI TAP stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga382089ef9cc353b61de31b31c47ceae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamL2capSink </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Sink corresponding to an L2CAP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection ID to fetch the Sink for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae1fcd189669b92707329c3cfadb37d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmBdAddrGetRssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RSSI for the ACL with given remote device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpaddr</td><td>The remote Bluetooth device address. </td></tr>
    <tr><td class="paramname">rssi</td><td>If a valid ACL is found, the RSSI in dBm will be written to this location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the RSSI has been obtained successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b38b0d50f3d0b5ca75c0bb0f2f5a83b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmCisConnGetRssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpbdaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RSSI for the CIS handle with the remote device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpbdaddr</td><td>The remote Bluetooth device address. </td></tr>
    <tr><td class="paramname">handle</td><td>The remote Bluetooth device CIS connection handle. </td></tr>
    <tr><td class="paramname">rssi</td><td>If a valid CIS connection is found, the RSSI in dBm will be written to the memory pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the RSSI has been obtained successfully, FALSE otherwise. This trap will also return FALSE on CSRA68105, QCC302x, QCC512x, QCC514x, and QCC515x devices </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1cf7f61ce5b649757798909457ab52a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetAclLinkQuality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>link_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the ACL rx link quality. This trap is intended to support 'wireless' debugging of link issues for example as a 'quantitative' metric to compare the quality of the primary's and secondary's receptions from the remote Bluetooth device. Only EDR ACL links are supported and not LE links. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices as their radios don't implement this feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
    <tr><td class="paramname">link_quality</td><td>Pointer to the memory to write the link quality if successful. The return value is a measure of the quality of this link for the reception of packets. 0 represents the lowest (worst) quality and 65535 represents the highest (best) quality).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4eb51076a93f160ca1ae2ba1db45681a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 VmGetAclMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mode of the defined ACL connection. </p>
<p>This trap allows the application to read the mode of a ACL connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HCI_BT_MODE_ACTIVE, HCI_BT_MODE_HOLD or HCI_BT_MODE_SNIFF will be returned if the ACL exists. HCI_BT_MODE_MAX will be returned if the ACL does not exist. These values are defined in the file hci.h. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9576d235fcdbdfed5df63c8e79e490b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 VmGetAclRole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the role of the defined ACL connection. </p>
<p>This trap allows the application to read the local role of a ACL connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HCI_MASTER or HCI_SLAVE will be returned if the ACL exists. HCI_MASTER_SLAVE_UNKNOWN will be returned if the ACL does not exist. These values are defined in the file hci.h. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e104a1dc884af12dbccd18a608018fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetBdAddrtFromCid </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection identifier to fetch the Bluetooth address from. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>If the address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if an address was found for a given CID, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac29e1496922249cd04d17dd64558faab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetHandleFromPointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must: </p>
<ul>
<li>Allocate a block</li>
<li>Convert it to a handle</li>
<li>Store the handle in the primitive rather than storing the pointer itself <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga64c8a83677acdc389f0b3454c4ea7b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetLocalIrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__irk.html">packed_irk</a> *&#160;</td>
          <td class="paramname"><em>irk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves local IRK (Identity Resolving Key) of the device. </p>
<p>The IR (Identity Root) is a root key of the device for the LE Transport and is used to generate the local IRK. The local IRK can be requested only after the initialization of the IR value using "DM_SM_INIT_REQ_T" primitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irk</td><td>If IRK information could be read, it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if local IRK was retrieved, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5caccd8ae3cfa1246373caffe1d218b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetPointerFromHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1258d4e01d5cec00dd9a21ae73ed9966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetPublicAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>random_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>public_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves public device address or static random address for a given resolvable random address. Note: To be used only on an established link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_addr</td><td>Random address. </td></tr>
    <tr><td class="paramname">public_addr</td><td>If the public device address or static random address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if public device address or static random address was found for a given resolvable random address, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d78960f4bdd7bc5a00f305650964ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetScoStatistics </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sco_statistics_t *&#160;</td>
          <td class="paramname"><em>sco_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read SCO statistics for the given SCO connection. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle of SCO connection. </td></tr>
    <tr><td class="paramname">sco_stats</td><td>Pointer to the memory to write statistics if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f6a871c7336b62f171fa4302c24e00e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideL2capConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override L2CAP connecton context. </p>
<p>This trap allows application to override the L2CAP connection context for a given cid. In general, this trap will be used where the L2CAP connection structures in Bluestack is populated as a result of unmarshalling and not because of a L2CAP connection initiation from the application. In such a case connection context in the L2CAP connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant L2CAP connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The L2CAP connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga717489e28b88057dde0c6e96c1137dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideRfcommConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>conn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override RFCOMM connecton context. </p>
<p>This trap allows application to override the RFCOMM connection context for a given RFCOMM connection id. In general, this trap will be used where the RFCOMM connection structures in Bluestack is populated as a result of unmarshalling and not because of a RFCOMM client connection initiation from the application. In such a case connection context in the RFCOMM connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant RFCOMM connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_id</td><td>The RFCOMM connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga25d4e01659e990ebc0b77ceb832869c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideSyncConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override DM Sync connecton context. </p>
<p>This trap allows application to override the DM Sync connection context for a given eSCO connection handle. In general, this trap will be used where the DM Sync connection structures in Bluestack is populated as a result of unmarshalling and not because of a DM Sync connection initiation from the application. In such a case connection context in the DM Sync connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant eSCO connection handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The eSCO connection handle </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85e6971ddeacbee25ef2b7b6a5cdebdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmReadNextSniffClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">next_sniff_clock_t *&#160;</td>
          <td class="paramname"><em>next_sniff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the system clock values for the next Sniff instant and the next Sniff Subrating instant on the connection for the given bluetooth address. The next_sniff_clock values give the time in microseconds for the next sniff instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpaddr</td><td>The Bluetooth address to use. </td></tr>
    <tr><td class="paramname">next_sniff</td><td>Pointer to the memory to write next sniff clock information if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c7349b61ec91e3078739b24c9832f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendDmPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a DM Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga623628caf10541c84058d562a909b329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendL2capPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an L2CAP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b2a62ea647b44972a997650ffb74938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendSdpPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an SDP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbaffd14325353278ea2e684f06b14c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmUpdateRootKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *&#160;</td>
          <td class="paramname"><em>root_keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap. </p>
<p>The root keys comprise IR and ER keys. These are used to generate IRK, CSRK and Legacy LTK. This trap is normally used if a device wants to synchronize its root keys with a device with which it would share a common Bluetooth address. This trap doesn't update the root keys in the persistent store, so the change is not persistent. Note: The application needs to make sure that it should not call this trap when the device is advertising or scanning using a resolvable private address. Moreover, if the device has a pre-existing LE SC (secure connections) pairing with other remote devices and this trap is called then the new ER value will not affect the bonding state for those devices. If the device has a legacy pairing with remote devices, then overwriting the ER value will invalidate the bonding state for those remote devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_keys</td><td>New ER and IR values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if IR and ER values were set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
