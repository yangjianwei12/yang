
/home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/tools/KCSMaker/out/14612/maor_rom_release/download/debugbin/download_aanc2_external.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

842005c0 <$_aanc2_create>:

bool aanc2_create(OPERATOR_DATA *op_data,
                  void *message_data,
                  unsigned *response_id,
                  void **resp_data)
{
842005c0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842005c2:	16 00       	r4 = r0 + Null;
842005c4:	2b 09       	r9 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
842005c6:	ff fd 01 f0 	call (m) 0x8ea;
842005ca:	25 e9 
842005cc:	17 00       	r5 = r0 + Null;
{
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);
    unsigned *p_default_params;     /* Pointer to default params */
    unsigned *p_cap_params;         /* Pointer to capability params */
    CPS_PARAM_DEF *p_param_def;     /* Pointer to parameter definition */
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
842005ce:	72 88       	r0 = M[r4 + 4];
842005d0:	52 55       	r0 = r0 LSHIFT 6;
842005d2:	40 f0 00 f2 	r8 = r0 OR 0x4000;
842005d6:	5a d8 
    /* NB: create is passed a zero-initialized structure so any fields not
     * explicitly initialized are 0.
     */

    L5_DBG_MSG2("OPID: %x, AANC2 Create: p_ext_data at %p", ext_op_id, p_ext_data);
842005d8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842005dc:	48 25       	Null = rMAC - 5;
842005de:	09 68       	if LT jump (m) Lc_aanc2_create_3;

842005e0 <Lc_aanc2_create_2>:
842005e0:	55 f1 02 f0 	r0 = Null + 357564640;
842005e4:	e0 40 
842005e6:	3c 00       	r2 = r5 + Null;
842005e8:	53 08       	r1 = r8 + Null;
842005ea:	ff fd 05 f0 	call (m) 0x10d6;
842005ee:	2d e7 

842005f0 <Lc_aanc2_create_3>:

    if (!base_op_create_lite(op_data, resp_data))
842005f0:	5b 08       	r1 = r9 + Null;
842005f2:	32 00       	r0 = r4 + Null;
842005f4:	ff fd 01 f0 	call (m) 0x850;
842005f8:	3d e2 
842005fa:	10 04       	Null = r0 - Null;
842005fc:	03 62       	if NE jump (m) Lc_aanc2_create_5;

842005fe <Lc_aanc2_create_4>:
    {
        return FALSE;
842005fe:	02 00       	r0 = Null + Null;
84200600:	60 6e       	jump (m) Lc_aanc2_create_12;

84200602 <Lc_aanc2_create_5>:
    }

    /* Capabilty ID is used to store and retrieve parameters */
    p_ext_data->cap_id = AANC2_16K_CAP_ID;
84200602:	21 f0 a0 40 	rMAC = Null + 16544;
84200606:	79 8e       	M[r5 + 4] = rMAC;

    /* Sample rate is used to configure the EDs within the capability */
    p_ext_data->sample_rate = 16000;
84200608:	11 f0 80 7a 	rMAC = Null + 16000;
8420060c:	39 ee       	M[r5 + Null] = rMAC;

    /* Create the class data */
    aud_cur_create(op_data, AANC2_MAX_SOURCES, AANC2_MAX_SINKS);
8420060e:	04 21       	r2 = Null + 4;
84200610:	23 00       	r1 = r2 + Null;
84200612:	32 00       	r0 = r4 + Null;
84200614:	0b f0 35 e7 	call (m) $_aud_cur_create;
    aud_cur_set_callbacks(op_data,
                          aanc2_start_hook,
                          NULL,
                          aanc2_connect_hook,
                          aanc2_disconnect_hook,
                          NULL);
84200618:	00 f0 30 cf 	push Null;
8420061c:	42 f0 05 f0 	r3 = Null + 69208359;
84200620:	27 51 
84200622:	42 f0 03 f0 	r1 = Null + 69208341;
84200626:	15 51 
84200628:	04 00       	r2 = Null + Null;
8420062a:	42 f0 09 f0 	push Null + 69208423;
8420062e:	57 e6 
84200630:	32 00       	r0 = r4 + Null;
84200632:	0c f0 3d e9 	call (m) $_aud_cur_set_callbacks;
84200636:	7e 4c       	SP = SP + -8;
    /* Setup class data flags */
    aud_cur_set_flags(op_data,
                      AANC2_SUPPORTS_IN_PLACE,
                      AANC2_SUPPORTS_METADATA,
                      AANC2_DYNAMIC_BUFFERS);
84200638:	44 20       	r2 = Null + 1;
8420063a:	05 00       	r3 = Null + Null;
8420063c:	23 00       	r1 = r2 + Null;
8420063e:	32 00       	r0 = r4 + Null;
84200640:	0c f0 31 ea 	call (m) $_aud_cur_set_flags;
    /* Setup class data block and buffer sizes */
    aud_cur_set_block_size(op_data, AANC2_DEFAULT_FRAME_SIZE);
84200644:	03 f0 40 40 	r1 = Null + 64;
84200648:	32 00       	r0 = r4 + Null;
8420064a:	0c f0 3f eb 	call (m) $_aud_cur_set_block_size;
    aud_cur_set_buffer_size(op_data, AANC2_DEFAULT_BUFFER_SIZE);
8420064e:	03 f0 80 40 	r1 = Null + 128;
84200652:	32 00       	r0 = r4 + Null;
84200654:	0c f0 25 eb 	call (m) $_aud_cur_set_buffer_size;

    /* Initialize parameters */
    p_default_params = (unsigned*)AANC2_GetDefaults(p_ext_data->cap_id);
84200658:	7a 88       	r0 = M[r5 + 4];
8420065a:	05 f0 2f e6 	call (m) $_AANC2_GetDefaults;
8420065e:	11 09       	r7 = r0 + Null;
    p_cap_params = (unsigned*)&p_ext_data->aanc2_cap_params;
84200660:	78 f0 08 20 	r6 = r5 + 8;
    p_param_def = aud_cur_get_cps(op_data);
84200664:	32 00       	r0 = r4 + Null;
84200666:	0c f0 25 ea 	call (m) $_aud_cur_get_cps;
    if(!cpsInitParameters(p_param_def,
                          p_default_params,
                          p_cap_params,
                          sizeof(AANC2_PARAMETERS)))
8420066a:	05 f0 1c 41 	r3 = Null + 284;
8420066e:	44 08       	r2 = r6 + Null;
84200670:	4b 08       	r1 = r7 + Null;
84200672:	ff fd 02 f0 	call (m) 0xb2a;
84200676:	39 e5 
84200678:	10 04       	Null = r0 - Null;
8420067a:	1a 60       	if EQ jump (m) Lc_aanc2_create_9;

8420067c <Lc_aanc2_create_6>:
       base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
       return TRUE;
    }

    /* Initialize system mode */
    p_ext_data->cur_mode = AANC2_SYSMODE_FULL;
8420067c:	81 20       	rMAC = Null + 2;
8420067e:	71 f0 49 8e 	M[r5 + 292] = rMAC;
    p_ext_data->host_mode = AANC2_SYSMODE_FULL;
84200682:	71 f0 4a 8e 	M[r5 + 296] = rMAC;
    p_ext_data->qact_mode = AANC2_SYSMODE_FULL;
84200686:	71 f0 4b 8e 	M[r5 + 300] = rMAC;

    /* Create any sub-block objects */
    if (!aanc2_proc_create(&p_ext_data->ag, p_ext_data->sample_rate))
8420068a:	3b e8       	r1 = M[r5 + Null];
8420068c:	72 f0 3c 21 	r0 = r5 + 316;
84200690:	05 f0 33 e5 	call (m) $_aanc2_proc_create;
84200694:	10 04       	Null = r0 - Null;
84200696:	12 62       	if NE jump (m) Lc_aanc2_create_10;

84200698 <Lc_aanc2_create_7>:
    {
        L4_DBG_MSG1("OPID: %x, AANC2 failed to create AG data", ext_op_id);
84200698:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420069c:	08 25       	Null = rMAC - 4;
8420069e:	08 68       	if LT jump (m) Lc_aanc2_create_9;

842006a0 <Lc_aanc2_create_8>:
842006a0:	55 f1 02 f0 	r0 = Null + 357564681;
842006a4:	09 41 
842006a6:	53 08       	r1 = r8 + Null;
842006a8:	ff fd 05 f0 	call (m) 0x10c2;
842006ac:	3b e0 

842006ae <Lc_aanc2_create_9>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842006ae:	01 f0 00 60 	rMAC = Null + 4096;
842006b2:	b2 f0 00 e8 	r0 = M[r9 + Null];
842006b6:	51 8e       	M[r0 + 4] = rMAC;
842006b8:	03 6e       	jump (m) Lc_aanc2_create_11;

842006ba <Lc_aanc2_create_10>:
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
    }
    p_ext_data->ag.opid = ext_op_id;
842006ba:	7a f0 7e 8e 	M[r5 + 504] = r8;

842006be <Lc_aanc2_create_11>:
                          p_default_params,
                          p_cap_params,
                          sizeof(AANC2_PARAMETERS)))
    {
       base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
       return TRUE;
842006be:	42 20       	r0 = Null + 1;

842006c0 <Lc_aanc2_create_12>:
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
    }
    p_ext_data->ag.opid = ext_op_id;
    return TRUE;
}
842006c0:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842006c2:	d8 4c       	rts;

842006c4 <$_aanc2_destroy>:

bool aanc2_destroy(OPERATOR_DATA *op_data,
                   void *message_data,
                   unsigned *response_id,
                   void **resp_data)
{
842006c4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842006c6:	17 00       	r5 = r0 + Null;
842006c8:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
842006ca:	ff fd 01 f0 	call (m) 0x8ea;
842006ce:	21 e1 
842006d0:	16 00       	r4 = r0 + Null;
                   void **resp_data)
{
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);

    /* Call base op destroy to create and populate the response */
    if (!base_op_destroy_lite(op_data, resp_data))
842006d2:	43 08       	r1 = r6 + Null;
842006d4:	3a 00       	r0 = r5 + Null;
842006d6:	ff fd 00 f0 	call (m) 0x834;
842006da:	3f ea 
842006dc:	10 04       	Null = r0 - Null;
842006de:	03 62       	if NE jump (m) Lc_aanc2_destroy_3;

842006e0 <Lc_aanc2_destroy_2>:
    {
        return FALSE;
842006e0:	02 00       	r0 = Null + Null;
842006e2:	0e 6e       	jump (m) Lc_aanc2_destroy_6;

842006e4 <Lc_aanc2_destroy_3>:
    }

    /* Release sub-block and shared memory */
    if (p_ext_data != NULL)
842006e4:	30 04       	Null = r4 - Null;
842006e6:	08 60       	if EQ jump (m) Lc_aanc2_destroy_5;

842006e8 <Lc_aanc2_destroy_4>:
    {
        aanc2_proc_destroy(&p_ext_data->ag);
842006e8:	62 f0 3c 21 	r0 = r4 + 316;
842006ec:	06 f0 29 ec 	call (m) $_aanc2_proc_destroy;
        aanc2_release_shared_gains(p_ext_data);
842006f0:	32 00       	r0 = r4 + Null;
842006f2:	04 f0 29 e6 	call (m) Lc_aanc2_release_shared_gains_1;

842006f6 <Lc_aanc2_destroy_5>:
    }

    /* Release class data */
    aud_cur_destroy(op_data);
842006f6:	3a 00       	r0 = r5 + Null;
842006f8:	0b f0 2f e4 	call (m) $_aud_cur_destroy;

    return TRUE;
842006fc:	42 20       	r0 = Null + 1;

842006fe <Lc_aanc2_destroy_6>:
}
842006fe:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200700:	d8 4c       	rts;

84200702 <$_aanc2_process_data>:
/****************************************************************************
Data processing function
*/

void aanc2_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200702:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200704:	17 00       	r5 = r0 + Null;
84200706:	1b 09       	r9 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200708:	ff fd 00 f0 	call (m) 0x8ea;
8420070c:	23 ef 
8420070e:	16 00       	r4 = r0 + Null;

    /* Calculate amount of data/space available and update the touched terminal
     * state based on the assumption that if there is enough data (at least one
     * frame) and enough space then that data will be consumed/produced.
     */
    samples = aud_cur_calc_samples(op_data, touched);
84200710:	5b 08       	r1 = r9 + Null;
84200712:	3a 00       	r0 = r5 + Null;
84200714:	0c f0 3f ef 	call (m) $_aud_cur_calc_samples;

     /* Return early if no data or not enough space to process */
    if (samples < AANC2_DEFAULT_FRAME_SIZE)
84200718:	20 f0 40 24 	Null = r0 - 64;
8420071c:	fa 68       	if LT jump (m) Lc_aanc2_process_data_52;

8420071e <Lc_aanc2_process_data_2>:

    /* Default the gain validity to FALSE to prevent incorrect gains being
     * preserved if the mode is changed from FULL.
     */
    p_ff_gain = p_ext_data->p_ff_fine_gain;
    if (p_ff_gain != NULL)
8420071e:	6a f0 b8 88 	r8 = M[r4 + 736];
84200722:	03 60       	if EQ jump (m) Lc_aanc2_process_data_4;

84200724 <Lc_aanc2_process_data_3>:
    {
        p_ff_gain->valid = FALSE;
84200724:	a0 f0 0d 8a 	MB[r8 + 13] = Null;

84200728 <Lc_aanc2_process_data_4>:
    }

    run_processing = p_ext_data->cur_mode != AANC2_SYSMODE_STANDBY;
84200728:	01 00       	rMAC = Null + Null;
8420072a:	60 f0 49 88 	Null = M[r4 + 292];
8420072e:	21 f0 41 ce 	if NE rMAC = Null + 1;

    /* Reinitialize events and the algorithm */
    if (run_processing && aud_cur_get_reinit(op_data))
84200732:	41 de       	M[FP + 32] = rMAC;
84200734:	27 60       	if EQ jump (m) Lc_aanc2_process_data_7;

84200736 <Lc_aanc2_process_data_5>:
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84200736:	3a 00       	r0 = r5 + Null;
84200738:	ff fd 00 f0 	call (m) 0x934;
8420073c:	3d ef 
8420073e:	11 e2       	rMAC = MBU[r0 + Null];
84200740:	21 60       	if EQ jump (m) Lc_aanc2_process_data_7;

84200742 <Lc_aanc2_process_data_6>:
84200742:	3a 00       	r0 = r5 + Null;
84200744:	ff fd 00 f0 	call (m) 0x934;
84200748:	31 ef 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
8420074a:	10 ea       	MB[r0 + Null] = Null;
    {
        /* Clear reinitialization flag */
        aud_cur_set_reinit(op_data, FALSE);

        aanc2_initialize_events(op_data, p_ext_data);
8420074c:	33 00       	r1 = r4 + Null;
8420074e:	3a 00       	r0 = r5 + Null;
84200750:	03 f0 37 e3 	call (m) Lc_aanc2_initialize_events_1;
        p_params = &p_ext_data->aanc2_cap_params;
84200754:	68 f0 08 20 	r6 = r4 + 8;
        p_ext_data->disable_events = \
            (p_params->OFFSET_AANC2_DEBUG &
             AANC2_CONFIG_AANC2_DEBUG_DISABLE_EVENT_MESSAGING);
84200758:	81 f0 01 88 	rMAC = M[r6 + 4];
8420075c:	49 c1       	rMAC = rMAC AND 0x8;
8420075e:	61 f0 3a 8b 	MB[r4 + 314] = rMAC;

        AANC2_PROC *p_ag = &p_ext_data->ag;
84200762:	89 f0 34 21 	r7 = r6 + 308;

        aanc2_proc_initialize(p_ag, p_params);
84200766:	43 08       	r1 = r6 + Null;
84200768:	4a 08       	r0 = r7 + Null;
8420076a:	06 f0 35 eb 	call (m) $_aanc2_proc_initialize;
        concurrency = p_ext_data->cur_mode == AANC2_SYSMODE_FULL_CONCURRENCY;
8420076e:	61 f0 49 88 	rMAC = M[r4 + 292];
84200772:	04 00       	r2 = Null + Null;
84200774:	c8 24       	Null = rMAC - 3;
84200776:	20 f0 44 ce 	if EQ r2 = Null + 1;
        aanc2_proc_initialize_concurrency(p_ag, p_params, concurrency);
8420077a:	43 08       	r1 = r6 + Null;
8420077c:	4a 08       	r0 = r7 + Null;
8420077e:	08 f0 29 ee 	call (m) $_aanc2_proc_initialize_concurrency;

84200782 <Lc_aanc2_process_data_7>:
    }

    /* Only full mode does gain adaptation */
    calculate_gain = FALSE;
84200782:	00 09       	r6 = Null + Null;
    if ((p_ext_data->cur_mode == AANC2_SYSMODE_FULL) ||
        (p_ext_data->cur_mode == AANC2_SYSMODE_FULL_CONCURRENCY))
84200784:	61 f0 49 88 	rMAC = M[r4 + 292];
84200788:	88 24       	Null = rMAC - 2;
8420078a:	03 60       	if EQ jump (m) Lc_aanc2_process_data_9;

8420078c <Lc_aanc2_process_data_8>:
8420078c:	c8 24       	Null = rMAC - 3;
8420078e:	08 62       	if NE jump (m) Lc_aanc2_process_data_12;

84200790 <Lc_aanc2_process_data_9>:
    {
        if (p_ff_gain != NULL)
84200790:	0f fa 00 c2 	Null = r8 - Null;
84200794:	04 60       	if EQ jump (m) Lc_aanc2_process_data_11;

84200796 <Lc_aanc2_process_data_10>:
        {
            if (p_ff_gain->using_nominal)
84200796:	a1 f0 14 82 	rMAC = MBU[r8 + 20];
8420079a:	02 60       	if EQ jump (m) Lc_aanc2_process_data_12;

8420079c <Lc_aanc2_process_data_11>:
                calculate_gain = TRUE;
            }
        }
        else
        {
            calculate_gain = TRUE;
8420079c:	08 71       	r6 = Null + 1;

8420079e <Lc_aanc2_process_data_12>:
8420079e:	0a 71       	r8 = Null + 1;
        }
    }

    sample_count = 0;
842007a0:	01 09       	r7 = Null + Null;

842007a2 <Lc_aanc2_process_data_13>:
    /* Consume all the data in the input buffer, or until there isn't space
     * available in blocks of the frame size.
     */
    do
    {
        if (run_processing)
842007a2:	41 d8       	rMAC = M[FP + 32];
842007a4:	94 60       	if EQ jump (m) Lc_aanc2_process_data_45;

842007a6 <Lc_aanc2_process_data_14>:
        {
            if (p_ext_data->quiet_condition)
842007a6:	60 f0 b7 88 	Null = M[r4 + 732];
842007aa:	02 60       	if EQ jump (m) Lc_aanc2_process_data_16;

842007ac <Lc_aanc2_process_data_15>:
            {
                calculate_gain = FALSE;
842007ac:	00 09       	r6 = Null + Null;

842007ae <Lc_aanc2_process_data_16>:
            }
            aanc2_proc_process_data(&p_ext_data->ag,
                                    AANC2_DEFAULT_FRAME_SIZE,
                                    calculate_gain);
842007ae:	03 f0 40 40 	r1 = Null + 64;
842007b2:	62 f0 3c 21 	r0 = r4 + 316;
842007b6:	44 08       	r2 = r6 + Null;
842007b8:	08 f0 21 ee 	call (m) $_aanc2_proc_process_data;

            /* Update the mode behavior based on the flags */
            mode_after_flags = p_ext_data->cur_mode;
842007bc:	61 f0 49 88 	rMAC = M[r4 + 292];
            if ((p_ext_data->ag.proc_flags & AANC2_ED_FLAG_MASK) > 0)
842007c0:	62 f0 4f 88 	r0 = M[r4 + 316];
842007c4:	24 f0 70 00 	r2 = r0 AND 0x70;
842007c8:	11 60       	if EQ jump (m) Lc_aanc2_process_data_20;

842007ca <Lc_aanc2_process_data_17>:
            {
                L5_DBG_MSG2("OPID: %x, AANC ED detected: %u",
                             INT_TO_EXT_OPID(op_data->id), p_ext_data->ag.proc_flags & AANC2_ED_FLAG_MASK);
842007ca:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842007ce:	48 25       	Null = rMAC - 5;
842007d0:	0c 68       	if LT jump (m) Lc_aanc2_process_data_19;

842007d2 <Lc_aanc2_process_data_18>:
842007d2:	7a 88       	r0 = M[r5 + 4];
842007d4:	52 55       	r0 = r0 LSHIFT 6;
842007d6:	40 f0 00 f2 	r1 = r0 OR 0x4000;
842007da:	53 d8 
842007dc:	55 f1 02 f0 	r0 = Null + 357565031;
842007e0:	67 42 
842007e2:	ff fd 04 f0 	call (m) 0x10d6;
842007e6:	35 e7 

842007e8 <Lc_aanc2_process_data_19>:
                mode_after_flags = AANC2_SYSMODE_FREEZE;
842007e8:	51 08       	rMAC = r8 + Null;

842007ea <Lc_aanc2_process_data_20>:
            }

            if ((p_ext_data->ag.proc_flags & AANC2_CLIPPING_FLAG_MASK) > 0)
842007ea:	62 f0 4f 88 	r0 = M[r4 + 316];
842007ee:	24 f0 00 07 	r2 = r0 AND 0x700;
842007f2:	11 60       	if EQ jump (m) Lc_aanc2_process_data_24;

842007f4 <Lc_aanc2_process_data_21>:
            {
                L5_DBG_MSG2("OPID: %x, AANC Clipping detected: %u",
                             INT_TO_EXT_OPID(op_data->id), p_ext_data->ag.proc_flags & \
                             AANC2_CLIPPING_FLAG_MASK);
842007f4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842007f8:	48 25       	Null = rMAC - 5;
842007fa:	0c 68       	if LT jump (m) Lc_aanc2_process_data_23;

842007fc <Lc_aanc2_process_data_22>:
842007fc:	7a 88       	r0 = M[r5 + 4];
842007fe:	52 55       	r0 = r0 LSHIFT 6;
84200800:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200804:	53 d8 
84200806:	55 f1 02 f0 	r0 = Null + 357565062;
8420080a:	86 42 
8420080c:	ff fd 04 f0 	call (m) 0x10d6;
84200810:	2b e6 

84200812 <Lc_aanc2_process_data_23>:
                mode_after_flags = AANC2_SYSMODE_FREEZE;
84200812:	51 08       	rMAC = r8 + Null;

84200814 <Lc_aanc2_process_data_24>:
            }

            if ((p_ext_data->ag.proc_flags & AANC2_SATURATION_FLAG_MASK) > 0)
84200814:	62 f0 4f 88 	r0 = M[r4 + 316];
84200818:	24 f7 00 10 	r2 = r0 AND 0xf000;
8420081c:	11 60       	if EQ jump (m) Lc_aanc2_process_data_28;

8420081e <Lc_aanc2_process_data_25>:
            {
                L5_DBG_MSG2("OPID: %x, AANC Saturation detected: %u",
                             INT_TO_EXT_OPID(op_data->id), p_ext_data->ag.proc_flags & \
                             AANC2_SATURATION_FLAG_MASK);
8420081e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200822:	48 25       	Null = rMAC - 5;
84200824:	0c 68       	if LT jump (m) Lc_aanc2_process_data_27;

84200826 <Lc_aanc2_process_data_26>:
84200826:	7a 88       	r0 = M[r5 + 4];
84200828:	52 55       	r0 = r0 LSHIFT 6;
8420082a:	40 f0 00 f2 	r1 = r0 OR 0x4000;
8420082e:	53 d8 
84200830:	55 f1 02 f0 	r0 = Null + 357565099;
84200834:	ab 42 
84200836:	ff fd 04 f0 	call (m) 0x10d6;
8420083a:	21 e5 

8420083c <Lc_aanc2_process_data_27>:
                mode_after_flags = AANC2_SYSMODE_FREEZE;
8420083c:	51 08       	rMAC = r8 + Null;

8420083e <Lc_aanc2_process_data_28>:
            }

            if (p_ext_data->quiet_condition)
8420083e:	60 f0 b7 88 	Null = M[r4 + 732];
84200842:	11 60       	if EQ jump (m) Lc_aanc2_process_data_32;

84200844 <Lc_aanc2_process_data_29>:
            {
                L5_DBG_MSG1("OPID: %x, AANC Quiet Condition detected",
                             INT_TO_EXT_OPID(op_data->id));
84200844:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200848:	48 25       	Null = rMAC - 5;
8420084a:	0c 68       	if LT jump (m) Lc_aanc2_process_data_31;

8420084c <Lc_aanc2_process_data_30>:
8420084c:	7a 88       	r0 = M[r5 + 4];
8420084e:	52 55       	r0 = r0 LSHIFT 6;
84200850:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200854:	53 d8 
84200856:	55 f1 02 f0 	r0 = Null + 357565138;
8420085a:	d2 42 
8420085c:	ff fd 04 f0 	call (m) 0x10c2;
84200860:	27 e3 

84200862 <Lc_aanc2_process_data_31>:
                mode_after_flags = AANC2_SYSMODE_FREEZE;
84200862:	51 08       	rMAC = r8 + Null;

84200864 <Lc_aanc2_process_data_32>:
            }

            /* Update the gain if in FULL mode. Otherwise ensure the shared gain
            * value is marked as invalid so that it isn't accidentally taken.
            */
            p_gain_calc = &p_ext_data->ag.p_fxlms->adaptive_gain;
84200864:	62 f0 61 88 	r0 = M[r4 + 388];
84200868:	02 f0 44 44 	r0 = r0 + 68;
            p_ff_gain = p_ext_data->p_ff_fine_gain;
8420086c:	63 f0 b8 88 	r1 = M[r4 + 736];

            if (((mode_after_flags == AANC2_SYSMODE_FULL) ||
                 (mode_after_flags == AANC2_SYSMODE_FULL_CONCURRENCY)) &&
                p_ff_gain != NULL)
84200870:	88 24       	Null = rMAC - 2;
84200872:	03 60       	if EQ jump (m) Lc_aanc2_process_data_34;

84200874 <Lc_aanc2_process_data_33>:
84200874:	c8 24       	Null = rMAC - 3;
84200876:	07 62       	if NE jump (m) Lc_aanc2_process_data_36;

84200878 <Lc_aanc2_process_data_34>:
84200878:	18 04       	Null = r1 - Null;
8420087a:	05 60       	if EQ jump (m) Lc_aanc2_process_data_36;

8420087c <Lc_aanc2_process_data_35>:
            {
                p_ff_gain->gain = (uint8)*p_gain_calc;
8420087c:	12 e8       	r0 = M[r0 + Null];
8420087e:	1a 9b       	MB[r1 + 12] = r0;
                p_ff_gain->valid = TRUE;
84200880:	3a f0 0d 8a 	MB[r1 + 13] = r8;

84200884 <Lc_aanc2_process_data_36>:
            }

            if (p_ext_data->filter_config == AANC2_FILTER_CONFIG_DUAL)
84200884:	62 f0 9c 86 	r0 = MHU[r4 + 312];
84200888:	90 24       	Null = r0 - 2;
8420088a:	11 62       	if NE jump (m) Lc_aanc2_process_data_41;

8420088c <Lc_aanc2_process_data_37>:
            {
                /* Update instance 1 */
                p_gain_calc = &p_ext_data->ag.p_fxlms->adaptive_gain1;
8420088c:	62 f0 61 88 	r0 = M[r4 + 388];
84200890:	23 f0 48 20 	r1 = r0 + 72;
                p_ff_gain = p_ext_data->p_ff_fine_gain1;
84200894:	62 f0 b9 88 	r0 = M[r4 + 740];

                if (((mode_after_flags == AANC2_SYSMODE_FULL) ||
                    (mode_after_flags == AANC2_SYSMODE_FULL_CONCURRENCY)) &&
                    p_ff_gain != NULL)
84200898:	88 24       	Null = rMAC - 2;
8420089a:	03 60       	if EQ jump (m) Lc_aanc2_process_data_39;

8420089c <Lc_aanc2_process_data_38>:
8420089c:	c8 24       	Null = rMAC - 3;
8420089e:	07 62       	if NE jump (m) Lc_aanc2_process_data_41;

842008a0 <Lc_aanc2_process_data_39>:
842008a0:	10 04       	Null = r0 - Null;
842008a2:	05 60       	if EQ jump (m) Lc_aanc2_process_data_41;

842008a4 <Lc_aanc2_process_data_40>:
                {
                    p_ff_gain->gain = (uint8)*p_gain_calc;
842008a4:	19 e8       	rMAC = M[r1 + Null];
842008a6:	11 9b       	MB[r0 + 12] = rMAC;
                    p_ff_gain->valid = TRUE;
842008a8:	2a f0 0d 8a 	MB[r0 + 13] = r8;

842008ac <Lc_aanc2_process_data_41>:
                }
            }
            /* Evaluate event messaging criteria */
            if (!p_ext_data->disable_events)
842008ac:	61 f0 3a 83 	rMAC = MBU[r4 + 314];
842008b0:	04 62       	if NE jump (m) Lc_aanc2_process_data_43;

842008b2 <Lc_aanc2_process_data_42>:
            {
                aanc2_process_events(p_ext_data);
842008b2:	32 00       	r0 = r4 + Null;
842008b4:	02 f0 31 ec 	call (m) Lc_aanc2_process_events_1;

842008b8 <Lc_aanc2_process_data_43>:
        #ifdef RUNNING_ON_KALSIM
            aanc2_send_kalsim_msg(op_data, p_ext_data);
        #endif

            /* Transfer data on unused terminals */
            if (p_ext_data->ag.p_fbmon_ip != NULL)
842008b8:	61 f0 76 88 	rMAC = M[r4 + 472];
842008bc:	16 60       	if EQ jump (m) Lc_aanc2_process_data_48;

842008be <Lc_aanc2_process_data_44>:
            {
                aud_cur_mic_data_transfer(op_data,
                                          AANC2_DEFAULT_FRAME_SIZE,
                                          AANC2_SKIP_TERMINALS);
842008be:	04 23       	r2 = Null + 12;
842008c0:	03 f0 40 40 	r1 = Null + 64;
842008c4:	3a 00       	r0 = r5 + Null;
842008c6:	0c f0 39 e7 	call (m) $_aud_cur_mic_data_transfer;
842008ca:	0f 6e       	jump (m) Lc_aanc2_process_data_48;

842008cc <Lc_aanc2_process_data_45>:
        else
        {
            /* Consume all input data when not running the processing
             * algorithms.
             */
            if (p_ext_data->ag.p_playback_ip != NULL)
842008cc:	61 f0 75 88 	rMAC = M[r4 + 468];
842008d0:	06 60       	if EQ jump (m) Lc_aanc2_process_data_47;

842008d2 <Lc_aanc2_process_data_46>:
            {
                aud_cur_playback_data_transfer(op_data,
                                               AANC2_DEFAULT_FRAME_SIZE);
842008d2:	03 f0 40 40 	r1 = Null + 64;
842008d6:	3a 00       	r0 = r5 + Null;
842008d8:	0c f0 39 eb 	call (m) $_aud_cur_playback_data_transfer;

842008dc <Lc_aanc2_process_data_47>:
            }
            aud_cur_mic_data_transfer(op_data,
                                      AANC2_DEFAULT_FRAME_SIZE,
                                      AANC2_TRANSFER_ALL_MASK);
842008dc:	03 f0 40 40 	r1 = Null + 64;
842008e0:	04 00       	r2 = Null + Null;
842008e2:	3a 00       	r0 = r5 + Null;
842008e4:	0c f0 3b e6 	call (m) $_aud_cur_mic_data_transfer;

842008e8 <Lc_aanc2_process_data_48>:
        }

        /* Update sample count */
        sample_count += AANC2_DEFAULT_FRAME_SIZE;
842008e8:	09 f0 40 44 	r7 = r7 + 64;
        samples = aud_cur_calc_samples(op_data, touched);
842008ec:	5b 08       	r1 = r9 + Null;
842008ee:	3a 00       	r0 = r5 + Null;
842008f0:	0c f0 23 e1 	call (m) $_aud_cur_calc_samples;
    } while (samples >= AANC2_DEFAULT_FRAME_SIZE);
842008f4:	20 f0 40 24 	Null = r0 - 64;
842008f8:	55 67       	if GE jump (m) Lc_aanc2_process_data_13;

842008fa <Lc_aanc2_process_data_49>:

    /* Transfer as much metadata as data has been processed */
    if (p_ext_data->ag.p_playback_ip != NULL)
842008fa:	61 f0 75 88 	rMAC = M[r4 + 468];
842008fe:	05 60       	if EQ jump (m) Lc_aanc2_process_data_51;

84200900 <Lc_aanc2_process_data_50>:
    {
        aud_cur_playback_metadata_transfer(op_data, sample_count);
84200900:	4b 08       	r1 = r7 + Null;
84200902:	3a 00       	r0 = r5 + Null;
84200904:	0c f0 27 ec 	call (m) $_aud_cur_playback_metadata_transfer;

84200908 <Lc_aanc2_process_data_51>:
    }
    aud_cur_mic_metadata_transfer(op_data, sample_count);
84200908:	4b 08       	r1 = r7 + Null;
8420090a:	3a 00       	r0 = r5 + Null;
8420090c:	0c f0 23 e9 	call (m) $_aud_cur_mic_metadata_transfer;

84200910 <Lc_aanc2_process_data_52>:

    return;
}
84200910:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200912:	d8 4c       	rts;

84200914 <$_aanc2_start_hook>:

    return TRUE;
}

bool aanc2_start_hook(OPERATOR_DATA *op_data)
{
84200914:	c8 1c       	pushm <FP(=SP), rLink>;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200916:	ef fd ff ff 	call (m) 0x8ea;
8420091a:	35 ee 

bool aanc2_start_hook(OPERATOR_DATA *op_data)
{
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);

    aanc2_initialize_gain(p_ext_data);
8420091c:	03 f0 31 eb 	call (m) Lc_aanc2_initialize_gain_1;

    return TRUE;
84200920:	42 20       	r0 = Null + 1;

84200922 <Lc_aanc2_start_hook_2>:
}
84200922:	c8 48       	popm <FP, rLink>;
84200924:	d8 4c       	rts;

84200926 <$_aanc2_connect_hook>:

bool aanc2_connect_hook(OPERATOR_DATA *op_data, unsigned terminal_id)
{
84200926:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200928:	16 00       	r4 = r0 + Null;
8420092a:	19 09       	r7 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
8420092c:	ef fd ff ff 	call (m) 0x8ea;
84200930:	3f ed 
84200932:	10 09       	r6 = r0 + Null;
     * in the algorithm structure. This is dependent on the fact that the
     * internal references are stored in the same sequence as the terminals
     * themselves, so the buffer pointer is just incremented by the terminal
     * numberl.
     */
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
84200934:	97 f0 3f 00 	r5 = r7 AND 0x3f;
    if ((terminal_id & TERMINAL_SINK_MASK) > 0)
84200938:	40 f0 91 f0 	rMAC = r7 AND 0x800000;
8420093c:	00 00 
8420093e:	08 60       	if EQ jump (m) Lc_aanc2_connect_hook_3;

84200940 <Lc_aanc2_connect_hook_2>:
    {
        p_external = aud_cur_get_sink_terminal(op_data, terminal_num);
84200940:	3b 00       	r1 = r5 + Null;
84200942:	32 00       	r0 = r4 + Null;
84200944:	0b f0 2b e5 	call (m) $_aud_cur_get_sink_terminal;
        pp_internal = &p_ext_data->ag.p_playback_ip;
84200948:	81 f0 d4 21 	rMAC = r6 + 468;
8420094c:	07 6e       	jump (m) Lc_aanc2_connect_hook_4;

8420094e <Lc_aanc2_connect_hook_3>:
        pp_internal += terminal_num;
        *pp_internal = p_external;
    }
    else
    {
        p_external = aud_cur_get_source_terminal(op_data, terminal_num);
8420094e:	3b 00       	r1 = r5 + Null;
84200950:	32 00       	r0 = r4 + Null;
84200952:	0b f0 27 e4 	call (m) $_aud_cur_get_source_terminal;
        pp_internal = &p_ext_data->ag.p_playback_op;
84200956:	81 f0 e4 21 	rMAC = r6 + 484;

8420095a <Lc_aanc2_connect_hook_4>:
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
    if ((terminal_id & TERMINAL_SINK_MASK) > 0)
    {
        p_external = aud_cur_get_sink_terminal(op_data, terminal_num);
        pp_internal = &p_ext_data->ag.p_playback_ip;
        pp_internal += terminal_num;
8420095a:	7b 54       	r1 = r5 LSHIFT 2;
8420095c:	59 00       	rMAC = r1 + rMAC;
        *pp_internal = p_external;
8420095e:	0a ee       	M[rMAC + Null] = r0;
        p_external = aud_cur_get_source_terminal(op_data, terminal_num);
        pp_internal = &p_ext_data->ag.p_playback_op;
        pp_internal += terminal_num;
        *pp_internal = p_external;
    }
    return TRUE;
84200960:	42 20       	r0 = Null + 1;

84200962 <Lc_aanc2_connect_hook_5>:
}
84200962:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200964:	d8 4c       	rts;

84200966 <$_aanc2_disconnect_hook>:

bool aanc2_disconnect_hook(OPERATOR_DATA *op_data, unsigned terminal_id)
{
84200966:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200968:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
8420096a:	ef fd ff ff 	call (m) 0x8ea;
8420096e:	21 ec 

    uint16 terminal_num;
    tCbuffer **pp_internal;

    /* Set internal terminal buffer pointers to NULL */
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
84200970:	b3 c2       	r1 = r4 AND 0x3f;
    if ((terminal_id & TERMINAL_SINK_MASK) > 0)
84200972:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200976:	00 00 
84200978:	04 60       	if EQ jump (m) Lc_aanc2_disconnect_hook_3;

8420097a <Lc_aanc2_disconnect_hook_2>:
    {
        pp_internal = &p_ext_data->ag.p_playback_ip;
8420097a:	21 f0 d4 21 	rMAC = r0 + 468;
8420097e:	03 6e       	jump (m) Lc_aanc2_disconnect_hook_4;

84200980 <Lc_aanc2_disconnect_hook_3>:
        pp_internal += terminal_num;
        *pp_internal = NULL;
    }
    else
    {
        pp_internal = &p_ext_data->ag.p_playback_op;
84200980:	21 f0 e4 21 	rMAC = r0 + 484;

84200984 <Lc_aanc2_disconnect_hook_4>:
    /* Set internal terminal buffer pointers to NULL */
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
    if ((terminal_id & TERMINAL_SINK_MASK) > 0)
    {
        pp_internal = &p_ext_data->ag.p_playback_ip;
        pp_internal += terminal_num;
84200984:	5a 54       	r0 = r1 LSHIFT 2;
84200986:	51 00       	rMAC = r0 + rMAC;
        *pp_internal = NULL;
84200988:	08 ee       	M[rMAC + Null] = Null;
    {
        pp_internal = &p_ext_data->ag.p_playback_op;
        pp_internal += terminal_num;
        *pp_internal = NULL;
    }
    return TRUE;
8420098a:	42 20       	r0 = Null + 1;

8420098c <Lc_aanc2_disconnect_hook_5>:
}
8420098c:	f1 48       	popm <FP, r4, rLink>;
8420098e:	d8 4c       	rts;

84200990 <$_aanc2_opmsg_set_control>:
*/
bool aanc2_opmsg_set_control(OPERATOR_DATA *op_data,
                             void *message_data,
                             unsigned *resp_length,
                             OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200990:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200992:	42 de       	M[FP + 32] = r0;
84200994:	1b 09       	r9 = r1 + Null;
84200996:	27 00       	r5 = r2 + Null;
84200998:	4d de       	M[FP + 36] = r3;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
8420099a:	ef fd ff ff 	call (m) 0x8ea;
8420099e:	31 ea 
842009a0:	16 00       	r4 = r0 + Null;

    OPMSG_RESULT_STATES result;
    CPS_CONTROL_SOURCE ctrl_src;
    unsigned ctrl_value, ctrl_id;

    if(!cps_control_setup(message_data, resp_length, resp_data, &num_controls))
842009a2:	85 12       	r3 = FP + 40;
842009a4:	3b 00       	r1 = r5 + Null;
842009a6:	5a 08       	r0 = r9 + Null;
842009a8:	4c d8       	r2 = M[FP + 36];
842009aa:	ff fd 02 f0 	call (m) 0xe9e;
842009ae:	35 e7 
842009b0:	10 04       	Null = r0 - Null;
842009b2:	03 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_3;

842009b4 <Lc_aanc2_opmsg_set_control_2>:
    {
       return FALSE;
842009b4:	02 00       	r0 = Null + Null;
842009b6:	85 6e       	jump (m) Lc_aanc2_opmsg_set_control_31;

842009b8 <Lc_aanc2_opmsg_set_control_3>:
    }

    /* Iterate through the control messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
842009b8:	00 09       	r6 = Null + Null;
842009ba:	0a 71       	r8 = Null + 1;
842009bc:	11 71       	r7 = Null + 2;
    for (i=0; i<num_controls; i++)
842009be:	07 00       	r5 = Null + Null;
842009c0:	03 6e       	jump (m) Lc_aanc2_opmsg_set_control_6;

842009c2 <Lc_aanc2_opmsg_set_control_4>:

            /* No override flags indicated for filter config */
            continue;
        }

        result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
842009c2:	20 71       	r6 = Null + 4;

842009c4 <Lc_aanc2_opmsg_set_control_5>:
       return FALSE;
    }

    /* Iterate through the control messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
    for (i=0; i<num_controls; i++)
842009c4:	7f 20       	r5 = r5 + 1;

842009c6 <Lc_aanc2_opmsg_set_control_6>:
842009c6:	51 d8       	rMAC = M[FP + 40];
842009c8:	78 04       	Null = r5 - rMAC;
842009ca:	02 f0 cf e1 	if C jump (m) Lc_aanc2_opmsg_set_control_27;

842009ce <Lc_aanc2_opmsg_set_control_7>:
    {
        ctrl_id = cps_control_get(message_data, i, &ctrl_value, &ctrl_src);
842009ce:	c5 12       	r3 = FP + 44;
842009d0:	04 13       	r2 = FP + 48;
842009d2:	3b 00       	r1 = r5 + Null;
842009d4:	5a 08       	r0 = r9 + Null;
842009d6:	ff fd 02 f0 	call (m) 0xee2;
842009da:	2d e8 

        /* Mode override */
        if (ctrl_id == OPMSG_CONTROL_MODE_ID)
842009dc:	50 24       	Null = r0 - 1;
842009de:	37 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_19;

842009e0 <Lc_aanc2_opmsg_set_control_8>:
        {
            /* Check for valid mode */
            ctrl_value &= AANC2_SYSMODE_MASK;
842009e0:	61 d8       	rMAC = M[FP + 48];
842009e2:	89 c0       	rMAC = rMAC AND 0x3;
842009e4:	61 de       	M[FP + 48] = rMAC;
             * then is switched to FREEZE, which doesn't interrupt any of the
             * event counters for the corresponding clear condition. Only after
             * the quiet condition clears is the capability switched back to
             * FULL mode, which then resets the counters.
             */
            switch (ctrl_value)
842009e6:	88 24       	Null = rMAC - 2;
842009e8:	0b 64       	if NC jump (m) Lc_aanc2_opmsg_set_control_10;

842009ea <Lc_aanc2_opmsg_set_control_9>:
                case AANC2_SYSMODE_STANDBY:
                case AANC2_SYSMODE_FREEZE:
                    break;
                case AANC2_SYSMODE_FULL:
                case AANC2_SYSMODE_FULL_CONCURRENCY:
                    aanc2_initialize_events(op_data, p_ext_data);
842009ea:	33 00       	r1 = r4 + Null;
842009ec:	42 d8       	r0 = M[FP + 32];
842009ee:	01 f0 39 ee 	call (m) Lc_aanc2_initialize_events_1;
                    aanc2_proc_reset_prev_flags(&p_ext_data->ag);
842009f2:	61 f0 3c 21 	rMAC = r4 + 316;
 */
inline void aanc2_proc_reset_prev_flags(AANC2_PROC *p_ag);

inline void aanc2_proc_reset_prev_flags(AANC2_PROC *p_ag)
{
    p_ag->prev_flags = 0;
842009f6:	48 8e       	M[rMAC + 4] = Null;
                    aanc2_initialize_gain(p_ext_data);
842009f8:	32 00       	r0 = r4 + Null;
842009fa:	03 f0 33 e4 	call (m) Lc_aanc2_initialize_gain_1;

842009fe <Lc_aanc2_opmsg_set_control_10>:
                default:
                    break;
            }

            p_ag = &p_ext_data->ag;
842009fe:	62 f0 3c 21 	r0 = r4 + 316;
            p_params = &p_ext_data->aanc2_cap_params;
84200a02:	23 f3 cc 3a 	r1 = r0 + -308;

            switch (ctrl_value)
84200a06:	61 d8       	rMAC = M[FP + 48];
84200a08:	88 24       	Null = rMAC - 2;
84200a0a:	0c 60       	if EQ jump (m) Lc_aanc2_opmsg_set_control_15;

84200a0c <Lc_aanc2_opmsg_set_control_11>:
84200a0c:	c8 24       	Null = rMAC - 3;
84200a0e:	04 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_13;

84200a10 <Lc_aanc2_opmsg_set_control_12>:
                    break;
                case AANC2_SYSMODE_FULL:
                    aanc2_proc_initialize_concurrency(p_ag, p_params, FALSE);
                    break;
                case AANC2_SYSMODE_FULL_CONCURRENCY:
                    aanc2_proc_initialize_concurrency(p_ag, p_params, TRUE);
84200a10:	54 08       	r2 = r8 + Null;
84200a12:	07 f0 35 e9 	call (m) $_aanc2_proc_initialize_concurrency;

84200a16 <Lc_aanc2_opmsg_set_control_13>:

            /* Determine whether the mode change comes from the host or from
             * QACT. If it comes from QACT (OBPM) then set the override control
             * flag so that QACT displays the mode override correctly.
             */
            if (ctrl_src == CPS_SOURCE_HOST)
84200a16:	61 d1       	rMAC = MBS[FP + 44];
84200a18:	09 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_16;

84200a1a <Lc_aanc2_opmsg_set_control_14>:
            {
                p_ext_data->host_mode = ctrl_value;
84200a1a:	61 d8       	rMAC = M[FP + 48];
84200a1c:	61 f0 4a 8e 	M[r4 + 296] = rMAC;
84200a20:	d2 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a22 <Lc_aanc2_opmsg_set_control_15>:
            {
                case AANC2_SYSMODE_STANDBY:
                case AANC2_SYSMODE_FREEZE:
                    break;
                case AANC2_SYSMODE_FULL:
                    aanc2_proc_initialize_concurrency(p_ag, p_params, FALSE);
84200a22:	04 00       	r2 = Null + Null;
84200a24:	07 f0 23 e9 	call (m) $_aanc2_proc_initialize_concurrency;
                    break;
84200a28:	f7 6f       	jump (m) Lc_aanc2_opmsg_set_control_13;

84200a2a <Lc_aanc2_opmsg_set_control_16>:
            {
                p_ext_data->host_mode = ctrl_value;
            }
            else
            {
                p_ext_data->qact_mode = ctrl_value;
84200a2a:	61 d8       	rMAC = M[FP + 48];
84200a2c:	61 f0 4b 8e 	M[r4 + 300] = rMAC;
                if (ctrl_src == CPS_SOURCE_OBPM_ENABLE)
84200a30:	61 d1       	rMAC = MBS[FP + 44];
84200a32:	88 24       	Null = rMAC - 2;
84200a34:	09 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_18;

84200a36 <Lc_aanc2_opmsg_set_control_17>:
                {
                    p_ext_data->ovr_control |= AANC2_CONTROL_MODE_OVERRIDE;
84200a36:	61 f0 4c 88 	rMAC = M[r4 + 304];
84200a3a:	20 f0 00 f1 	rMAC = rMAC OR 0x2000;
84200a3e:	51 d8 
84200a40:	61 f0 4c 8e 	M[r4 + 304] = rMAC;
84200a44:	c0 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a46 <Lc_aanc2_opmsg_set_control_18>:
                }
                else
                {
                    p_ext_data->ovr_control = 0;
84200a46:	60 f0 4c 8e 	M[r4 + 304] = Null;
84200a4a:	bd 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a4c <Lc_aanc2_opmsg_set_control_19>:

            continue;
        }

        /* Sample rate control */
        else if (ctrl_id == AANC2_CONSTANT_SAMPLE_RATE_CTRL)
84200a4c:	10 25       	Null = r0 - 4;
84200a4e:	08 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_21;

84200a50 <Lc_aanc2_opmsg_set_control_20>:
        {
            ctrl_value &= 0x3;
84200a50:	61 d8       	rMAC = M[FP + 48];
84200a52:	89 c0       	rMAC = rMAC AND 0x3;
84200a54:	61 de       	M[FP + 48] = rMAC;
            p_ext_data->ag.p_fxlms->sample_rate_config = ctrl_value;
84200a56:	62 f0 61 88 	r0 = M[r4 + 388];
84200a5a:	d1 9f       	M[r0 + 60] = rMAC;

            /* No override flags indicated for sample rate */
            continue;
84200a5c:	b4 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a5e <Lc_aanc2_opmsg_set_control_21>:
        }

        /* Filter configuration control */
        else if (ctrl_id == AANC2_CONSTANT_FILTER_CONFIG_CTRL)
84200a5e:	d0 24       	Null = r0 - 3;
84200a60:	b1 63       	if NE jump (m) Lc_aanc2_opmsg_set_control_4;

84200a62 <Lc_aanc2_opmsg_set_control_22>:
        {
            ctrl_value &= 0x3;
84200a62:	61 d8       	rMAC = M[FP + 48];
84200a64:	89 c0       	rMAC = rMAC AND 0x3;
84200a66:	61 de       	M[FP + 48] = rMAC;
            p_fxlms_cfg = &p_ext_data->ag.p_fxlms->configuration;
84200a68:	62 f0 61 88 	r0 = M[r4 + 388];
84200a6c:	13 3a       	r1 = r0 + 56;
            fxlms_cur_cfg = *p_fxlms_cfg & FXLMS100_CONFIG_LAYOUT_MASK_INV;
84200a6e:	1a e8       	r0 = M[r1 + Null];
84200a70:	22 f7 f0 1f 	r0 = r0 AND 0xfff0;

            switch (ctrl_value)
84200a74:	48 24       	Null = rMAC - 1;
84200a76:	08 60       	if EQ jump (m) Lc_aanc2_opmsg_set_control_25;

84200a78 <Lc_aanc2_opmsg_set_control_23>:
84200a78:	88 24       	Null = rMAC - 2;
84200a7a:	0b 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_26;

84200a7c <Lc_aanc2_opmsg_set_control_24>:
                case AANC2_FILTER_CONFIG_PARALLEL:
                    *p_fxlms_cfg = fxlms_cur_cfg | FXLMS100_CONFIG_PARALLEL;
                    p_ext_data->filter_config = AANC2_FILTER_CONFIG_PARALLEL;
                    break;
                case AANC2_FILTER_CONFIG_DUAL:
                    *p_fxlms_cfg = fxlms_cur_cfg | FXLMS100_CONFIG_DUAL;
84200a7c:	51 c8       	rMAC = r0 OR 0x2;
84200a7e:	19 ee       	M[r1 + Null] = rMAC;
                    p_ext_data->filter_config = AANC2_FILTER_CONFIG_DUAL;
84200a80:	69 f0 9c 8c 	MH[r4 + 312] = r7;
                    break;
84200a84:	a0 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a86 <Lc_aanc2_opmsg_set_control_25>:
            fxlms_cur_cfg = *p_fxlms_cfg & FXLMS100_CONFIG_LAYOUT_MASK_INV;

            switch (ctrl_value)
            {
                case AANC2_FILTER_CONFIG_PARALLEL:
                    *p_fxlms_cfg = fxlms_cur_cfg | FXLMS100_CONFIG_PARALLEL;
84200a86:	11 c8       	rMAC = r0 OR 0x1;
84200a88:	19 ee       	M[r1 + Null] = rMAC;
                    p_ext_data->filter_config = AANC2_FILTER_CONFIG_PARALLEL;
84200a8a:	6a f0 9c 8c 	MH[r4 + 312] = r8;
                    break;
84200a8e:	9b 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a90 <Lc_aanc2_opmsg_set_control_26>:
                    *p_fxlms_cfg = fxlms_cur_cfg | FXLMS100_CONFIG_DUAL;
                    p_ext_data->filter_config = AANC2_FILTER_CONFIG_DUAL;
                    break;
                case AANC2_FILTER_CONFIG_SINGLE:
                default:
                    *p_fxlms_cfg = fxlms_cur_cfg | FXLMS100_CONFIG_SINGLE;
84200a90:	1a ee       	M[r1 + Null] = r0;
                    p_ext_data->filter_config = AANC2_FILTER_CONFIG_SINGLE;
84200a92:	60 f0 9c 8c 	MH[r4 + 312] = Null;
                    break;
84200a96:	97 6f       	jump (m) Lc_aanc2_opmsg_set_control_5;

84200a98 <Lc_aanc2_opmsg_set_control_27>:

        result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
    }

    /* Set current operating mode based on override */
    if ((p_ext_data->ovr_control & AANC2_CONTROL_MODE_OVERRIDE) > 0)
84200a98:	61 f0 4c 88 	rMAC = M[r4 + 304];
84200a9c:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
84200aa0:	06 60       	if EQ jump (m) Lc_aanc2_opmsg_set_control_29;

84200aa2 <Lc_aanc2_opmsg_set_control_28>:
    {
        p_ext_data->cur_mode = p_ext_data->qact_mode;
84200aa2:	61 f0 4b 88 	rMAC = M[r4 + 300];
84200aa6:	61 f0 49 8e 	M[r4 + 292] = rMAC;
84200aaa:	05 6e       	jump (m) Lc_aanc2_opmsg_set_control_30;

84200aac <Lc_aanc2_opmsg_set_control_29>:
    }
    else
    {
        p_ext_data->cur_mode = p_ext_data->host_mode;
84200aac:	61 f0 4a 88 	rMAC = M[r4 + 296];
84200ab0:	61 f0 49 8e 	M[r4 + 292] = rMAC;

84200ab4 <Lc_aanc2_opmsg_set_control_30>:
    }

    cps_response_set_result(resp_data, result);
84200ab4:	43 08       	r1 = r6 + Null;
84200ab6:	4a d8       	r0 = M[FP + 36];
84200ab8:	ff fd 02 f0 	call (m) 0xf30;
84200abc:	39 e3 

    return TRUE;
84200abe:	52 08       	r0 = r8 + Null;

84200ac0 <Lc_aanc2_opmsg_set_control_31>:
}
84200ac0:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200ac2:	d8 4c       	rts;

84200ac4 <$_aanc2_opmsg_get_status>:

bool aanc2_opmsg_get_status(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *resp_length,
                            OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ac4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200ac6:	4d 4c       	SP = SP + 52;
84200ac8:	19 09       	r7 = r1 + Null;
84200aca:	27 00       	r5 = r2 + Null;
84200acc:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200ace:	ef fd ff ff 	call (m) 0x8ea;
84200ad2:	3d e0 
84200ad4:	16 00       	r4 = r0 + Null;
    /* Build the statistics message response */
    if(!common_obpm_status_helper(message_data,
                                  resp_length,
                                  resp_data,
                                  sizeof(AANC2_STATISTICS),
                                  &resp))
84200ad6:	81 11       	rMAC = FP + 24;
84200ad8:	09 1c       	pushm <rMAC>;
84200ada:	05 38       	r3 = Null + 48;
84200adc:	44 08       	r2 = r6 + Null;
84200ade:	3b 00       	r1 = r5 + Null;
84200ae0:	4a 08       	r0 = r7 + Null;
84200ae2:	ff fd 02 f0 	call (m) 0xf46;
84200ae6:	25 e3 
84200ae8:	7f 4c       	SP = SP + -4;
84200aea:	10 04       	Null = r0 - Null;
84200aec:	03 62       	if NE jump (m) Lc_aanc2_opmsg_get_status_3;

84200aee <Lc_aanc2_opmsg_get_status_2>:
    {
         return FALSE;
84200aee:	02 00       	r0 = Null + Null;
84200af0:	3b 6e       	jump (m) Lc_aanc2_opmsg_get_status_7;

84200af2 <Lc_aanc2_opmsg_get_status_3>:
    }

    if (resp != NULL)
84200af2:	31 d8       	rMAC = M[FP + 24];
84200af4:	38 60       	if EQ jump (m) Lc_aanc2_opmsg_get_status_6;

84200af6 <Lc_aanc2_opmsg_get_status_4>:
    {
        /* Setup the data for each statistic */
        p_fxlms = p_ext_data->ag.p_fxlms;
84200af6:	61 f0 61 88 	rMAC = M[r4 + 388];
        stats.OFFSET_CUR_MODE = p_ext_data->cur_mode;
84200afa:	62 f0 49 88 	r0 = M[r4 + 292];
84200afe:	3a de       	M[FP + 28] = r0;
        stats.OFFSET_OVR_CONTROL = p_ext_data->ovr_control;
84200b00:	62 f0 4c 88 	r0 = M[r4 + 304];
84200b04:	42 de       	M[FP + 32] = r0;
        stats.OFFSET_FILTER_CONFIG = p_fxlms->configuration;
84200b06:	8a 99       	r0 = M[rMAC + 56];
84200b08:	4a de       	M[FP + 36] = r0;
        stats.OFFSET_FILTER_SAMPLE_RATE = \
            p_fxlms->sample_rate_config;
84200b0a:	ca 99       	r0 = M[rMAC + 60];
84200b0c:	52 de       	M[FP + 40] = r0;
        stats.OFFSET_FLAGS = p_ext_data->cap_flags | p_ext_data->ag.proc_flags;
84200b0e:	62 f0 4f 88 	r0 = M[r4 + 316];
84200b12:	63 f0 4d 88 	r1 = M[r4 + 308];
84200b16:	d2 12       	r0 = r0 OR r1;
84200b18:	5a de       	M[FP + 44] = r0;
        stats.OFFSET_AG_CALC = p_fxlms->adaptive_gain;
84200b1a:	49 a8       	rMAC = M[rMAC + 68];
84200b1c:	61 de       	M[FP + 48] = rMAC;

        p_ag = &p_ext_data->ag;
84200b1e:	61 f0 3c 21 	rMAC = r4 + 316;
        stats.OFFSET_SPL_EXT = p_ag->p_ed_ext->spl;
84200b22:	4a 99       	r0 = M[rMAC + 52];
84200b24:	52 a8       	r0 = M[r0 + 68];
84200b26:	6a de       	M[FP + 52] = r0;
        stats.OFFSET_SPL_INT = p_ag->p_ed_int->spl;
84200b28:	8a 89       	r0 = M[rMAC + 24];
84200b2a:	52 a8       	r0 = M[r0 + 68];
84200b2c:	72 de       	M[FP + 56] = r0;
        stats.OFFSET_SPL_PB = p_ag->p_ed_pb->spl;
84200b2e:	0a a8       	r0 = M[rMAC + 64];
84200b30:	52 a8       	r0 = M[r0 + 68];
84200b32:	7a de       	M[FP + 60] = r0;
        /* Read and reset peak meters */
        stats.OFFSET_PEAK_EXT = p_ag->clip_ext.peak_value;
84200b34:	8a a9       	r0 = M[rMAC + 88];
84200b36:	82 de       	M[FP + 64] = r0;
        p_ag->clip_ext.peak_value = 0;
84200b38:	88 af       	M[rMAC + 88] = Null;
        stats.OFFSET_PEAK_INT = p_ag->clip_int.peak_value;
84200b3a:	ca b8       	r0 = M[rMAC + 108];
84200b3c:	8a de       	M[FP + 68] = r0;
        p_ag->clip_int.peak_value = 0;
84200b3e:	c8 be       	M[rMAC + 108] = Null;
        stats.OFFSET_PEAK_PB = p_ag->clip_pb.peak_value;
84200b40:	12 f0 20 88 	r0 = M[rMAC + 128];
84200b44:	92 de       	M[FP + 72] = r0;
        p_ag->clip_pb.peak_value = 0;
84200b46:	10 f0 20 8e 	M[rMAC + 128] = Null;

        pparam = (ParamType*)(&stats);
        for (i=0; i<AANC2_N_STAT/2; i++)
84200b4a:	06 00       	r4 = Null + Null;
84200b4c:	c7 11       	r5 = FP + 28;

84200b4e <Lc_aanc2_opmsg_get_status_5>:
        {
            resp = cpsPack2Words(pparam[2*i], pparam[2*i+1], resp);
84200b4e:	34 d8       	r2 = M[FP + 24];
84200b50:	7b 88       	r1 = M[r5 + 4];
84200b52:	3a e8       	r0 = M[r5 + Null];
84200b54:	ff fd 67 f2 	call (m) 0x4da2c;
84200b58:	39 e6 
84200b5a:	32 de       	M[FP + 24] = r0;
        p_ag->clip_int.peak_value = 0;
        stats.OFFSET_PEAK_PB = p_ag->clip_pb.peak_value;
        p_ag->clip_pb.peak_value = 0;

        pparam = (ParamType*)(&stats);
        for (i=0; i<AANC2_N_STAT/2; i++)
84200b5c:	76 20       	r4 = r4 + 1;
84200b5e:	3f 22       	r5 = r5 + 8;
84200b60:	b0 25       	Null = r4 - 6;
84200b62:	f6 69       	if LT jump (m) Lc_aanc2_opmsg_get_status_5;

84200b64 <Lc_aanc2_opmsg_get_status_6>:
        {
            cpsPack1Word(pparam[AANC2_N_STAT-1], resp);
        }
    }

    return TRUE;
84200b64:	42 20       	r0 = Null + 1;

84200b66 <Lc_aanc2_opmsg_get_status_7>:
}
84200b66:	73 4c       	SP = SP + -52;
84200b68:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200b6a:	d8 4c       	rts;

84200b6c <$_aanc2_opmsg_link_ahm>:

bool aanc2_opmsg_link_ahm(OPERATOR_DATA *op_data,
                          void *message_data,
                          unsigned *resp_length,
                          OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200b6c:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200b6e:	1f 00       	r5 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200b70:	ef fd fe ff 	call (m) 0x8ea;
84200b74:	3b eb 
84200b76:	16 00       	r4 = r0 + Null;
    uint16 ahm_op_id;
    bool link;

    link_data = OPMSG_FIELD_GET(message_data,
                                OPMSG_COMMON_MSG_LINK_ANC_HW_MANAGER,
                                LINK);
84200b78:	f9 88       	rMAC = M[r5 + 12];
    ahm_op_id = OPMSG_FIELD_GET(message_data,
                                  OPMSG_COMMON_MSG_LINK_ANC_HW_MANAGER,
                                  AHM_OP_ID);
84200b7a:	3a 89       	r0 = M[r5 + 16];
84200b7c:	94 c6       	r2 = r0 AND 0xffff;

    p_ext_data->ahm_op_id = ahm_op_id;
84200b7e:	64 f0 74 8d 	MH[r4 + 744] = r2;

    link = (bool)link_data;

    if (link)
84200b82:	89 c6       	rMAC = rMAC AND 0xffff;
84200b84:	2f 60       	if EQ jump (m) Lc_aanc2_opmsg_link_ahm_8;

84200b86 <Lc_aanc2_opmsg_link_ahm_2>:
    {
        if (p_ext_data->p_ff_fine_gain != NULL)
84200b86:	61 f0 b8 88 	rMAC = M[r4 + 736];
84200b8a:	0f 60       	if EQ jump (m) Lc_aanc2_opmsg_link_ahm_6;

84200b8c <Lc_aanc2_opmsg_link_ahm_3>:
        {
            L2_DBG_MSG1("OPID: %x, AANC2: link failed: already linked", p_ext_data->ag.opid);
84200b8c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200b90:	88 24       	Null = rMAC - 2;
84200b92:	09 68       	if LT jump (m) Lc_aanc2_opmsg_link_ahm_5;

84200b94 <Lc_aanc2_opmsg_link_ahm_4>:
84200b94:	63 f0 7e 88 	r1 = M[r4 + 504];
84200b98:	55 f1 02 f0 	r0 = Null + 357564722;
84200b9c:	32 41 
84200b9e:	ff fd 02 f0 	call (m) 0x10c2;
84200ba2:	25 e9 

84200ba4 <Lc_aanc2_opmsg_link_ahm_5>:
            return FALSE;
84200ba4:	02 00       	r0 = Null + Null;
84200ba6:	22 6e       	jump (m) Lc_aanc2_opmsg_link_ahm_10;

84200ba8 <Lc_aanc2_opmsg_link_ahm_6>:
        aud_cur_get_shared_fine_gain((void*)p_ext_data,
                                     AHM_ANC_FILTER_FF_ID,
                                     p_ext_data->ahm_op_id,
                                     AHM_GAIN_CONTROL_TYPE_NOMINAL,
                                     AHM_ANC_INSTANCE_ANC0_ID,
                                     aanc2_opmsg_link_ahm_callback);
84200ba8:	42 f0 0f f0 	push Null + 69210111;
84200bac:	5f ef 
84200bae:	45 20       	r3 = Null + 1;
84200bb0:	03 00       	r1 = Null + Null;
84200bb2:	00 f0 51 e0 	push Null + 1;
84200bb6:	32 00       	r0 = r4 + Null;
84200bb8:	0b f0 3b eb 	call (m) $_aud_cur_get_shared_fine_gain;
84200bbc:	7e 4c       	SP = SP + -8;
        if (p_ext_data->filter_config == AANC2_FILTER_CONFIG_DUAL)
84200bbe:	61 f0 9c 86 	rMAC = MHU[r4 + 312];
84200bc2:	88 24       	Null = rMAC - 2;
84200bc4:	12 62       	if NE jump (m) Lc_aanc2_opmsg_link_ahm_9;

84200bc6 <Lc_aanc2_opmsg_link_ahm_7>:
            aud_cur_get_shared_fine_gain((void*)p_ext_data,
                                         AHM_ANC_FILTER_FF_ID,
                                         p_ext_data->ahm_op_id,
                                         AHM_GAIN_CONTROL_TYPE_NOMINAL,
                                         AHM_ANC_INSTANCE_ANC1_ID,
                                         aanc2_opmsg_link_ahm_callback);
84200bc6:	42 f0 0f f0 	push Null + 69210111;
84200bca:	5f ef 
84200bcc:	45 20       	r3 = Null + 1;
84200bce:	64 f0 74 87 	r2 = MHU[r4 + 744];
84200bd2:	03 00       	r1 = Null + Null;
84200bd4:	00 f0 52 e0 	push Null + 2;
84200bd8:	32 00       	r0 = r4 + Null;
84200bda:	0b f0 39 ea 	call (m) $_aud_cur_get_shared_fine_gain;
84200bde:	7e 4c       	SP = SP + -8;
84200be0:	04 6e       	jump (m) Lc_aanc2_opmsg_link_ahm_9;

84200be2 <Lc_aanc2_opmsg_link_ahm_8>:
        }
    }
    else
    {
        aanc2_release_shared_gains(p_ext_data);
84200be2:	32 00       	r0 = r4 + Null;
84200be4:	01 f0 37 ee 	call (m) Lc_aanc2_release_shared_gains_1;

84200be8 <Lc_aanc2_opmsg_link_ahm_9>:

    }

    return TRUE;
84200be8:	42 20       	r0 = Null + 1;

84200bea <Lc_aanc2_opmsg_link_ahm_10>:
}
84200bea:	f2 48       	popm <FP, r4, r5, rLink>;
84200bec:	d8 4c       	rts;

84200bee <$_aanc2_opmsg_get_shared_gain_ptr>:

bool aanc2_opmsg_get_shared_gain_ptr(OPERATOR_DATA *op_data,
                                     void *message_data,
                                     unsigned *resp_length,
                                     OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200bee:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200bf0:	11 09       	r7 = r0 + Null;
84200bf2:	1e 00       	r4 = r1 + Null;
84200bf4:	23 09       	r9 = r2 + Null;
84200bf6:	2a 09       	r8 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200bf8:	ef fd fe ff 	call (m) 0x8ea;
84200bfc:	33 e7 
84200bfe:	17 00       	r5 = r0 + Null;
    unsigned is_coarse_data, p_recv_ext_data, msg_id;
    bool is_coarse;

    p_recv_ext_data = OPMSG_FIELD_GET32(message_data,
                                        OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                        P_EXT_DATA);
84200c00:	31 89       	rMAC = M[r4 + 16];
84200c02:	8a c6       	r0 = rMAC AND 0xffff;
84200c04:	92 56       	r0 = r0 LSHIFT 16;
84200c06:	f1 88       	rMAC = M[r4 + 12];
84200c08:	89 c6       	rMAC = rMAC AND 0xffff;
84200c0a:	1f f2 08 c0 	r6 = r0 + rMAC;
    is_coarse_data = OPMSG_FIELD_GET(message_data,
                                     OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                     COARSE);
84200c0e:	b1 89       	rMAC = M[r4 + 24];
    is_coarse = (bool)is_coarse_data;

    /* Only handle fine gains */
    if (is_coarse)
84200c10:	89 c6       	rMAC = rMAC AND 0xffff;
84200c12:	13 60       	if EQ jump (m) Lc_aanc2_opmsg_get_shared_gain_ptr_5;

84200c14 <Lc_aanc2_opmsg_get_shared_gain_ptr_2>:
    {
        L2_DBG_MSG1("OPID: %x, AANC2: Shared coarse gain not supported",
                     INT_TO_EXT_OPID(op_data->id));
84200c14:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200c18:	88 24       	Null = rMAC - 2;
84200c1a:	0d 68       	if LT jump (m) Lc_aanc2_opmsg_get_shared_gain_ptr_4;

84200c1c <Lc_aanc2_opmsg_get_shared_gain_ptr_3>:
84200c1c:	92 f0 01 88 	r0 = M[r7 + 4];
84200c20:	52 55       	r0 = r0 LSHIFT 6;
84200c22:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200c26:	53 d8 
84200c28:	55 f1 02 f0 	r0 = Null + 357564767;
84200c2c:	5f 41 
84200c2e:	ff fd 02 f0 	call (m) 0x10c2;
84200c32:	35 e4 

84200c34 <Lc_aanc2_opmsg_get_shared_gain_ptr_4>:
        return FALSE;
84200c34:	02 00       	r0 = Null + Null;
84200c36:	2b 6e       	jump (m) Lc_aanc2_opmsg_get_shared_gain_ptr_8;

84200c38 <Lc_aanc2_opmsg_get_shared_gain_ptr_5>:
    }

    p_resp = xzpnewn(OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP_WORD_SIZE, unsigned);
84200c38:	c3 20       	r1 = Null + 3;
84200c3a:	02 3b       	r0 = Null + 60;
84200c3c:	ff fd 31 f0 	call (m) 0x6f8e;
84200c40:	33 ea 
    if (p_resp == NULL)
84200c42:	10 04       	Null = r0 - Null;
84200c44:	0e 62       	if NE jump (m) Lc_aanc2_opmsg_get_shared_gain_ptr_7;

84200c46 <Lc_aanc2_opmsg_get_shared_gain_ptr_6>:
    {
        L0_DBG_MSG1("OPID: %x, ANC2: Failed to create shared gain response",
                     INT_TO_EXT_OPID(op_data->id));
84200c46:	92 f0 01 88 	r0 = M[r7 + 4];
84200c4a:	52 55       	r0 = r0 LSHIFT 6;
84200c4c:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200c50:	53 d8 
84200c52:	55 f1 02 f0 	r0 = Null + 357564817;
84200c56:	91 41 
84200c58:	ff fd 02 f0 	call (m) 0x10c2;
84200c5c:	2b e3 
84200c5e:	eb 6f       	jump (m) Lc_aanc2_opmsg_get_shared_gain_ptr_4;

84200c60 <Lc_aanc2_opmsg_get_shared_gain_ptr_7>:
        return FALSE;
    }
    *resp_length = OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP_WORD_SIZE;
84200c60:	c1 23       	rMAC = Null + 15;
84200c62:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
    msg_id = OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*)message_data);
84200c66:	b1 88       	rMAC = M[r4 + 8];

    /* Set the message ID */
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                             MESSAGE_ID,
                             msg_id);
84200c68:	11 ee       	M[r0 + Null] = rMAC;
    /* Set the extra operator data pointer */
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               P_EXT_DATA,
                               p_recv_ext_data);
84200c6a:	81 f7 ff 1f 	rMAC = r6 AND 0xffff;
84200c6e:	78 f8 d3 c8 	r1 = r6 LSHIFT -16;
84200c72:	51 8e       	M[r0 + 4] = rMAC;
84200c74:	93 8e       	M[r0 + 8] = r1;
    /* Set shared gain pointer */
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               SHARED_GAIN_PTR,
                               (unsigned)p_ext_data->p_ff_fine_gain);
84200c76:	71 f0 b8 88 	rMAC = M[r5 + 736];
84200c7a:	89 c6       	rMAC = rMAC AND 0xffff;
84200c7c:	d1 8e       	M[r0 + 12] = rMAC;
84200c7e:	73 f0 b8 88 	r1 = M[r5 + 736];
84200c82:	9b 52       	r1 = r1 LSHIFT -16;
84200c84:	13 8f       	M[r0 + 16] = r1;


    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)p_resp;
84200c86:	a2 f0 00 ee 	M[r8 + Null] = r0;

    return TRUE;
84200c8a:	42 20       	r0 = Null + 1;

84200c8c <Lc_aanc2_opmsg_get_shared_gain_ptr_8>:
}
84200c8c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200c8e:	d8 4c       	rts;

84200c90 <$_aanc2_opmsg_set_plant_model>:
*/
bool aanc2_opmsg_set_plant_model(OPERATOR_DATA *op_data,
                                 void *message_data,
                                 unsigned *resp_length,
                                 OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200c90:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200c92:	16 00       	r4 = r0 + Null;
84200c94:	1f 00       	r5 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200c96:	ef fd fe ff 	call (m) 0x8ea;
84200c9a:	35 e2 
84200c9c:	10 09       	r6 = r0 + Null;
                                 unsigned *resp_length,
                                 OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (!aanc_fxlms100_set_plant_model(p_ext_data->ag.p_fxlms, message_data))
84200c9e:	82 f0 61 88 	r0 = M[r6 + 388];
84200ca2:	3b 00       	r1 = r5 + Null;
84200ca4:	0e f0 21 ee 	call (m) $_aanc_fxlms100_set_plant_model;
84200ca8:	10 04       	Null = r0 - Null;
84200caa:	12 62       	if NE jump (m) Lc_aanc2_opmsg_set_plant_model_5;

84200cac <Lc_aanc2_opmsg_set_plant_model_2>:
    {
        L4_DBG_MSG1("OPID: %x, AANC set plant coefficients failed", INT_TO_EXT_OPID(op_data->id));
84200cac:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200cb0:	08 25       	Null = rMAC - 4;
84200cb2:	0c 68       	if LT jump (m) Lc_aanc2_opmsg_set_plant_model_4;

84200cb4 <Lc_aanc2_opmsg_set_plant_model_3>:
84200cb4:	72 88       	r0 = M[r4 + 4];
84200cb6:	52 55       	r0 = r0 LSHIFT 6;
84200cb8:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200cbc:	53 d8 
84200cbe:	55 f1 02 f0 	r0 = Null + 357564871;
84200cc2:	c7 41 
84200cc4:	ff fd 01 f0 	call (m) 0x10c2;
84200cc8:	3f ef 

84200cca <Lc_aanc2_opmsg_set_plant_model_4>:
        return FALSE;
84200cca:	02 00       	r0 = Null + Null;
84200ccc:	0f 6e       	jump (m) Lc_aanc2_opmsg_set_plant_model_6;

84200cce <Lc_aanc2_opmsg_set_plant_model_5>:
    }

    /* Indicate the model loading state and trigger a reinitialization */
    p_ext_data->cap_flags |= AANC2_FLAGS_PLANT_MODEL_LOADED;
84200cce:	81 f0 4d 88 	rMAC = M[r6 + 308];
84200cd2:	00 f2 00 f1 	rMAC = rMAC OR 0x20000;
84200cd6:	51 d8 
84200cd8:	81 f0 4d 8e 	M[r6 + 308] = rMAC;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84200cdc:	32 00       	r0 = r4 + Null;
84200cde:	ef fd fe ff 	call (m) 0x934;
84200ce2:	37 e2 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
84200ce4:	41 20       	rMAC = Null + 1;
84200ce6:	11 ea       	MB[r0 + Null] = rMAC;
    aud_cur_set_reinit(op_data, TRUE);

    return TRUE;
84200ce8:	0a 00       	r0 = rMAC + Null;

84200cea <Lc_aanc2_opmsg_set_plant_model_6>:
}
84200cea:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200cec:	d8 4c       	rts;

84200cee <$_aanc2_opmsg_set_control_model>:

bool aanc2_opmsg_set_control_model(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *resp_length,
                                   OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200cee:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200cf0:	16 00       	r4 = r0 + Null;
84200cf2:	18 09       	r6 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200cf4:	ef fd fd ff 	call (m) 0x8ea;
84200cf8:	37 ef 
84200cfa:	17 00       	r5 = r0 + Null;
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);

    int destination;

    if (!aanc_fxlms100_set_control_model(p_ext_data->ag.p_fxlms, message_data,
                                         &destination))
84200cfc:	44 11       	r2 = FP + 20;
84200cfe:	72 f0 61 88 	r0 = M[r5 + 388];
84200d02:	43 08       	r1 = r6 + Null;
84200d04:	0e f0 39 ee 	call (m) $_aanc_fxlms100_set_control_model;
84200d08:	10 04       	Null = r0 - Null;
84200d0a:	12 62       	if NE jump (m) Lc_aanc2_opmsg_set_control_model_5;

84200d0c <Lc_aanc2_opmsg_set_control_model_2>:
    {
        L4_DBG_MSG1("OPID: %x, AANC set control coefficients failed", INT_TO_EXT_OPID(op_data->id));
84200d0c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200d10:	08 25       	Null = rMAC - 4;
84200d12:	0c 68       	if LT jump (m) Lc_aanc2_opmsg_set_control_model_4;

84200d14 <Lc_aanc2_opmsg_set_control_model_3>:
84200d14:	72 88       	r0 = M[r4 + 4];
84200d16:	52 55       	r0 = r0 LSHIFT 6;
84200d18:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200d1c:	53 d8 
84200d1e:	55 f1 02 f0 	r0 = Null + 357564916;
84200d22:	f4 41 
84200d24:	ff fd 01 f0 	call (m) 0x10c2;
84200d28:	3f ec 

84200d2a <Lc_aanc2_opmsg_set_control_model_4>:
        return FALSE;
84200d2a:	02 00       	r0 = Null + Null;
84200d2c:	1a 6e       	jump (m) Lc_aanc2_opmsg_set_control_model_9;

84200d2e <Lc_aanc2_opmsg_set_control_model_5>:
    }

    /* Indicate the model loading state and trigger a reinitialization */
    if (destination)
84200d2e:	28 d8       	Null = M[FP + 20];
84200d30:	0a 60       	if EQ jump (m) Lc_aanc2_opmsg_set_control_model_7;

84200d32 <Lc_aanc2_opmsg_set_control_model_6>:
    {
        p_ext_data->cap_flags |= AANC2_FLAGS_CONTROL_1_MODEL_LOADED;
84200d32:	71 f0 4d 88 	rMAC = M[r5 + 308];
84200d36:	00 f0 00 f8 	rMAC = rMAC OR 0x80000;
84200d3a:	00 f1 51 c8 
84200d3e:	71 f0 4d 8e 	M[r5 + 308] = rMAC;
84200d42:	08 6e       	jump (m) Lc_aanc2_opmsg_set_control_model_8;

84200d44 <Lc_aanc2_opmsg_set_control_model_7>:
    }
    else
    {
        p_ext_data->cap_flags |= AANC2_FLAGS_CONTROL_0_MODEL_LOADED;
84200d44:	71 f0 4d 88 	rMAC = M[r5 + 308];
84200d48:	00 f4 00 f1 	rMAC = rMAC OR 0x40000;
84200d4c:	51 d8 
84200d4e:	71 f0 4d 8e 	M[r5 + 308] = rMAC;

84200d52 <Lc_aanc2_opmsg_set_control_model_8>:
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84200d52:	32 00       	r0 = r4 + Null;
84200d54:	ef fd fd ff 	call (m) 0x934;
84200d58:	21 ef 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
84200d5a:	41 20       	rMAC = Null + 1;
84200d5c:	11 ea       	MB[r0 + Null] = rMAC;
    }
    aud_cur_set_reinit(op_data, TRUE);

    return TRUE;
84200d5e:	0a 00       	r0 = rMAC + Null;

84200d60 <Lc_aanc2_opmsg_set_control_model_9>:
}
84200d60:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200d62:	d8 4c       	rts;

84200d64 <$_aanc2_opmsg_get_adaptive_gain>:

bool aanc2_opmsg_get_adaptive_gain(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *resp_length,
                                   OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d64:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200d66:	16 00       	r4 = r0 + Null;
84200d68:	1a 09       	r8 = r1 + Null;
84200d6a:	27 00       	r5 = r2 + Null;
84200d6c:	29 09       	r7 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC2_OP_DATA.
 */
static inline AANC2_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC2_OP_DATA *) base_op_get_instance_data(op_data);
84200d6e:	ef fd fd ff 	call (m) 0x8ea;
84200d72:	3d eb 
84200d74:	10 09       	r6 = r0 + Null;
    AANC2_OP_DATA *p_ext_data = get_instance_data(op_data);
    unsigned *p_resp;
    uint16 adaptive_gain;
    uint16 msg_id;

    *resp_length = OPMSG_GET_AANC_ADAPTIVE_GAIN_RESP_WORD_SIZE;
84200d76:	81 20       	rMAC = Null + 2;
84200d78:	39 ee       	M[r5 + Null] = rMAC;

    p_resp = xzpnewn(OPMSG_GET_AANC_ADAPTIVE_GAIN_RESP_WORD_SIZE, unsigned);
84200d7a:	c3 20       	r1 = Null + 3;
84200d7c:	02 22       	r0 = Null + 8;
84200d7e:	ff fd 31 f0 	call (m) 0x6f8e;
84200d82:	31 e0 
    if (p_resp == NULL)
84200d84:	10 04       	Null = r0 - Null;
84200d86:	12 62       	if NE jump (m) Lc_aanc2_opmsg_get_adaptive_gain_5;

84200d88 <Lc_aanc2_opmsg_get_adaptive_gain_2>:
    {
        L2_DBG_MSG1("OPID: %x, AANC: get_adaptive_gain - Failed to allocate response msg",
                     INT_TO_EXT_OPID(op_data->id));
84200d88:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200d8c:	88 24       	Null = rMAC - 2;
84200d8e:	0c 68       	if LT jump (m) Lc_aanc2_opmsg_get_adaptive_gain_4;

84200d90 <Lc_aanc2_opmsg_get_adaptive_gain_3>:
84200d90:	72 88       	r0 = M[r4 + 4];
84200d92:	52 55       	r0 = r0 LSHIFT 6;
84200d94:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200d98:	53 d8 
84200d9a:	55 f1 02 f0 	r0 = Null + 357564963;
84200d9e:	23 42 
84200da0:	ff fd 01 f0 	call (m) 0x10c2;
84200da4:	23 e9 

84200da6 <Lc_aanc2_opmsg_get_adaptive_gain_4>:
        return FALSE;
84200da6:	02 00       	r0 = Null + Null;
84200da8:	0d 6e       	jump (m) Lc_aanc2_opmsg_get_adaptive_gain_6;

84200daa <Lc_aanc2_opmsg_get_adaptive_gain_5>:
    }

    adaptive_gain = (uint16)p_ext_data->ag.p_fxlms->adaptive_gain;
84200daa:	81 f0 61 88 	rMAC = M[r6 + 388];
84200dae:	49 a8       	rMAC = M[rMAC + 68];
84200db0:	89 c6       	rMAC = rMAC AND 0xffff;
    msg_id = (uint16)OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*)message_data);
84200db2:	a3 f0 02 88 	r1 = M[r8 + 8];
84200db6:	9b c6       	r1 = r1 AND 0xffff;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AANC_ADAPTIVE_GAIN_RESP,
                             MESSAGE_ID,
                             msg_id);
84200db8:	13 ee       	M[r0 + Null] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AANC_ADAPTIVE_GAIN_RESP,
                             ADAPTIVE_GAIN,
                             adaptive_gain);
84200dba:	51 8e       	M[r0 + 4] = rMAC;

    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)p_resp;
84200dbc:	92 f0 00 ee 	M[r7 + Null] = r0;

    return TRUE;
84200dc0:	42 20       	r0 = Null + 1;

84200dc2 <Lc_aanc2_opmsg_get_adaptive_gain_6>:
}
84200dc2:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200dc4:	d8 4c       	rts;

84200dc6 <Lc_aanc2_initialize_events_1>:
 * Initialize each event in the operator extra_op_data according to its
 * event ID and duration.
 */
static void aanc2_initialize_events(OPERATOR_DATA *op_data,
                                    AANC2_OP_DATA *p_ext_data)
{
84200dc6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200dc8:	16 00       	r4 = r0 + Null;
84200dca:	18 09       	r6 = r1 + Null;
    AANC2_PARAMETERS *p_params = &p_ext_data->aanc2_cap_params;
84200dcc:	87 f0 08 20 	r5 = r6 + 8;
    aanc2_initialize_event(&p_ext_data->gain_event,
                           op_data,
                           p_params->OFFSET_EVENT_GAIN_STUCK,
                           AANC2_EVENT_ID_GAIN);
84200dd0:	fc 89       	r2 = M[r5 + 28];
84200dd2:	72 f0 f4 21 	r0 = r5 + 500;
84200dd6:	05 00       	r3 = Null + Null;
84200dd8:	33 00       	r1 = r4 + Null;
84200dda:	07 f0 39 e1 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->ed_event,
                           op_data,
                           p_params->OFFSET_EVENT_ED_STUCK,
                           AANC2_EVENT_ID_ED);
84200dde:	45 20       	r3 = Null + 1;
84200de0:	7c a9       	r2 = M[r5 + 84];
84200de2:	82 f0 18 22 	r0 = r6 + 536;
84200de6:	33 00       	r1 = r4 + Null;
84200de8:	07 f0 2b e1 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->quiet_event_detect,
                           op_data,
                           p_params->OFFSET_EVENT_QUIET_DETECT,
                           AANC2_EVENT_ID_QUIET);
84200dec:	85 20       	r3 = Null + 2;
84200dee:	fc 99       	r2 = M[r5 + 60];
84200df0:	82 f0 34 22 	r0 = r6 + 564;
84200df4:	33 00       	r1 = r4 + Null;
84200df6:	07 f0 3d e0 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->quiet_event_clear,
                           op_data,
                           p_params->OFFSET_EVENT_QUIET_CLEAR,
                           AANC2_EVENT_ID_QUIET);
84200dfa:	85 20       	r3 = Null + 2;
84200dfc:	3c a8       	r2 = M[r5 + 64];
84200dfe:	82 f0 50 22 	r0 = r6 + 592;
84200e02:	33 00       	r1 = r4 + Null;
84200e04:	07 f0 2f e0 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->clip_event,
                           op_data,
                           p_params->OFFSET_EVENT_CLIP_STUCK,
                           AANC2_EVENT_ID_CLIP);
84200e08:	c5 20       	r3 = Null + 3;
84200e0a:	7c 98       	r2 = M[r5 + 36];
84200e0c:	82 f0 6c 22 	r0 = r6 + 620;
84200e10:	33 00       	r1 = r4 + Null;
84200e12:	07 f0 21 e0 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->sat_event,
                           op_data,
                           p_params->OFFSET_EVENT_SAT_STUCK,
                           AANC2_EVENT_ID_SAT);
84200e16:	05 21       	r3 = Null + 4;
84200e18:	bc 98       	r2 = M[r5 + 40];
84200e1a:	82 f0 88 22 	r0 = r6 + 648;
84200e1e:	33 00       	r1 = r4 + Null;
84200e20:	06 f0 33 ef 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->self_talk_event,
                           op_data,
                           p_params->OFFSET_EVENT_SELF_TALK,
                           AANC2_EVENT_ID_SELF_TALK);
84200e24:	45 21       	r3 = Null + 5;
84200e26:	7c a8       	r2 = M[r5 + 68];
84200e28:	82 f0 a4 22 	r0 = r6 + 676;
84200e2c:	33 00       	r1 = r4 + Null;
84200e2e:	06 f0 25 ef 	call (m) $_aanc2_initialize_event;
    aanc2_initialize_event(&p_ext_data->spl_event,
                           op_data,
                           p_params->OFFSET_EVENT_SPL,
                           AANC2_EVENT_ID_SPL);
84200e32:	85 21       	r3 = Null + 6;
84200e34:	fc a8       	r2 = M[r5 + 76];
84200e36:	82 f0 c0 22 	r0 = r6 + 704;
84200e3a:	33 00       	r1 = r4 + Null;
84200e3c:	06 f0 37 ee 	call (m) $_aanc2_initialize_event;

84200e40 <Lc_aanc2_initialize_events_2>:
    return;
84200e40:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200e42:	d8 4c       	rts;

84200e44 <Lc_aanc2_process_events_1>:
 * Calculate the event state machine for each event in the operator
 * extra_op_data.
 *
 */
static void aanc2_process_events(AANC2_OP_DATA *p_ext_data)
{
84200e44:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200e46:	16 00       	r4 = r0 + Null;
     * previous gain matches the current gain, otherwise is reset. If there
     * is an ED event then this will also reset the event state, sending a
     * negative trigger unsolicited message if the gain stuck event has already
     * been sent.
     */
    p_event = &p_ext_data->gain_event;
84200e48:	62 f0 fc 21 	r0 = r4 + 508;
    cur_gain = (uint8)p_ext_data->ag.p_fxlms->adaptive_gain;
84200e4c:	61 f0 61 88 	rMAC = M[r4 + 388];
84200e50:	49 a8       	rMAC = M[rMAC + 68];
84200e52:	89 c3       	rMAC = rMAC AND 0xff;
    p_event->msg.payload = (uint16)cur_gain;
84200e54:	91 9c       	MH[r0 + 20] = rMAC;
    /* Adaptive gain event: reset if ED detected */
    if (p_ext_data->ag.proc_flags & AANC2_ED_FLAG_MASK)
84200e56:	63 f0 4f 88 	r1 = M[r4 + 316];
84200e5a:	33 f0 70 00 	r1 = r1 AND 0x70;
84200e5e:	0f 60       	if EQ jump (m) Lc_aanc2_process_events_5;

84200e60 <Lc_aanc2_process_events_2>:
    {
        /* If we had previously sent a message then send the negative trigger */
        if (p_event->running == AANC2_EVENT_SENT)
84200e60:	11 90       	rMAC = MBS[r0 + 8];
84200e62:	88 24       	Null = rMAC - 2;
84200e64:	06 62       	if NE jump (m) Lc_aanc2_process_events_4;

84200e66 <Lc_aanc2_process_events_3>:
        {
            p_event->msg.payload = 0;
84200e66:	90 9c       	MH[r0 + 20] = Null;
            p_event->msg.type = AANC2_EVENT_MSG_NEGATIVE_TRIGGER;
84200e68:	10 aa       	MB[r0 + 16] = Null;
            aanc2_send_event_trigger(&p_event->msg);
84200e6a:	12 23       	r0 = r0 + 12;
84200e6c:	06 f0 21 ef 	call (m) $_aanc2_send_event_trigger;

84200e70 <Lc_aanc2_process_events_4>:
        }
        aanc2_clear_event(&p_ext_data->gain_event);
84200e70:	61 f0 fc 21 	rMAC = r4 + 508;
 */
inline void aanc2_clear_event(AANC2_EVENT *p_event);

inline void aanc2_clear_event(AANC2_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84200e74:	4a 88       	r0 = M[rMAC + 4];
84200e76:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC2_EVENT_CLEAR;
84200e78:	08 9a       	MB[rMAC + 8] = Null;
84200e7a:	0a 6e       	jump (m) Lc_aanc2_process_events_8;

84200e7c <Lc_aanc2_process_events_5>:
    }
    /* Condition holds */
    else if (cur_gain == p_ext_data->ag.prev_gain)
84200e7c:	63 f0 5c 83 	r1 = MBU[r4 + 348];
84200e80:	c8 04       	Null = rMAC - r1;
84200e82:	04 62       	if NE jump (m) Lc_aanc2_process_events_7;

84200e84 <Lc_aanc2_process_events_6>:
    {
        aanc2_process_event_detect_condition(p_event);
84200e84:	07 f0 2f e1 	call (m) $_aanc2_process_event_detect_condition;
84200e88:	03 6e       	jump (m) Lc_aanc2_process_events_8;

84200e8a <Lc_aanc2_process_events_7>:
    }
    /* Condition cleared */
    else
    {
        aanc2_process_event_clear_condition(p_event);
84200e8a:	07 f0 3d e2 	call (m) $_aanc2_process_event_clear_condition;

84200e8e <Lc_aanc2_process_events_8>:
     * the only conditions associated with the event are the current flags
     * and previous flags.
     */
    aanc2_process_event(&p_ext_data->ed_event,
                        p_ext_data->ag.proc_flags & AANC2_ED_FLAG_MASK,
                        p_ext_data->ag.prev_flags & AANC2_ED_FLAG_MASK);
84200e8e:	61 f0 50 88 	rMAC = M[r4 + 320];
84200e92:	14 f0 70 00 	r2 = rMAC AND 0x70;
84200e96:	61 f0 4f 88 	rMAC = M[r4 + 316];
84200e9a:	13 f0 70 00 	r1 = rMAC AND 0x70;
84200e9e:	62 f0 18 22 	r0 = r4 + 536;
84200ea2:	06 f0 33 ec 	call (m) $_aanc2_process_event;

    /* Quiet condition detection event. This event has positive and negative
     * triggers dependent on the state of the detection flags.
     */
    p_detect = &p_ext_data->quiet_event_detect;
84200ea6:	68 f0 34 22 	r6 = r4 + 564;
    p_clear = &p_ext_data->quiet_event_clear;
84200eaa:	87 f0 1c 20 	r5 = r6 + 28;
    cur_qm = p_ext_data->ag.proc_flags & AANC2_FLAGS_QUIET_MODE;
84200eae:	61 f0 4f 88 	rMAC = M[r4 + 316];
    prev_qm = p_ext_data->ag.prev_flags & AANC2_FLAGS_QUIET_MODE;
84200eb2:	62 f0 50 88 	r0 = M[r4 + 320];
84200eb6:	08 f0 22 f0 	r0 = r0 AND 0x100000;
84200eba:	00 00 
    /* Quiet condition currently detected */
    if (cur_qm > 0)
84200ebc:	08 f0 11 f0 	rMAC = rMAC AND 0x100000;
84200ec0:	00 00 
84200ec2:	26 60       	if EQ jump (m) Lc_aanc2_process_events_14;

84200ec4 <Lc_aanc2_process_events_9>:
    {
        /* Quiet condition also in the previous frame. If the event has been
         * detected then decrement the frame counter. When the counter expires
         * then send the positive detection message.
         */
        if (prev_qm > 0)
84200ec4:	10 04       	Null = r0 - Null;
84200ec6:	19 60       	if EQ jump (m) Lc_aanc2_process_events_13;

84200ec8 <Lc_aanc2_process_events_10>:
        {
            if (p_detect->running == AANC2_EVENT_DETECTED)
84200ec8:	81 f0 08 80 	rMAC = MBS[r6 + 8];
84200ecc:	48 24       	Null = rMAC - 1;
84200ece:	3e 62       	if NE jump (m) Lc_aanc2_process_events_19;

84200ed0 <Lc_aanc2_process_events_11>:
            {
                p_detect->frame_counter -= 1;
84200ed0:	ff f8 11 d1 	rMAC = M[r6] + -1;
84200ed4:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                if (p_detect->frame_counter <= 0)
84200ed8:	08 24       	Null = rMAC - 0;
84200eda:	38 6a       	if GT jump (m) Lc_aanc2_process_events_19;

84200edc <Lc_aanc2_process_events_12>:
                {
                    p_detect->msg.type = AANC2_EVENT_MSG_POSITIVE_TRIGGER;
84200edc:	41 20       	rMAC = Null + 1;
84200ede:	81 f0 10 8a 	MB[r6 + 16] = rMAC;
                    aanc2_send_event_trigger(&p_detect->msg);
84200ee2:	82 f0 0c 20 	r0 = r6 + 12;
84200ee6:	06 f0 27 eb 	call (m) $_aanc2_send_event_trigger;
                    p_detect->running = AANC2_EVENT_SENT;
84200eea:	81 20       	rMAC = Null + 2;
84200eec:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
                    p_ext_data->quiet_condition = TRUE;
84200ef0:	41 20       	rMAC = Null + 1;
84200ef2:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
84200ef6:	2a 6e       	jump (m) Lc_aanc2_process_events_19;

84200ef8 <Lc_aanc2_process_events_13>:
         * for event detection, so change event state and reset the clear event
         * state.
         */
        else
        {
            p_detect->frame_counter -= 1;
84200ef8:	ff f8 11 d1 	rMAC = M[r6] + -1;
84200efc:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            p_detect->running = AANC2_EVENT_DETECTED;
84200f00:	41 20       	rMAC = Null + 1;
84200f02:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
 */
inline void aanc2_clear_event(AANC2_EVENT *p_event);

inline void aanc2_clear_event(AANC2_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84200f06:	79 88       	rMAC = M[r5 + 4];
84200f08:	39 ee       	M[r5 + Null] = rMAC;
       p_event->running = AANC2_EVENT_CLEAR;
84200f0a:	38 9a       	MB[r5 + 8] = Null;
84200f0c:	1f 6e       	jump (m) Lc_aanc2_process_events_19;

84200f0e <Lc_aanc2_process_events_14>:
    {
        /* Previous frame was a quiet condition. This is the falling edge for
         * event detection, so change event state on the clear counter and
         * reset the detected event state.
         */
        if (prev_qm)
84200f0e:	10 04       	Null = r0 - Null;
84200f10:	0d 60       	if EQ jump (m) Lc_aanc2_process_events_16;

84200f12 <Lc_aanc2_process_events_15>:
        {
            p_clear->frame_counter -= 1;
84200f12:	ff f7 11 d1 	rMAC = M[r5] + -1;
84200f16:	39 ee       	M[r5 + Null] = rMAC;
            p_clear->running = AANC2_EVENT_DETECTED;
84200f18:	41 20       	rMAC = Null + 1;
84200f1a:	39 9a       	MB[r5 + 8] = rMAC;
 */
inline void aanc2_clear_event(AANC2_EVENT *p_event);

inline void aanc2_clear_event(AANC2_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84200f1c:	81 f0 01 88 	rMAC = M[r6 + 4];
84200f20:	81 f0 00 ee 	M[r6 + Null] = rMAC;
       p_event->running = AANC2_EVENT_CLEAR;
84200f24:	80 f0 08 8a 	MB[r6 + 8] = Null;
84200f28:	11 6e       	jump (m) Lc_aanc2_process_events_19;

84200f2a <Lc_aanc2_process_events_16>:
         * quiet mode. Decrement the frame counter and once below the threshold
         * indicate that the quiet condition has cleared.
         */
        else
        {
            if (p_clear->running == AANC2_EVENT_DETECTED)
84200f2a:	39 90       	rMAC = MBS[r5 + 8];
84200f2c:	48 24       	Null = rMAC - 1;
84200f2e:	0e 62       	if NE jump (m) Lc_aanc2_process_events_19;

84200f30 <Lc_aanc2_process_events_17>:
            {
                p_clear->frame_counter -= 1;
84200f30:	ff f7 11 d1 	rMAC = M[r5] + -1;
84200f34:	39 ee       	M[r5 + Null] = rMAC;
                if (p_clear->frame_counter <= 0)
84200f36:	08 24       	Null = rMAC - 0;
84200f38:	09 6a       	if GT jump (m) Lc_aanc2_process_events_19;

84200f3a <Lc_aanc2_process_events_18>:
                {
                    p_clear->msg.type = AANC2_EVENT_MSG_NEGATIVE_TRIGGER;
84200f3a:	38 aa       	MB[r5 + 16] = Null;
                    aanc2_send_event_trigger(&p_clear->msg);
84200f3c:	3a 23       	r0 = r5 + 12;
84200f3e:	06 f0 2f e8 	call (m) $_aanc2_send_event_trigger;
                    p_clear->running = AANC2_EVENT_SENT;
84200f42:	81 20       	rMAC = Null + 2;
84200f44:	39 9a       	MB[r5 + 8] = rMAC;
                    p_ext_data->quiet_condition = FALSE;
84200f46:	60 f0 b7 8e 	M[r4 + 732] = Null;

84200f4a <Lc_aanc2_process_events_19>:
     * because the only conditions associated with the event are the current
     * flags and previous flags.
     */
    aanc2_process_event(&p_ext_data->clip_event,
                        p_ext_data->ag.proc_flags & AANC2_CLIPPING_FLAG_MASK,
                        p_ext_data->ag.prev_flags & AANC2_CLIPPING_FLAG_MASK);
84200f4a:	61 f0 50 88 	rMAC = M[r4 + 320];
84200f4e:	14 f0 00 07 	r2 = rMAC AND 0x700;
84200f52:	61 f0 4f 88 	rMAC = M[r4 + 316];
84200f56:	13 f0 00 07 	r1 = rMAC AND 0x700;
84200f5a:	62 f0 6c 22 	r0 = r4 + 620;
84200f5e:	06 f0 37 e6 	call (m) $_aanc2_process_event;
     * because the only conditions associated with the event are the current
     * flags and previous flags.
     */
    aanc2_process_event(&p_ext_data->sat_event,
                        p_ext_data->ag.proc_flags & AANC2_SATURATION_FLAG_MASK,
                        p_ext_data->ag.prev_flags & AANC2_SATURATION_FLAG_MASK);
84200f62:	61 f0 50 88 	rMAC = M[r4 + 320];
84200f66:	14 f7 00 10 	r2 = rMAC AND 0xf000;
84200f6a:	61 f0 4f 88 	rMAC = M[r4 + 316];
84200f6e:	13 f7 00 10 	r1 = rMAC AND 0xf000;
84200f72:	62 f0 88 22 	r0 = r4 + 648;
84200f76:	06 f0 3f e5 	call (m) $_aanc2_process_event;
     * because the only conditions associated with the event are the current
     * flags and previous flags.
     */
    aanc2_process_event(&p_ext_data->self_talk_event,
                        p_ext_data->ag.proc_flags & AANC2_FLAGS_SELF_SPEECH,
                        p_ext_data->ag.prev_flags & AANC2_FLAGS_SELF_SPEECH);
84200f7a:	61 f0 50 88 	rMAC = M[r4 + 320];
84200f7e:	4c c3       	r2 = rMAC AND 0x80;
84200f80:	61 f0 4f 88 	rMAC = M[r4 + 316];
84200f84:	4b c3       	r1 = rMAC AND 0x80;
84200f86:	62 f0 a4 22 	r0 = r4 + 676;
84200f8a:	06 f0 2b e5 	call (m) $_aanc2_process_event;

    /* SPL above threshold event. If the external SPL is above the threshold
     * then increment the detection counter, otherwise clear the event.
     */
    cur_ext = p_ext_data->ag.p_ed_ext->spl;
84200f8e:	61 f0 5c 88 	rMAC = M[r4 + 368];
84200f92:	4b a8       	r1 = M[rMAC + 68];
    p_event = &p_ext_data->spl_event;
84200f94:	62 f0 c0 22 	r0 = r4 + 704;
    p_event->msg.payload = (uint16)(cur_ext >> 16);
84200f98:	9c 5a       	r2 = r1 ASHIFT -16;
84200f9a:	94 9c       	MH[r0 + 20] = r2;
    if (cur_ext > p_ext_data->aanc2_cap_params.OFFSET_EVENT_SPL_THRESHOLD)
84200f9c:	b1 a9       	rMAC = M[r4 + 88];
84200f9e:	58 04       	Null = r1 - rMAC;
84200fa0:	09 f0 8b e0 	if LS jump (m) Lc_aanc2_process_events_21;

84200fa4 <Lc_aanc2_process_events_20>:
    {
        aanc2_process_event_detect_condition(p_event);
84200fa4:	06 f0 2f e8 	call (m) $_aanc2_process_event_detect_condition;
84200fa8:	03 6e       	jump (m) Lc_aanc2_process_events_22;

84200faa <Lc_aanc2_process_events_21>:
    }
    else
    {
        aanc2_process_event_clear_condition(p_event);
84200faa:	06 f0 3d e9 	call (m) $_aanc2_process_event_clear_condition;

84200fae <Lc_aanc2_process_events_22>:
    }

    /* Update previous flag states */
    aanc2_proc_update_prev_flags(&p_ext_data->ag);
84200fae:	61 f0 3c 21 	rMAC = r4 + 316;
 */
inline void aanc2_proc_update_prev_flags(AANC2_PROC *p_ag);

inline void aanc2_proc_update_prev_flags(AANC2_PROC *p_ag)
{
    p_ag->prev_flags = p_ag->proc_flags;
84200fb2:	0a e8       	r0 = M[rMAC + Null];
84200fb4:	4a 8e       	M[rMAC + 4] = r0;

84200fb6 <Lc_aanc2_process_events_23>:

    return;
84200fb6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200fb8:	d8 4c       	rts;

84200fba <Lc_aanc2_release_shared_gains_1>:
 *
 * \return - None
 *
 */
static void aanc2_release_shared_gains(AANC2_OP_DATA *p_ext_data)
{
84200fba:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200fbc:	16 00       	r4 = r0 + Null;
    AHM_SHARED_FINE_GAIN *p_gain;

    /* Release channel 0 */
    p_gain = p_ext_data->p_ff_fine_gain;

    if ((p_gain == NULL) || (p_ext_data->ahm_op_id == 0))
84200fbe:	67 f0 b8 88 	r5 = M[r4 + 736];
84200fc2:	1c 60       	if EQ jump (m) Lc_aanc2_release_shared_gains_6;

84200fc4 <Lc_aanc2_release_shared_gains_2>:
84200fc4:	65 f0 74 87 	r3 = MHU[r4 + 744];
84200fc8:	19 60       	if EQ jump (m) Lc_aanc2_release_shared_gains_6;

84200fca <Lc_aanc2_release_shared_gains_3>:

    aud_cur_release_shared_fine_gain(p_gain,
                                     AHM_ANC_FILTER_FF_ID,
                                     AHM_GAIN_CONTROL_TYPE_NOMINAL,
                                     p_ext_data->ahm_op_id,
                                     AHM_ANC_INSTANCE_ANC0_ID);
84200fca:	00 f0 51 e0 	push Null + 1;
84200fce:	44 20       	r2 = Null + 1;
84200fd0:	03 00       	r1 = Null + Null;
84200fd2:	3a 00       	r0 = r5 + Null;
84200fd4:	09 f0 2b e9 	call (m) $_aud_cur_release_shared_fine_gain;
84200fd8:	7f 4c       	SP = SP + -4;
    if (p_ext_data->filter_config == AANC2_FILTER_CONFIG_DUAL)
84200fda:	61 f0 9c 86 	rMAC = MHU[r4 + 312];
84200fde:	88 24       	Null = rMAC - 2;
84200fe0:	0b 62       	if NE jump (m) Lc_aanc2_release_shared_gains_5;

84200fe2 <Lc_aanc2_release_shared_gains_4>:
    {
        aud_cur_release_shared_fine_gain(p_gain,
                                         AHM_ANC_FILTER_FF_ID,
                                         AHM_GAIN_CONTROL_TYPE_NOMINAL,
                                         p_ext_data->ahm_op_id,
                                         AHM_ANC_INSTANCE_ANC1_ID);
84200fe2:	00 f0 52 e0 	push Null + 2;
84200fe6:	65 f0 74 87 	r3 = MHU[r4 + 744];
84200fea:	44 20       	r2 = Null + 1;
84200fec:	03 00       	r1 = Null + Null;
84200fee:	3a 00       	r0 = r5 + Null;
84200ff0:	09 f0 2f e8 	call (m) $_aud_cur_release_shared_fine_gain;
84200ff4:	7f 4c       	SP = SP + -4;

84200ff6 <Lc_aanc2_release_shared_gains_5>:
    }
    p_ext_data->p_ff_fine_gain = NULL;
84200ff6:	60 f0 b8 8e 	M[r4 + 736] = Null;

84200ffa <Lc_aanc2_release_shared_gains_6>:

    return;
}
84200ffa:	f2 48       	popm <FP, r4, r5, rLink>;
84200ffc:	d8 4c       	rts;

84200ffe <Lc_aanc2_opmsg_link_ahm_callback_1>:
static bool aanc2_opmsg_link_ahm_callback(CONNECTION_LINK con_id,
                                          STATUS_KYMERA status,
                                          EXT_OP_ID op_id,
                                          unsigned num_resp_params,
                                          unsigned *resp_params)
{
84200ffe:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201000:	19 00       	rMAC = r1 + Null;
84201002:	fa d9       	r0 = M[FP + -4];
    AHM_ANC_INSTANCE anc_instance;
    unsigned anc_filter_raw, anc_instance_raw;

    raw_ptr = OPMSG_CREATION_FIELD_GET32(resp_params,
                                         OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                                         P_EXT_DATA);
84201004:	93 88       	r1 = M[r0 + 8];
84201006:	54 88       	r2 = M[r0 + 4];
84201008:	9b 56       	r1 = r1 LSHIFT 16;
8420100a:	e4 12       	r2 = r2 OR r1;
    p_ext_data = (AANC2_OP_DATA*)raw_ptr;

    if (status != ACCMD_STATUS_OK)
8420100c:	08 04       	Null = rMAC - Null;
8420100e:	0c 60       	if EQ jump (m) Lc_aanc2_opmsg_link_ahm_callback_3;

84201010 <Lc_aanc2_opmsg_link_ahm_callback_2>:
    {
        L0_DBG_MSG2("OPID: %x, AANC2 link response failed: status=%d", p_ext_data->ag.opid, status);
84201010:	43 f0 7e 88 	r1 = M[r2 + 504];
84201014:	55 f1 02 f0 	r0 = Null + 357564416;
84201018:	00 40 
8420101a:	0c 00       	r2 = rMAC + Null;
8420101c:	ff fd 00 f0 	call (m) 0x10d6;
84201020:	3b e5 
        return FALSE;
84201022:	02 00       	r0 = Null + Null;
84201024:	32 6e       	jump (m) Lc_aanc2_opmsg_link_ahm_callback_11;

84201026 <Lc_aanc2_opmsg_link_ahm_callback_3>:
    }
    raw_gain = OPMSG_CREATION_FIELD_GET32(resp_params,
                                          OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                                          SHARED_GAIN_PTR);
84201026:	13 89       	r1 = M[r0 + 16];
84201028:	d1 88       	rMAC = M[r0 + 12];
8420102a:	9b 56       	r1 = r1 LSHIFT 16;
8420102c:	5d 12       	r3 = r1 OR rMAC;
    p_gain = (AHM_SHARED_FINE_GAIN*)raw_gain;

    static_gain = OPMSG_CREATION_FIELD_GET32(
        resp_params, OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP, STATIC_GAINS_PTR);
8420102e:	13 98       	r1 = M[r0 + 32];
84201030:	d1 89       	rMAC = M[r0 + 28];
84201032:	9b 56       	r1 = r1 LSHIFT 16;
84201034:	c9 12       	rMAC = rMAC OR r1;


    cur_gain = OPMSG_CREATION_FIELD_GET32(
        resp_params, OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP, CURRENT_GAINS_PTR);
84201036:	93 89       	r1 = M[r0 + 24];
84201038:	56 89       	r4 = M[r0 + 20];
8420103a:	9b 56       	r1 = r1 LSHIFT 16;
8420103c:	9b 13       	r1 = r1 OR r4;

    anc_filter_raw = OPMSG_CREATION_FIELD_GET(resp_params,
                                              OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                                              FILTER_TYPE);
8420103e:	d6 98       	r4 = M[r0 + 44];
    anc_filter = (AHM_ANC_FILTER) anc_filter_raw;
84201040:	36 08       	r4 = SE8 r4;
    anc_instance_raw = OPMSG_CREATION_FIELD_GET(resp_params,
                                                 OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                                                 CHANNEL);
84201042:	12 99       	r0 = M[r0 + 48];
    anc_instance = (AHM_ANC_INSTANCE) anc_instance_raw;
84201044:	17 08       	r5 = SE8 r0;

    if(anc_instance == AHM_ANC_INSTANCE_ANC0_ID && anc_filter == AHM_ANC_FILTER_FF_ID)
84201046:	78 24       	Null = r5 - 1;
84201048:	0a 62       	if NE jump (m) Lc_aanc2_opmsg_link_ahm_callback_6;

8420104a <Lc_aanc2_opmsg_link_ahm_callback_4>:
8420104a:	30 04       	Null = r4 - Null;
8420104c:	13 62       	if NE jump (m) Lc_aanc2_opmsg_link_ahm_callback_9;

8420104e <Lc_aanc2_opmsg_link_ahm_callback_5>:
    {
        p_ext_data->p_ff_fine_gain = p_gain;
8420104e:	45 f0 b8 8e 	M[r2 + 736] = r3;
        p_ext_data->p_cur_gain = (AHM_GAIN_BANK*)cur_gain;
84201052:	43 f0 bd 8e 	M[r2 + 756] = r1;
        p_ext_data->p_static_gain = (AHM_GAIN_BANK*)static_gain;
84201056:	41 f0 bb 8e 	M[r2 + 748] = rMAC;
8420105a:	16 6e       	jump (m) Lc_aanc2_opmsg_link_ahm_callback_10;

8420105c <Lc_aanc2_opmsg_link_ahm_callback_6>:
    }
    else if(anc_instance == AHM_ANC_INSTANCE_ANC1_ID && anc_filter == AHM_ANC_FILTER_FF_ID)
8420105c:	b8 24       	Null = r5 - 2;
8420105e:	0a 62       	if NE jump (m) Lc_aanc2_opmsg_link_ahm_callback_9;

84201060 <Lc_aanc2_opmsg_link_ahm_callback_7>:
84201060:	30 04       	Null = r4 - Null;
84201062:	08 62       	if NE jump (m) Lc_aanc2_opmsg_link_ahm_callback_9;

84201064 <Lc_aanc2_opmsg_link_ahm_callback_8>:
    {
        p_ext_data->p_ff_fine_gain1 = p_gain;
84201064:	45 f0 b9 8e 	M[r2 + 740] = r3;
        p_ext_data->p_cur_gain1 = (AHM_GAIN_BANK*)cur_gain;
84201068:	43 f0 be 8e 	M[r2 + 760] = r1;
        p_ext_data->p_static_gain1 = (AHM_GAIN_BANK*)static_gain;
8420106c:	41 f0 bc 8e 	M[r2 + 752] = rMAC;
84201070:	0b 6e       	jump (m) Lc_aanc2_opmsg_link_ahm_callback_10;

84201072 <Lc_aanc2_opmsg_link_ahm_callback_9>:
    }
    else
    {
        L0_DBG_MSG3("OPID: %x, AANC2 invalid ANC instance: %d or ANC filter: %d",p_ext_data->ag.opid, anc_instance, anc_filter);
84201072:	43 f0 7e 88 	r1 = M[r2 + 504];
84201076:	55 f1 02 f0 	r0 = Null + 357564464;
8420107a:	30 40 
8420107c:	35 00       	r3 = r4 + Null;
8420107e:	3c 00       	r2 = r5 + Null;
84201080:	ff fd 00 f0 	call (m) 0x10ec;
84201084:	2d e3 

84201086 <Lc_aanc2_opmsg_link_ahm_callback_10>:
    }
    return TRUE;
84201086:	42 20       	r0 = Null + 1;

84201088 <Lc_aanc2_opmsg_link_ahm_callback_11>:
}
84201088:	f2 48       	popm <FP, r4, r5, rLink>;
8420108a:	d8 4c       	rts;

8420108c <Lc_aanc2_initialize_gain_1>:
 *
 * \param p_ext_data  Pointer to operator extra data object
 */

static void aanc2_initialize_gain(AANC2_OP_DATA *p_ext_data)
{
8420108c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420108e:	16 00       	r4 = r0 + Null;

    uint16 gain_value, gain_value1;

    /* Check for the instance0 gain linking */
    if (p_ext_data->p_cur_gain != NULL && p_ext_data->p_static_gain != NULL)
84201090:	61 f0 bd 88 	rMAC = M[r4 + 756];
84201094:	15 60       	if EQ jump (m) Lc_aanc2_initialize_gain_10;

84201096 <Lc_aanc2_initialize_gain_2>:
84201096:	62 f0 bb 88 	r0 = M[r4 + 748];
8420109a:	12 60       	if EQ jump (m) Lc_aanc2_initialize_gain_10;

8420109c <Lc_aanc2_initialize_gain_3>:
    {
        gain_value = p_ext_data->p_cur_gain->ff.fine;
        if (gain_value == 0)
8420109c:	18 f0 01 86 	r6 = MHU[rMAC + 2];
842010a0:	03 62       	if NE jump (m) Lc_aanc2_initialize_gain_5;

842010a2 <Lc_aanc2_initialize_gain_4>:
        {
            gain_value = p_ext_data->p_static_gain->ff.fine;
842010a2:	28 f0 01 86 	r6 = MHU[r0 + 2];

842010a6 <Lc_aanc2_initialize_gain_5>:
        }

        /* Check for the instance1 gain linking */
        if (p_ext_data->p_cur_gain1 != NULL && p_ext_data->p_static_gain1 != NULL)
842010a6:	61 f0 be 88 	rMAC = M[r4 + 760];
842010aa:	08 60       	if EQ jump (m) Lc_aanc2_initialize_gain_9;

842010ac <Lc_aanc2_initialize_gain_6>:
842010ac:	62 f0 bc 88 	r0 = M[r4 + 752];
842010b0:	05 60       	if EQ jump (m) Lc_aanc2_initialize_gain_9;

842010b2 <Lc_aanc2_initialize_gain_7>:
        {
            gain_value1 = p_ext_data->p_cur_gain1->ff.fine;
            if (gain_value1 == 0)
842010b2:	4f 86       	r5 = MHU[rMAC + 2];
842010b4:	15 62       	if NE jump (m) Lc_aanc2_initialize_gain_12;

842010b6 <Lc_aanc2_initialize_gain_8>:
            {
                gain_value1 = p_ext_data->p_static_gain1->ff.fine;
842010b6:	57 86       	r5 = MHU[r0 + 2];
842010b8:	13 6e       	jump (m) Lc_aanc2_initialize_gain_12;

842010ba <Lc_aanc2_initialize_gain_9>:
            }
        }
        else
        {
            gain_value1 = gain_value;
842010ba:	47 08       	r5 = r6 + Null;
842010bc:	11 6e       	jump (m) Lc_aanc2_initialize_gain_12;

842010be <Lc_aanc2_initialize_gain_10>:
        }
    }
    else
    {
        /* Step 3: if the gain hasn't been linked then prime with a default value */
        gain_value = AANC2_DEFAULT_INIT_VALUE;
842010be:	08 f0 80 40 	r6 = Null + 128;
        gain_value1 = AANC2_DEFAULT_INIT_VALUE;
842010c2:	47 08       	r5 = r6 + Null;
        L2_DBG_MSG2("OPID: %x, AANC2 init gain: no link, default to %d", p_ext_data->ag.opid, gain_value);
842010c4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842010c8:	88 24       	Null = rMAC - 2;
842010ca:	0a 68       	if LT jump (m) Lc_aanc2_initialize_gain_12;

842010cc <Lc_aanc2_initialize_gain_11>:
842010cc:	63 f0 7e 88 	r1 = M[r4 + 504];
842010d0:	3c 00       	r2 = r5 + Null;
842010d2:	55 f1 02 f0 	r0 = Null + 357564523;
842010d6:	6b 40 
842010d8:	ef fd ff ff 	call (m) 0x10d6;
842010dc:	3f ef 

842010de <Lc_aanc2_initialize_gain_12>:
    }

    if (gain_value != p_ext_data->ag.p_fxlms->adaptive_gain ||
        gain_value1 != p_ext_data->ag.p_fxlms->adaptive_gain1)
842010de:	62 f0 61 88 	r0 = M[r4 + 388];
842010e2:	51 a8       	rMAC = M[r0 + 68];
842010e4:	1f f8 00 c2 	Null = r6 - rMAC;
842010e8:	04 62       	if NE jump (m) Lc_aanc2_initialize_gain_14;

842010ea <Lc_aanc2_initialize_gain_13>:
842010ea:	91 a8       	rMAC = M[r0 + 72];
842010ec:	78 04       	Null = r5 - rMAC;
842010ee:	0d 60       	if EQ jump (m) Lc_aanc2_initialize_gain_15;

842010f0 <Lc_aanc2_initialize_gain_14>:
    {
        aanc_fxlms100_update_gain(p_ext_data->ag.p_fxlms, gain_value, gain_value1);
842010f0:	3c 00       	r2 = r5 + Null;
842010f2:	43 08       	r1 = r6 + Null;
842010f4:	0c f0 2f e5 	call (m) $_aanc_fxlms100_update_gain;
        p_ext_data->p_ff_fine_gain->gain = (uint8)gain_value;
842010f8:	61 f0 b8 88 	rMAC = M[r4 + 736];
842010fc:	18 f0 0c 8a 	MB[rMAC + 12] = r6;
        p_ext_data->p_ff_fine_gain1->gain = (uint8)gain_value1;
84201100:	61 f0 b9 88 	rMAC = M[r4 + 740];
84201104:	0f 9b       	MB[rMAC + 12] = r5;
84201106:	0f 6e       	jump (m) Lc_aanc2_initialize_gain_17;

84201108 <Lc_aanc2_initialize_gain_15>:
    }
    else
    {
        L2_DBG_MSG3("OPID: %x, AANC2 init gain matches: gain_value: %d, gain_value1: %d",
                     p_ext_data->ag.opid, gain_value, gain_value1);
84201108:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420110c:	88 24       	Null = rMAC - 2;
8420110e:	0b 68       	if LT jump (m) Lc_aanc2_initialize_gain_17;

84201110 <Lc_aanc2_initialize_gain_16>:
84201110:	63 f0 7e 88 	r1 = M[r4 + 504];
84201114:	55 f1 02 f0 	r0 = Null + 357564573;
84201118:	9d 40 
8420111a:	3d 00       	r3 = r5 + Null;
8420111c:	44 08       	r2 = r6 + Null;
8420111e:	ef fd ff ff 	call (m) 0x10ec;
84201122:	2f ee 

84201124 <Lc_aanc2_initialize_gain_17>:
    }
    return;
}
84201124:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201126:	d8 4c       	rts;

84201128 <$_AANC2_GetDefaults>:
84201128:	20 f0 c8 24 	Null = r0 - 200;
   0x00F00000u,			// ED_INT_MIN_SIGNAL_CONC
   0x00A00000u			// PLAYBACK_RATIO_THRESHOLD_CONC
};

unsigned *AANC2_GetDefaults(unsigned capid){
	switch(capid){
8420112c:	05 60       	if EQ jump (m) Lc_AANC2_GetDefaults_3;

8420112e <Lc_AANC2_GetDefaults_2>:
8420112e:	01 f0 20 f0 	Null = r0 - 16544;
84201132:	a0 24 
84201134:	05 62       	if NE jump (m) Lc_AANC2_GetDefaults_4;

84201136 <Lc_AANC2_GetDefaults_3>:
		case 0x00C8: return defaults_aanc2AANC2_16K;
84201136:	f1 ff 02 f3 	r0 = Null + -15335424;
8420113a:	00 40 
8420113c:	02 6e       	jump (m) Lc_AANC2_GetDefaults_5;

8420113e <Lc_AANC2_GetDefaults_4>:
		case 0x40A0: return defaults_aanc2AANC2_16K;
	}
	return((unsigned *)0);
8420113e:	02 00       	r0 = Null + Null;

84201140 <Lc_AANC2_GetDefaults_5>:
84201140:	d8 4c       	rts;

84201142 <$_aanc2_proc_create>:
84201142:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
/******************************************************************************
Public Function Implementations
*/

bool aanc2_proc_create(AANC2_PROC *p_ag, unsigned sample_rate)
{
84201144:	53 4c       	SP = SP + 76;
84201146:	16 00       	r4 = r0 + Null;
84201148:	43 de       	M[FP + 32] = r1;
    uint16 fxlms_dmx_words, fxlms_dm_words; /* Memory required by FxLMS */
    uint16 ed_dmx_words, ed_dm1_words;      /* Memory required by EDs */
    FXLMS100_FILTER_COEFFS* coeffs;         /* Pointer to FxLMS coefficients */

    /* Load the feature handle for AANC private libraries */
    if (!load_aanc_handle(&p_ag->f_handle))
8420114a:	62 f0 b8 20 	r0 = r4 + 184;
8420114e:	0e f0 33 e6 	call (m) $_load_aanc_handle;
84201152:	10 04       	Null = r0 - Null;
84201154:	13 62       	if NE jump (m) Lc_aanc2_proc_create_5;

84201156 <Lc_aanc2_proc_create_2>:
    {
        aanc2_proc_destroy(p_ag);
84201156:	32 00       	r0 = r4 + Null;
84201158:	01 f0 3d e8 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to load feature handle", p_ag->opid);
8420115c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201160:	88 24       	Null = rMAC - 2;
84201162:	09 68       	if LT jump (m) Lc_aanc2_proc_create_4;

84201164 <Lc_aanc2_proc_create_3>:
84201164:	63 f0 2f 88 	r1 = M[r4 + 188];
84201168:	55 f1 02 f0 	r0 = Null + 357565178;
8420116c:	fa 42 
8420116e:	ef fd ff ff 	call (m) 0x10c2;
84201172:	35 ea 

84201174 <Lc_aanc2_proc_create_4>:
        return FALSE;
84201174:	02 00       	r0 = Null + Null;
84201176:	0f f0 f9 e5 	jump (m) Lc_aanc2_proc_create_27;

8420117a <Lc_aanc2_proc_create_5>:
    }

    /* Allocate internal input cbuffer in DM1 */
    if (!aud_cur_create_cbuffer(&p_ag->p_tmp_int_ip,
                                AANC2_INTERNAL_BUFFER_SIZE,
                                MALLOC_PREFERENCE_DM1))
8420117a:	44 20       	r2 = Null + 1;
8420117c:	03 f0 41 40 	r1 = Null + 65;
84201180:	32 28       	r0 = r4 + 16;
84201182:	08 f0 2b e9 	call (m) $_aud_cur_create_cbuffer;
84201186:	10 04       	Null = r0 - Null;
84201188:	11 62       	if NE jump (m) Lc_aanc2_proc_create_8;

8420118a <Lc_aanc2_proc_create_6>:
    {
        aanc2_proc_destroy(p_ag);
8420118a:	32 00       	r0 = r4 + Null;
8420118c:	01 f0 29 e7 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate int mic input buffer", p_ag->opid);
84201190:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201194:	88 24       	Null = rMAC - 2;
84201196:	ef 69       	if LT jump (m) Lc_aanc2_proc_create_4;

84201198 <Lc_aanc2_proc_create_7>:
84201198:	63 f0 2f 88 	r1 = M[r4 + 188];
8420119c:	55 f1 02 f0 	r0 = Null + 357565229;
842011a0:	2d 43 
842011a2:	ef fd ff ff 	call (m) 0x10c2;
842011a6:	21 e9 
842011a8:	e6 6f       	jump (m) Lc_aanc2_proc_create_4;

842011aa <Lc_aanc2_proc_create_8>:
    }

    /* Allocate external input cbuffer in DM2 */
    if (!aud_cur_create_cbuffer(&p_ag->p_tmp_ext_ip,
                                AANC2_INTERNAL_BUFFER_SIZE,
                                MALLOC_PREFERENCE_DM1))
842011aa:	44 20       	r2 = Null + 1;
842011ac:	03 f0 41 40 	r1 = Null + 65;
842011b0:	32 33       	r0 = r4 + 44;
842011b2:	08 f0 3b e7 	call (m) $_aud_cur_create_cbuffer;
842011b6:	10 04       	Null = r0 - Null;
842011b8:	11 62       	if NE jump (m) Lc_aanc2_proc_create_11;

842011ba <Lc_aanc2_proc_create_9>:
    {
        aanc2_proc_destroy(p_ag);
842011ba:	32 00       	r0 = r4 + Null;
842011bc:	01 f0 39 e5 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate ext mic input buffer", p_ag->opid);
842011c0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842011c4:	88 24       	Null = rMAC - 2;
842011c6:	d7 69       	if LT jump (m) Lc_aanc2_proc_create_4;

842011c8 <Lc_aanc2_proc_create_10>:
842011c8:	63 f0 2f 88 	r1 = M[r4 + 188];
842011cc:	55 f1 02 f0 	r0 = Null + 357565290;
842011d0:	6a 43 
842011d2:	ef fd ff ff 	call (m) 0x10c2;
842011d6:	31 e7 
842011d8:	ce 6f       	jump (m) Lc_aanc2_proc_create_4;

842011da <Lc_aanc2_proc_create_11>:
    }

    /* Allocate int mic output cbuffer in DM2 */
    if (!aud_cur_create_cbuffer(&p_ag->p_tmp_int_op,
                                AANC2_INTERNAL_BUFFER_SIZE,
                                MALLOC_PREFERENCE_DM2))
842011da:	84 20       	r2 = Null + 2;
842011dc:	03 f0 41 40 	r1 = Null + 65;
842011e0:	32 29       	r0 = r4 + 20;
842011e2:	08 f0 2b e6 	call (m) $_aud_cur_create_cbuffer;
842011e6:	10 04       	Null = r0 - Null;
842011e8:	11 62       	if NE jump (m) Lc_aanc2_proc_create_14;

842011ea <Lc_aanc2_proc_create_12>:
    {
        aanc2_proc_destroy(p_ag);
842011ea:	32 00       	r0 = r4 + Null;
842011ec:	01 f0 29 e4 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate int mic output buffer", p_ag->opid);
842011f0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842011f4:	88 24       	Null = rMAC - 2;
842011f6:	bf 69       	if LT jump (m) Lc_aanc2_proc_create_4;

842011f8 <Lc_aanc2_proc_create_13>:
842011f8:	63 f0 2f 88 	r1 = M[r4 + 188];
842011fc:	55 f1 02 f0 	r0 = Null + 357565351;
84201200:	a7 43 
84201202:	ef fd ff ff 	call (m) 0x10c2;
84201206:	21 e6 
84201208:	b6 6f       	jump (m) Lc_aanc2_proc_create_4;

8420120a <Lc_aanc2_proc_create_14>:
    }

    /* Allocate ext mic output cbuffer in DM2 */
    if (!aud_cur_create_cbuffer(&p_ag->p_tmp_ext_op,
                                AANC2_INTERNAL_BUFFER_SIZE,
                                MALLOC_PREFERENCE_DM2))
8420120a:	84 20       	r2 = Null + 2;
8420120c:	03 f0 41 40 	r1 = Null + 65;
84201210:	32 38       	r0 = r4 + 48;
84201212:	08 f0 3b e4 	call (m) $_aud_cur_create_cbuffer;
84201216:	10 04       	Null = r0 - Null;
84201218:	11 62       	if NE jump (m) Lc_aanc2_proc_create_17;

8420121a <Lc_aanc2_proc_create_15>:
    {
        aanc2_proc_destroy(p_ag);
8420121a:	32 00       	r0 = r4 + Null;
8420121c:	01 f0 39 e2 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate ext mic output buffer", p_ag->opid);
84201220:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201224:	88 24       	Null = rMAC - 2;
84201226:	a7 69       	if LT jump (m) Lc_aanc2_proc_create_4;

84201228 <Lc_aanc2_proc_create_16>:
84201228:	63 f0 2f 88 	r1 = M[r4 + 188];
8420122c:	55 f1 02 f0 	r0 = Null + 357565413;
84201230:	e5 43 
84201232:	ef fd ff ff 	call (m) 0x10c2;
84201236:	31 e4 
84201238:	9e 6f       	jump (m) Lc_aanc2_proc_create_4;

8420123a <Lc_aanc2_proc_create_17>:
        return FALSE;
    }

    /* Create playback cbuffer */
    p_ag->p_tmp_pb_ip = cbuffer_create_with_malloc(AANC2_INTERNAL_BUFFER_SIZE,
                                                   BUF_DESC_SW_BUFFER);
8420123a:	02 f0 41 40 	r0 = Null + 65;
8420123e:	03 00       	r1 = Null + Null;
84201240:	ff fd 97 f0 	call (m) 0x1421e;
84201244:	3f ee 
84201246:	f2 9f       	M[r4 + 60] = r0;
    if (p_ag->p_tmp_pb_ip == NULL)
84201248:	f1 99       	rMAC = M[r4 + 60];
8420124a:	11 62       	if NE jump (m) Lc_aanc2_proc_create_20;

8420124c <Lc_aanc2_proc_create_18>:
    {
        aanc2_proc_destroy(p_ag);
8420124c:	32 00       	r0 = r4 + Null;
8420124e:	01 f0 27 e1 	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate playback cbuffer", p_ag->opid);
84201252:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201256:	88 24       	Null = rMAC - 2;
84201258:	8e 69       	if LT jump (m) Lc_aanc2_proc_create_4;

8420125a <Lc_aanc2_proc_create_19>:
8420125a:	63 f0 2f 88 	r1 = M[r4 + 188];
8420125e:	55 f1 02 f0 	r0 = Null + 357565475;
84201262:	23 48 
84201264:	ef fd ff ff 	call (m) 0x10c2;
84201268:	3f e2 
8420126a:	85 6f       	jump (m) Lc_aanc2_proc_create_4;

8420126c <Lc_aanc2_proc_create_20>:
        return FALSE;
    }

    /* Allocate FxLMS and ED memory using the mem_table API */
    fxlms_dmx_words = (uint16)(aanc_fxlms100_dmx_bytes()/sizeof(unsigned));
8420126c:	0a f0 23 e0 	call (m) $_aanc_fxlms100_dmx_bytes;
84201270:	57 50       	r5 = r0 LSHIFT -2;
    fxlms_dm_words = (uint16)(AANC2_PROC_FXLMS_DM_BYTES/sizeof(unsigned));
    ed_dmx_words = (uint16)(aanc_ed100_dmx_bytes()/sizeof(unsigned));
84201272:	0d f0 2b e2 	call (m) $_aanc_ed100_dmx_bytes;
84201276:	7f f2 da c8 	r8 = r0 LSHIFT -2;
    ed_dm1_words = (uint16)(aanc_ed100_dm1_bytes()/sizeof(unsigned));
8420127a:	0d f0 29 e2 	call (m) $_aanc_ed100_dm1_bytes;
8420127e:	7f f2 db c8 	r9 = r0 LSHIFT -2;

    p_ag->p_table = xzpnewn(AANC2_PROC_MEM_TABLE_SIZE, malloc_t_entry);
84201282:	c3 20       	r1 = Null + 3;
84201284:	82 39       	r0 = Null + 54;
84201286:	ff fd 2e f0 	call (m) 0x6f8e;
8420128a:	29 e8 
8420128c:	b2 8e       	M[r4 + 8] = r0;
8420128e:	18 71       	r6 = Null + 3;
84201290:	01 f0 48 40 	rMAC = Null + 72;
84201294:	97 dc       	MH[FP + 36] = r5;
84201296:	e8 f0 13 8c 	MH[FP + 38] = r6;
8420129a:	a1 dc       	MH[FP + 40] = rMAC;
    p_ag->p_table[0] = (malloc_t_entry){
        fxlms_dmx_words,
        MALLOC_PREFERENCE_NONE,
        offsetof(AANC2_PROC, p_fxlms)};
8420129c:	43 12       	r1 = FP + 36;
8420129e:	84 21       	r2 = Null + 6;
842012a0:	ff fd c7 f0 	call (m) 0x1a170;
842012a4:	31 e6 
842012a6:	09 f0 4b 41 	r7 = Null + 331;
842012aa:	47 20       	r5 = Null + 1;
842012ac:	01 f0 4c 40 	rMAC = Null + 76;
842012b0:	e9 f0 16 8c 	MH[FP + 44] = r7;
842012b4:	bf dc       	MH[FP + 46] = r5;
842012b6:	c1 dc       	MH[FP + 48] = rMAC;
    p_ag->p_table[1] = (malloc_t_entry){
        fxlms_dm_words,
        MALLOC_PREFERENCE_DM1,
        offsetof(AANC2_PROC, p_fxlms_dm1)};
842012b8:	c3 12       	r1 = FP + 44;
842012ba:	b1 88       	rMAC = M[r4 + 8];
842012bc:	84 21       	r2 = Null + 6;
842012be:	8a 21       	r0 = rMAC + 6;
842012c0:	ff fd c7 f0 	call (m) 0x1a170;
842012c4:	31 e5 
842012c6:	e9 f0 1a 8c 	MH[FP + 52] = r7;
842012ca:	81 20       	rMAC = Null + 2;
842012cc:	d9 dc       	MH[FP + 54] = rMAC;
842012ce:	01 f0 50 40 	rMAC = Null + 80;
842012d2:	e1 dc       	MH[FP + 56] = rMAC;
    p_ag->p_table[2] = (malloc_t_entry){
        fxlms_dm_words,
        MALLOC_PREFERENCE_DM2,
        offsetof(AANC2_PROC, p_fxlms_dm2)};
842012d4:	43 13       	r1 = FP + 52;
842012d6:	b1 88       	rMAC = M[r4 + 8];
842012d8:	84 21       	r2 = Null + 6;
842012da:	0a 23       	r0 = rMAC + 12;
842012dc:	ff fd c7 f0 	call (m) 0x1a170;
842012e0:	35 e4 
842012e2:	ea f0 1e 8c 	MH[FP + 60] = r8;
842012e6:	01 2a       	rMAC = Null + 24;
842012e8:	e8 f0 1f 8c 	MH[FP + 62] = r6;
842012ec:	01 dd       	MH[FP + 64] = rMAC;
    p_ag->p_table[3] = (malloc_t_entry){
        ed_dmx_words,
        MALLOC_PREFERENCE_NONE,
        offsetof(AANC2_PROC, p_ed_int)};
842012ee:	c3 13       	r1 = FP + 60;
842012f0:	b1 88       	rMAC = M[r4 + 8];
842012f2:	84 21       	r2 = Null + 6;
842012f4:	8a 28       	r0 = rMAC + 18;
842012f6:	ff fd c7 f0 	call (m) 0x1a170;
842012fa:	3b e3 
842012fc:	eb f0 22 8c 	MH[FP + 68] = r9;
84201300:	01 2b       	rMAC = Null + 28;
84201302:	1f dd       	MH[FP + 70] = r5;
84201304:	21 dd       	MH[FP + 72] = rMAC;
    p_ag->p_table[4] = (malloc_t_entry){
        ed_dm1_words,
        MALLOC_PREFERENCE_DM1,
        offsetof(AANC2_PROC, p_ed_int_dm1)};
84201306:	43 14       	r1 = FP + 68;
84201308:	b1 88       	rMAC = M[r4 + 8];
8420130a:	84 21       	r2 = Null + 6;
8420130c:	0a 2a       	r0 = rMAC + 24;
8420130e:	ff fd c7 f0 	call (m) 0x1a170;
84201312:	23 e3 
84201314:	ea f0 26 8c 	MH[FP + 76] = r8;
84201318:	01 39       	rMAC = Null + 52;
8420131a:	e8 f0 27 8c 	MH[FP + 78] = r6;
8420131e:	41 dd       	MH[FP + 80] = rMAC;
    p_ag->p_table[5] = (malloc_t_entry){
        ed_dmx_words,
        MALLOC_PREFERENCE_NONE,
        offsetof(AANC2_PROC, p_ed_ext)};
84201320:	c3 14       	r1 = FP + 76;
84201322:	b1 88       	rMAC = M[r4 + 8];
84201324:	84 21       	r2 = Null + 6;
84201326:	8a 2b       	r0 = rMAC + 30;
84201328:	ff fd c7 f0 	call (m) 0x1a170;
8420132c:	29 e2 
8420132e:	eb f0 2a 8c 	MH[FP + 84] = r9;
84201332:	01 3a       	rMAC = Null + 56;
84201334:	5f dd       	MH[FP + 86] = r5;
84201336:	61 dd       	MH[FP + 88] = rMAC;
    p_ag->p_table[6] = (malloc_t_entry){
        ed_dm1_words,
        MALLOC_PREFERENCE_DM1,
        offsetof(AANC2_PROC, p_ed_ext_dm1)};
84201338:	43 15       	r1 = FP + 84;
8420133a:	b1 88       	rMAC = M[r4 + 8];
8420133c:	84 21       	r2 = Null + 6;
8420133e:	0a 31       	r0 = rMAC + 36;
84201340:	ff fd c7 f0 	call (m) 0x1a170;
84201344:	31 e1 
84201346:	ea f0 2e 8c 	MH[FP + 92] = r8;
8420134a:	01 f0 40 40 	rMAC = Null + 64;
8420134e:	e8 f0 2f 8c 	MH[FP + 94] = r6;
84201352:	81 dd       	MH[FP + 96] = rMAC;
    p_ag->p_table[7] = (malloc_t_entry){
        ed_dmx_words,
        MALLOC_PREFERENCE_NONE,
        offsetof(AANC2_PROC, p_ed_pb)};
84201354:	c3 15       	r1 = FP + 92;
84201356:	b1 88       	rMAC = M[r4 + 8];
84201358:	84 21       	r2 = Null + 6;
8420135a:	8a 32       	r0 = rMAC + 42;
8420135c:	ff fd c7 f0 	call (m) 0x1a170;
84201360:	35 e0 
84201362:	eb f0 32 8c 	MH[FP + 100] = r9;
84201366:	01 f0 44 40 	rMAC = Null + 68;
8420136a:	9f dd       	MH[FP + 102] = r5;
8420136c:	a1 dd       	MH[FP + 104] = rMAC;
    p_ag->p_table[8] = (malloc_t_entry){
        ed_dm1_words,
        MALLOC_PREFERENCE_DM1,
        offsetof(AANC2_PROC, p_ed_pb_dm1)};
8420136e:	43 16       	r1 = FP + 100;
84201370:	b1 88       	rMAC = M[r4 + 8];
84201372:	84 21       	r2 = Null + 6;
84201374:	0a 38       	r0 = rMAC + 48;
84201376:	ff fd c6 f0 	call (m) 0x1a170;
8420137a:	3b ef 

    if (!mem_table_zalloc((void *)p_ag,
                          p_ag->p_table,
                          AANC2_PROC_MEM_TABLE_SIZE))
8420137c:	44 22       	r2 = Null + 9;
8420137e:	b3 88       	r1 = M[r4 + 8];
84201380:	32 00       	r0 = r4 + Null;
84201382:	ff fd 07 f0 	call (m) 0x22d6;
84201386:	35 ea 
84201388:	10 04       	Null = r0 - Null;
8420138a:	12 62       	if NE jump (m) Lc_aanc2_proc_create_23;

8420138c <Lc_aanc2_proc_create_21>:
    {
        aanc2_proc_destroy(p_ag);
8420138c:	32 00       	r0 = r4 + Null;
8420138e:	73 4e       	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate memory", p_ag->opid);
84201390:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201394:	88 24       	Null = rMAC - 2;
84201396:	fb ff df eb 	if LT jump (m) Lc_aanc2_proc_create_4;

8420139a <Lc_aanc2_proc_create_22>:
8420139a:	63 f0 2f 88 	r1 = M[r4 + 188];
8420139e:	55 f1 02 f0 	r0 = Null + 357565532;
842013a2:	5c 48 
842013a4:	ef fd fe ff 	call (m) 0x10c2;
842013a8:	3f e8 
842013aa:	ff ff cb eb 	jump (m) Lc_aanc2_proc_create_4;

842013ae <Lc_aanc2_proc_create_23>:
        return FALSE;
    }

    /* Create shared ED cbuffer without specific bank allocation */
    p_ag->p_tmp_ed = cbuffer_create_with_malloc(ED100_DEFAULT_BUFFER_SIZE,
                                                BUF_DESC_SW_BUFFER);
842013ae:	02 f0 41 40 	r0 = Null + 65;
842013b2:	03 00       	r1 = Null + Null;
842013b4:	ff fd 97 f0 	call (m) 0x1421e;
842013b8:	2b e3 
842013ba:	f2 8e       	M[r4 + 12] = r0;
    if (p_ag->p_tmp_ed == NULL)
842013bc:	f1 88       	rMAC = M[r4 + 12];
842013be:	12 62       	if NE jump (m) Lc_aanc2_proc_create_26;

842013c0 <Lc_aanc2_proc_create_24>:
    {
        aanc2_proc_destroy(p_ag);
842013c0:	32 00       	r0 = r4 + Null;
842013c2:	59 4e       	call (m) $_aanc2_proc_destroy;
        L2_DBG_MSG1("OPID: %x, AANC2_PROC failed to allocate ED cbuffer", p_ag->opid);
842013c4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842013c8:	88 24       	Null = rMAC - 2;
842013ca:	fb ff ab eb 	if LT jump (m) Lc_aanc2_proc_create_4;

842013ce <Lc_aanc2_proc_create_25>:
842013ce:	63 f0 2f 88 	r1 = M[r4 + 188];
842013d2:	55 f1 02 f0 	r0 = Null + 357565579;
842013d6:	8b 48 
842013d8:	ef fd fe ff 	call (m) 0x10c2;
842013dc:	2b e7 
842013de:	ff ff 97 eb 	jump (m) Lc_aanc2_proc_create_4;

842013e2 <Lc_aanc2_proc_create_26>:
        return FALSE;
    }

    aanc_ed100_create(p_ag->p_ed_int, p_ag->p_ed_int_dm1, sample_rate);
842013e2:	f3 89       	r1 = M[r4 + 28];
842013e4:	b2 89       	r0 = M[r4 + 24];
842013e6:	44 d8       	r2 = M[FP + 32];
842013e8:	0c f0 21 e7 	call (m) $_aanc_ed100_create;
    aanc_ed100_create(p_ag->p_ed_ext, p_ag->p_ed_ext_dm1, sample_rate);
842013ec:	b3 99       	r1 = M[r4 + 56];
842013ee:	72 99       	r0 = M[r4 + 52];
842013f0:	44 d8       	r2 = M[FP + 32];
842013f2:	0c f0 37 e6 	call (m) $_aanc_ed100_create;
    aanc_ed100_create(p_ag->p_ed_pb, p_ag->p_ed_pb_dm1, sample_rate);
842013f6:	73 a8       	r1 = M[r4 + 68];
842013f8:	32 a8       	r0 = M[r4 + 64];
842013fa:	44 d8       	r2 = M[FP + 32];
842013fc:	0c f0 2d e6 	call (m) $_aanc_ed100_create;

    /* Initialize number of taps to allow correct buffer alignment in create */
    p_ag->p_fxlms->p_plant.num_coeffs = AANC2_PROC_NUM_TAPS_PLANT;
84201400:	41 22       	rMAC = Null + 9;
84201402:	b2 a8       	r0 = M[r4 + 72];
84201404:	21 f0 34 8c 	MH[r0 + 104] = rMAC;
    p_ag->p_fxlms->p_plant.full_num_coeffs = AANC2_PROC_NUM_TAPS_PLANT;
84201408:	b2 a8       	r0 = M[r4 + 72];
8420140a:	21 f0 35 8c 	MH[r0 + 106] = rMAC;
    p_ag->p_fxlms->p_control_0.num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
8420140e:	b2 a8       	r0 = M[r4 + 72];
84201410:	21 f0 4a 8c 	MH[r0 + 148] = rMAC;
    p_ag->p_fxlms->p_control_0.full_num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
84201414:	b2 a8       	r0 = M[r4 + 72];
84201416:	21 f0 4b 8c 	MH[r0 + 150] = rMAC;
    p_ag->p_fxlms->p_control_1.num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
8420141a:	b2 a8       	r0 = M[r4 + 72];
8420141c:	21 f0 60 8c 	MH[r0 + 192] = rMAC;
    p_ag->p_fxlms->p_control_1.full_num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
84201420:	b2 a8       	r0 = M[r4 + 72];
84201422:	21 f0 61 8c 	MH[r0 + 194] = rMAC;
    p_ag->p_fxlms->p_bp_int.num_coeffs = AANC2_PROC_NUM_TAPS_BP;
84201426:	41 21       	rMAC = Null + 5;
84201428:	b2 a8       	r0 = M[r4 + 72];
8420142a:	21 f0 76 8c 	MH[r0 + 236] = rMAC;
    p_ag->p_fxlms->p_bp_int.full_num_coeffs = AANC2_PROC_NUM_TAPS_BP;
8420142e:	b2 a8       	r0 = M[r4 + 72];
84201430:	21 f0 77 8c 	MH[r0 + 238] = rMAC;
    p_ag->p_fxlms->p_bp_ext.num_coeffs = AANC2_PROC_NUM_TAPS_BP;
84201434:	b2 a8       	r0 = M[r4 + 72];
84201436:	21 f0 8c 8c 	MH[r0 + 280] = rMAC;
    p_ag->p_fxlms->p_bp_ext.full_num_coeffs = AANC2_PROC_NUM_TAPS_BP;
8420143a:	b2 a8       	r0 = M[r4 + 72];
8420143c:	21 f0 8d 8c 	MH[r0 + 282] = rMAC;

    aanc_fxlms100_create(p_ag->p_fxlms, p_ag->p_fxlms_dm1, p_ag->p_fxlms_dm2);
84201440:	34 a9       	r2 = M[r4 + 80];
84201442:	f3 a8       	r1 = M[r4 + 76];
84201444:	b2 a8       	r0 = M[r4 + 72];
84201446:	09 f0 2f e1 	call (m) $_aanc_fxlms100_create;

    /* Initialize plant model as pass-through */
    coeffs = &p_ag->p_fxlms->p_plant.coeffs;
8420144a:	b1 a8       	rMAC = M[r4 + 72];
8420144c:	01 f0 50 44 	rMAC = rMAC + 80;
    coeffs->p_num[0] = FXLMS100_MODEL_COEFF0;
84201450:	10 f0 02 f0 	r0 = Null + 16777216;
84201454:	00 40 
84201456:	0b e8       	r1 = M[rMAC + Null];
84201458:	1a ee       	M[r1 + Null] = r0;
    coeffs->p_den[0] = FXLMS100_MODEL_COEFF0;
8420145a:	49 88       	rMAC = M[rMAC + 4];
8420145c:	0a ee       	M[rMAC + Null] = r0;

    /* Initialize control 0 model as pass-through */
    coeffs = &p_ag->p_fxlms->p_control_0.coeffs;
8420145e:	b1 a8       	rMAC = M[r4 + 72];
84201460:	01 f0 7c 44 	rMAC = rMAC + 124;
    coeffs->p_num[0] = FXLMS100_MODEL_COEFF0;
84201464:	0b e8       	r1 = M[rMAC + Null];
84201466:	1a ee       	M[r1 + Null] = r0;
    coeffs->p_den[0] = FXLMS100_MODEL_COEFF0;
84201468:	49 88       	rMAC = M[rMAC + 4];
8420146a:	0a ee       	M[rMAC + Null] = r0;

    return TRUE;
8420146c:	3a 00       	r0 = r5 + Null;

8420146e <Lc_aanc2_proc_create_27>:
}
8420146e:	6d 4c       	SP = SP + -76;
84201470:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201472:	d8 4c       	rts;

84201474 <$_aanc2_proc_destroy>:

bool aanc2_proc_destroy(AANC2_PROC *p_ag)
{
84201474:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201476:	16 00       	r4 = r0 + Null;
    /* Destroy EDs */
    aanc_ed100_destroy(p_ag->p_ed_int);
84201478:	b2 89       	r0 = M[r4 + 24];
8420147a:	0c f0 3f eb 	call (m) $_aanc_ed100_destroy;
    aanc_ed100_destroy(p_ag->p_ed_ext);
8420147e:	72 99       	r0 = M[r4 + 52];
84201480:	0c f0 39 eb 	call (m) $_aanc_ed100_destroy;
    aanc_ed100_destroy(p_ag->p_ed_pb);
84201484:	32 a8       	r0 = M[r4 + 64];
84201486:	0c f0 33 eb 	call (m) $_aanc_ed100_destroy;

    /* Free memory table */
    if (p_ag->p_table != NULL)
8420148a:	b3 88       	r1 = M[r4 + 8];
8420148c:	0a 60       	if EQ jump (m) Lc_aanc2_proc_destroy_3;

8420148e <Lc_aanc2_proc_destroy_2>:
    {
        mem_table_free((void *)p_ag, p_ag->p_table, AANC2_PROC_MEM_TABLE_SIZE);
8420148e:	44 22       	r2 = Null + 9;
84201490:	32 00       	r0 = r4 + Null;
84201492:	ff fd 07 f0 	call (m) 0x22e4;
84201496:	33 e2 
        pdelete(p_ag->p_table);
84201498:	b2 88       	r0 = M[r4 + 8];
8420149a:	ff fd 2d f0 	call (m) 0x6fbe;
8420149e:	25 e9 

842014a0 <Lc_aanc2_proc_destroy_3>:
    }

    /* Destroy internal cbuffers */
    cbuffer_destroy(p_ag->p_tmp_ed);
842014a0:	f2 88       	r0 = M[r4 + 12];
842014a2:	ff fd 97 f0 	call (m) 0x14302;
842014a6:	21 e3 

    cbuffer_destroy(p_ag->p_tmp_int_ip);
842014a8:	32 89       	r0 = M[r4 + 16];
842014aa:	ff fd 97 f0 	call (m) 0x14302;
842014ae:	39 e2 
    cbuffer_destroy(p_ag->p_tmp_ext_ip);
842014b0:	f2 98       	r0 = M[r4 + 44];
842014b2:	ff fd 97 f0 	call (m) 0x14302;
842014b6:	31 e2 
    cbuffer_destroy(p_ag->p_tmp_pb_ip);
842014b8:	f2 99       	r0 = M[r4 + 60];
842014ba:	ff fd 97 f0 	call (m) 0x14302;
842014be:	29 e2 

    cbuffer_destroy(p_ag->p_tmp_int_op);
842014c0:	72 89       	r0 = M[r4 + 20];
842014c2:	ff fd 97 f0 	call (m) 0x14302;
842014c6:	21 e2 
    cbuffer_destroy(p_ag->p_tmp_ext_op);
842014c8:	32 99       	r0 = M[r4 + 48];
842014ca:	ff fd 97 f0 	call (m) 0x14302;
842014ce:	39 e1 

    /* Unload the feature handle */
    unload_aanc_handle(p_ag->f_handle);
842014d0:	62 f0 2e 88 	r0 = M[r4 + 184];
842014d4:	0c f0 2f ed 	call (m) $_unload_aanc_handle;

    return TRUE;
842014d8:	42 20       	r0 = Null + 1;

842014da <Lc_aanc2_proc_destroy_4>:
}
842014da:	f1 48       	popm <FP, r4, rLink>;
842014dc:	d8 4c       	rts;

842014de <$_aanc2_proc_initialize>:

bool aanc2_proc_initialize(AANC2_PROC *p_ag,
                           AANC2_PARAMETERS *p_params)
{
842014de:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842014e0:	54 f3 10 cf 	SP = SP + 168;
842014e4:	17 00       	r5 = r0 + Null;
842014e6:	18 09       	r6 = r1 + Null;
    bool disable_filter_check;      /* Disable filter check indicator */
    unsigned config, debug_config;  /* Config and debug parameter values */
    unsigned clip_disable;          /* Clip disable flag */

    /* Re-initialize flags */
    p_ag->proc_flags = 0;
842014e8:	38 ee       	M[r5 + Null] = Null;
    p_ag->prev_flags = 0;
842014ea:	78 8e       	M[r5 + 4] = Null;

    /* Initialize the FxLMS */
    p_dmx = p_ag->p_fxlms;
842014ec:	be a8       	r4 = M[r5 + 72];

    /* Initialize buffer pointers */
    p_dmx->p_int_ip = p_ag->p_tmp_int_ip;
842014ee:	39 89       	rMAC = M[r5 + 16];
842014f0:	31 ee       	M[r4 + Null] = rMAC;
    p_dmx->p_int_op = p_ag->p_tmp_int_op;
842014f2:	79 89       	rMAC = M[r5 + 20];
842014f4:	b1 8e       	M[r4 + 8] = rMAC;
    p_dmx->p_ext_ip = p_ag->p_tmp_ext_ip;
842014f6:	f9 98       	rMAC = M[r5 + 44];
842014f8:	71 8e       	M[r4 + 4] = rMAC;
    p_dmx->p_ext_op = p_ag->p_tmp_ext_op;
842014fa:	39 99       	rMAC = M[r5 + 48];
842014fc:	f1 8e       	M[r4 + 12] = rMAC;

    /* Set FxLMS parameters */
    p_dmx->target_nr = p_params->OFFSET_TARGET_NOISE_REDUCTION;
842014fe:	81 f0 06 88 	rMAC = M[r6 + 24];
84201502:	31 8f       	M[r4 + 16] = rMAC;
    p_dmx->mu = p_params->OFFSET_MU;
84201504:	81 f0 02 88 	rMAC = M[r6 + 8];
84201508:	71 8f       	M[r4 + 20] = rMAC;
    p_dmx->gamma = AANC2_FXLMS_GAMMA;
8420150a:	b0 8f       	M[r4 + 24] = Null;
    p_dmx->lambda = p_params->OFFSET_LAMBDA;
8420150c:	81 f0 05 88 	rMAC = M[r6 + 20];
84201510:	31 9e       	M[r4 + 32] = rMAC;
    p_dmx->frame_size = AANC2_DEFAULT_FRAME_SIZE;
84201512:	01 f0 40 40 	rMAC = Null + 64;
84201516:	f1 8f       	M[r4 + 28] = rMAC;
    p_dmx->min_bound = p_params->OFFSET_FXLMS_MIN_BOUND;
84201518:	81 f0 03 88 	rMAC = M[r6 + 12];
8420151c:	f1 9e       	M[r4 + 44] = rMAC;
    p_dmx->max_bound = p_params->OFFSET_FXLMS_MAX_BOUND;
8420151e:	81 f0 04 88 	rMAC = M[r6 + 16];
84201522:	31 9f       	M[r4 + 48] = rMAC;
    p_dmx->max_delta = AANC2_FXLMS_MAX_DELTA;
84201524:	0a f0 01 f2 	rMAC = Null + 10747904;
84201528:	00 40 
8420152a:	71 9f       	M[r4 + 52] = rMAC;

    /* Optimization to reduce the effective number of taps in plant and control
     * filters if there are both trailing numerator and denominator coefficients
     */
    debug_config = p_params->OFFSET_AANC2_DEBUG;
8420152c:	81 f0 01 88 	rMAC = M[r6 + 4];
    if ((debug_config & AANC2_CONFIG_AANC2_DEBUG_DISABLE_FILTER_OPTIM) > 0)
84201530:	49 c4       	rMAC = rMAC AND 0x200;
84201532:	15 60       	if EQ jump (m) Lc_aanc2_proc_initialize_4;

84201534 <Lc_aanc2_proc_initialize_2>:
    {
        p_dmx->p_plant.num_coeffs = AANC2_PROC_NUM_TAPS_PLANT;
84201534:	41 22       	rMAC = Null + 9;
84201536:	61 f0 34 8c 	MH[r4 + 104] = rMAC;
        p_dmx->p_control_0.num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
8420153a:	61 f0 4a 8c 	MH[r4 + 148] = rMAC;
        p_dmx->p_control_1.num_coeffs = AANC2_PROC_NUM_TAPS_CONTROL;
8420153e:	61 f0 60 8c 	MH[r4 + 192] = rMAC;
        L4_DBG_MSG1("OPID: %x, AANC_PROC filters set to default number of coefficients",
                    p_ag->opid);
84201542:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201546:	08 25       	Null = rMAC - 4;
84201548:	39 68       	if LT jump (m) Lc_aanc2_proc_initialize_6;

8420154a <Lc_aanc2_proc_initialize_3>:
8420154a:	73 f0 2f 88 	r1 = M[r5 + 188];
8420154e:	55 f1 02 f0 	r0 = Null + 357565630;
84201552:	be 48 
84201554:	ef fd fd ff 	call (m) 0x10c2;
84201558:	2f eb 
8420155a:	30 6e       	jump (m) Lc_aanc2_proc_initialize_6;

8420155c <Lc_aanc2_proc_initialize_4>:
    }
    else
    {
        p_dmx->p_plant.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_plant, AANC2_PROC_NUM_TAPS_PLANT);
8420155c:	69 f0 68 20 	r7 = r4 + 104;
84201560:	43 22       	r1 = Null + 9;
84201562:	92 f3 e8 3b 	r0 = r7 + -24;
84201566:	0b f0 27 e0 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
8420156a:	92 f0 00 ec 	MH[r7 + Null] = r0;
        p_dmx->p_control_0.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_control_0, AANC2_PROC_NUM_TAPS_CONTROL);
8420156e:	69 f0 94 20 	r7 = r4 + 148;
84201572:	43 22       	r1 = Null + 9;
84201574:	92 f3 e8 3b 	r0 = r7 + -24;
84201578:	0a f0 35 ef 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
8420157c:	92 f0 00 ec 	MH[r7 + Null] = r0;
        p_dmx->p_control_1.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_control_1, AANC2_PROC_NUM_TAPS_CONTROL);
84201580:	69 f0 c0 20 	r7 = r4 + 192;
84201584:	43 22       	r1 = Null + 9;
84201586:	92 f3 e8 3b 	r0 = r7 + -24;
8420158a:	0a f0 23 ef 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
8420158e:	92 f0 00 ec 	MH[r7 + Null] = r0;

        L4_DBG_MSG4(
            "OPID: %x, AANC_PROC filter coeffs: Plant=%hu, Control 0=%hu, Control 1=%hu",
            p_ag->opid, p_dmx->p_plant.num_coeffs, p_dmx->p_control_0.num_coeffs,
            p_dmx->p_control_1.num_coeffs);
84201592:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201596:	08 25       	Null = rMAC - 4;
84201598:	11 68       	if LT jump (m) Lc_aanc2_proc_initialize_6;

8420159a <Lc_aanc2_proc_initialize_5>:
8420159a:	61 f0 60 86 	rMAC = MHU[r4 + 192];
8420159e:	09 1c       	pushm <rMAC>;
842015a0:	65 f0 4a 86 	r3 = MHU[r4 + 148];
842015a4:	64 f0 34 86 	r2 = MHU[r4 + 104];
842015a8:	73 f0 2f 88 	r1 = M[r5 + 188];
842015ac:	55 f1 02 f0 	r0 = Null + 357565696;
842015b0:	00 49 
842015b2:	ef fd fd ff 	call (m) 0x1104;
842015b6:	33 ea 
842015b8:	7f 4c       	SP = SP + -4;

842015ba <Lc_aanc2_proc_initialize_6>:
842015ba:	81 f0 3d 88 	rMAC = M[r6 + 244];
842015be:	f1 de       	M[FP + 120] = rMAC;
842015c0:	81 f0 3e 88 	rMAC = M[r6 + 248];
842015c4:	f9 de       	M[FP + 124] = rMAC;
842015c6:	81 f0 3f 88 	rMAC = M[r6 + 252];
842015ca:	01 df       	M[FP + 128] = rMAC;
842015cc:	81 f0 40 88 	rMAC = M[r6 + 256];
842015d0:	09 df       	M[FP + 132] = rMAC;
842015d2:	81 f0 41 88 	rMAC = M[r6 + 260];
842015d6:	11 df       	M[FP + 136] = rMAC;
        p_params->OFFSET_BPF_NUMERATOR_COEFF_INT_0,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_INT_1,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_INT_2,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_INT_3,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_INT_4
    };
842015d8:	83 17       	r1 = FP + 120;
842015da:	82 12       	r0 = FP + 40;
842015dc:	44 21       	r2 = Null + 5;
842015de:	ff fd c5 f0 	call (m) 0x1a094;
842015e2:	37 e5 
842015e4:	81 f0 38 88 	rMAC = M[r6 + 224];
842015e8:	19 df       	M[FP + 140] = rMAC;
842015ea:	81 f0 39 88 	rMAC = M[r6 + 228];
842015ee:	21 df       	M[FP + 144] = rMAC;
842015f0:	81 f0 3a 88 	rMAC = M[r6 + 232];
842015f4:	29 df       	M[FP + 148] = rMAC;
842015f6:	81 f0 3b 88 	rMAC = M[r6 + 236];
842015fa:	31 df       	M[FP + 152] = rMAC;
842015fc:	81 f0 3c 88 	rMAC = M[r6 + 240];
84201600:	39 df       	M[FP + 156] = rMAC;
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_INT_0,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_INT_1,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_INT_2,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_INT_3,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_INT_4
    };
84201602:	c3 18       	r1 = FP + 140;
84201604:	c2 13       	r0 = FP + 60;
84201606:	44 21       	r2 = Null + 5;
84201608:	ff fd c5 f0 	call (m) 0x1a094;
8420160c:	2d e4 
8420160e:	81 f0 33 88 	rMAC = M[r6 + 204];
84201612:	41 df       	M[FP + 160] = rMAC;
84201614:	81 f0 34 88 	rMAC = M[r6 + 208];
84201618:	49 df       	M[FP + 164] = rMAC;
8420161a:	81 f0 35 88 	rMAC = M[r6 + 212];
8420161e:	51 df       	M[FP + 168] = rMAC;
84201620:	81 f0 36 88 	rMAC = M[r6 + 216];
84201624:	59 df       	M[FP + 172] = rMAC;
84201626:	81 f0 37 88 	rMAC = M[r6 + 220];
8420162a:	61 df       	M[FP + 176] = rMAC;
        p_params->OFFSET_BPF_NUMERATOR_COEFF_EXT_0,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_EXT_1,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_EXT_2,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_EXT_3,
        p_params->OFFSET_BPF_NUMERATOR_COEFF_EXT_4
    };
8420162c:	03 1a       	r1 = FP + 160;
8420162e:	02 15       	r0 = FP + 80;
84201630:	44 21       	r2 = Null + 5;
84201632:	ff fd c5 f0 	call (m) 0x1a094;
84201636:	23 e3 
84201638:	81 f0 2e 88 	rMAC = M[r6 + 184];
8420163c:	69 df       	M[FP + 180] = rMAC;
8420163e:	81 f0 2f 88 	rMAC = M[r6 + 188];
84201642:	71 df       	M[FP + 184] = rMAC;
84201644:	81 f0 30 88 	rMAC = M[r6 + 192];
84201648:	79 df       	M[FP + 188] = rMAC;
8420164a:	81 f0 31 88 	rMAC = M[r6 + 196];
8420164e:	81 df       	M[FP + 192] = rMAC;
84201650:	81 f0 32 88 	rMAC = M[r6 + 200];
84201654:	89 df       	M[FP + 196] = rMAC;
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_0,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_1,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_2,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_3,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_4
    };
84201656:	43 1b       	r1 = FP + 180;
84201658:	42 16       	r0 = FP + 100;
8420165a:	44 21       	r2 = Null + 5;
8420165c:	ff fd c5 f0 	call (m) 0x1a094;
84201660:	39 e1 

    for (i = 0; i < p_dmx->p_bp_ext.num_coeffs; i++)
84201662:	02 00       	r0 = Null + Null;
84201664:	01 15       	rMAC = FP + 80;
84201666:	43 16       	r1 = FP + 100;
84201668:	84 12       	r2 = FP + 40;
8420166a:	c5 13       	r3 = FP + 60;

8420166c <Lc_aanc2_proc_initialize_7>:
8420166c:	69 f0 8c 86 	r7 = MHU[r4 + 280];
84201670:	9f f2 00 c2 	Null = r0 - r7;
84201674:	21 66       	if GE jump (m) Lc_aanc2_proc_initialize_9;

84201676 <Lc_aanc2_proc_initialize_8>:
    {
        p_dmx->p_bp_ext.coeffs.p_num[i] = bp_num_coeffs_ext[i];
84201676:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;
8420167a:	1a f0 00 e8 	r8 = M[rMAC + Null];
8420167e:	6b f0 40 88 	r9 = M[r4 + 256];
84201682:	ba f0 09 ee 	M[r9 + r7] = r8;
        p_dmx->p_bp_ext.coeffs.p_den[i] = bp_den_coeffs_ext[i];
84201686:	3a f0 00 e8 	r8 = M[r1 + Null];
8420168a:	6b f0 41 88 	r9 = M[r4 + 260];
8420168e:	ba f0 09 ee 	M[r9 + r7] = r8;
        p_dmx->p_bp_int.coeffs.p_num[i] = bp_num_coeffs_int[i];
84201692:	4a f0 00 e8 	r8 = M[r2 + Null];
84201696:	6b f0 35 88 	r9 = M[r4 + 212];
8420169a:	ba f0 09 ee 	M[r9 + r7] = r8;
        p_dmx->p_bp_int.coeffs.p_den[i] = bp_den_coeffs_int[i];
8420169e:	5a f0 00 e8 	r8 = M[r3 + Null];
842016a2:	6b f0 36 88 	r9 = M[r4 + 216];
842016a6:	ba f0 09 ee 	M[r9 + r7] = r8;
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_2,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_3,
        p_params->OFFSET_BPF_DENOMINATOR_COEFF_EXT_4
    };

    for (i = 0; i < p_dmx->p_bp_ext.num_coeffs; i++)
842016aa:	52 20       	r0 = r0 + 1;
842016ac:	09 21       	rMAC = rMAC + 4;
842016ae:	1b 21       	r1 = r1 + 4;
842016b0:	24 21       	r2 = r2 + 4;
842016b2:	2d 21       	r3 = r3 + 4;
842016b4:	dc 6f       	jump (m) Lc_aanc2_proc_initialize_7;

842016b6 <Lc_aanc2_proc_initialize_9>:
     * FxLMS filter stage. In that case the read pointer for the input buffers
     * is updated within the FxLMS because the data is not copied at a later
     * stage. Otherwise the read pointer is left untouched so that the cbuffer
     * copy routine operates correctly.
     */
    debug_config = p_params->OFFSET_AANC2_DEBUG;
842016b6:	81 f0 01 88 	rMAC = M[r6 + 4];
842016ba:	41 de       	M[FP + 32] = rMAC;
    p_ag->p_fxlms->read_ptr_upd = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_MUX_SEL_ALGORITHM) > 0;
842016bc:	ca c3       	r0 = rMAC AND 0x100;
842016be:	01 00       	rMAC = Null + Null;
842016c0:	10 04       	Null = r0 - Null;
842016c2:	21 f0 41 ce 	if NE rMAC = Null + 1;
842016c6:	ba a8       	r0 = M[r5 + 72];
842016c8:	91 9e       	M[r0 + 40] = rMAC;

    aanc_fxlms100_initialize(p_ag->f_handle, p_ag->p_fxlms, FALSE);
842016ca:	bb a8       	r1 = M[r5 + 72];
842016cc:	72 f0 2e 88 	r0 = M[r5 + 184];
842016d0:	04 00       	r2 = Null + Null;
842016d2:	08 f0 3f e1 	call (m) $_aanc_fxlms100_initialize;

    /* Set the quiet condition thresholds */
    p_ag->quiet_hi_threshold = p_params->OFFSET_QUIET_MODE_HI_THRESHOLD;
842016d6:	81 f0 0d 88 	rMAC = M[r6 + 52];
842016da:	71 f0 24 8e 	M[r5 + 144] = rMAC;
    p_ag->quiet_lo_threshold = p_params->OFFSET_QUIET_MODE_LO_THRESHOLD;
842016de:	81 f0 0e 88 	rMAC = M[r6 + 56];
842016e2:	71 f0 25 8e 	M[r5 + 148] = rMAC;

    /* Set the self-speech condition threshold */
    config = p_params->OFFSET_AANC2_CONFIG;
842016e6:	89 f0 00 e8 	r7 = M[r6 + Null];
    p_ag->self_speech_disabled = (config & \
        AANC2_CONFIG_AANC2_CONFIG_DISABLE_SELF_SPEECH) > 0;
842016ea:	01 00       	rMAC = Null + Null;
842016ec:	92 f0 08 00 	r0 = r7 AND 0x8;
842016f0:	21 f0 41 ce 	if NE rMAC = Null + 1;
842016f4:	71 f0 21 8a 	MB[r5 + 33] = rMAC;
    p_ag->self_speech_threshold = p_params->OFFSET_SELF_SPEECH_THRESHOLD;
842016f8:	81 f0 12 88 	rMAC = M[r6 + 72];
842016fc:	79 9e       	M[r5 + 36] = rMAC;

    p_ag->pb_ratio_disabled = (config & \
        AANC2_CONFIG_AANC2_CONFIG_DISABLE_PLAYBACK_RATIO) > 0;
842016fe:	01 00       	rMAC = Null + Null;
84201700:	92 f0 10 00 	r0 = r7 AND 0x10;
84201704:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201708:	71 f0 22 8a 	MB[r5 + 34] = rMAC;
    p_ag->pb_ratio_threshold = p_params->OFFSET_PLAYBACK_RATIO_THRESHOLD_CONC;
8420170c:	81 f0 46 88 	rMAC = M[r6 + 280];
84201710:	b9 9e       	M[r5 + 40] = rMAC;

    /* Initialize the internal ED */
    p_ag->p_ed_int->p_input = p_ag->p_tmp_int_ip;
84201712:	39 89       	rMAC = M[r5 + 16];
84201714:	ba 89       	r0 = M[r5 + 24];
84201716:	11 ee       	M[r0 + Null] = rMAC;
    p_ag->p_ed_int->p_tmp = p_ag->p_tmp_ed;
84201718:	f9 88       	rMAC = M[r5 + 12];
8420171a:	ba 89       	r0 = M[r5 + 24];
8420171c:	51 8e       	M[r0 + 4] = rMAC;
    p_ag->p_ed_int->disabled = (config & \
        AANC2_CONFIG_AANC2_CONFIG_DISABLE_ED_INT) > 0;
8420171e:	91 f0 01 00 	rMAC = r7 AND 0x1;
84201722:	ba 89       	r0 = M[r5 + 24];
84201724:	91 8e       	M[r0 + 8] = rMAC;
    p_ag->p_ed_int->frame_size = AANC2_DEFAULT_FRAME_SIZE;
84201726:	01 f0 40 40 	rMAC = Null + 64;
8420172a:	49 de       	M[FP + 36] = rMAC;
8420172c:	0a 00       	r0 = rMAC + Null;
8420172e:	b9 89       	rMAC = M[r5 + 24];
84201730:	ca 8e       	M[rMAC + 12] = r0;
    p_ag->p_ed_int->attack_time = AANC2_ED_ATTACK;
84201732:	7f f0 76 f7 	r4 = Null + 134150619;
84201736:	db 71 
84201738:	b9 89       	rMAC = M[r5 + 24];
8420173a:	0e 8f       	M[rMAC + 16] = r4;
    p_ag->p_ed_int->decay_time = AANC2_ED_DECAY;
8420173c:	b9 89       	rMAC = M[r5 + 24];
8420173e:	4e 8f       	M[rMAC + 20] = r4;
    p_ag->p_ed_int->envelope_time = p_params->OFFSET_ED_INT_ENVELOPE;
84201740:	81 f0 1e 88 	rMAC = M[r6 + 120];
84201744:	ba 89       	r0 = M[r5 + 24];
84201746:	91 8f       	M[r0 + 24] = rMAC;
    p_ag->p_ed_int->init_frame_time = AANC2_ED_INIT_FRAME;
84201748:	0b f1 4a 58 	r9 = Null + 134218;
8420174c:	b9 89       	rMAC = M[r5 + 24];
8420174e:	1b f0 07 8e 	M[rMAC + 28] = r9;
    p_ag->p_ed_int->ratio = p_params->OFFSET_ED_INT_RATIO;
84201752:	81 f0 1f 88 	rMAC = M[r6 + 124];
84201756:	ba 89       	r0 = M[r5 + 24];
84201758:	11 9e       	M[r0 + 32] = rMAC;
    p_ag->p_ed_int->min_signal = p_params->OFFSET_ED_INT_MIN_SIGNAL;
8420175a:	81 f0 20 88 	rMAC = M[r6 + 128];
8420175e:	ba 89       	r0 = M[r5 + 24];
84201760:	51 9e       	M[r0 + 36] = rMAC;
    p_ag->p_ed_int->min_max_envelope = \
        p_params->OFFSET_ED_INT_MIN_MAX_ENVELOPE;
84201762:	81 f0 21 88 	rMAC = M[r6 + 132];
84201766:	ba 89       	r0 = M[r5 + 24];
84201768:	91 9e       	M[r0 + 40] = rMAC;
    p_ag->p_ed_int->delta_th = p_params->OFFSET_ED_INT_DELTA_TH;
8420176a:	81 f0 22 88 	rMAC = M[r6 + 136];
8420176e:	ba 89       	r0 = M[r5 + 24];
84201770:	d1 9e       	M[r0 + 44] = rMAC;
    p_ag->p_ed_int->count_th = AANC2_ED_COUNT_TH;
84201772:	10 f0 1a f5 	r8 = Null + 17448305;
84201776:	71 79 
84201778:	b9 89       	rMAC = M[r5 + 24];
8420177a:	1a f0 0c 8e 	M[rMAC + 48] = r8;
    p_ag->p_ed_int->hold_frames = p_params->OFFSET_ED_INT_HOLD_FRAMES;
8420177e:	81 f0 23 88 	rMAC = M[r6 + 140];
84201782:	ba 89       	r0 = M[r5 + 24];
84201784:	51 9f       	M[r0 + 52] = rMAC;
    p_ag->p_ed_int->e_min_threshold = \
        p_params->OFFSET_ED_INT_E_FILTER_MIN_THRESHOLD;
84201786:	81 f0 24 88 	rMAC = M[r6 + 144];
8420178a:	ba 89       	r0 = M[r5 + 24];
8420178c:	91 9f       	M[r0 + 56] = rMAC;
    p_ag->p_ed_int->e_min_counter_threshold = \
        p_params->OFFSET_ED_INT_E_FILTER_MIN_COUNTER_THRESHOLD;
8420178e:	81 f0 25 88 	rMAC = M[r6 + 148];
84201792:	ba 89       	r0 = M[r5 + 24];
84201794:	d1 9f       	M[r0 + 60] = rMAC;
    disable_filter_check = FALSE;
    disable_filter_check = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_ED_INT_E_FILTER_CHECK) > 0;
84201796:	41 d8       	rMAC = M[FP + 32];
84201798:	ca c1       	r0 = rMAC AND 0x10;
8420179a:	01 00       	rMAC = Null + Null;
8420179c:	10 04       	Null = r0 - Null;
8420179e:	21 f0 41 ce 	if NE rMAC = Null + 1;
    p_ag->p_ed_int->e_min_check_disabled = disable_filter_check;
842017a2:	ba 89       	r0 = M[r5 + 24];
842017a4:	11 ae       	M[r0 + 64] = rMAC;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_int);
842017a6:	bb 89       	r1 = M[r5 + 24];
842017a8:	72 f0 2e 88 	r0 = M[r5 + 184];
842017ac:	0a f0 23 ec 	call (m) $_aanc_ed100_initialize;

    /* Initialize the external ED */
    p_ag->p_ed_ext->p_input = p_ag->p_tmp_ext_ip;
842017b0:	f9 98       	rMAC = M[r5 + 44];
842017b2:	7a 99       	r0 = M[r5 + 52];
842017b4:	11 ee       	M[r0 + Null] = rMAC;
    p_ag->p_ed_ext->p_tmp = p_ag->p_tmp_ed;
842017b6:	f9 88       	rMAC = M[r5 + 12];
842017b8:	7a 99       	r0 = M[r5 + 52];
842017ba:	51 8e       	M[r0 + 4] = rMAC;
    p_ag->p_ed_ext->disabled = (config & \
        AANC2_CONFIG_AANC2_CONFIG_DISABLE_ED_EXT) > 0;
842017bc:	01 00       	rMAC = Null + Null;
842017be:	92 f0 02 00 	r0 = r7 AND 0x2;
842017c2:	21 f0 41 ce 	if NE rMAC = Null + 1;
842017c6:	7a 99       	r0 = M[r5 + 52];
842017c8:	91 8e       	M[r0 + 8] = rMAC;
    p_ag->p_ed_ext->frame_size = AANC2_DEFAULT_FRAME_SIZE;
842017ca:	79 99       	rMAC = M[r5 + 52];
842017cc:	4a d8       	r0 = M[FP + 36];
842017ce:	ca 8e       	M[rMAC + 12] = r0;
    p_ag->p_ed_ext->attack_time = AANC2_ED_ATTACK;
842017d0:	79 99       	rMAC = M[r5 + 52];
842017d2:	0e 8f       	M[rMAC + 16] = r4;
    p_ag->p_ed_ext->decay_time = AANC2_ED_DECAY;
842017d4:	79 99       	rMAC = M[r5 + 52];
842017d6:	4e 8f       	M[rMAC + 20] = r4;
    p_ag->p_ed_ext->envelope_time = p_params->OFFSET_ED_EXT_ENVELOPE;
842017d8:	81 f0 16 88 	rMAC = M[r6 + 88];
842017dc:	7a 99       	r0 = M[r5 + 52];
842017de:	91 8f       	M[r0 + 24] = rMAC;
    p_ag->p_ed_ext->init_frame_time = AANC2_ED_INIT_FRAME;
842017e0:	79 99       	rMAC = M[r5 + 52];
842017e2:	1b f0 07 8e 	M[rMAC + 28] = r9;
    p_ag->p_ed_ext->ratio = p_params->OFFSET_ED_EXT_RATIO;
842017e6:	81 f0 17 88 	rMAC = M[r6 + 92];
842017ea:	7a 99       	r0 = M[r5 + 52];
842017ec:	11 9e       	M[r0 + 32] = rMAC;
    p_ag->p_ed_ext->min_signal = p_params->OFFSET_ED_EXT_MIN_SIGNAL;
842017ee:	81 f0 18 88 	rMAC = M[r6 + 96];
842017f2:	7a 99       	r0 = M[r5 + 52];
842017f4:	51 9e       	M[r0 + 36] = rMAC;
    p_ag->p_ed_ext->min_max_envelope = \
        p_params->OFFSET_ED_EXT_MIN_MAX_ENVELOPE;
842017f6:	81 f0 19 88 	rMAC = M[r6 + 100];
842017fa:	7a 99       	r0 = M[r5 + 52];
842017fc:	91 9e       	M[r0 + 40] = rMAC;
    p_ag->p_ed_ext->delta_th = p_params->OFFSET_ED_EXT_DELTA_TH;
842017fe:	81 f0 1a 88 	rMAC = M[r6 + 104];
84201802:	7a 99       	r0 = M[r5 + 52];
84201804:	d1 9e       	M[r0 + 44] = rMAC;
    p_ag->p_ed_ext->count_th = AANC2_ED_COUNT_TH;
84201806:	79 99       	rMAC = M[r5 + 52];
84201808:	1a f0 0c 8e 	M[rMAC + 48] = r8;
    p_ag->p_ed_ext->hold_frames = p_params->OFFSET_ED_EXT_HOLD_FRAMES;
8420180c:	81 f0 1b 88 	rMAC = M[r6 + 108];
84201810:	7a 99       	r0 = M[r5 + 52];
84201812:	51 9f       	M[r0 + 52] = rMAC;
    p_ag->p_ed_ext->e_min_threshold = \
        p_params->OFFSET_ED_EXT_E_FILTER_MIN_THRESHOLD;
84201814:	81 f0 1c 88 	rMAC = M[r6 + 112];
84201818:	7a 99       	r0 = M[r5 + 52];
8420181a:	91 9f       	M[r0 + 56] = rMAC;
    p_ag->p_ed_ext->e_min_counter_threshold = \
        p_params->OFFSET_ED_EXT_E_FILTER_MIN_COUNTER_THRESHOLD;
8420181c:	81 f0 1d 88 	rMAC = M[r6 + 116];
84201820:	7a 99       	r0 = M[r5 + 52];
84201822:	d1 9f       	M[r0 + 60] = rMAC;
    disable_filter_check = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_ED_EXT_E_FILTER_CHECK) > 0;
84201824:	41 d8       	rMAC = M[FP + 32];
84201826:	4a c2       	r0 = rMAC AND 0x20;
84201828:	01 00       	rMAC = Null + Null;
8420182a:	10 04       	Null = r0 - Null;
8420182c:	21 f0 41 ce 	if NE rMAC = Null + 1;
    p_ag->p_ed_ext->e_min_check_disabled = disable_filter_check;
84201830:	7a 99       	r0 = M[r5 + 52];
84201832:	11 ae       	M[r0 + 64] = rMAC;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_ext);
84201834:	7b 99       	r1 = M[r5 + 52];
84201836:	72 f0 2e 88 	r0 = M[r5 + 184];
8420183a:	0a f0 35 e7 	call (m) $_aanc_ed100_initialize;

    /* Initialize the playback ED */
    p_ag->p_ed_pb->p_input = p_ag->p_tmp_pb_ip;
8420183e:	f9 99       	rMAC = M[r5 + 60];
84201840:	3a a8       	r0 = M[r5 + 64];
84201842:	11 ee       	M[r0 + Null] = rMAC;
    p_ag->p_ed_pb->p_tmp = p_ag->p_tmp_ed;
84201844:	f9 88       	rMAC = M[r5 + 12];
84201846:	3a a8       	r0 = M[r5 + 64];
84201848:	51 8e       	M[r0 + 4] = rMAC;
    p_ag->p_ed_pb->disabled = (config &
        AANC2_CONFIG_AANC2_CONFIG_DISABLE_ED_PB) > 0;
8420184a:	01 00       	rMAC = Null + Null;
8420184c:	92 f0 04 00 	r0 = r7 AND 0x4;
84201850:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201854:	3a a8       	r0 = M[r5 + 64];
84201856:	91 8e       	M[r0 + 8] = rMAC;
    p_ag->p_ed_pb->frame_size = AANC2_DEFAULT_FRAME_SIZE;
84201858:	39 a8       	rMAC = M[r5 + 64];
8420185a:	4a d8       	r0 = M[FP + 36];
8420185c:	ca 8e       	M[rMAC + 12] = r0;
    p_ag->p_ed_pb->attack_time = AANC2_ED_ATTACK;
8420185e:	39 a8       	rMAC = M[r5 + 64];
84201860:	0e 8f       	M[rMAC + 16] = r4;
    p_ag->p_ed_pb->decay_time = AANC2_ED_DECAY;
84201862:	39 a8       	rMAC = M[r5 + 64];
84201864:	4e 8f       	M[rMAC + 20] = r4;
    p_ag->p_ed_pb->envelope_time = p_params->OFFSET_ED_PB_ENVELOPE;
84201866:	81 f0 26 88 	rMAC = M[r6 + 152];
8420186a:	3a a8       	r0 = M[r5 + 64];
8420186c:	91 8f       	M[r0 + 24] = rMAC;
    p_ag->p_ed_pb->init_frame_time = AANC2_ED_INIT_FRAME;
8420186e:	39 a8       	rMAC = M[r5 + 64];
84201870:	1b f0 07 8e 	M[rMAC + 28] = r9;
    p_ag->p_ed_pb->ratio = p_params->OFFSET_ED_PB_RATIO;
84201874:	81 f0 27 88 	rMAC = M[r6 + 156];
84201878:	3a a8       	r0 = M[r5 + 64];
8420187a:	11 9e       	M[r0 + 32] = rMAC;
    p_ag->p_ed_pb->min_signal = p_params->OFFSET_ED_PB_MIN_SIGNAL;
8420187c:	81 f0 28 88 	rMAC = M[r6 + 160];
84201880:	3a a8       	r0 = M[r5 + 64];
84201882:	51 9e       	M[r0 + 36] = rMAC;
    p_ag->p_ed_pb->min_max_envelope = \
        p_params->OFFSET_ED_PB_MIN_MAX_ENVELOPE;
84201884:	81 f0 29 88 	rMAC = M[r6 + 164];
84201888:	3a a8       	r0 = M[r5 + 64];
8420188a:	91 9e       	M[r0 + 40] = rMAC;
    p_ag->p_ed_pb->delta_th = p_params->OFFSET_ED_PB_DELTA_TH;
8420188c:	81 f0 2a 88 	rMAC = M[r6 + 168];
84201890:	3a a8       	r0 = M[r5 + 64];
84201892:	d1 9e       	M[r0 + 44] = rMAC;
    p_ag->p_ed_pb->count_th = AANC2_ED_COUNT_TH;
84201894:	39 a8       	rMAC = M[r5 + 64];
84201896:	1a f0 0c 8e 	M[rMAC + 48] = r8;
    p_ag->p_ed_pb->hold_frames = p_params->OFFSET_ED_PB_HOLD_FRAMES;
8420189a:	81 f0 2b 88 	rMAC = M[r6 + 172];
8420189e:	3a a8       	r0 = M[r5 + 64];
842018a0:	51 9f       	M[r0 + 52] = rMAC;
    p_ag->p_ed_pb->e_min_threshold = \
        p_params->OFFSET_ED_PB_E_FILTER_MIN_THRESHOLD;
842018a2:	81 f0 2c 88 	rMAC = M[r6 + 176];
842018a6:	3a a8       	r0 = M[r5 + 64];
842018a8:	91 9f       	M[r0 + 56] = rMAC;
    p_ag->p_ed_pb->e_min_counter_threshold = \
        p_params->OFFSET_ED_PB_E_FILTER_MIN_COUNTER_THRESHOLD;
842018aa:	81 f0 2d 88 	rMAC = M[r6 + 180];
842018ae:	3a a8       	r0 = M[r5 + 64];
842018b0:	d1 9f       	M[r0 + 60] = rMAC;
    disable_filter_check = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_ED_PB_E_FILTER_CHECK) > 0;
842018b2:	41 d8       	rMAC = M[FP + 32];
842018b4:	ca c2       	r0 = rMAC AND 0x40;
842018b6:	01 00       	rMAC = Null + Null;
842018b8:	10 04       	Null = r0 - Null;
842018ba:	21 f0 41 ce 	if NE rMAC = Null + 1;
    p_ag->p_ed_pb->e_min_check_disabled = disable_filter_check;
842018be:	3a a8       	r0 = M[r5 + 64];
842018c0:	11 ae       	M[r0 + 64] = rMAC;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_pb);
842018c2:	3b a8       	r1 = M[r5 + 64];
842018c4:	72 f0 2e 88 	r0 = M[r5 + 184];
842018c8:	0a f0 27 e3 	call (m) $_aanc_ed100_initialize;

    /* Initialize clipping */
    clip_disable = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_CLIPPING_DETECT_INT) > 0;
842018cc:	41 d8       	rMAC = M[FP + 32];
842018ce:	ca c5       	r0 = rMAC AND 0x1000;
842018d0:	01 00       	rMAC = Null + Null;
842018d2:	10 04       	Null = r0 - Null;
842018d4:	21 f0 41 ce 	if NE rMAC = Null + 1;
    aanc2_clipping_initialize(&p_ag->clip_int,
                              p_ag->p_tmp_int_ip,
                              AANC2_CLIPPING_THRESHOLD,
                              p_params->OFFSET_CLIPPING_DURATION_INT,
                              clip_disable);
842018d8:	09 1c       	pushm <rMAC>;
842018da:	85 f0 0b 88 	r3 = M[r6 + 44];
842018de:	ff f3 f4 f7 	r2 = Null + 1073741823;
842018e2:	ff 7b 
842018e4:	3b 89       	r1 = M[r5 + 16];
842018e6:	72 f0 68 20 	r0 = r5 + 104;
842018ea:	01 f0 21 e7 	call (m) $_aanc2_clipping_initialize;
842018ee:	7f 4c       	SP = SP + -4;

    clip_disable = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_CLIPPING_DETECT_EXT) > 0;
842018f0:	41 d8       	rMAC = M[FP + 32];
842018f2:	12 f1 00 00 	r0 = rMAC AND 0x2000;
842018f6:	01 00       	rMAC = Null + Null;
842018f8:	10 04       	Null = r0 - Null;
842018fa:	21 f0 41 ce 	if NE rMAC = Null + 1;
    aanc2_clipping_initialize(&p_ag->clip_ext,
                              p_ag->p_tmp_ext_ip,
                              AANC2_CLIPPING_THRESHOLD,
                              p_params->OFFSET_CLIPPING_DURATION_EXT,
                              clip_disable);
842018fe:	09 1c       	pushm <rMAC>;
84201900:	85 f0 08 88 	r3 = M[r6 + 32];
84201904:	ff f3 f4 f7 	r2 = Null + 1073741823;
84201908:	ff 7b 
8420190a:	fb 98       	r1 = M[r5 + 44];
8420190c:	72 f0 54 20 	r0 = r5 + 84;
84201910:	01 f0 3b e5 	call (m) $_aanc2_clipping_initialize;
84201914:	7f 4c       	SP = SP + -4;

    clip_disable = (debug_config & \
        AANC2_CONFIG_AANC2_DEBUG_DISABLE_CLIPPING_DETECT_PB) > 0;
84201916:	41 d8       	rMAC = M[FP + 32];
84201918:	12 f2 00 00 	r0 = rMAC AND 0x4000;
8420191c:	01 00       	rMAC = Null + Null;
8420191e:	10 04       	Null = r0 - Null;
84201920:	21 f0 41 ce 	if NE rMAC = Null + 1;
    aanc2_clipping_initialize(&p_ag->clip_pb,
                              p_ag->p_tmp_pb_ip,
                              AANC2_CLIPPING_THRESHOLD,
                              p_params->OFFSET_CLIPPING_DURATION_PB,
                              clip_disable);
84201924:	09 1c       	pushm <rMAC>;
84201926:	85 f0 0c 88 	r3 = M[r6 + 48];
8420192a:	ff f3 f4 f7 	r2 = Null + 1073741823;
8420192e:	ff 7b 
84201930:	fb 99       	r1 = M[r5 + 60];
84201932:	72 f0 7c 20 	r0 = r5 + 124;
84201936:	01 f0 35 e4 	call (m) $_aanc2_clipping_initialize;
8420193a:	7f 4c       	SP = SP + -4;

    return TRUE;
8420193c:	42 20       	r0 = Null + 1;

8420193e <Lc_aanc2_proc_initialize_10>:
}
8420193e:	ac f3 10 cf 	SP = SP + -168;
84201942:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201944:	d8 4c       	rts;

84201946 <$_aanc2_proc_initialize_concurrency>:

bool aanc2_proc_initialize_concurrency(AANC2_PROC *p_ag,
                                       AANC2_PARAMETERS *p_params,
                                       bool concurrency)
{
    if (concurrency)
84201946:	20 04       	Null = r2 - Null;
84201948:	0d 60       	if EQ jump (m) Lc_aanc2_proc_initialize_concurrency_3;

8420194a <Lc_aanc2_proc_initialize_concurrency_2>:
    {
        p_ag->self_speech_threshold = p_params->OFFSET_SELF_SPEECH_THRESHOLD_CONC;
8420194a:	31 f0 43 88 	rMAC = M[r1 + 268];
8420194e:	51 9e       	M[r0 + 36] = rMAC;
        p_ag->p_ed_int->envelope_time = p_params->OFFSET_ED_INT_ENVELOPE_CONC;
84201950:	31 f0 44 88 	rMAC = M[r1 + 272];
84201954:	94 89       	r2 = M[r0 + 24];
84201956:	a1 8f       	M[r2 + 24] = rMAC;
        p_ag->p_ed_int->min_signal = p_params->OFFSET_ED_INT_MIN_SIGNAL_CONC;
84201958:	31 f0 45 88 	rMAC = M[r1 + 276];
8420195c:	92 89       	r0 = M[r0 + 24];
8420195e:	51 9e       	M[r0 + 36] = rMAC;
84201960:	0a 6e       	jump (m) Lc_aanc2_proc_initialize_concurrency_4;

84201962 <Lc_aanc2_proc_initialize_concurrency_3>:
    }
    else {
        p_ag->self_speech_threshold = p_params->OFFSET_SELF_SPEECH_THRESHOLD;
84201962:	99 a8       	rMAC = M[r1 + 72];
84201964:	51 9e       	M[r0 + 36] = rMAC;
        p_ag->p_ed_int->envelope_time = p_params->OFFSET_ED_INT_ENVELOPE;
84201966:	99 b9       	rMAC = M[r1 + 120];
84201968:	94 89       	r2 = M[r0 + 24];
8420196a:	a1 8f       	M[r2 + 24] = rMAC;
        p_ag->p_ed_int->min_signal = p_params->OFFSET_ED_INT_MIN_SIGNAL;
8420196c:	31 f0 20 88 	rMAC = M[r1 + 128];
84201970:	92 89       	r0 = M[r0 + 24];
84201972:	51 9e       	M[r0 + 36] = rMAC;

84201974 <Lc_aanc2_proc_initialize_concurrency_4>:
    }

    return TRUE;
84201974:	42 20       	r0 = Null + 1;

84201976 <Lc_aanc2_proc_initialize_concurrency_5>:
84201976:	d8 4c       	rts;

84201978 <$_aanc2_proc_process_data>:
}

bool aanc2_proc_process_data(AANC2_PROC *p_ag,
                             unsigned samples,
                             bool calculate_gain)
{
84201978:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420197a:	16 00       	r4 = r0 + Null;
8420197c:	1a 09       	r8 = r1 + Null;
8420197e:	23 09       	r9 = r2 + Null;
    bool self_speech, copy_output, high_pb_ratio;
    unsigned flags, clip_det;

    /* Copy input data to internal data buffers */
    cbuffer_copy(p_ag->p_tmp_int_ip, p_ag->p_mic_int_ip, samples);
84201980:	63 f0 28 88 	r1 = M[r4 + 160];
84201984:	32 89       	r0 = M[r4 + 16];
84201986:	54 08       	r2 = r8 + Null;
84201988:	ff fd 62 f2 	call (m) 0x4dda4;
8420198c:	3d e0 
    cbuffer_copy(p_ag->p_tmp_ext_ip, p_ag->p_mic_ext_ip, samples);
8420198e:	63 f0 29 88 	r1 = M[r4 + 164];
84201992:	f2 98       	r0 = M[r4 + 44];
84201994:	54 08       	r2 = r8 + Null;
84201996:	ff fd 62 f2 	call (m) 0x4dda4;
8420199a:	2f e0 

    /* Copy playback data to internal data buffers if connected */
    if (p_ag->p_playback_ip != NULL)
8420199c:	63 f0 26 88 	r1 = M[r4 + 152];
842019a0:	06 60       	if EQ jump (m) Lc_aanc2_proc_process_data_3;

842019a2 <Lc_aanc2_proc_process_data_2>:
    {
        cbuffer_copy(p_ag->p_tmp_pb_ip, p_ag->p_playback_ip, samples);
842019a2:	f2 99       	r0 = M[r4 + 60];
842019a4:	54 08       	r2 = r8 + Null;
842019a6:	ff fd 61 f2 	call (m) 0x4dda4;
842019aa:	3f ef 

842019ac <Lc_aanc2_proc_process_data_3>:
    }

    /* Clear all flags connected with processing data but persist quiet mode */
    flags = p_ag->proc_flags & AANC2_FLAGS_QUIET_MODE;
842019ac:	31 e8       	rMAC = M[r4 + Null];
842019ae:	08 f0 17 f0 	r5 = rMAC AND 0x100000;
842019b2:	00 00 

    /* Calculate peak values and clipping status */
    if (!p_ag->clip_ext.disabled && !p_ag->clip_int.disabled)
842019b4:	61 f0 65 82 	rMAC = MBU[r4 + 101];
842019b8:	13 62       	if NE jump (m) Lc_aanc2_proc_process_data_6;

842019ba <Lc_aanc2_proc_process_data_4>:
842019ba:	61 f0 79 82 	rMAC = MBU[r4 + 121];
842019be:	10 62       	if NE jump (m) Lc_aanc2_proc_process_data_6;

842019c0 <Lc_aanc2_proc_process_data_5>:
    {
        aanc2_clipping_peak_detect_dual(&p_ag->clip_int,
                                        &p_ag->clip_ext,
                                        samples);
842019c0:	62 f0 68 20 	r0 = r4 + 104;
842019c4:	23 f3 ec 3b 	r1 = r0 + -20;
842019c8:	54 08       	r2 = r8 + Null;
842019ca:	05 f0 3d ec 	call (m) $_aanc2_clipping_peak_detect_dual;
        aanc2_clipping_process_detection(&p_ag->clip_ext);
842019ce:	62 f0 54 20 	r0 = r4 + 84;
842019d2:	01 f0 21 e1 	call (m) $_aanc2_clipping_process_detection;
        aanc2_clipping_process_detection(&p_ag->clip_int);
842019d6:	62 f0 68 20 	r0 = r4 + 104;
842019da:	01 f0 39 e0 	call (m) $_aanc2_clipping_process_detection;

842019de <Lc_aanc2_proc_process_data_6>:
    }
    if (!p_ag->clip_pb.disabled && p_ag->p_playback_ip != NULL)
842019de:	61 f0 8d 82 	rMAC = MBU[r4 + 141];
842019e2:	0c 62       	if NE jump (m) Lc_aanc2_proc_process_data_9;

842019e4 <Lc_aanc2_proc_process_data_7>:
842019e4:	61 f0 26 88 	rMAC = M[r4 + 152];
842019e8:	09 60       	if EQ jump (m) Lc_aanc2_proc_process_data_9;

842019ea <Lc_aanc2_proc_process_data_8>:
    {
        aanc2_clipping_peak_detect_single(&p_ag->clip_pb, samples);
842019ea:	62 f0 7c 20 	r0 = r4 + 124;
842019ee:	53 08       	r1 = r8 + Null;
842019f0:	06 f0 2b e0 	call (m) $_aanc2_clipping_peak_detect_single;
        aanc2_clipping_process_detection(&p_ag->clip_pb);
842019f4:	62 f0 7c 20 	r0 = r4 + 124;
842019f8:	fd 4e       	call (m) $_aanc2_clipping_process_detection;

842019fa <Lc_aanc2_proc_process_data_9>:
    }

    /* If clipping is detected pass data through and exit early */
    clip_det = p_ag->clip_ext.detected * AANC2_FLAGS_CLIPPING_EXT;
842019fa:	62 f0 66 82 	r0 = MBU[r4 + 102];
842019fe:	04 f2 d8 d8 	r6 = r0 LSHIFT 9;
    clip_det |= p_ag->clip_int.detected * AANC2_FLAGS_CLIPPING_INT;
84201a02:	62 f0 7a 82 	r0 = MBU[r4 + 122];
84201a06:	d2 55       	r0 = r0 LSHIFT 8;
84201a08:	00 f2 78 c8 	r6 = r6 OR r0;
    clip_det |= p_ag->clip_pb.detected * AANC2_FLAGS_CLIPPING_PLAYBACK;
84201a0c:	62 f0 8e 82 	r0 = MBU[r4 + 142];
84201a10:	05 f2 d2 c8 	r0 = r0 LSHIFT 10;

    if (clip_det > 0)
84201a14:	00 f2 78 c8 	r6 = r6 OR r0;
84201a18:	0a 60       	if EQ jump (m) Lc_aanc2_proc_process_data_11;

84201a1a <Lc_aanc2_proc_process_data_10>:
    {
        aanc2_proc_pass_data(p_ag, samples, FALSE);
84201a1a:	04 00       	r2 = Null + Null;
84201a1c:	53 08       	r1 = r8 + Null;
84201a1e:	32 00       	r0 = r4 + Null;
84201a20:	85 4e       	call (m) Lc_aanc2_proc_pass_data_1;
        flags |= clip_det;
84201a22:	00 f8 77 c8 	r5 = r5 OR r6;
        p_ag->proc_flags = flags;
84201a26:	37 ee       	M[r4 + Null] = r5;
        return FALSE;
84201a28:	02 00       	r0 = Null + Null;
84201a2a:	7e 6e       	jump (m) Lc_aanc2_proc_process_data_41;

84201a2c <Lc_aanc2_proc_process_data_11>:
    }

    /* ED process ext mic */
    if (!p_ag->p_ed_ext->disabled)
84201a2c:	73 99       	r1 = M[r4 + 52];
84201a2e:	98 88       	Null = M[r1 + 8];
84201a30:	1d 62       	if NE jump (m) Lc_aanc2_proc_process_data_18;

84201a32 <Lc_aanc2_proc_process_data_12>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_ext);
84201a32:	62 f0 2e 88 	r0 = M[r4 + 184];
84201a36:	09 f0 39 e9 	call (m) $_aanc_ed100_process_data;

        /* Catch external ED detection */
        if (p_ag->p_ed_ext->detection)
84201a3a:	71 99       	rMAC = M[r4 + 52];
84201a3c:	08 a9       	Null = M[rMAC + 80];
84201a3e:	02 60       	if EQ jump (m) Lc_aanc2_proc_process_data_14;

84201a40 <Lc_aanc2_proc_process_data_13>:
        {
            flags |= AANC2_FLAGS_ED_EXT;
84201a40:	7f ca       	r5 = r5 OR 0x20;

84201a42 <Lc_aanc2_proc_process_data_14>:
        }

        /* Threshold detect on external ED */
        if (p_ag->p_ed_ext->spl < p_ag->quiet_lo_threshold)
84201a42:	49 a8       	rMAC = M[rMAC + 68];
84201a44:	62 f0 25 88 	r0 = M[r4 + 148];
84201a48:	88 04       	Null = rMAC - r0;
84201a4a:	02 f0 8f e0 	if C jump (m) Lc_aanc2_proc_process_data_16;

84201a4e <Lc_aanc2_proc_process_data_15>:
        {
            /* Set quiet mode flag */
            flags |= AANC2_FLAGS_QUIET_MODE;
84201a4e:	01 f0 00 f0 	r5 = r5 OR 0x100000;
84201a52:	00 f7 57 c8 
84201a56:	0a 6e       	jump (m) Lc_aanc2_proc_process_data_18;

84201a58 <Lc_aanc2_proc_process_data_16>:
        }
        else if (p_ag->p_ed_ext->spl > p_ag->quiet_hi_threshold)
84201a58:	62 f0 24 88 	r0 = M[r4 + 144];
84201a5c:	88 04       	Null = rMAC - r0;
84201a5e:	09 f0 8d e0 	if LS jump (m) Lc_aanc2_proc_process_data_18;

84201a62 <Lc_aanc2_proc_process_data_17>:
        {
            /* Reset quiet mode flag */
            flags &= AANC2_PROC_QUIET_MODE_RESET_FLAG;
84201a62:	03 f0 f7 ff 	r5 = r5 AND 0x7fefffff;
84201a66:	77 ff ff 1f 

84201a6a <Lc_aanc2_proc_process_data_18>:
        }
    }

    /* ED process int mic */
    if (!p_ag->p_ed_int->disabled)
84201a6a:	b3 89       	r1 = M[r4 + 24];
84201a6c:	98 88       	Null = M[r1 + 8];
84201a6e:	09 62       	if NE jump (m) Lc_aanc2_proc_process_data_21;

84201a70 <Lc_aanc2_proc_process_data_19>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_int);
84201a70:	62 f0 2e 88 	r0 = M[r4 + 184];
84201a74:	09 f0 3b e7 	call (m) $_aanc_ed100_process_data;
        if (p_ag->p_ed_int->detection)
84201a78:	b1 89       	rMAC = M[r4 + 24];
84201a7a:	08 a9       	Null = M[rMAC + 80];
84201a7c:	02 60       	if EQ jump (m) Lc_aanc2_proc_process_data_21;

84201a7e <Lc_aanc2_proc_process_data_20>:
        {
            flags |= AANC2_FLAGS_ED_INT;
84201a7e:	ff c9       	r5 = r5 OR 0x10;

84201a80 <Lc_aanc2_proc_process_data_21>:
        }
    }

    /* ED process self-speech */
    self_speech = FALSE;
84201a80:	01 09       	r7 = Null + Null;
    if (!p_ag->self_speech_disabled)
84201a82:	61 f0 21 82 	rMAC = MBU[r4 + 33];
84201a86:	09 62       	if NE jump (m) Lc_aanc2_proc_process_data_24;

84201a88 <Lc_aanc2_proc_process_data_22>:
    {
        self_speech = aanc_ed100_self_speech_detect(
            p_ag->p_ed_int, p_ag->p_ed_ext,
            p_ag->self_speech_threshold);
84201a88:	74 98       	r2 = M[r4 + 36];
84201a8a:	73 99       	r1 = M[r4 + 52];
84201a8c:	b2 89       	r0 = M[r4 + 24];
84201a8e:	09 f0 3f eb 	call (m) $_aanc_ed100_self_speech_detect;
84201a92:	11 09       	r7 = r0 + Null;
        if (self_speech)
84201a94:	02 60       	if EQ jump (m) Lc_aanc2_proc_process_data_24;

84201a96 <Lc_aanc2_proc_process_data_23>:
        {
            flags |= AANC2_FLAGS_SELF_SPEECH;
84201a96:	7f cb       	r5 = r5 OR 0x80;

84201a98 <Lc_aanc2_proc_process_data_24>:
        }
    }

    /* ED process playback */
    high_pb_ratio = FALSE;
84201a98:	00 09       	r6 = Null + Null;
    if (p_ag->p_playback_ip != NULL && !p_ag->p_ed_pb->disabled)
84201a9a:	61 f0 26 88 	rMAC = M[r4 + 152];
84201a9e:	1b 60       	if EQ jump (m) Lc_aanc2_proc_process_data_32;

84201aa0 <Lc_aanc2_proc_process_data_25>:
84201aa0:	33 a8       	r1 = M[r4 + 64];
84201aa2:	98 88       	Null = M[r1 + 8];
84201aa4:	18 62       	if NE jump (m) Lc_aanc2_proc_process_data_32;

84201aa6 <Lc_aanc2_proc_process_data_26>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_pb);
84201aa6:	62 f0 2e 88 	r0 = M[r4 + 184];
84201aaa:	09 f0 25 e6 	call (m) $_aanc_ed100_process_data;
        if (p_ag->p_ed_pb->detection)
84201aae:	32 a8       	r0 = M[r4 + 64];
84201ab0:	10 a9       	Null = M[r0 + 80];
84201ab2:	02 60       	if EQ jump (m) Lc_aanc2_proc_process_data_28;

84201ab4 <Lc_aanc2_proc_process_data_27>:
        {
            flags |= AANC2_FLAGS_ED_PLAYBACK;
84201ab4:	ff ca       	r5 = r5 OR 0x40;

84201ab6 <Lc_aanc2_proc_process_data_28>:
        }

        /* Compute playback ratio */
        if (!p_ag->pb_ratio_disabled && !p_ag->p_ed_ext->disabled)
84201ab6:	61 f0 22 82 	rMAC = MBU[r4 + 34];
84201aba:	0d 62       	if NE jump (m) Lc_aanc2_proc_process_data_32;

84201abc <Lc_aanc2_proc_process_data_29>:
84201abc:	73 99       	r1 = M[r4 + 52];
84201abe:	98 88       	Null = M[r1 + 8];
84201ac0:	0a 62       	if NE jump (m) Lc_aanc2_proc_process_data_32;

84201ac2 <Lc_aanc2_proc_process_data_30>:
        {
            high_pb_ratio = aanc_ed100_self_speech_detect(
                p_ag->p_ed_pb, p_ag->p_ed_ext,
                p_ag->pb_ratio_threshold);
84201ac2:	b4 98       	r2 = M[r4 + 40];
84201ac4:	09 f0 29 ea 	call (m) $_aanc_ed100_self_speech_detect;
84201ac8:	10 09       	r6 = r0 + Null;
            if (high_pb_ratio)
84201aca:	05 60       	if EQ jump (m) Lc_aanc2_proc_process_data_32;

84201acc <Lc_aanc2_proc_process_data_31>:
            {
                flags |= AANC2_FLAGS_HIGH_PB_RATIO;
84201acc:	02 f0 00 f0 	r5 = r5 OR 0x200000;
84201ad0:	00 f7 57 c8 

84201ad4 <Lc_aanc2_proc_process_data_32>:


    /* Call adaptive ANC function */
    if (!p_ag->p_ed_ext->detection && !p_ag->p_ed_int->detection &&
        !p_ag->p_ed_pb->detection  && !self_speech && calculate_gain &&
        !high_pb_ratio)
84201ad4:	71 99       	rMAC = M[r4 + 52];
84201ad6:	08 a9       	Null = M[rMAC + 80];
84201ad8:	1d 62       	if NE jump (m) Lc_aanc2_proc_process_data_40;

84201ada <Lc_aanc2_proc_process_data_33>:
84201ada:	b1 89       	rMAC = M[r4 + 24];
84201adc:	08 a9       	Null = M[rMAC + 80];
84201ade:	1a 62       	if NE jump (m) Lc_aanc2_proc_process_data_40;

84201ae0 <Lc_aanc2_proc_process_data_34>:
84201ae0:	31 a8       	rMAC = M[r4 + 64];
84201ae2:	08 a9       	Null = M[rMAC + 80];
84201ae4:	17 62       	if NE jump (m) Lc_aanc2_proc_process_data_40;

84201ae6 <Lc_aanc2_proc_process_data_35>:
84201ae6:	0f f9 00 c2 	Null = r7 - Null;
84201aea:	14 62       	if NE jump (m) Lc_aanc2_proc_process_data_40;

84201aec <Lc_aanc2_proc_process_data_36>:
84201aec:	0f fb 00 c2 	Null = r9 - Null;
84201af0:	11 60       	if EQ jump (m) Lc_aanc2_proc_process_data_40;

84201af2 <Lc_aanc2_proc_process_data_37>:
84201af2:	0f f8 00 c2 	Null = r6 - Null;
84201af6:	0e 62       	if NE jump (m) Lc_aanc2_proc_process_data_40;

84201af8 <Lc_aanc2_proc_process_data_38>:
    {
        p_ag->prev_gain = (uint8)p_ag->p_fxlms->adaptive_gain;
84201af8:	b3 a8       	r1 = M[r4 + 72];
84201afa:	59 a8       	rMAC = M[r1 + 68];
84201afc:	61 f0 20 8a 	MB[r4 + 32] = rMAC;
        if (aanc_fxlms100_process_data(p_ag->f_handle, p_ag->p_fxlms))
84201b00:	62 f0 2e 88 	r0 = M[r4 + 184];
84201b04:	06 f0 27 eb 	call (m) $_aanc_fxlms100_process_data;
84201b08:	10 04       	Null = r0 - Null;
84201b0a:	04 60       	if EQ jump (m) Lc_aanc2_proc_process_data_40;

84201b0c <Lc_aanc2_proc_process_data_39>:
        {
            flags |= p_ag->p_fxlms->flags;
84201b0c:	b1 a8       	rMAC = M[r4 + 72];
84201b0e:	09 a8       	rMAC = M[rMAC + 64];
84201b10:	7f 12       	r5 = r5 OR rMAC;

84201b12 <Lc_aanc2_proc_process_data_40>:
        }
    }

    /* Update flags */
    p_ag->proc_flags = flags;
84201b12:	37 ee       	M[r4 + Null] = r5;

    /* Copy data from internal to external buffers */
    copy_output = p_ag->p_fxlms->read_ptr_upd > 0;
84201b14:	b1 a8       	rMAC = M[r4 + 72];
84201b16:	04 00       	r2 = Null + Null;
84201b18:	88 98       	Null = M[rMAC + 40];
84201b1a:	21 f0 44 ce 	if NE r2 = Null + 1;
    aanc2_proc_pass_data(p_ag, samples, copy_output);
84201b1e:	53 08       	r1 = r8 + Null;
84201b20:	32 00       	r0 = r4 + Null;
84201b22:	04 4e       	call (m) Lc_aanc2_proc_pass_data_1;

    return TRUE;
84201b24:	42 20       	r0 = Null + 1;

84201b26 <Lc_aanc2_proc_process_data_41>:
}
84201b26:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201b28:	d8 4c       	rts;

84201b2a <Lc_aanc2_proc_pass_data_1>:
 * \return  boolean indicating success or failure.
 */
static void aanc2_proc_pass_data(AANC2_PROC *p_ag,
                                 unsigned samples,
                                 bool use_output)
{
84201b2a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201b2c:	17 00       	r5 = r0 + Null;
84201b2e:	1e 00       	r4 = r1 + Null;
    tCbuffer *p_int_working_buffer, *p_ext_working_buffer;

    if (use_output)
84201b30:	20 04       	Null = r2 - Null;
84201b32:	18 60       	if EQ jump (m) Lc_aanc2_proc_pass_data_3;

84201b34 <Lc_aanc2_proc_pass_data_2>:
    {
        p_int_working_buffer = p_ag->p_tmp_int_op;
84201b34:	78 f0 05 88 	r6 = M[r5 + 20];
        p_ext_working_buffer = p_ag->p_tmp_ext_op;
84201b38:	3a 99       	r0 = M[r5 + 48];
84201b3a:	11 09       	r7 = r0 + Null;

        /* The internal output buffers have been populated by the FxLMS
         * processing routine. To make the buffer alignment work we need to
         * advance the respective read and write pointers.
         */
        cbuffer_advance_write_ptr(p_ag->p_tmp_ext_op, samples);
84201b3c:	ff fd 60 f2 	call (m) 0x4dbb0;
84201b40:	35 e3 
        cbuffer_advance_write_ptr(p_ag->p_tmp_int_op, samples);
84201b42:	7a 89       	r0 = M[r5 + 20];
84201b44:	33 00       	r1 = r4 + Null;
84201b46:	ff fd 60 f2 	call (m) 0x4dbb0;
84201b4a:	2b e3 
        cbuffer_advance_read_ptr(p_ag->p_tmp_ext_ip, samples);
84201b4c:	fa 98       	r0 = M[r5 + 44];
84201b4e:	33 00       	r1 = r4 + Null;
84201b50:	ff fd 60 f2 	call (m) 0x4db68;
84201b54:	39 e0 
        cbuffer_advance_read_ptr(p_ag->p_tmp_int_ip, samples);
84201b56:	3a 89       	r0 = M[r5 + 16];
84201b58:	33 00       	r1 = r4 + Null;
84201b5a:	ff fd 60 f2 	call (m) 0x4db68;
84201b5e:	2f e0 
84201b60:	05 6e       	jump (m) Lc_aanc2_proc_pass_data_4;

84201b62 <Lc_aanc2_proc_pass_data_3>:
    }
    else
    {
        p_int_working_buffer = p_ag->p_tmp_int_ip;
84201b62:	78 f0 04 88 	r6 = M[r5 + 16];
        p_ext_working_buffer = p_ag->p_tmp_ext_ip;
84201b66:	79 f0 0b 88 	r7 = M[r5 + 44];

84201b6a <Lc_aanc2_proc_pass_data_4>:
 */
static inline void aanc2_proc_consume_cbuffer(tCbuffer *p_dest,
                                              tCbuffer *p_src,
                                              unsigned samples)
{
    if (p_dest != NULL)
84201b6a:	72 f0 2c 88 	r0 = M[r5 + 176];
84201b6e:	19 60       	if EQ jump (m) Lc_aanc2_proc_pass_data_10;

84201b70 <Lc_aanc2_proc_pass_data_5>:
    {
        cbuffer_copy(p_dest, p_src, samples);
84201b70:	34 00       	r2 = r4 + Null;
84201b72:	43 08       	r1 = r6 + Null;
84201b74:	ff fd 61 f2 	call (m) 0x4dda4;
84201b78:	31 e1 
84201b7a:	18 6e       	jump (m) Lc_aanc2_proc_pass_data_11;

84201b7c <Lc_aanc2_proc_pass_data_6>:
    }
    else
    {
        cbuffer_discard_data(p_src, samples);
84201b7c:	33 00       	r1 = r4 + Null;
84201b7e:	4a 08       	r0 = r7 + Null;
84201b80:	ff fd 60 f2 	call (m) 0x4dc8c;
84201b84:	2d e8 

84201b86 <Lc_aanc2_proc_pass_data_7>:
    aanc2_proc_consume_cbuffer(p_ag->p_mic_ext_op,
                               p_ext_working_buffer,
                               samples);

    /* Copy or discard data on the playback stream */
    if (p_ag->p_playback_ip != NULL) {
84201b86:	71 f0 26 88 	rMAC = M[r5 + 152];
84201b8a:	1e 60       	if EQ jump (m) Lc_aanc2_proc_pass_data_14;

84201b8c <Lc_aanc2_proc_pass_data_8>:
        aanc2_proc_consume_cbuffer(p_ag->p_playback_op,
                                   p_ag->p_tmp_pb_ip,
                                   samples);
84201b8c:	f9 99       	rMAC = M[r5 + 60];
 */
static inline void aanc2_proc_consume_cbuffer(tCbuffer *p_dest,
                                              tCbuffer *p_src,
                                              unsigned samples)
{
    if (p_dest != NULL)
84201b8e:	72 f0 2a 88 	r0 = M[r5 + 168];
84201b92:	15 60       	if EQ jump (m) Lc_aanc2_proc_pass_data_13;

84201b94 <Lc_aanc2_proc_pass_data_9>:
    {
        cbuffer_copy(p_dest, p_src, samples);
84201b94:	34 00       	r2 = r4 + Null;
84201b96:	0b 00       	r1 = rMAC + Null;
84201b98:	ff fd 61 f2 	call (m) 0x4dda4;
84201b9c:	2d e0 
84201b9e:	14 6e       	jump (m) Lc_aanc2_proc_pass_data_14;

84201ba0 <Lc_aanc2_proc_pass_data_10>:
    }
    else
    {
        cbuffer_discard_data(p_src, samples);
84201ba0:	33 00       	r1 = r4 + Null;
84201ba2:	42 08       	r0 = r6 + Null;
84201ba4:	ff fd 60 f2 	call (m) 0x4dc8c;
84201ba8:	29 e7 

84201baa <Lc_aanc2_proc_pass_data_11>:
 */
static inline void aanc2_proc_consume_cbuffer(tCbuffer *p_dest,
                                              tCbuffer *p_src,
                                              unsigned samples)
{
    if (p_dest != NULL)
84201baa:	72 f0 2d 88 	r0 = M[r5 + 180];
84201bae:	e7 61       	if EQ jump (m) Lc_aanc2_proc_pass_data_6;

84201bb0 <Lc_aanc2_proc_pass_data_12>:
    {
        cbuffer_copy(p_dest, p_src, samples);
84201bb0:	34 00       	r2 = r4 + Null;
84201bb2:	4b 08       	r1 = r7 + Null;
84201bb4:	ff fd 60 f2 	call (m) 0x4dda4;
84201bb8:	31 ef 
84201bba:	e6 6f       	jump (m) Lc_aanc2_proc_pass_data_7;

84201bbc <Lc_aanc2_proc_pass_data_13>:
    }
    else
    {
        cbuffer_discard_data(p_src, samples);
84201bbc:	33 00       	r1 = r4 + Null;
84201bbe:	0a 00       	r0 = rMAC + Null;
84201bc0:	ff fd 60 f2 	call (m) 0x4dc8c;
84201bc4:	2d e6 

84201bc6 <Lc_aanc2_proc_pass_data_14>:
    if (p_ag->p_playback_ip != NULL) {
        aanc2_proc_consume_cbuffer(p_ag->p_playback_op,
                                   p_ag->p_tmp_pb_ip,
                                   samples);
    }
}
84201bc6:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201bc8:	d8 4c       	rts;

84201bca <$_aanc2_clipping_initialize>:
84201bca:	48 1c       	pushm <FP(=SP)>;
                               unsigned duration,
                               bool disabled)
{
    unsigned frame_duration;

    p_clip->p_data = p_data;        /* Setup internal data reference */
84201bcc:	13 ee       	M[r0 + Null] = r1;
    p_clip->threshold = threshold;  /* Setup threshold */
84201bce:	94 8e       	M[r0 + 8] = r2;

    /* Setup frame duration in frames */
    frame_duration = duration * AANC2_FRAME_RATE;
84201bd0:	7d f5 94 c9 	r2 = r3 * 250 (int);
    p_clip->duration = (uint16)(frame_duration >> AANC2_TIMER_PARAM_SHIFT);
84201bd4:	e4 52       	r2 = r2 LSHIFT -20;
84201bd6:	94 8d       	MH[r0 + 12] = r2;

    /* Reset counter and detection states */
    p_clip->counter = 0;
84201bd8:	d0 8d       	MH[r0 + 14] = Null;
    p_clip->peak_value = 0;
84201bda:	50 8e       	M[r0 + 4] = Null;
    p_clip->frame_detect = FALSE;
84201bdc:	10 aa       	MB[r0 + 16] = Null;
    p_clip->disabled = disabled;
84201bde:	f9 d9       	rMAC = M[FP + -4];
84201be0:	51 aa       	MB[r0 + 17] = rMAC;
    p_clip->detected = FALSE;
84201be2:	90 aa       	MB[r0 + 18] = Null;

    /* Override disabled flag if there's no input buffer */
    if (p_data == NULL)
84201be4:	18 04       	Null = r1 - Null;
84201be6:	03 62       	if NE jump (m) Lc_aanc2_clipping_initialize_3;

84201be8 <Lc_aanc2_clipping_initialize_2>:
    {
        p_clip->disabled = TRUE;
84201be8:	41 20       	rMAC = Null + 1;
84201bea:	51 aa       	MB[r0 + 17] = rMAC;

84201bec <Lc_aanc2_clipping_initialize_3>:
    }

    return TRUE;
84201bec:	42 20       	r0 = Null + 1;

84201bee <Lc_aanc2_clipping_initialize_4>:
}
84201bee:	48 48       	popm <FP>;
84201bf0:	d8 4c       	rts;

84201bf2 <$_aanc2_clipping_process_detection>:
 * for a given duration (frames).
 */
void aanc2_clipping_process_detection(AANC2_CLIP_DETECT *p_clip)
{
    /* Disabled resets the flag */
    if (p_clip->disabled)
84201bf2:	51 a2       	rMAC = MBU[r0 + 17];
84201bf4:	03 60       	if EQ jump (m) Lc_aanc2_clipping_process_detection_3;

84201bf6 <Lc_aanc2_clipping_process_detection_2>:
    {
        p_clip->detected = FALSE;
84201bf6:	90 aa       	MB[r0 + 18] = Null;
84201bf8:	0c 6e       	jump (m) Lc_aanc2_clipping_process_detection_7;

84201bfa <Lc_aanc2_clipping_process_detection_3>:
    }
    else
    {
        /* Detection sets the flag and resets the counter */
        if (p_clip->frame_detect)
84201bfa:	11 a2       	rMAC = MBU[r0 + 16];
84201bfc:	06 60       	if EQ jump (m) Lc_aanc2_clipping_process_detection_5;

84201bfe <Lc_aanc2_clipping_process_detection_4>:
        {
            p_clip->counter = p_clip->duration;
84201bfe:	91 87       	rMAC = MHU[r0 + 12];
84201c00:	d1 8d       	MH[r0 + 14] = rMAC;
            p_clip->detected = TRUE;
84201c02:	41 20       	rMAC = Null + 1;
84201c04:	91 aa       	MB[r0 + 18] = rMAC;
84201c06:	05 6e       	jump (m) Lc_aanc2_clipping_process_detection_7;

84201c08 <Lc_aanc2_clipping_process_detection_5>:
        }
        else
        {
            /* No detection decrements the counter until 0 */
            if (p_clip->counter > 0)
84201c08:	d1 87       	rMAC = MHU[r0 + 14];
84201c0a:	f6 61       	if EQ jump (m) Lc_aanc2_clipping_process_detection_2;

84201c0c <Lc_aanc2_clipping_process_detection_6>:
            {
                p_clip->counter--;
84201c0c:	49 24       	rMAC = rMAC - 1;
84201c0e:	d1 8d       	MH[r0 + 14] = rMAC;

84201c10 <Lc_aanc2_clipping_process_detection_7>:
84201c10:	d8 4c       	rts;

84201c12 <$_aanc2_initialize_event>:
84201c12:	c8 1c       	pushm <FP(=SP), rLink>;
void aanc2_initialize_event(AANC2_EVENT *p_event,
                            OPERATOR_DATA *op_data,
                            unsigned timer_duration,
                            uint16 id)
{
    unsigned frame_rate = timer_duration * AANC2_FRAME_RATE;
84201c14:	7d f4 94 c9 	r2 = r2 * 250 (int);
    p_event->set_frames = frame_rate >> AANC2_TIMER_PARAM_SHIFT;
84201c18:	e4 52       	r2 = r2 LSHIFT -20;
84201c1a:	54 8e       	M[r0 + 4] = r2;
    p_event->msg.op_data = op_data;
84201c1c:	d3 8e       	M[r0 + 12] = r1;
    p_event->msg.payload = 0;
84201c1e:	90 9c       	MH[r0 + 20] = Null;
    p_event->msg.id = id;
84201c20:	55 9c       	MH[r0 + 18] = r3;
    p_event->msg.opid = INT_TO_EXT_OPID(op_data->id);
84201c22:	5b 88       	r1 = M[r1 + 4];
84201c24:	5b 55       	r1 = r1 LSHIFT 6;
84201c26:	40 f0 00 f3 	rMAC = r1 OR 0x4000;
84201c2a:	51 d8 
84201c2c:	91 8f       	M[r0 + 24] = rMAC;
    aanc2_process_event_clear_condition(p_event);
84201c2e:	5c 4e       	call (m) $_aanc2_process_event_clear_condition;

84201c30 <Lc_aanc2_initialize_event_2>:
}
84201c30:	c8 48       	popm <FP, rLink>;
84201c32:	d8 4c       	rts;

84201c34 <$_aanc2_process_event>:

void aanc2_process_event(AANC2_EVENT *p_event,
                         unsigned cur_state,
                         unsigned prev_state)
{
84201c34:	c8 1c       	pushm <FP(=SP), rLink>;
    p_event->msg.payload = (uint16)cur_state;
    if (cur_state > 0)
84201c36:	93 9c       	MH[r0 + 20] = r1;
84201c38:	05 60       	if EQ jump (m) Lc_aanc2_process_event_4;

84201c3a <Lc_aanc2_process_event_2>:
    {
        /* Non-zero flags and no change starts/continues event */
        if (cur_state == prev_state)
84201c3a:	18 05       	Null = r1 - r2;
84201c3c:	06 62       	if NE jump (m) Lc_aanc2_process_event_6;

84201c3e <Lc_aanc2_process_event_3>:
        {
            aanc2_process_event_detect_condition(p_event);
84201c3e:	3a 4e       	call (m) $_aanc2_process_event_detect_condition;
84201c40:	04 6e       	jump (m) Lc_aanc2_process_event_6;

84201c42 <Lc_aanc2_process_event_4>:
        }
    }
    else
    {
        /* Flags reset causes event to be reset */
        if (cur_state != prev_state)
84201c42:	20 04       	Null = r2 - Null;
84201c44:	02 60       	if EQ jump (m) Lc_aanc2_process_event_6;

84201c46 <Lc_aanc2_process_event_5>:
        {
            aanc2_process_event_clear_condition(p_event);
84201c46:	50 4e       	call (m) $_aanc2_process_event_clear_condition;

84201c48 <Lc_aanc2_process_event_6>:
        }
    }
}
84201c48:	c8 48       	popm <FP, rLink>;
84201c4a:	d8 4c       	rts;

84201c4c <$_aanc2_send_event_trigger>:
/******************************************************************************
Public Function Definitions
*/

bool aanc2_send_event_trigger(AANC2_EVENT_MSG *p_msg)
{
84201c4c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201c4e:	16 00       	r4 = r0 + Null;

    /* Set the message ID */
    switch (p_msg->type)
    {
        case AANC2_EVENT_MSG_NEGATIVE_TRIGGER:
            message_id = OPMSG_REPLY_ID_AANC_EVENT_NEGATIVE_TRIGGER;
84201c50:	42 22       	r0 = Null + 9;
84201c52:	40 71       	r6 = Null + 8;
84201c54:	31 81       	rMAC = MBS[r4 + 4];
84201c56:	00 f2 08 c0 	if EQ r6 = r0 + Null;
            message_id = OPMSG_REPLY_ID_AANC_EVENT_TRIGGER;
    }

    /* Populate the message payload */
    msg_size = OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER_WORD_SIZE;
    trigger_message = xpnewn(msg_size, unsigned);
84201c5a:	c3 20       	r1 = Null + 3;
84201c5c:	02 28       	r0 = Null + 16;
84201c5e:	ff fd 29 f0 	call (m) 0x6e90;
84201c62:	33 e1 
84201c64:	17 00       	r5 = r0 + Null;
    if (trigger_message == NULL)
84201c66:	0e 62       	if NE jump (m) Lc_aanc2_send_event_trigger_5;

84201c68 <Lc_aanc2_send_event_trigger_2>:
    {
        L2_DBG_MSG1("OPID: %x, Failed to send AANC event message", p_msg->opid);
84201c68:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201c6c:	88 24       	Null = rMAC - 2;
84201c6e:	08 68       	if LT jump (m) Lc_aanc2_send_event_trigger_4;

84201c70 <Lc_aanc2_send_event_trigger_3>:
84201c70:	f3 88       	r1 = M[r4 + 12];
84201c72:	55 f1 02 f0 	r0 = Null + 357565771;
84201c76:	4b 49 
84201c78:	ef fd fa ff 	call (m) 0x10c2;
84201c7c:	2b e2 

84201c7e <Lc_aanc2_send_event_trigger_4>:
        return FALSE;
84201c7e:	02 00       	r0 = Null + Null;
84201c80:	17 6e       	jump (m) Lc_aanc2_send_event_trigger_6;

84201c82 <Lc_aanc2_send_event_trigger_5>:
    }

    OPMSG_CREATION_FIELD_SET(trigger_message,
                             OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER,
                             ID,
                             p_msg->id);
84201c82:	f1 86       	rMAC = MHU[r4 + 6];
84201c84:	39 ee       	M[r5 + Null] = rMAC;
    OPMSG_CREATION_FIELD_SET(trigger_message,
                             OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER,
                             PAYLOAD,
                             p_msg->payload);
84201c86:	31 87       	rMAC = MHU[r4 + 8];
84201c88:	79 8e       	M[r5 + 4] = rMAC;
    OPMSG_CREATION_FIELD_SET32(trigger_message,
                               OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER,
                               OPID,
                               p_msg->opid); 
84201c8a:	f1 88       	rMAC = M[r4 + 12];
84201c8c:	89 c6       	rMAC = rMAC AND 0xffff;
84201c8e:	b9 8e       	M[r5 + 8] = rMAC;
84201c90:	f2 88       	r0 = M[r4 + 12];
84201c92:	92 52       	r0 = r0 LSHIFT -16;
84201c94:	fa 8e       	M[r5 + 12] = r0;
    common_send_unsolicited_message(p_msg->op_data,
                                    message_id,
                                    msg_size,
                                    trigger_message);
84201c96:	04 21       	r2 = Null + 4;
84201c98:	32 e8       	r0 = M[r4 + Null];
84201c9a:	3d 00       	r3 = r5 + Null;
84201c9c:	43 08       	r1 = r6 + Null;
84201c9e:	ef fd f6 ff 	call (m) 0x970;
84201ca2:	33 e6 

    pdelete(trigger_message);
84201ca4:	3a 00       	r0 = r5 + Null;
84201ca6:	ff fd 29 f0 	call (m) 0x6fbe;
84201caa:	39 e8 

    return TRUE;
84201cac:	42 20       	r0 = Null + 1;

84201cae <Lc_aanc2_send_event_trigger_6>:
}
84201cae:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201cb0:	d8 4c       	rts;

84201cb2 <$_aanc2_process_event_detect_condition>:
            break;
    }
}

void aanc2_process_event_detect_condition(AANC2_EVENT *p_event)
{
84201cb2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201cb4:	16 00       	r4 = r0 + Null;
    switch (p_event->running)
84201cb6:	31 90       	rMAC = MBS[r4 + 8];
84201cb8:	09 60       	if EQ jump (m) Lc_aanc2_process_event_detect_condition_5;

84201cba <Lc_aanc2_process_event_detect_condition_2>:
84201cba:	48 24       	Null = rMAC - 1;
84201cbc:	13 62       	if NE jump (m) Lc_aanc2_process_event_detect_condition_7;

84201cbe <Lc_aanc2_process_event_detect_condition_3>:
            p_event->frame_counter -= 1;
            p_event->running = AANC2_EVENT_DETECTED;
            break;
        case AANC2_EVENT_DETECTED:
            /* Increment the event counter */
            if (p_event->frame_counter > 0)
84201cbe:	31 e8       	rMAC = M[r4 + Null];
84201cc0:	08 24       	Null = rMAC - 0;
84201cc2:	0a 6c       	if LE jump (m) Lc_aanc2_process_event_detect_condition_6;

84201cc4 <Lc_aanc2_process_event_detect_condition_4>:
            {
                p_event->frame_counter -= 1;
84201cc4:	49 24       	rMAC = rMAC - 1;
84201cc6:	31 ee       	M[r4 + Null] = rMAC;
84201cc8:	0d 6e       	jump (m) Lc_aanc2_process_event_detect_condition_7;

84201cca <Lc_aanc2_process_event_detect_condition_5>:
{
    switch (p_event->running)
    {
        case AANC2_EVENT_CLEAR:
            /* Start the event counter */
            p_event->frame_counter -= 1;
84201cca:	ff f6 11 d1 	rMAC = M[r4] + -1;
84201cce:	31 ee       	M[r4 + Null] = rMAC;
            p_event->running = AANC2_EVENT_DETECTED;
84201cd0:	41 20       	rMAC = Null + 1;
84201cd2:	31 9a       	MB[r4 + 8] = rMAC;
            break;
84201cd4:	07 6e       	jump (m) Lc_aanc2_process_event_detect_condition_7;

84201cd6 <Lc_aanc2_process_event_detect_condition_6>:
                p_event->frame_counter -= 1;
            }
            else
            {
                /* Send the event positive trigger message */
                p_event->msg.type = AANC2_EVENT_MSG_POSITIVE_TRIGGER;
84201cd6:	41 20       	rMAC = Null + 1;
84201cd8:	31 aa       	MB[r4 + 16] = rMAC;
                aanc2_send_event_trigger(&p_event->msg);
84201cda:	32 23       	r0 = r4 + 12;
84201cdc:	b8 4f       	call (m) $_aanc2_send_event_trigger;
                p_event->running = AANC2_EVENT_SENT;
84201cde:	81 20       	rMAC = Null + 2;
84201ce0:	31 9a       	MB[r4 + 8] = rMAC;

84201ce2 <Lc_aanc2_process_event_detect_condition_7>:
            }
            break;
        case AANC2_EVENT_SENT:
            break;
    }
}
84201ce2:	f1 48       	popm <FP, r4, rLink>;
84201ce4:	d8 4c       	rts;

84201ce6 <$_aanc2_process_event_clear_condition>:

    return TRUE;
}

void aanc2_process_event_clear_condition(AANC2_EVENT *p_event)
{
84201ce6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201ce8:	16 00       	r4 = r0 + Null;
    switch (p_event->running)
84201cea:	31 90       	rMAC = MBS[r4 + 8];
84201cec:	04 f0 99 e0 	if NEG jump (m) Lc_aanc2_process_event_clear_condition_6;

84201cf0 <Lc_aanc2_process_event_clear_condition_2>:
84201cf0:	48 24       	Null = rMAC - 1;
84201cf2:	06 6c       	if LE jump (m) Lc_aanc2_process_event_clear_condition_5;

84201cf4 <Lc_aanc2_process_event_clear_condition_3>:
84201cf4:	88 24       	Null = rMAC - 2;
84201cf6:	07 62       	if NE jump (m) Lc_aanc2_process_event_clear_condition_6;

84201cf8 <Lc_aanc2_process_event_clear_condition_4>:
            /* Have detected but not sent message so clear */
            aanc2_clear_event(p_event);
            break;
        case AANC2_EVENT_SENT:
            /* Send a negative trigger message and clear the event */
            p_event->msg.type = AANC2_EVENT_MSG_NEGATIVE_TRIGGER;
84201cf8:	30 aa       	MB[r4 + 16] = Null;
            aanc2_send_event_trigger(&p_event->msg);
84201cfa:	32 23       	r0 = r4 + 12;
84201cfc:	a8 4f       	call (m) $_aanc2_send_event_trigger;

84201cfe <Lc_aanc2_process_event_clear_condition_5>:
 */
inline void aanc2_clear_event(AANC2_EVENT *p_event);

inline void aanc2_clear_event(AANC2_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201cfe:	71 88       	rMAC = M[r4 + 4];
84201d00:	31 ee       	M[r4 + Null] = rMAC;
       p_event->running = AANC2_EVENT_CLEAR;
84201d02:	30 9a       	MB[r4 + 8] = Null;

84201d04 <Lc_aanc2_process_event_clear_condition_6>:
                is correct.
            */
        case AANC2_EVENT_DETECTED:
            /* Have detected but not sent message so clear */
            aanc2_clear_event(p_event);
            break;
84201d04:	f1 48       	popm <FP, r4, rLink>;
84201d06:	d8 4c       	rts;

84201d08 <$_aud_cur_create>:
84201d08:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
}

bool aud_cur_create(OPERATOR_DATA *op_data,
                    unsigned max_sources,
                    unsigned max_sinks)
{
84201d0a:	16 00       	r4 = r0 + Null;
84201d0c:	1f 00       	r5 = r1 + Null;
84201d0e:	20 09       	r6 = r2 + Null;

    unsigned input_size, output_size;
    AUDIO_CURATION_DEF *ptr;

    /* Allocate class data including space for linked lists */
    output_size = max_sources * sizeof(tCbuffer);
84201d10:	3a 47       	r0 = r5 * 28 (int);
    input_size = max_sinks * sizeof(tCbuffer);
84201d12:	0e f8 91 c9 	rMAC = r6 * 28 (int);

    ptr = (AUDIO_CURATION_DEF*)xzpmalloc(sizeof(AUDIO_CURATION_DEF) + \
        input_size + output_size);
84201d16:	c3 20       	r1 = Null + 3;
84201d18:	51 00       	rMAC = r0 + rMAC;
84201d1a:	12 f0 64 20 	r0 = rMAC + 100;
84201d1e:	ff fd 29 f0 	call (m) 0x6f8e;
84201d22:	31 e3 
84201d24:	11 09       	r7 = r0 + Null;

    if (ptr == NULL)
84201d26:	0d 62       	if NE jump (m) Lc_aud_cur_create_5;

84201d28 <Lc_aud_cur_create_2>:
    {
          L4_DBG_MSG("base aud cur create: class allocation failed.");
84201d28:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201d2c:	08 25       	Null = rMAC - 4;
84201d2e:	07 68       	if LT jump (m) Lc_aud_cur_create_4;

84201d30 <Lc_aud_cur_create_3>:
84201d30:	55 f1 02 f0 	r0 = Null + 357566084;
84201d34:	84 4a 
84201d36:	ef fd f9 ff 	call (m) 0x10b0;
84201d3a:	3b eb 

84201d3c <Lc_aud_cur_create_4>:
          return FALSE;
84201d3c:	02 00       	r0 = Null + Null;
84201d3e:	22 6e       	jump (m) Lc_aud_cur_create_6;

84201d40 <Lc_aud_cur_create_5>:
    }

    ptr->sources.max = (uint16)max_sources;
84201d40:	97 f0 0a 8c 	MH[r7 + 20] = r5;
    ptr->sinks.max = (uint16)max_sinks;
84201d44:	98 f0 04 8c 	MH[r7 + 8] = r6;

    ptr->sinks.p_buffer_list = (tCbuffer**)&ptr->buffer_data;
84201d48:	91 f0 64 20 	rMAC = r7 + 100;
84201d4c:	91 f0 04 8e 	M[r7 + 16] = rMAC;
    ptr->sources.p_buffer_list = ptr->sinks.p_buffer_list + max_sources;
84201d50:	7a 54       	r0 = r5 LSHIFT 2;
84201d52:	51 00       	rMAC = r0 + rMAC;
84201d54:	91 f0 07 8e 	M[r7 + 28] = rMAC;

    ptr->buffer_size = 2 * AUD_CUR_DEFAULT_BLOCK_SIZE;
84201d58:	81 20       	rMAC = Null + 2;
84201d5a:	91 f0 08 8e 	M[r7 + 32] = rMAC;
    ptr->block_size  = AUD_CUR_DEFAULT_BLOCK_SIZE;
84201d5e:	41 20       	rMAC = Null + 1;
84201d60:	91 f0 09 8e 	M[r7 + 36] = rMAC;

    ptr->cap_id = base_op_get_cap_id(op_data);
84201d64:	32 00       	r0 = r4 + Null;
84201d66:	ef fd f5 ff 	call (m) 0x8ee;
84201d6a:	29 ec 
84201d6c:	92 f0 0f 8e 	M[r7 + 60] = r0;

    ptr->re_init_flag = TRUE;
84201d70:	41 20       	rMAC = Null + 1;
84201d72:	91 f0 00 ea 	MB[r7 + Null] = rMAC;
 * \return - NONE
 */
static inline void set_class_data(OPERATOR_DATA *op_data,
                                  AUDIO_CURATION_DEF *class_data)
{
    base_op_set_class_ext(op_data, class_data);
84201d76:	4b 08       	r1 = r7 + Null;
84201d78:	32 00       	r0 = r4 + Null;
84201d7a:	ef fd f5 ff 	call (m) 0x938;
84201d7e:	3f ed 
    ptr->re_init_flag = TRUE;

    /* Save Pointer to channel definition in operator data */
    set_class_data(op_data, ptr);

    return TRUE;
84201d80:	42 20       	r0 = Null + 1;

84201d82 <Lc_aud_cur_create_6>:
}
84201d82:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201d84:	d8 4c       	rts;

84201d86 <$_aud_cur_destroy>:

void aud_cur_destroy(OPERATOR_DATA *op_data)
{
84201d86:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201d88:	16 00       	r4 = r0 + Null;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84201d8a:	ef fd f5 ff 	call (m) 0x934;
84201d8e:	2b ed 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    if (p_class_data == NULL)
84201d90:	10 04       	Null = r0 - Null;
84201d92:	09 60       	if EQ jump (m) Lc_aud_cur_destroy_3;

84201d94 <Lc_aud_cur_destroy_2>:
    {
        return;
    }

    pfree(p_class_data);
84201d94:	ff fd 29 f0 	call (m) 0x6fbe;
84201d98:	2b e1 
    set_class_data(op_data, NULL);
84201d9a:	03 00       	r1 = Null + Null;
 * \return - NONE
 */
static inline void set_class_data(OPERATOR_DATA *op_data,
                                  AUDIO_CURATION_DEF *class_data)
{
    base_op_set_class_ext(op_data, class_data);
84201d9c:	32 00       	r0 = r4 + Null;
84201d9e:	ef fd f5 ff 	call (m) 0x938;
84201da2:	3b ec 

84201da4 <Lc_aud_cur_destroy_3>:
    }

    pfree(p_class_data);
    set_class_data(op_data, NULL);
    return;
}
84201da4:	f1 48       	popm <FP, r4, rLink>;
84201da6:	d8 4c       	rts;

84201da8 <$_aud_cur_connect>:

bool aud_cur_connect(OPERATOR_DATA *op_data,
                     void *message_data,
                     unsigned *response_id,
                     void **response_data)
{
84201da8:	c8 1c       	pushm <FP(=SP), rLink>;
    return aud_cur_connect_common(op_data,
                                  message_data,
                                  response_id,
                                  response_data,
                                  TRUE);
84201daa:	00 f0 51 e0 	push Null + 1;
84201dae:	03 f0 33 e1 	call (m) Lc_aud_cur_connect_common_1;
84201db2:	7f 4c       	SP = SP + -4;

84201db4 <Lc_aud_cur_connect_2>:
}
84201db4:	c8 48       	popm <FP, rLink>;
84201db6:	d8 4c       	rts;

84201db8 <$_aud_cur_disconnect>:

bool aud_cur_disconnect(OPERATOR_DATA *op_data,
                        void *message_data,
                        unsigned *response_id,
                        void **response_data)
{
84201db8:	c8 1c       	pushm <FP(=SP), rLink>;
    return aud_cur_connect_common(op_data,
                                  message_data,
                                  response_id,
                                  response_data,
                                  FALSE);
84201dba:	00 f0 30 cf 	push Null;
84201dbe:	03 f0 23 e1 	call (m) Lc_aud_cur_connect_common_1;
84201dc2:	7f 4c       	SP = SP + -4;

84201dc4 <Lc_aud_cur_disconnect_2>:
}
84201dc4:	c8 48       	popm <FP, rLink>;
84201dc6:	d8 4c       	rts;

84201dc8 <$_aud_cur_buffer_details>:

bool aud_cur_buffer_details(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *response_id,
                            void **response_data)
{
84201dc8:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201dca:	17 00       	r5 = r0 + Null;
84201dcc:	19 09       	r7 = r1 + Null;
84201dce:	2e 00       	r4 = r3 + Null;
84201dd0:	ef fd f5 ff 	call (m) 0x934;
84201dd4:	25 eb 
84201dd6:	10 09       	r6 = r0 + Null;
    tCbuffer **p_metadata;
    unsigned terminal_id, buffer_size;
    uint16 terminal_num;
    bool is_sink;

    if (!base_op_buffer_details_lite(op_data, response_data))
84201dd8:	33 00       	r1 = r4 + Null;
84201dda:	3a 00       	r0 = r5 + Null;
84201ddc:	ef fd f5 ff 	call (m) 0x842;
84201de0:	27 e3 
84201de2:	10 04       	Null = r0 - Null;
84201de4:	03 62       	if NE jump (m) Lc_aud_cur_buffer_details_3;

84201de6 <Lc_aud_cur_buffer_details_2>:
    {
        return FALSE;
84201de6:	02 00       	r0 = Null + Null;
84201de8:	4f 6e       	jump (m) Lc_aud_cur_buffer_details_20;

84201dea <Lc_aud_cur_buffer_details_3>:
    }

    p_resp = (OP_BUF_DETAILS_RSP*) *response_data;
84201dea:	31 e8       	rMAC = M[r4 + Null];

    /* Make sure the buffer size is at least adequate for the capability */
    buffer_size = p_resp->b.buffer_size;
84201dec:	4f 89       	r5 = M[rMAC + 20];
    if (buffer_size < p_class_data->buffer_size)
84201dee:	82 f0 08 88 	r0 = M[r6 + 32];
84201df2:	b8 04       	Null = r5 - r0;
84201df4:	02 f0 87 e0 	if C jump (m) Lc_aud_cur_buffer_details_5;

84201df8 <Lc_aud_cur_buffer_details_4>:
    {
        buffer_size = p_class_data->buffer_size;
84201df8:	17 00       	r5 = r0 + Null;

84201dfa <Lc_aud_cur_buffer_details_5>:
    }

    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84201dfa:	95 f0 00 e8 	r3 = M[r7 + Null];
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
84201dfe:	ab c2       	r1 = r3 AND 0x3f;
    is_sink = terminal_id & TERMINAL_SINK_MASK;

    /* Setup the selected terminal */
    if (is_sink)
84201e00:	40 f0 52 f0 	r0 = r3 AND 0x800000;
84201e04:	00 00 
84201e06:	07 60       	if EQ jump (m) Lc_aud_cur_buffer_details_7;

84201e08 <Lc_aud_cur_buffer_details_6>:
    {
        /* Select source (opposite to the given buffer) */
        p_opposite_terminal = &p_class_data->sources;
84201e08:	84 f0 14 20 	r2 = r6 + 20;
84201e0c:	22 00       	r0 = r2 + Null;
        p_metadata = p_class_data->metadata_ip;
84201e0e:	04 f0 40 44 	r2 = r2 + 64;
84201e12:	06 6e       	jump (m) Lc_aud_cur_buffer_details_8;

84201e14 <Lc_aud_cur_buffer_details_7>:
    }
    else
    {
        /* Select sink (opposite to the given buffer) */
        p_opposite_terminal = &p_class_data->sinks;
84201e14:	84 f0 08 20 	r2 = r6 + 8;
84201e18:	22 00       	r0 = r2 + Null;
        p_metadata = p_class_data->metadata_op;
84201e1a:	04 f0 54 44 	r2 = r2 + 84;

84201e1e <Lc_aud_cur_buffer_details_8>:
    }

    if (p_class_data->in_place_flag)
84201e1e:	89 f0 01 82 	r7 = MBU[r6 + 1];
84201e22:	22 60       	if EQ jump (m) Lc_aud_cur_buffer_details_14;

84201e24 <Lc_aud_cur_buffer_details_9>:
    {
        /* Make sure the terminal is valid */
        if (terminal_num >= p_opposite_terminal->max)
84201e24:	29 f0 00 e6 	r7 = MHU[r0 + Null];
84201e28:	9f f3 00 c2 	Null = r1 - r7;
84201e2c:	10 68       	if LT jump (m) Lc_aud_cur_buffer_details_13;

84201e2e <Lc_aud_cur_buffer_details_10>:
        {
            L4_DBG_MSG1("base aud cur details: invalid terminal number %d",
                        terminal_num);
84201e2e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201e32:	08 25       	Null = rMAC - 4;
84201e34:	07 68       	if LT jump (m) Lc_aud_cur_buffer_details_12;

84201e36 <Lc_aud_cur_buffer_details_11>:
84201e36:	55 f1 02 f0 	r0 = Null + 357566130;
84201e3a:	b2 4a 
84201e3c:	ef fd f9 ff 	call (m) 0x10c2;
84201e40:	27 e4 

84201e42 <Lc_aud_cur_buffer_details_12>:
84201e42:	01 f0 00 60 	rMAC = Null + 4096;
84201e46:	32 e8       	r0 = M[r4 + Null];
84201e48:	51 8e       	M[r0 + 4] = rMAC;
84201e4a:	1d 6e       	jump (m) Lc_aud_cur_buffer_details_19;

84201e4c <Lc_aud_cur_buffer_details_13>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        /* Setup in-place payload */
        p_resp->runs_in_place = TRUE;
84201e4c:	46 20       	r4 = Null + 1;
84201e4e:	ce 9a       	MB[rMAC + 11] = r4;
        p_resp->b.in_place_buff_params.in_place_terminal = \
            SWAP_TERMINAL_DIRECTION(terminal_id);
84201e50:	08 f0 00 f0 	r3 = r3 XOR 0x800000;
84201e54:	00 f5 95 c8 
84201e58:	4d 8f       	M[rMAC + 20] = r3;
        p_resp->b.in_place_buff_params.size = buffer_size;
84201e5a:	8f 8f       	M[rMAC + 24] = r5;
 * \return - pointer to the terminal cbuffer
 */
static inline tCbuffer *aud_cur_get_terminal(AUD_CUR_TERMINAL *p_def,
                                             uint16 num)
{
    return p_def->p_buffer_list[num];
84201e5c:	92 88       	r0 = M[r0 + 8];
84201e5e:	5d 54       	r3 = r1 LSHIFT 2;
84201e60:	52 e9       	r0 = M[r0 + r3];
}
84201e62:	ca 8f       	M[rMAC + 28] = r0;
84201e64:	03 6e       	jump (m) Lc_aud_cur_buffer_details_15;

84201e66 <Lc_aud_cur_buffer_details_14>:
        p_resp->b.in_place_buff_params.buffer = \
            aud_cur_get_terminal(p_opposite_terminal, terminal_num);
    }
    else
    {
        p_resp->runs_in_place = FALSE;
84201e66:	c8 9a       	MB[rMAC + 11] = Null;
        p_resp->b.buffer_size = buffer_size;
84201e68:	4f 8f       	M[rMAC + 20] = r5;

84201e6a <Lc_aud_cur_buffer_details_15>:
    }

    /* Populate metadata response */
    p_resp->supports_metadata = p_class_data->supports_metadata_flag;
84201e6a:	82 f0 02 82 	r0 = MBU[r6 + 2];
84201e6e:	0a 9b       	MB[rMAC + 12] = r0;
    if (p_class_data->supports_metadata_flag)
84201e70:	82 f0 02 82 	r0 = MBU[r6 + 2];
84201e74:	08 60       	if EQ jump (m) Lc_aud_cur_buffer_details_19;

84201e76 <Lc_aud_cur_buffer_details_16>:
    {
        if (terminal_num == AUD_CUR_PLAYBACK_TERMINAL)
84201e76:	18 04       	Null = r1 - Null;
84201e78:	04 62       	if NE jump (m) Lc_aud_cur_buffer_details_18;

84201e7a <Lc_aud_cur_buffer_details_17>:
        {
            p_resp->metadata_buffer = p_metadata[AUD_CUR_METADATA_PLAYBACK];
84201e7a:	22 e8       	r0 = M[r2 + Null];
84201e7c:	0a 8f       	M[rMAC + 16] = r0;
84201e7e:	03 6e       	jump (m) Lc_aud_cur_buffer_details_19;

84201e80 <Lc_aud_cur_buffer_details_18>:
        }
        else
        {
            p_resp->metadata_buffer = p_metadata[AUD_CUR_METADATA_MIC];
84201e80:	62 88       	r0 = M[r2 + 4];
84201e82:	0a 8f       	M[rMAC + 16] = r0;

84201e84 <Lc_aud_cur_buffer_details_19>:
        }
    }

    return TRUE;
84201e84:	42 20       	r0 = Null + 1;

84201e86 <Lc_aud_cur_buffer_details_20>:
}
84201e86:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201e88:	d8 4c       	rts;

84201e8a <$_aud_cur_start>:

bool aud_cur_start(OPERATOR_DATA *op_data,
                   void *message_data,
                   unsigned *response_id,
                   void **response_data)
{
84201e8a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201e8c:	16 00       	r4 = r0 + Null;
84201e8e:	19 09       	r7 = r1 + Null;
84201e90:	27 00       	r5 = r2 + Null;
84201e92:	2a 09       	r8 = r3 + Null;
84201e94:	ef fd f5 ff 	call (m) 0x934;
84201e98:	21 e5 
84201e9a:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    /* Create the response. If there aren't sufficient resources for this fail
     * early.
     */
    if (!base_op_start(op_data, message_data, response_id, response_data))
84201e9c:	55 08       	r3 = r8 + Null;
84201e9e:	3c 00       	r2 = r5 + Null;
84201ea0:	4b 08       	r1 = r7 + Null;
84201ea2:	32 00       	r0 = r4 + Null;
84201ea4:	ef fd f4 ff 	call (m) 0x730;
84201ea8:	2d e4 
84201eaa:	10 04       	Null = r0 - Null;
84201eac:	03 62       	if NE jump (m) Lc_aud_cur_start_3;

84201eae <Lc_aud_cur_start_2>:
    {
        return FALSE;
84201eae:	02 00       	r0 = Null + Null;
84201eb0:	23 6e       	jump (m) Lc_aud_cur_start_11;

84201eb2 <Lc_aud_cur_start_3>:
    }

    /* If already running just ack */
    if (opmgr_op_is_running(op_data))
84201eb2:	32 00       	r0 = r4 + Null;
84201eb4:	ff fd 1e f0 	call (m) 0x5ca4;
84201eb8:	31 ef 
84201eba:	10 04       	Null = r0 - Null;
84201ebc:	12 62       	if NE jump (m) Lc_aud_cur_start_7;

84201ebe <Lc_aud_cur_start_4>:
       return TRUE;
    }

    /* Make sure we have valid terminal connections */
    if (!aud_cur_check_valid_terminals(&p_class_data->sinks) ||
        !aud_cur_check_valid_terminals(&p_class_data->sources))
84201ebe:	82 f0 08 20 	r0 = r6 + 8;
84201ec2:	03 f0 2f e3 	call (m) Lc_aud_cur_check_valid_terminals_1;
84201ec6:	10 04       	Null = r0 - Null;
84201ec8:	07 60       	if EQ jump (m) Lc_aud_cur_start_6;

84201eca <Lc_aud_cur_start_5>:
84201eca:	82 f0 14 20 	r0 = r6 + 20;
84201ece:	03 f0 23 e3 	call (m) Lc_aud_cur_check_valid_terminals_1;
84201ed2:	10 04       	Null = r0 - Null;
84201ed4:	08 62       	if NE jump (m) Lc_aud_cur_start_8;

84201ed6 <Lc_aud_cur_start_6>:
84201ed6:	01 f0 00 60 	rMAC = Null + 4096;
84201eda:	a2 f0 00 e8 	r0 = M[r8 + Null];
84201ede:	51 8e       	M[r0 + 4] = rMAC;

84201ee0 <Lc_aud_cur_start_7>:
    }

    /* If already running just ack */
    if (opmgr_op_is_running(op_data))
    {
       return TRUE;
84201ee0:	42 20       	r0 = Null + 1;
84201ee2:	0a 6e       	jump (m) Lc_aud_cur_start_11;

84201ee4 <Lc_aud_cur_start_8>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (p_class_data->start_fn != NULL)
84201ee4:	81 f0 10 88 	rMAC = M[r6 + 64];
84201ee8:	03 60       	if EQ jump (m) Lc_aud_cur_start_10;

84201eea <Lc_aud_cur_start_9>:
    {
        p_class_data->start_fn(op_data);
84201eea:	32 00       	r0 = r4 + Null;
84201eec:	d1 4c       	call rMAC;

84201eee <Lc_aud_cur_start_10>:
    }

    /* Reinitialize the operator */
    p_class_data->re_init_flag = TRUE;
84201eee:	41 20       	rMAC = Null + 1;
84201ef0:	81 f0 00 ea 	MB[r6 + Null] = rMAC;
84201ef4:	f6 6f       	jump (m) Lc_aud_cur_start_7;

84201ef6 <Lc_aud_cur_start_11>:

    return TRUE;
}
84201ef6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201ef8:	d8 4c       	rts;

84201efa <$_aud_cur_reset>:

bool aud_cur_reset(OPERATOR_DATA *op_data,
                   void *message_data,
                   unsigned *response_id,
                   void **response_data)
{
84201efa:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201efc:	16 00       	r4 = r0 + Null;
84201efe:	1a 09       	r8 = r1 + Null;
84201f00:	27 00       	r5 = r2 + Null;
84201f02:	29 09       	r7 = r3 + Null;
84201f04:	ef fd f5 ff 	call (m) 0x934;
84201f08:	31 e1 
84201f0a:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_reset(op_data, message_data, response_id, response_data))
84201f0c:	4d 08       	r3 = r7 + Null;
84201f0e:	3c 00       	r2 = r5 + Null;
84201f10:	53 08       	r1 = r8 + Null;
84201f12:	32 00       	r0 = r4 + Null;
84201f14:	ef fd f4 ff 	call (m) 0x724;
84201f18:	31 e0 
84201f1a:	10 04       	Null = r0 - Null;
84201f1c:	03 62       	if NE jump (m) Lc_aud_cur_reset_3;

84201f1e <Lc_aud_cur_reset_2>:
    {
        return FALSE;
84201f1e:	02 00       	r0 = Null + Null;
84201f20:	05 6e       	jump (m) Lc_aud_cur_reset_4;

84201f22 <Lc_aud_cur_reset_3>:
    }

    p_class_data->re_init_flag = TRUE;
84201f22:	41 20       	rMAC = Null + 1;
84201f24:	81 f0 00 ea 	MB[r6 + Null] = rMAC;

    return TRUE;
84201f28:	0a 00       	r0 = rMAC + Null;

84201f2a <Lc_aud_cur_reset_4>:
}
84201f2a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201f2c:	d8 4c       	rts;

84201f2e <$_aud_cur_get_sched_info>:

bool aud_cur_get_sched_info(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *response_id,
                            void **response_data)
{
84201f2e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201f30:	16 00       	r4 = r0 + Null;
84201f32:	1a 09       	r8 = r1 + Null;
84201f34:	20 09       	r6 = r2 + Null;
84201f36:	2f 00       	r5 = r3 + Null;
84201f38:	ef fd f4 ff 	call (m) 0x934;
84201f3c:	3d ef 
84201f3e:	11 09       	r7 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84201f40:	44 08       	r2 = r6 + Null;
84201f42:	53 08       	r1 = r8 + Null;
84201f44:	32 00       	r0 = r4 + Null;
84201f46:	ef fd f4 ff 	call (m) 0x7f6;
84201f4a:	31 e5 
    if (resp == NULL)
84201f4c:	10 04       	Null = r0 - Null;
84201f4e:	09 62       	if NE jump (m) Lc_aud_cur_get_sched_info_3;

84201f50 <Lc_aud_cur_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED,
                                             response_data);
84201f50:	03 f0 00 60 	r1 = Null + 4096;
84201f54:	3c 00       	r2 = r5 + Null;
84201f56:	32 00       	r0 = r4 + Null;
84201f58:	ef fd f4 ff 	call (m) 0x8c0;
84201f5c:	29 eb 
84201f5e:	06 6e       	jump (m) Lc_aud_cur_get_sched_info_4;

84201f60 <Lc_aud_cur_get_sched_info_3>:
    }

    *response_data = resp;
84201f60:	3a ee       	M[r5 + Null] = r0;
    resp->block_size = p_class_data->block_size;
84201f62:	91 f0 09 88 	rMAC = M[r7 + 36];
84201f66:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84201f68:	42 20       	r0 = Null + 1;

84201f6a <Lc_aud_cur_get_sched_info_4>:
}
84201f6a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201f6c:	d8 4c       	rts;

84201f6e <$_aud_cur_set_callbacks>:
                           AUD_CUR_START_FN start_fn,
                           AUD_CUR_STOP_FN stop_fn,
                           AUD_CUR_CONNECT_FN connect_fn,
                           AUD_CUR_DISCONNECT_FN disconnect_fn,
                           AUD_CUR_PARAM_UPDATE_FN param_update_fn)
{
84201f6e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201f70:	1e 00       	r4 = r1 + Null;
84201f72:	27 00       	r5 = r2 + Null;
84201f74:	28 09       	r6 = r3 + Null;
84201f76:	ef fd f4 ff 	call (m) 0x934;
84201f7a:	3f ed 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->start_fn = start_fn;
84201f7c:	16 ae       	M[r0 + 64] = r4;
    p_class_data->stop_fn = stop_fn;
84201f7e:	57 ae       	M[r0 + 68] = r5;
    p_class_data->connect_fn = connect_fn;
84201f80:	28 f0 12 8e 	M[r0 + 72] = r6;
    p_class_data->disconnect_fn = disconnect_fn;
84201f84:	f9 d9       	rMAC = M[FP + -4];
84201f86:	d1 ae       	M[r0 + 76] = rMAC;
    p_class_data->param_update_fn = param_update_fn;
84201f88:	f1 d9       	rMAC = M[FP + -8];
84201f8a:	11 af       	M[r0 + 80] = rMAC;

84201f8c <Lc_aud_cur_set_callbacks_2>:

    return;
84201f8c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201f8e:	d8 4c       	rts;

84201f90 <$_aud_cur_set_flags>:

void aud_cur_set_flags(OPERATOR_DATA *op_data,
                       bool in_place,
                       bool supports_metadata,
                       bool dynamic_buffer_size)
{
84201f90:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201f92:	1e 00       	r4 = r1 + Null;
84201f94:	27 00       	r5 = r2 + Null;
84201f96:	28 09       	r6 = r3 + Null;
84201f98:	ef fd f4 ff 	call (m) 0x934;
84201f9c:	3d ec 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    p_class_data->in_place_flag = in_place;
84201f9e:	56 8a       	MB[r0 + 1] = r4;
    p_class_data->supports_metadata_flag = supports_metadata;
84201fa0:	97 8a       	MB[r0 + 2] = r5;
    p_class_data->dynamic_buffer_size_flag = dynamic_buffer_size;
84201fa2:	28 f0 03 8a 	MB[r0 + 3] = r6;

84201fa6 <Lc_aud_cur_set_flags_2>:

    return;
84201fa6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201fa8:	d8 4c       	rts;

84201faa <$_aud_cur_get_cps>:

    return;
}

CPS_PARAM_DEF *aud_cur_get_cps(OPERATOR_DATA *op_data)
{
84201faa:	c8 1c       	pushm <FP(=SP), rLink>;
84201fac:	ef fd f4 ff 	call (m) 0x934;
84201fb0:	29 ec 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return &p_class_data->param_def;
84201fb2:	12 32       	r0 = r0 + 40;

84201fb4 <Lc_aud_cur_get_cps_2>:
}
84201fb4:	c8 48       	popm <FP, rLink>;
84201fb6:	d8 4c       	rts;

84201fb8 <$_aud_cur_set_buffer_size>:

    return;
}

void aud_cur_set_buffer_size(OPERATOR_DATA *op_data, unsigned buffer_size)
{
84201fb8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201fba:	1e 00       	r4 = r1 + Null;
84201fbc:	ef fd f4 ff 	call (m) 0x934;
84201fc0:	39 eb 
   AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
   p_class_data->buffer_size  = buffer_size;
84201fc2:	16 9e       	M[r0 + 32] = r4;

84201fc4 <Lc_aud_cur_set_buffer_size_2>:
}
84201fc4:	f1 48       	popm <FP, r4, rLink>;
84201fc6:	d8 4c       	rts;

84201fc8 <$_aud_cur_set_block_size>:

void aud_cur_set_block_size(OPERATOR_DATA *op_data, unsigned block_size)
{
84201fc8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201fca:	1e 00       	r4 = r1 + Null;
84201fcc:	ef fd f4 ff 	call (m) 0x934;
84201fd0:	29 eb 
   AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
   p_class_data->block_size  = block_size;
84201fd2:	56 9e       	M[r0 + 36] = r4;

84201fd4 <Lc_aud_cur_set_block_size_2>:
}
84201fd4:	f1 48       	popm <FP, r4, rLink>;
84201fd6:	d8 4c       	rts;

84201fd8 <$_aud_cur_get_source_terminal>:

    return TRUE;
}

tCbuffer *aud_cur_get_source_terminal(OPERATOR_DATA *op_data, uint16 id)
{
84201fd8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201fda:	1e 00       	r4 = r1 + Null;
84201fdc:	ef fd f4 ff 	call (m) 0x934;
84201fe0:	39 ea 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return aud_cur_get_terminal(&p_class_data->sources, id);
84201fe2:	11 29       	rMAC = r0 + 20;
 * \return - pointer to the terminal cbuffer
 */
static inline tCbuffer *aud_cur_get_terminal(AUD_CUR_TERMINAL *p_def,
                                             uint16 num)
{
    return p_def->p_buffer_list[num];
84201fe4:	89 88       	rMAC = M[rMAC + 8];
84201fe6:	72 54       	r0 = r4 LSHIFT 2;
84201fe8:	8a e8       	r0 = M[rMAC + r0];

84201fea <Lc_aud_cur_get_source_terminal_2>:
}

tCbuffer *aud_cur_get_source_terminal(OPERATOR_DATA *op_data, uint16 id)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return aud_cur_get_terminal(&p_class_data->sources, id);
84201fea:	f1 48       	popm <FP, r4, rLink>;
84201fec:	d8 4c       	rts;

84201fee <$_aud_cur_get_sink_terminal>:
}

tCbuffer *aud_cur_get_sink_terminal(OPERATOR_DATA *op_data, uint16 id)
{
84201fee:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201ff0:	1e 00       	r4 = r1 + Null;
84201ff2:	ef fd f4 ff 	call (m) 0x934;
84201ff6:	23 ea 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return aud_cur_get_terminal(&p_class_data->sinks, id);
84201ff8:	11 22       	rMAC = r0 + 8;
 * \return - pointer to the terminal cbuffer
 */
static inline tCbuffer *aud_cur_get_terminal(AUD_CUR_TERMINAL *p_def,
                                             uint16 num)
{
    return p_def->p_buffer_list[num];
84201ffa:	89 88       	rMAC = M[rMAC + 8];
84201ffc:	72 54       	r0 = r4 LSHIFT 2;
84201ffe:	8a e8       	r0 = M[rMAC + r0];

84202000 <Lc_aud_cur_get_sink_terminal_2>:
}

tCbuffer *aud_cur_get_sink_terminal(OPERATOR_DATA *op_data, uint16 id)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return aud_cur_get_terminal(&p_class_data->sinks, id);
84202000:	f1 48       	popm <FP, r4, rLink>;
84202002:	d8 4c       	rts;

84202004 <$_aud_cur_opmsg_get_params>:

bool aud_cur_opmsg_get_params(OPERATOR_DATA *op_data,
                              void *message_data,
                              unsigned *resp_length,
                              OP_OPMSG_RSP_PAYLOAD **response_data)
{
84202004:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84202006:	1f 00       	r5 = r1 + Null;
84202008:	26 00       	r4 = r2 + Null;
8420200a:	28 09       	r6 = r3 + Null;
8420200c:	ef fd f4 ff 	call (m) 0x934;
84202010:	29 e9 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetParameterMsgHandler(&p_class_data->param_def, message_data,
                                     resp_length, response_data);
84202012:	12 32       	r0 = r0 + 40;
84202014:	45 08       	r3 = r6 + Null;
84202016:	34 00       	r2 = r4 + Null;
84202018:	3b 00       	r1 = r5 + Null;
8420201a:	ef fd f5 ff 	call (m) 0xb7c;
8420201e:	23 eb 

84202020 <Lc_aud_cur_opmsg_get_params_2>:
}
84202020:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202022:	d8 4c       	rts;

84202024 <$_aud_cur_opmsg_get_defaults>:

bool aud_cur_opmsg_get_defaults(OPERATOR_DATA *op_data,
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **response_data)
{
84202024:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84202026:	1f 00       	r5 = r1 + Null;
84202028:	26 00       	r4 = r2 + Null;
8420202a:	28 09       	r6 = r3 + Null;
8420202c:	ef fd f4 ff 	call (m) 0x934;
84202030:	29 e8 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetDefaultsMsgHandler(&p_class_data->param_def, message_data,
                                    resp_length, response_data);
84202032:	12 32       	r0 = r0 + 40;
84202034:	45 08       	r3 = r6 + Null;
84202036:	34 00       	r2 = r4 + Null;
84202038:	3b 00       	r1 = r5 + Null;
8420203a:	ef fd f5 ff 	call (m) 0xc2c;
8420203e:	33 ef 

84202040 <Lc_aud_cur_opmsg_get_defaults_2>:
}
84202040:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202042:	d8 4c       	rts;

84202044 <$_aud_cur_opmsg_set_params>:

bool aud_cur_opmsg_set_params(OPERATOR_DATA *op_data,
                              void *message_data,
                              unsigned *resp_length,
                              OP_OPMSG_RSP_PAYLOAD **response_data)
{
84202044:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202046:	11 09       	r7 = r0 + Null;
84202048:	1a 09       	r8 = r1 + Null;
8420204a:	27 00       	r5 = r2 + Null;
8420204c:	28 09       	r6 = r3 + Null;
8420204e:	ef fd f4 ff 	call (m) 0x934;
84202052:	27 e7 
84202054:	16 00       	r4 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    bool success;

    success = cpsSetParameterMsgHandler(&p_class_data->param_def, message_data,
                                        resp_length, response_data);
84202056:	32 32       	r0 = r4 + 40;
84202058:	45 08       	r3 = r6 + Null;
8420205a:	3c 00       	r2 = r5 + Null;
8420205c:	53 08       	r1 = r8 + Null;
8420205e:	ef fd f6 ff 	call (m) 0xd00;
84202062:	23 e5 
84202064:	17 00       	r5 = r0 + Null;

    if (success)
84202066:	07 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_params_5;

84202068 <Lc_aud_cur_opmsg_set_params_2>:
    {
        if (p_class_data->param_update_fn != NULL)
84202068:	31 a9       	rMAC = M[r4 + 80];
8420206a:	03 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_params_4;

8420206c <Lc_aud_cur_opmsg_set_params_3>:
        {
            p_class_data->param_update_fn(op_data);
8420206c:	4a 08       	r0 = r7 + Null;
8420206e:	d1 4c       	call rMAC;

84202070 <Lc_aud_cur_opmsg_set_params_4>:
        }
        /* Set re-initialization flag */
        p_class_data->re_init_flag = TRUE;
84202070:	41 20       	rMAC = Null + 1;
84202072:	31 ea       	MB[r4 + Null] = rMAC;

84202074 <Lc_aud_cur_opmsg_set_params_5>:
    }

    return success;
84202074:	3a 00       	r0 = r5 + Null;

84202076 <Lc_aud_cur_opmsg_set_params_6>:
}
84202076:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84202078:	d8 4c       	rts;

8420207a <$_aud_cur_ups_params>:
                        PERSISTENCE_RANK rank,
                        uint16 length,
                        unsigned* data,
                        STATUS_KYMERA status,
                        uint16 extra_status_info)
{
8420207a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420207c:	10 09       	r6 = r0 + Null;
8420207e:	2f 00       	r5 = r3 + Null;
84202080:	ef fd f4 ff 	call (m) 0x934;
84202084:	35 e5 
84202086:	16 00       	r4 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*)instance_data;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    cpsSetParameterFromPsStore(&p_class_data->param_def, length, data, status);
84202088:	e5 d5       	r3 = MHS[FP + -8];
8420208a:	fc d9       	r2 = M[FP + -4];
8420208c:	32 32       	r0 = r4 + 40;
8420208e:	3b 00       	r1 = r5 + Null;
84202090:	ef fd f6 ff 	call (m) 0xdf6;
84202094:	27 eb 

    if (p_class_data->param_update_fn != NULL)
84202096:	31 a9       	rMAC = M[r4 + 80];
84202098:	03 60       	if EQ jump (m) Lc_aud_cur_ups_params_3;

8420209a <Lc_aud_cur_ups_params_2>:
    {
        p_class_data->param_update_fn(op_data);
8420209a:	42 08       	r0 = r6 + Null;
8420209c:	d1 4c       	call rMAC;

8420209e <Lc_aud_cur_ups_params_3>:
    }

    /* Set the re-init flag after the parameters are updated. */
    p_class_data->re_init_flag = TRUE;
8420209e:	41 20       	rMAC = Null + 1;
842020a0:	31 ea       	MB[r4 + Null] = rMAC;

    return TRUE;
842020a2:	0a 00       	r0 = rMAC + Null;

842020a4 <Lc_aud_cur_ups_params_4>:
}
842020a4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842020a6:	d8 4c       	rts;

842020a8 <$_aud_cur_opmsg_set_ucid>:

bool aud_cur_opmsg_set_ucid(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *resp_length,
                            OP_OPMSG_RSP_PAYLOAD **response_data)
{
842020a8:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842020aa:	12 09       	r8 = r0 + Null;
842020ac:	19 09       	r7 = r1 + Null;
842020ae:	27 00       	r5 = r2 + Null;
842020b0:	28 09       	r6 = r3 + Null;
842020b2:	ef fd f4 ff 	call (m) 0x934;
842020b6:	23 e4 
842020b8:	16 00       	r4 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    PS_KEY_TYPE key;
    bool success;

    success = cpsSetUcidMsgHandler(&p_class_data->param_def, message_data,
                                  resp_length, response_data);
842020ba:	32 32       	r0 = r4 + 40;
842020bc:	45 08       	r3 = r6 + Null;
842020be:	3c 00       	r2 = r5 + Null;
842020c0:	4b 08       	r1 = r7 + Null;
842020c2:	ef fd f6 ff 	call (m) 0xd92;
842020c6:	31 e6 
842020c8:	17 00       	r5 = r0 + Null;
    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(p_class_data->cap_id,
                                         p_class_data->param_def.ucid,
                                         OPMSG_P_STORE_PARAMETER_SUB_ID);
842020ca:	f1 99       	rMAC = M[r4 + 60];
842020cc:	8a c6       	r0 = rMAC AND 0xffff;
842020ce:	92 55       	r0 = r0 LSHIFT 7;
842020d0:	b1 99       	rMAC = M[r4 + 56];
842020d2:	8b c2       	r1 = rMAC AND 0x3f;
842020d4:	1b 54       	r1 = r1 LSHIFT 1;
842020d6:	9b 12       	r1 = r1 OR r0;

    ps_entry_read((void*)op_data, key, PERSIST_ANY, aud_cur_ups_params);
842020d8:	42 f0 15 f0 	r3 = Null + 69214331;
842020dc:	7b 40 
842020de:	04 00       	r2 = Null + Null;
842020e0:	52 08       	r0 = r8 + Null;
842020e2:	ff fd 31 f0 	call (m) 0x8370;
842020e6:	2f e4 

    return success;
842020e8:	3a 00       	r0 = r5 + Null;

842020ea <Lc_aud_cur_opmsg_set_ucid_2>:
}
842020ea:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842020ec:	d8 4c       	rts;

842020ee <$_aud_cur_opmsg_get_ps_id>:

bool aud_cur_opmsg_get_ps_id(OPERATOR_DATA *op_data,
                             void *message_data,
                             unsigned *resp_length,
                             OP_OPMSG_RSP_PAYLOAD **response_data)
{
842020ee:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842020f0:	1f 00       	r5 = r1 + Null;
842020f2:	26 00       	r4 = r2 + Null;
842020f4:	28 09       	r6 = r3 + Null;
842020f6:	ef fd f4 ff 	call (m) 0x934;
842020fa:	3f e1 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetUcidMsgHandler(&p_class_data->param_def, p_class_data->cap_id,
                                message_data, resp_length, response_data);
842020fc:	10 1c       	pushm <r6>;
842020fe:	d3 99       	r1 = M[r0 + 60];
84202100:	35 00       	r3 = r4 + Null;
84202102:	12 32       	r0 = r0 + 40;
84202104:	3c 00       	r2 = r5 + Null;
84202106:	ef fd f6 ff 	call (m) 0xdb4;
8420210a:	2f e5 
8420210c:	7f 4c       	SP = SP + -4;

8420210e <Lc_aud_cur_opmsg_get_ps_id_2>:
}
8420210e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202110:	d8 4c       	rts;

84202112 <$_aud_cur_calc_samples>:
/****************************************************************************
Process Data
*/

unsigned aud_cur_calc_samples(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84202112:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84202114:	43 de       	M[FP + 32] = r1;
84202116:	ef fd f4 ff 	call (m) 0x934;
8420211a:	3f e0 
8420211c:	16 00       	r4 = r0 + Null;

    unsigned min_data, min_space, block_size, amount, i, samples;
    tCbuffer **p_inputs, **p_outputs;

    /* If no input terminal connections then do nothing */
    if (p_class_data->sinks.connected == 0)
8420211e:	f1 87       	rMAC = MHU[r4 + 14];
84202120:	03 62       	if NE jump (m) Lc_aud_cur_calc_samples_3;

84202122 <Lc_aud_cur_calc_samples_2>:
    {
        return 0;
84202122:	02 00       	r0 = Null + Null;
84202124:	4b 6e       	jump (m) Lc_aud_cur_calc_samples_23;

84202126 <Lc_aud_cur_calc_samples_3>:
    }

    /* Initialize data */
    block_size = p_class_data->block_size;
84202126:	6b f0 09 88 	r9 = M[r4 + 36];

    /* Find the minimum amount of data available in the input buffers */
    min_data = UINT_MAX;
8420212a:	0a f0 01 24 	r8 = Null - 1;
    p_inputs = p_class_data->sinks.p_buffer_list;
8420212e:	68 f0 04 88 	r6 = M[r4 + 16];

    for (i = 0; i < p_class_data->sinks.max; i++)
84202132:	07 00       	r5 = Null + Null;

84202134 <Lc_aud_cur_calc_samples_4>:
84202134:	31 87       	rMAC = MHU[r4 + 8];
84202136:	78 04       	Null = r5 - rMAC;
84202138:	02 f0 a7 e0 	if C jump (m) Lc_aud_cur_calc_samples_10;

8420213c <Lc_aud_cur_calc_samples_5>:
    {
        if (p_inputs[i] != NULL)
8420213c:	82 f0 00 e8 	r0 = M[r6 + Null];
84202140:	0c 60       	if EQ jump (m) Lc_aud_cur_calc_samples_9;

84202142 <Lc_aud_cur_calc_samples_6>:
        {
            amount = cbuffer_calc_amount_data_in_words(p_inputs[i]);
84202142:	ff fd 5d f2 	call (m) 0x4db5a;
84202146:	39 e0 
            if (amount < min_data)
84202148:	af f2 00 c2 	Null = r0 - r8;
8420214c:	02 f0 8d e0 	if C jump (m) Lc_aud_cur_calc_samples_9;

84202150 <Lc_aud_cur_calc_samples_7>:
            {
                /* Need at least one block of data available */
                if (amount < block_size)
84202150:	bf f2 00 c2 	Null = r0 - r9;
84202154:	e7 65       	if NC jump (m) Lc_aud_cur_calc_samples_2;

84202156 <Lc_aud_cur_calc_samples_8>:
                {
                    return 0;
                }
                min_data = amount;
84202156:	12 09       	r8 = r0 + Null;

84202158 <Lc_aud_cur_calc_samples_9>:

    /* Find the minimum amount of data available in the input buffers */
    min_data = UINT_MAX;
    p_inputs = p_class_data->sinks.p_buffer_list;

    for (i = 0; i < p_class_data->sinks.max; i++)
84202158:	7f 20       	r5 = r5 + 1;
8420215a:	20 75       	r6 = r6 + 4;
8420215c:	ec 6f       	jump (m) Lc_aud_cur_calc_samples_4;

8420215e <Lc_aud_cur_calc_samples_10>:
            }
        }
    }

    /* Find the minimum amount of space available at the output buffers */
    min_space = UINT_MAX;
8420215e:	47 24       	r5 = Null - 1;
    p_outputs = p_class_data->sources.p_buffer_list;
84202160:	69 f0 07 88 	r7 = M[r4 + 28];

    if (p_class_data->sources.connected > 0)
84202164:	71 97       	rMAC = MHU[r4 + 26];
84202166:	17 60       	if EQ jump (m) Lc_aud_cur_calc_samples_18;

84202168 <Lc_aud_cur_calc_samples_11>:
    {
        for (i = 0; i < p_class_data->sources.max; i++)
84202168:	00 09       	r6 = Null + Null;

8420216a <Lc_aud_cur_calc_samples_12>:
8420216a:	b1 96       	rMAC = MHU[r4 + 20];
8420216c:	1f f8 00 c2 	Null = r6 - rMAC;
84202170:	02 f0 a5 e0 	if C jump (m) Lc_aud_cur_calc_samples_18;

84202174 <Lc_aud_cur_calc_samples_13>:
        {
            if (p_outputs[i] != NULL)
84202174:	92 f0 00 e8 	r0 = M[r7 + Null];
84202178:	0b 60       	if EQ jump (m) Lc_aud_cur_calc_samples_17;

8420217a <Lc_aud_cur_calc_samples_14>:
            {
                amount = cbuffer_calc_amount_space_in_words(p_outputs[i]);
8420217a:	ff fd 5c f2 	call (m) 0x4db14;
8420217e:	3b ec 
                if (amount < min_space)
84202180:	d0 05       	Null = r0 - r5;
84202182:	02 f0 8d e0 	if C jump (m) Lc_aud_cur_calc_samples_17;

84202186 <Lc_aud_cur_calc_samples_15>:
                {
                    /* Need at least one block of space available */
                    if (amount < block_size)
84202186:	bf f2 00 c2 	Null = r0 - r9;
8420218a:	cc 65       	if NC jump (m) Lc_aud_cur_calc_samples_2;

8420218c <Lc_aud_cur_calc_samples_16>:
                    {
                        return 0;
                    }
                    min_space = amount;
8420218c:	17 00       	r5 = r0 + Null;

8420218e <Lc_aud_cur_calc_samples_17>:
    min_space = UINT_MAX;
    p_outputs = p_class_data->sources.p_buffer_list;

    if (p_class_data->sources.connected > 0)
    {
        for (i = 0; i < p_class_data->sources.max; i++)
8420218e:	08 75       	r6 = r6 + 1;
84202190:	21 75       	r7 = r7 + 4;
84202192:	ec 6f       	jump (m) Lc_aud_cur_calc_samples_12;

84202194 <Lc_aud_cur_calc_samples_18>:
            }
        }
    }

    /* Update kick flags */
    touched->sources = p_class_data->sources.connected;
84202194:	71 97       	rMAC = MHU[r4 + 26];
84202196:	42 d8       	r0 = M[FP + 32];
84202198:	11 ee       	M[r0 + Null] = rMAC;

    /* Samples to process is the smaller of data or space available */
    if (min_data < min_space)
8420219a:	7f fa 00 c2 	Null = r8 - r5;
8420219e:	02 f0 89 e0 	if C jump (m) Lc_aud_cur_calc_samples_20;

842021a2 <Lc_aud_cur_calc_samples_19>:
    {
        samples = min_data;
842021a2:	52 08       	r0 = r8 + Null;
842021a4:	02 6e       	jump (m) Lc_aud_cur_calc_samples_21;

842021a6 <Lc_aud_cur_calc_samples_20>:
    }
    else
    {
        samples = min_space;
842021a6:	3a 00       	r0 = r5 + Null;

842021a8 <Lc_aud_cur_calc_samples_21>:
    }

    /* If there is less than a block left then kick backwards */
    if (min_data - samples < block_size)
842021a8:	2f fa 01 c2 	rMAC = r8 - r0;
842021ac:	bf f1 00 c2 	Null = rMAC - r9;
842021b0:	02 f0 8b e0 	if C jump (m) Lc_aud_cur_calc_samples_23;

842021b4 <Lc_aud_cur_calc_samples_22>:
    {
        touched->sinks = p_class_data->sinks.connected;
842021b4:	f1 87       	rMAC = MHU[r4 + 14];
842021b6:	43 d8       	r1 = M[FP + 32];
842021b8:	59 8e       	M[r1 + 4] = rMAC;

842021ba <Lc_aud_cur_calc_samples_23>:
    }

    return samples;
842021ba:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842021bc:	d8 4c       	rts;

842021be <$_aud_cur_mic_data_transfer>:
}

unsigned aud_cur_mic_data_transfer(OPERATOR_DATA *op_data,
                                   unsigned amount,
                                   unsigned terminal_skip_mask)
{
842021be:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842021c0:	1a 09       	r8 = r1 + Null;
842021c2:	44 de       	M[FP + 32] = r2;
842021c4:	ef fd f3 ff 	call (m) 0x934;
842021c8:	31 eb 
842021ca:	4a de       	M[FP + 36] = r0;
842021cc:	11 00       	rMAC = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    unsigned i, mic_amt, temp_amt;
    tCbuffer **ip_buffers, **op_buffers;

    ip_buffers = p_class_data->sinks.p_buffer_list;
842021ce:	09 89       	rMAC = M[rMAC + 16];
    op_buffers = p_class_data->sources.p_buffer_list;
842021d0:	d2 89       	r0 = M[r0 + 28];

    /* Copy mic stream data */
    mic_amt = amount;
842021d2:	53 09       	r9 = r8 + Null;

    for (i = 1; i < p_class_data->sinks.max; i++)
842021d4:	46 20       	r4 = Null + 1;
842021d6:	18 f0 04 20 	r6 = rMAC + 4;
842021da:	17 21       	r5 = r0 + 4;
842021dc:	0d 6e       	jump (m) Lc_aud_cur_mic_data_transfer_6;

842021de <Lc_aud_cur_mic_data_transfer_2>:
                                            ip_buffers[i],
                                            amount);
                }
                else
                {
                    cbuffer_advance_read_ptr(ip_buffers[i], amount);
842021de:	53 08       	r1 = r8 + Null;
842021e0:	ff fd 5c f2 	call (m) 0x4db68;
842021e4:	29 ec 

842021e6 <Lc_aud_cur_mic_data_transfer_3>:
                }
                if (temp_amt < mic_amt)
842021e6:	bf f9 00 c2 	Null = r7 - r9;
842021ea:	02 f0 87 e0 	if C jump (m) Lc_aud_cur_mic_data_transfer_5;

842021ee <Lc_aud_cur_mic_data_transfer_4>:
                {
                    mic_amt = temp_amt;
842021ee:	4b 09       	r9 = r7 + Null;

842021f0 <Lc_aud_cur_mic_data_transfer_5>:
    op_buffers = p_class_data->sources.p_buffer_list;

    /* Copy mic stream data */
    mic_amt = amount;

    for (i = 1; i < p_class_data->sinks.max; i++)
842021f0:	76 20       	r4 = r4 + 1;
842021f2:	20 75       	r6 = r6 + 4;
842021f4:	3f 21       	r5 = r5 + 4;

842021f6 <Lc_aud_cur_mic_data_transfer_6>:
842021f6:	49 d8       	rMAC = M[FP + 36];
842021f8:	09 87       	rMAC = MHU[rMAC + 8];
842021fa:	70 04       	Null = r4 - rMAC;
842021fc:	02 f0 ad e0 	if C jump (m) Lc_aud_cur_mic_data_transfer_11;

84202200 <Lc_aud_cur_mic_data_transfer_7>:
    {
        if(!(AUD_CUR_GET_TERMINAL_POS(i) & terminal_skip_mask))
84202200:	31 00       	rMAC = r4 + Null;
84202202:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84202206:	41 d8       	rMAC = M[FP + 32];
84202208:	89 10       	rMAC = rMAC AND r0;
8420220a:	f3 63       	if NE jump (m) Lc_aud_cur_mic_data_transfer_5;

8420220c <Lc_aud_cur_mic_data_transfer_8>:
        {
            /* Perform copy/advance if terminal number (i) is not in
             * terminal_skip_mask
             */
            temp_amt = amount;
8420220c:	51 09       	r7 = r8 + Null;
            if (ip_buffers[i] != NULL)
8420220e:	82 f0 00 e8 	r0 = M[r6 + Null];
84202212:	ef 61       	if EQ jump (m) Lc_aud_cur_mic_data_transfer_5;

84202214 <Lc_aud_cur_mic_data_transfer_9>:
            {
                if (op_buffers[i] != NULL)
84202214:	39 e8       	rMAC = M[r5 + Null];
84202216:	e4 61       	if EQ jump (m) Lc_aud_cur_mic_data_transfer_2;

84202218 <Lc_aud_cur_mic_data_transfer_10>:
                {
                    temp_amt = cbuffer_copy(op_buffers[i],
                                            ip_buffers[i],
                                            amount);
84202218:	54 08       	r2 = r8 + Null;
8420221a:	13 00       	r1 = r0 + Null;
8420221c:	0a 00       	r0 = rMAC + Null;
8420221e:	ff fd 5d f2 	call (m) 0x4dda4;
84202222:	27 ec 
84202224:	11 09       	r7 = r0 + Null;
84202226:	e0 6f       	jump (m) Lc_aud_cur_mic_data_transfer_3;

84202228 <Lc_aud_cur_mic_data_transfer_11>:
                }
            }
        }
    }

    return mic_amt;
84202228:	5a 08       	r0 = r9 + Null;

8420222a <Lc_aud_cur_mic_data_transfer_12>:

}
8420222a:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420222c:	d8 4c       	rts;

8420222e <$_aud_cur_mic_metadata_transfer>:

unsigned aud_cur_mic_metadata_transfer(OPERATOR_DATA *op_data, unsigned amount)
{
8420222e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202230:	1e 00       	r4 = r1 + Null;
84202232:	ef fd f3 ff 	call (m) 0x934;
84202236:	23 e8 
84202238:	11 00       	rMAC = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    tCbuffer *p_metadata_ip, *p_metadata_op;
    /* Only copy metadata if samples were transferred */
    if (amount > 0)
8420223a:	30 04       	Null = r4 - Null;
8420223c:	07 60       	if EQ jump (m) Lc_aud_cur_mic_metadata_transfer_3;

8420223e <Lc_aud_cur_mic_metadata_transfer_2>:
    {
        p_metadata_ip = p_class_data->metadata_ip[AUD_CUR_METADATA_MIC];
8420223e:	8a a9       	r0 = M[rMAC + 88];
        p_metadata_op = p_class_data->metadata_op[AUD_CUR_METADATA_MIC];
84202240:	0b b8       	r1 = M[rMAC + 96];

        metadata_strict_transport(p_metadata_ip,
                                  p_metadata_op,
                                  amount * OCTETS_PER_SAMPLE);
84202242:	74 54       	r2 = r4 LSHIFT 2;
84202244:	ff fd 94 f0 	call (m) 0x14af0;
84202248:	2d e5 

8420224a <Lc_aud_cur_mic_metadata_transfer_3>:
    }
    return amount;
8420224a:	32 00       	r0 = r4 + Null;

8420224c <Lc_aud_cur_mic_metadata_transfer_4>:
}
8420224c:	f1 48       	popm <FP, r4, rLink>;
8420224e:	d8 4c       	rts;

84202250 <$_aud_cur_playback_data_transfer>:

unsigned aud_cur_playback_data_transfer(OPERATOR_DATA *op_data, unsigned amount)
{
84202250:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202252:	1e 00       	r4 = r1 + Null;
84202254:	ef fd f3 ff 	call (m) 0x934;
84202258:	21 e7 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    unsigned playback_amt;

    tCbuffer **ip_buffers, **op_buffers;

    ip_buffers = p_class_data->sinks.p_buffer_list;
8420225a:	11 89       	rMAC = M[r0 + 16];
    op_buffers = p_class_data->sources.p_buffer_list;
8420225c:	d3 89       	r1 = M[r0 + 28];

    playback_amt = amount;
8420225e:	37 00       	r5 = r4 + Null;

    /* Copy playback data. If there is no playback input then no data is
     * copied.
     */
    if (ip_buffers[AUD_CUR_PLAYBACK_TERMINAL] == NULL)
84202260:	0a e8       	r0 = M[rMAC + Null];
84202262:	03 62       	if NE jump (m) Lc_aud_cur_playback_data_transfer_3;

84202264 <Lc_aud_cur_playback_data_transfer_2>:
    {
        playback_amt = 0;
84202264:	07 00       	r5 = Null + Null;
84202266:	0f 6e       	jump (m) Lc_aud_cur_playback_data_transfer_6;

84202268 <Lc_aud_cur_playback_data_transfer_3>:
    }
    else
    {
        if (op_buffers[AUD_CUR_PLAYBACK_TERMINAL] != NULL)
84202268:	19 e8       	rMAC = M[r1 + Null];
8420226a:	09 60       	if EQ jump (m) Lc_aud_cur_playback_data_transfer_5;

8420226c <Lc_aud_cur_playback_data_transfer_4>:
        {
            playback_amt = cbuffer_copy(op_buffers[AUD_CUR_PLAYBACK_TERMINAL],
                                        ip_buffers[AUD_CUR_PLAYBACK_TERMINAL],
                                        amount);
8420226c:	34 00       	r2 = r4 + Null;
8420226e:	13 00       	r1 = r0 + Null;
84202270:	0a 00       	r0 = rMAC + Null;
84202272:	ff fd 5d f2 	call (m) 0x4dda4;
84202276:	33 e9 
84202278:	17 00       	r5 = r0 + Null;
8420227a:	05 6e       	jump (m) Lc_aud_cur_playback_data_transfer_6;

8420227c <Lc_aud_cur_playback_data_transfer_5>:
        }
        else
        {
            cbuffer_advance_read_ptr(ip_buffers[AUD_CUR_PLAYBACK_TERMINAL],
                                     amount);
8420227c:	33 00       	r1 = r4 + Null;
8420227e:	ff fd 5c f2 	call (m) 0x4db68;
84202282:	2b e7 

84202284 <Lc_aud_cur_playback_data_transfer_6>:
        }
    }

    return playback_amt;
84202284:	3a 00       	r0 = r5 + Null;

84202286 <Lc_aud_cur_playback_data_transfer_7>:
}
84202286:	f2 48       	popm <FP, r4, r5, rLink>;
84202288:	d8 4c       	rts;

8420228a <$_aud_cur_playback_metadata_transfer>:

unsigned aud_cur_playback_metadata_transfer(OPERATOR_DATA *op_data,
                                            unsigned amount)
{
8420228a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420228c:	1e 00       	r4 = r1 + Null;
8420228e:	ef fd f3 ff 	call (m) 0x934;
84202292:	27 e5 
84202294:	11 00       	rMAC = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    tCbuffer *p_metadata_ip, *p_metadata_op;
    /* Only copy metadata if samples were transferred */
    if (amount > 0)
84202296:	30 04       	Null = r4 - Null;
84202298:	07 60       	if EQ jump (m) Lc_aud_cur_playback_metadata_transfer_3;

8420229a <Lc_aud_cur_playback_metadata_transfer_2>:
    {
        p_metadata_ip = p_class_data->metadata_ip[AUD_CUR_METADATA_PLAYBACK];
8420229a:	4a a9       	r0 = M[rMAC + 84];
        p_metadata_op = p_class_data->metadata_op[AUD_CUR_METADATA_PLAYBACK];
8420229c:	cb a9       	r1 = M[rMAC + 92];
        metadata_strict_transport(p_metadata_ip,
                                  p_metadata_op,
                                  amount * OCTETS_PER_SAMPLE);
8420229e:	74 54       	r2 = r4 LSHIFT 2;
842022a0:	ff fd 94 f0 	call (m) 0x14af0;
842022a4:	31 e2 

842022a6 <Lc_aud_cur_playback_metadata_transfer_3>:
    }
    return amount;
842022a6:	32 00       	r0 = r4 + Null;

842022a8 <Lc_aud_cur_playback_metadata_transfer_4>:
}
842022a8:	f1 48       	popm <FP, r4, rLink>;
842022aa:	d8 4c       	rts;

842022ac <$_aud_cur_create_cbuffer>:

bool aud_cur_create_cbuffer(tCbuffer **pp_buffer,
                            unsigned size,
                            unsigned malloc_pref)
{
842022ac:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842022ae:	17 00       	r5 = r0 + Null;
842022b0:	1e 00       	r4 = r1 + Null;
842022b2:	23 00       	r1 = r2 + Null;
    /* Allocate buffer memory explicitly */
    int *ptr = xzppnewn(size, int, malloc_pref);
842022b4:	72 54       	r0 = r4 LSHIFT 2;
842022b6:	ff fd 26 f0 	call (m) 0x6f8e;
842022ba:	39 e6 
842022bc:	10 09       	r6 = r0 + Null;

    if (ptr == NULL)
842022be:	0d 60       	if EQ jump (m) Lc_aud_cur_create_cbuffer_4;

842022c0 <Lc_aud_cur_create_cbuffer_2>:
    {
        return FALSE;
    }

    /* Wrap allocated memory in a cbuffer */
    *pp_buffer = cbuffer_create(ptr, size, BUF_DESC_SW_BUFFER);
842022c0:	04 00       	r2 = Null + Null;
842022c2:	33 00       	r1 = r4 + Null;
842022c4:	ff fd 8f f0 	call (m) 0x141c4;
842022c8:	21 e8 
842022ca:	3a ee       	M[r5 + Null] = r0;
    if (*pp_buffer == NULL)
842022cc:	39 e8       	rMAC = M[r5 + Null];
842022ce:	07 62       	if NE jump (m) Lc_aud_cur_create_cbuffer_5;

842022d0 <Lc_aud_cur_create_cbuffer_3>:
    {
        pdelete(ptr);
842022d0:	42 08       	r0 = r6 + Null;
842022d2:	ff fd 26 f0 	call (m) 0x6fbe;
842022d6:	2d e7 

842022d8 <Lc_aud_cur_create_cbuffer_4>:
    /* Allocate buffer memory explicitly */
    int *ptr = xzppnewn(size, int, malloc_pref);

    if (ptr == NULL)
    {
        return FALSE;
842022d8:	02 00       	r0 = Null + Null;
842022da:	02 6e       	jump (m) Lc_aud_cur_create_cbuffer_6;

842022dc <Lc_aud_cur_create_cbuffer_5>:
        ptr = NULL;

        return FALSE;
    }

    return TRUE;
842022dc:	42 20       	r0 = Null + 1;

842022de <Lc_aud_cur_create_cbuffer_6>:
}
842022de:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842022e0:	d8 4c       	rts;

842022e2 <$_aud_cur_release_shared_gain_cback>:
bool aud_cur_release_shared_gain_cback(CONNECTION_LINK con_id,
                                       STATUS_KYMERA status,
                                       EXT_OP_ID op_id,
                                       unsigned num_resp_params,
                                       unsigned *resp_params)
{
842022e2:	c8 1c       	pushm <FP(=SP), rLink>;
    if (status != ACCMD_STATUS_OK)
842022e4:	18 04       	Null = r1 - Null;
842022e6:	09 60       	if EQ jump (m) Lc_aud_cur_release_shared_gain_cback_3;

842022e8 <Lc_aud_cur_release_shared_gain_cback_2>:
    {
        L0_DBG_MSG2("aud_cur unlink response failed: status=%d, op_id=%d",
                    status,
                    op_id);
842022e8:	55 f1 02 f0 	r0 = Null + 357566179;
842022ec:	e3 4a 
842022ee:	ef fd f6 ff 	call (m) 0x10d6;
842022f2:	29 ef 
        return FALSE;
842022f4:	02 00       	r0 = Null + Null;
842022f6:	02 6e       	jump (m) Lc_aud_cur_release_shared_gain_cback_4;

842022f8 <Lc_aud_cur_release_shared_gain_cback_3>:
    }
    return TRUE;
842022f8:	42 20       	r0 = Null + 1;

842022fa <Lc_aud_cur_release_shared_gain_cback_4>:
}
842022fa:	c8 48       	popm <FP, rLink>;
842022fc:	d8 4c       	rts;

842022fe <$_aud_cur_release_shared_fine_gain>:
                                      AHM_ANC_FILTER filter,
                                      AHM_GAIN_CONTROL_TYPE gain_type,
                                      uint16 ahm_op_id,
                                      AHM_ANC_INSTANCE anc_instance
                                      )
{
842022fe:	c8 1e       	pushm <FP(=SP), rLink>, SP = SP + 0x20;
84202300:	29 00       	rMAC = r3 + Null;
    unsigned msg[OPMSG_FREE_AHM_SHARED_GAIN_PTR_WORD_SIZE];
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                             MESSAGE_ID,
                             OPMSG_AHM_ID_FREE_AHM_SHARED_GAIN_PTR);
84202302:	05 28       	r3 = Null + 16;
84202304:	15 de       	M[FP + 8] = r3;
    OPMSG_CREATION_FIELD_SET32(msg,
                               OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                               SHARED_GAIN_PTR,
                               (unsigned)p_gain);
84202306:	95 c6       	r3 = r0 AND 0xffff;
84202308:	1d de       	M[FP + 12] = r3;
8420230a:	92 52       	r0 = r0 LSHIFT -16;
8420230c:	22 de       	M[FP + 16] = r0;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                             FILTER,
                             filter);
8420230e:	2b de       	M[FP + 20] = r1;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                             CHANNEL,
                             anc_instance);
84202310:	e2 d1       	r0 = MBS[FP + -4];
84202312:	42 de       	M[FP + 32] = r0;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                             COARSE,
                             FALSE);
84202314:	30 de       	M[FP + 24] = Null;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                             CONTROL_TYPE,
                             gain_type);
84202316:	3c de       	M[FP + 28] = r2;

    opmgr_operator_message(ADAPTOR_INTERNAL,
                           ahm_op_id,
                           OPMSG_FREE_AHM_SHARED_GAIN_PTR_WORD_SIZE,
                           (unsigned*)&msg,
                           aud_cur_release_shared_gain_cback);
84202318:	42 f0 22 f0 	push Null + 69214947;
8420231c:	53 ee 
8420231e:	85 10       	r3 = FP + 8;
84202320:	c4 21       	r2 = Null + 7;
84202322:	82 2b       	r0 = Null + 30;
84202324:	0b 00       	r1 = rMAC + Null;
84202326:	ff fd 13 f0 	call (m) 0x4aa0;
8420232a:	3b eb 
8420232c:	7f 4c       	SP = SP + -4;

8420232e <Lc_aud_cur_release_shared_fine_gain_2>:
}
8420232e:	c8 4a       	SP = SP - 0x20, popm <FP, rLink>;
84202330:	d8 4c       	rts;

84202332 <$_aud_cur_get_shared_fine_gain>:
                                  AHM_ANC_FILTER filter,
                                  unsigned op_id,
                                  AHM_GAIN_CONTROL_TYPE gain_type,
                                  AHM_ANC_INSTANCE anc_instance,
                                  OP_MSG_CBACK callback)
{
84202332:	c8 1e       	pushm <FP(=SP), rLink>, SP = SP + 0x20;
84202334:	21 00       	rMAC = r2 + Null;
    unsigned msg[OPMSG_COMMON_MSG_GET_SHARED_GAIN_WORD_SIZE];
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                             MESSAGE_ID,
                             OPMSG_COMMON_ID_GET_SHARED_GAIN);
84202336:	14 f0 26 40 	r2 = Null + 8230;
8420233a:	14 de       	M[FP + 8] = r2;
    OPMSG_CREATION_FIELD_SET32(msg,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                               P_EXT_DATA,
                               (unsigned)p_ext_data);
8420233c:	94 c6       	r2 = r0 AND 0xffff;
8420233e:	1c de       	M[FP + 12] = r2;
84202340:	92 52       	r0 = r0 LSHIFT -16;
84202342:	22 de       	M[FP + 16] = r0;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                             FILTER,
                             filter);
84202344:	2b de       	M[FP + 20] = r1;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                             CHANNEL,
                             anc_instance);
84202346:	e2 d1       	r0 = MBS[FP + -4];
84202348:	42 de       	M[FP + 32] = r0;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                             COARSE,
                             FALSE);
8420234a:	30 de       	M[FP + 24] = Null;
    OPMSG_CREATION_FIELD_SET(msg,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                             CONTROL_TYPE,
                             gain_type);
8420234c:	3d de       	M[FP + 28] = r3;
    opmgr_operator_message(ADAPTOR_INTERNAL,
                           op_id,
                           OPMSG_COMMON_MSG_GET_SHARED_GAIN_WORD_SIZE,
                           (unsigned*)&msg,
                           callback);
8420234e:	f2 d9       	r0 = M[FP + -8];
84202350:	11 1c       	pushm <r0>;
84202352:	85 10       	r3 = FP + 8;
84202354:	c4 21       	r2 = Null + 7;
84202356:	82 2b       	r0 = Null + 30;
84202358:	0b 00       	r1 = rMAC + Null;
8420235a:	ff fd 13 f0 	call (m) 0x4aa0;
8420235e:	27 ea 
84202360:	7f 4c       	SP = SP + -4;

84202362 <Lc_aud_cur_get_shared_fine_gain_2>:
}
84202362:	c8 4a       	SP = SP - 0x20, popm <FP, rLink>;
84202364:	d8 4c       	rts;

84202366 <Lc_aud_cur_connect_terminal_1>:
 */
static void aud_cur_connect_terminal(AUD_CUR_TERMINAL *p_def,
                                     uint16 num,
                                     tCbuffer *p_buffer)
{
    p_def->p_buffer_list[num] = p_buffer;
84202366:	91 88       	rMAC = M[r0 + 8];
84202368:	5d 54       	r3 = r1 LSHIFT 2;
8420236a:	4c ef       	M[rMAC + r3] = r2;
    p_def->connected |= (uint16)(1 << num);
8420236c:	00 f3 93 de 	r1 = 0x1 LSHIFT r1;
84202370:	d1 86       	rMAC = MHU[r0 + 6];
84202372:	c9 12       	rMAC = rMAC OR r1;
84202374:	d1 8c       	MH[r0 + 6] = rMAC;

84202376 <Lc_aud_cur_connect_terminal_2>:
    return;
84202376:	d8 4c       	rts;

84202378 <Lc_aud_cur_disconnect_terminal_1>:
 * \return - NONE
 */
static void aud_cur_disconnect_terminal(AUD_CUR_TERMINAL *p_def,
                                        uint16 num)
{
    p_def->p_buffer_list[num] = NULL;
84202378:	91 88       	rMAC = M[r0 + 8];
8420237a:	5c 54       	r2 = r1 LSHIFT 2;
8420237c:	08 ef       	M[rMAC + r2] = Null;
    p_def->connected &= (uint16)(~(1 << num));
8420237e:	00 f3 93 de 	r1 = 0x1 LSHIFT r1;
84202382:	ff f3 51 d6 	rMAC = -1 - r1;
84202386:	d3 86       	r1 = MHU[r0 + 6];
84202388:	c9 10       	rMAC = rMAC AND r1;
8420238a:	d1 8c       	MH[r0 + 6] = rMAC;

8420238c <Lc_aud_cur_disconnect_terminal_2>:
    return;
8420238c:	d8 4c       	rts;

8420238e <Lc_aud_cur_connect_metadata_1>:
    unsigned idx;

    /* Select the correct metadata buffer */
    if (num == AUD_CUR_PLAYBACK_TERMINAL)
    {
        idx = AUD_CUR_METADATA_PLAYBACK;
8420238e:	05 00       	r3 = Null + Null;
84202390:	18 04       	Null = r1 - Null;
84202392:	21 f0 45 ce 	if NE r3 = Null + 1;
    {
        idx = AUD_CUR_METADATA_MIC;
    }

    /* Populate the metadata buffer */
    if (p_metadata_list[idx] == NULL && buff_has_metadata(p_buffer))
84202396:	6b 54       	r1 = r3 LSHIFT 2;
84202398:	9a 00       	r0 = r1 + r0;
8420239a:	11 e8       	rMAC = M[r0 + Null];
8420239c:	04 62       	if NE jump (m) Lc_aud_cur_connect_metadata_4;

8420239e <Lc_aud_cur_connect_metadata_2>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(const tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420239e:	a1 89       	rMAC = M[r2 + 24];
842023a0:	02 60       	if EQ jump (m) Lc_aud_cur_connect_metadata_4;

842023a2 <Lc_aud_cur_connect_metadata_3>:
    {
            p_metadata_list[idx] = p_buffer;
842023a2:	14 ee       	M[r0 + Null] = r2;

842023a4 <Lc_aud_cur_connect_metadata_4>:
842023a4:	d8 4c       	rts;

842023a6 <Lc_aud_cur_disconnect_metadata_1>:
 * \return - None
 */
static void aud_cur_disconnect_metadata(tCbuffer **p_metadata_list,
                                        AUD_CUR_TERMINAL *p_def,
                                        uint16 num)
{
842023a6:	72 1c       	pushm <FP(=SP), r4, r5>;
    int i;
    tCbuffer *p_buffer;
    tCbuffer **p_buffer_list;

    /* Playback metadata only travels on a single terminal */
    if (num == AUD_CUR_PLAYBACK_TERMINAL)
842023a8:	20 04       	Null = r2 - Null;
842023aa:	03 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_3;

842023ac <Lc_aud_cur_disconnect_metadata_2>:
    {
        p_metadata_list[AUD_CUR_METADATA_PLAYBACK] = NULL;
842023ac:	10 ee       	M[r0 + Null] = Null;
842023ae:	17 6e       	jump (m) Lc_aud_cur_disconnect_metadata_11;

842023b0 <Lc_aud_cur_disconnect_metadata_3>:
    }

    /* Look for metadata on another terminal if the terminal being used for
     * metadata is being disconnected.
     */
    p_buffer_list = p_def->p_buffer_list;
842023b0:	99 88       	rMAC = M[r1 + 8];
    if (p_metadata_list[AUD_CUR_METADATA_MIC] == p_buffer_list[num])
842023b2:	55 88       	r3 = M[r0 + 4];
842023b4:	66 54       	r4 = r2 LSHIFT 2;
842023b6:	8e e9       	r4 = M[rMAC + r4];
842023b8:	a8 05       	Null = r3 - r4;
842023ba:	11 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_11;

842023bc <Lc_aud_cur_disconnect_metadata_4>:
    {
        /* Set the metadata buffer to NULL and populate if a replacement is
         * available.
         */
        p_metadata_list[AUD_CUR_METADATA_MIC] = NULL;
842023bc:	50 8e       	M[r0 + 4] = Null;
842023be:	1b e6       	r1 = MHU[r1 + Null];

        /* Iterate through microphone terminals */
        for (i = (AUD_CUR_PLAYBACK_TERMINAL + 1); i < p_def->max; i++)
842023c0:	45 20       	r3 = Null + 1;
842023c2:	0e 21       	r4 = rMAC + 4;

842023c4 <Lc_aud_cur_disconnect_metadata_5>:
842023c4:	e8 04       	Null = r3 - r1;
842023c6:	0b 66       	if GE jump (m) Lc_aud_cur_disconnect_metadata_11;

842023c8 <Lc_aud_cur_disconnect_metadata_6>:
        {
            /* Don't look at the terminal that is being disconnected */
            if (i == num)
842023c8:	28 05       	Null = r3 - r2;
842023ca:	05 60       	if EQ jump (m) Lc_aud_cur_disconnect_metadata_9;

842023cc <Lc_aud_cur_disconnect_metadata_7>:
            {
                continue;
            }
            /* Update the metadata buffer with the new buffer information */
            p_buffer = p_buffer_list[i];
            if (p_buffer != NULL && buff_has_metadata(p_buffer))
842023cc:	31 e8       	rMAC = M[r4 + Null];
842023ce:	03 60       	if EQ jump (m) Lc_aud_cur_disconnect_metadata_9;

842023d0 <Lc_aud_cur_disconnect_metadata_8>:
842023d0:	8f 89       	r5 = M[rMAC + 24];
842023d2:	04 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_10;

842023d4 <Lc_aud_cur_disconnect_metadata_9>:
         * available.
         */
        p_metadata_list[AUD_CUR_METADATA_MIC] = NULL;

        /* Iterate through microphone terminals */
        for (i = (AUD_CUR_PLAYBACK_TERMINAL + 1); i < p_def->max; i++)
842023d4:	6d 20       	r3 = r3 + 1;
842023d6:	36 21       	r4 = r4 + 4;
842023d8:	f6 6f       	jump (m) Lc_aud_cur_disconnect_metadata_5;

842023da <Lc_aud_cur_disconnect_metadata_10>:
            }
            /* Update the metadata buffer with the new buffer information */
            p_buffer = p_buffer_list[i];
            if (p_buffer != NULL && buff_has_metadata(p_buffer))
            {
                p_metadata_list[AUD_CUR_METADATA_MIC] = p_buffer;
842023da:	51 8e       	M[r0 + 4] = rMAC;

842023dc <Lc_aud_cur_disconnect_metadata_11>:
                break;
842023dc:	72 48       	popm <FP, r4, r5>;
842023de:	d8 4c       	rts;

842023e0 <Lc_aud_cur_connect_common_1>:
static bool aud_cur_connect_common(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *response_id,
                                   void **response_data,
                                   bool connect)
{
842023e0:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842023e2:	42 de       	M[FP + 32] = r0;
842023e4:	19 09       	r7 = r1 + Null;
842023e6:	26 00       	r4 = r2 + Null;
842023e8:	4d de       	M[FP + 36] = r3;
842023ea:	f9 d9       	rMAC = M[FP + -4];
842023ec:	51 de       	M[FP + 40] = rMAC;
842023ee:	ef fd f2 ff 	call (m) 0x934;
842023f2:	27 ea 
842023f4:	13 09       	r9 = r0 + Null;
    tCbuffer **p_metadata_list;
    AUD_CUR_TERMINAL *p_terminal;

    /* Verify class data and create response */
    if ((p_class_data == NULL) ||
        (!base_op_connect(op_data, message_data, response_id, response_data)))
842023f6:	0a 60       	if EQ jump (m) Lc_aud_cur_connect_common_3;

842023f8 <Lc_aud_cur_connect_common_2>:
842023f8:	34 00       	r2 = r4 + Null;
842023fa:	4b 08       	r1 = r7 + Null;
842023fc:	4d d8       	r3 = M[FP + 36];
842023fe:	42 d8       	r0 = M[FP + 32];
84202400:	ef fd f1 ff 	call (m) 0x7c8;
84202404:	29 ee 
84202406:	10 04       	Null = r0 - Null;
84202408:	03 62       	if NE jump (m) Lc_aud_cur_connect_common_4;

8420240a <Lc_aud_cur_connect_common_3>:
    {
        return FALSE;
8420240a:	02 00       	r0 = Null + Null;
8420240c:	90 6e       	jump (m) Lc_aud_cur_connect_common_30;

8420240e <Lc_aud_cur_connect_common_4>:
    }

    /* Prevent runtime connection */
    if (opmgr_op_is_running(op_data))
8420240e:	42 d8       	r0 = M[FP + 32];
84202410:	ff fd 1c f0 	call (m) 0x5ca4;
84202414:	35 e4 
84202416:	10 04       	Null = r0 - Null;
84202418:	06 60       	if EQ jump (m) Lc_aud_cur_connect_common_7;

8420241a <Lc_aud_cur_connect_common_5>:
    {
        /* Exception: allow runtime disconnection if the flag is set */
        if (connect || !p_class_data->runtime_disconnect)
8420241a:	51 d8       	rMAC = M[FP + 40];
8420241c:	29 62       	if NE jump (m) Lc_aud_cur_connect_common_13;

8420241e <Lc_aud_cur_connect_common_6>:
8420241e:	b1 f0 04 82 	rMAC = MBU[r9 + 4];
84202422:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_13;

84202424 <Lc_aud_cur_connect_common_7>:
            return TRUE;
        }
    }

    /* Get the terminal ID, number, and determine whether sink or source */
    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84202424:	9a f0 00 e8 	r8 = M[r7 + Null];
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
84202428:	a7 f0 3f 00 	r5 = r8 AND 0x3f;
    terminal_pos = (uint16)AUD_CUR_GET_TERMINAL_POS(terminal_num);
8420242c:	39 00       	rMAC = r5 + Null;
8420242e:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84202432:	91 c6       	rMAC = r0 AND 0xffff;
    is_sink = terminal_id & TERMINAL_SINK_MASK;

    /* Setup the selected terminal */
    if (is_sink)
84202434:	40 f0 a3 f0 	r1 = r8 AND 0x800000;
84202438:	00 00 
8420243a:	07 60       	if EQ jump (m) Lc_aud_cur_connect_common_9;

8420243c <Lc_aud_cur_connect_common_8>:
    {
        p_terminal = &p_class_data->sinks;
8420243c:	b3 f0 08 20 	r1 = r9 + 8;
84202440:	1e 00       	r4 = r1 + Null;
        p_metadata_list = p_class_data->metadata_ip;
84202442:	38 f0 4c 20 	r6 = r1 + 76;
84202446:	06 6e       	jump (m) Lc_aud_cur_connect_common_10;

84202448 <Lc_aud_cur_connect_common_9>:
    }
    else
    {
        p_terminal = &p_class_data->sources;
84202448:	b3 f0 14 20 	r1 = r9 + 20;
8420244c:	1e 00       	r4 = r1 + Null;
        p_metadata_list = p_class_data->metadata_op;
8420244e:	38 f0 48 20 	r6 = r1 + 72;

84202452 <Lc_aud_cur_connect_common_10>:
    }

    /* Make sure the terminal is valid */
    if (terminal_num >= p_terminal->max)
84202452:	33 e6       	r1 = MHU[r4 + Null];
84202454:	f8 04       	Null = r5 - r1;
84202456:	12 68       	if LT jump (m) Lc_aud_cur_connect_common_14;

84202458 <Lc_aud_cur_connect_common_11>:
    {
        L4_DBG_MSG1("base aud cur connect: terminal num %d is out \
                    of max range", terminal_num);
84202458:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420245c:	08 25       	Null = rMAC - 4;
8420245e:	08 68       	if LT jump (m) Lc_aud_cur_connect_common_13;

84202460 <Lc_aud_cur_connect_common_12>:
84202460:	55 f1 02 f0 	r0 = Null + 357565815;
84202464:	77 49 
84202466:	3b 00       	r1 = r5 + Null;
84202468:	ef fd f6 ff 	call (m) 0x10c2;
8420246c:	3b e2 

8420246e <Lc_aud_cur_connect_common_13>:
8420246e:	01 f0 00 60 	rMAC = Null + 4096;
84202472:	4a d8       	r0 = M[FP + 36];
84202474:	12 e8       	r0 = M[r0 + Null];
84202476:	51 8e       	M[r0 + 4] = rMAC;
84202478:	59 6e       	jump (m) Lc_aud_cur_connect_common_29;

8420247a <Lc_aud_cur_connect_common_14>:
        return TRUE;
    }

    /* Make sure the terminal is not marked as invalid */
    if (p_terminal->max_valid_mask &&
       !(p_terminal->max_valid_mask & terminal_pos))
8420247a:	b3 86       	r1 = MHU[r4 + 4];
8420247c:	0f 60       	if EQ jump (m) Lc_aud_cur_connect_common_18;

8420247e <Lc_aud_cur_connect_common_15>:
8420247e:	c9 10       	rMAC = rMAC AND r1;
84202480:	0d 62       	if NE jump (m) Lc_aud_cur_connect_common_18;

84202482 <Lc_aud_cur_connect_common_16>:
    {
        L4_DBG_MSG1("base aud cur connect: invalid terminal number %d",
                    terminal_num);
84202482:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202486:	08 25       	Null = rMAC - 4;
84202488:	f3 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

8420248a <Lc_aud_cur_connect_common_17>:
8420248a:	55 f1 02 f0 	r0 = Null + 357565893;
8420248e:	c5 49 
84202490:	3b 00       	r1 = r5 + Null;
84202492:	ef fd f6 ff 	call (m) 0x10c2;
84202496:	31 e1 
84202498:	eb 6f       	jump (m) Lc_aud_cur_connect_common_13;

8420249a <Lc_aud_cur_connect_common_18>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (connect)
8420249a:	51 d8       	rMAC = M[FP + 40];
8420249c:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_24;

8420249e <Lc_aud_cur_connect_common_19>:
 * \return - TRUE if the terminal is connected
 */
static inline bool aud_cur_is_terminal_connected(AUD_CUR_TERMINAL *p_def,
                                                 uint16 num)
{
    return (p_def->connected & (1 << num)) > 0;
8420249e:	f1 86       	rMAC = MHU[r4 + 6];
842024a0:	52 10       	r0 = r0 AND rMAC;
842024a2:	01 00       	rMAC = Null + Null;
842024a4:	10 04       	Null = r0 - Null;
842024a6:	2c f0 41 ce 	if GT rMAC = Null + 1;
        return TRUE;
    }

    if (connect)
    {
        if (aud_cur_is_terminal_connected(p_terminal, terminal_num))
842024aa:	08 04       	Null = rMAC - Null;
842024ac:	0d 60       	if EQ jump (m) Lc_aud_cur_connect_common_22;

842024ae <Lc_aud_cur_connect_common_20>:
        {
            L4_DBG_MSG1("base aud cur connect: terminal %d already connected",
                        terminal_num);
842024ae:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842024b2:	08 25       	Null = rMAC - 4;
842024b4:	dd 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

842024b6 <Lc_aud_cur_connect_common_21>:
842024b6:	55 f1 02 f0 	r0 = Null + 357565942;
842024ba:	f6 49 
842024bc:	3b 00       	r1 = r5 + Null;
842024be:	ef fd f6 ff 	call (m) 0x10c2;
842024c2:	25 e0 
842024c4:	d5 6f       	jump (m) Lc_aud_cur_connect_common_13;

842024c6 <Lc_aud_cur_connect_common_22>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        /* Connect the terminal */
        tCbuffer *p_buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842024c6:	99 f0 01 88 	r7 = M[r7 + 4];
        aud_cur_connect_terminal(p_terminal, terminal_num, p_buffer);
842024ca:	4c 08       	r2 = r7 + Null;
842024cc:	3b 00       	r1 = r5 + Null;
842024ce:	32 00       	r0 = r4 + Null;
842024d0:	4b 4f       	call (m) Lc_aud_cur_connect_terminal_1;
        aud_cur_connect_metadata(p_metadata_list, terminal_num, p_buffer);
842024d2:	4c 08       	r2 = r7 + Null;
842024d4:	3b 00       	r1 = r5 + Null;
842024d6:	42 08       	r0 = r6 + Null;
842024d8:	5b 4f       	call (m) Lc_aud_cur_connect_metadata_1;

        if (p_class_data->connect_fn != NULL)
842024da:	b1 f0 12 88 	rMAC = M[r9 + 72];
842024de:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_29;

842024e0 <Lc_aud_cur_connect_common_23>:
        {
            p_class_data->connect_fn(op_data, terminal_id);
842024e0:	53 08       	r1 = r8 + Null;
842024e2:	42 d8       	r0 = M[FP + 32];
842024e4:	d1 4c       	call rMAC;
842024e6:	22 6e       	jump (m) Lc_aud_cur_connect_common_29;

842024e8 <Lc_aud_cur_connect_common_24>:
 * \return - TRUE if the terminal is connected
 */
static inline bool aud_cur_is_terminal_connected(AUD_CUR_TERMINAL *p_def,
                                                 uint16 num)
{
    return (p_def->connected & (1 << num)) > 0;
842024e8:	f1 86       	rMAC = MHU[r4 + 6];
842024ea:	52 10       	r0 = r0 AND rMAC;
842024ec:	01 00       	rMAC = Null + Null;
842024ee:	10 04       	Null = r0 - Null;
842024f0:	2c f0 41 ce 	if GT rMAC = Null + 1;
            p_class_data->connect_fn(op_data, terminal_id);
        }
    }
    else
    {
        if (!aud_cur_is_terminal_connected(p_terminal, terminal_num))
842024f4:	08 04       	Null = rMAC - Null;
842024f6:	0d 62       	if NE jump (m) Lc_aud_cur_connect_common_27;

842024f8 <Lc_aud_cur_connect_common_25>:
        {
            L4_DBG_MSG1("base aud cur connect: terminal %d not connected",
                        terminal_num);
842024f8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842024fc:	08 25       	Null = rMAC - 4;
842024fe:	b8 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

84202500 <Lc_aud_cur_connect_common_26>:
84202500:	55 f1 02 f0 	r0 = Null + 357565994;
84202504:	2a 4a 
84202506:	3b 00       	r1 = r5 + Null;
84202508:	ef fd f5 ff 	call (m) 0x10c2;
8420250c:	3b ed 
8420250e:	b0 6f       	jump (m) Lc_aud_cur_connect_common_13;

84202510 <Lc_aud_cur_connect_common_27>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        aud_cur_disconnect_metadata(p_metadata_list, p_terminal, terminal_num);
84202510:	3c 00       	r2 = r5 + Null;
84202512:	33 00       	r1 = r4 + Null;
84202514:	42 08       	r0 = r6 + Null;
84202516:	48 4f       	call (m) Lc_aud_cur_disconnect_metadata_1;
        aud_cur_disconnect_terminal(p_terminal, terminal_num);
84202518:	3b 00       	r1 = r5 + Null;
8420251a:	32 00       	r0 = r4 + Null;
8420251c:	2e 4f       	call (m) Lc_aud_cur_disconnect_terminal_1;

        if (p_class_data->disconnect_fn != NULL)
8420251e:	b1 f0 13 88 	rMAC = M[r9 + 76];
84202522:	04 60       	if EQ jump (m) Lc_aud_cur_connect_common_29;

84202524 <Lc_aud_cur_connect_common_28>:
        {
            p_class_data->disconnect_fn(op_data, terminal_id);
84202524:	53 08       	r1 = r8 + Null;
84202526:	42 d8       	r0 = M[FP + 32];
84202528:	d1 4c       	call rMAC;

8420252a <Lc_aud_cur_connect_common_29>:
    {
        /* Exception: allow runtime disconnection if the flag is set */
        if (connect || !p_class_data->runtime_disconnect)
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
8420252a:	42 20       	r0 = Null + 1;

8420252c <Lc_aud_cur_connect_common_30>:
        {
            p_class_data->disconnect_fn(op_data, terminal_id);
        }
    }
    return TRUE;
}
8420252c:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420252e:	d8 4c       	rts;

84202530 <Lc_aud_cur_check_valid_terminals_1>:
 * \param  p_term           Pointer to the terminal information
 *
 * \return - result TRUE if the terminals are valid
 */
static bool aud_cur_check_valid_terminals(AUD_CUR_TERMINAL *p_term)
{
84202530:	c8 1c       	pushm <FP(=SP), rLink>;
    /* No validity mask to test */
    if (p_term->min_valid_mask == 0)
84202532:	51 86       	rMAC = MHU[r0 + 2];
84202534:	03 62       	if NE jump (m) Lc_aud_cur_check_valid_terminals_3;

84202536 <Lc_aud_cur_check_valid_terminals_2>:
    {
        return TRUE;
84202536:	42 20       	r0 = Null + 1;
84202538:	10 6e       	jump (m) Lc_aud_cur_check_valid_terminals_7;

8420253a <Lc_aud_cur_check_valid_terminals_3>:
    }

    /* Connection mask doesn't have at least the valid mask bits */
    if ((p_term->min_valid_mask & p_term->connected) != p_term->min_valid_mask)
8420253a:	d3 86       	r1 = MHU[r0 + 6];
8420253c:	5a 10       	r0 = r1 AND rMAC;
8420253e:	50 04       	Null = r0 - rMAC;
84202540:	fb 61       	if EQ jump (m) Lc_aud_cur_check_valid_terminals_2;

84202542 <Lc_aud_cur_check_valid_terminals_4>:
    {
        L4_DBG_MSG1("base aud cur start: invalid terminals %hu",
                    p_term->connected);
84202542:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202546:	08 25       	Null = rMAC - 4;
84202548:	07 68       	if LT jump (m) Lc_aud_cur_check_valid_terminals_6;

8420254a <Lc_aud_cur_check_valid_terminals_5>:
8420254a:	55 f1 02 f0 	r0 = Null + 357566042;
8420254e:	5a 4a 
84202550:	ef fd f5 ff 	call (m) 0x10c2;
84202554:	33 eb 

84202556 <Lc_aud_cur_check_valid_terminals_6>:
        return FALSE;
84202556:	02 00       	r0 = Null + Null;

84202558 <Lc_aud_cur_check_valid_terminals_7>:
    }

    return TRUE;
}
84202558:	c8 48       	popm <FP, rLink>;
8420255a:	d8 4c       	rts;

8420255c <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aanc2_16k_cap_data;
8420255c:	01 f0 02 f3 	r0 = Null + 1441792;
84202560:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84202562:	00 f0 4c 5a 	Null = Null + 3660;

84202566 <$_aanc2_clipping_peak_detect_dual>:
.MODULE $M.aanc2_clipping.clipping_peak_detect;
    .CODESEGMENT PM;

$_aanc2_clipping_peak_detect_dual:

    PUSH_ALL_C;
84202566:	fc fa 40 e0 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
8420256a:	07 f0 47 e4 	pushm <I0, I1, I2, I4, I5, I6>;
8420256e:	70 ff 40 e4 	pushm <M0, M1, M2, L0, L1, L4, L5>;

    r8 = r0;    // DM1 struct
84202572:	12 09       	r8 = r0 + Null;
    r9 = r1;    // DM2 struct
84202574:	1b 09       	r9 = r1 + Null;
    r10 = r2;   // Number of samples to process
84202576:	24 09       	r10 = r2 + Null;

    r3 = M[r8 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.THRESHOLD_FIELD];
84202578:	a5 f0 02 88 	r3 = M[r8 + 8];
    r4 = M[r9 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.THRESHOLD_FIELD];
8420257c:	b6 f0 02 88 	r4 = M[r9 + 8];

    // Get cbuffer details for DM1 input
    r0 = M[r8 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.P_DATA_FIELD];
84202580:	a2 f0 00 88 	r0 = M[r8 + 0];
    call $cbuffer.get_read_address_and_size_and_start_address;
84202584:	ff fd 5c f2 	call (m) 0x4df66;
84202588:	23 ef 
    push r2;
8420258a:	00 f0 34 cf 	push r2;
    pop B0;
8420258e:	00 f6 3a cf 	pop B0;
    I0 = r0;
84202592:	10 0a       	I0 = r0 + Null;
    L0 = r1;
84202594:	1c 0b       	L0 = r1 + Null;

    // Get cbuffer details for DM2 input
    r0 = M[r9 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.P_DATA_FIELD];
84202596:	b2 f0 00 88 	r0 = M[r9 + 0];
    call $cbuffer.get_read_address_and_size_and_start_address;
8420259a:	ff fd 5c f2 	call (m) 0x4df66;
8420259e:	2d ee 
    push r2;
842025a0:	00 f0 34 cf 	push r2;
    pop B4;
842025a4:	00 f6 3c cf 	pop B4;
    I4 = r0;
842025a8:	14 0a       	I4 = r0 + Null;
    L4 = r1;
842025aa:	1e 0b       	L4 = r1 + Null;

    r5 = 0; // DM1 mic clipping detection
842025ac:	07 00       	r5 = Null + Null;
    r6 = 0; // DM2 mic clipping detection
842025ae:	00 09       	r6 = Null + Null;

    r7 = M[r8 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD];
842025b0:	a9 f0 01 88 	r7 = M[r8 + 4];
    r1 = M[r9 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD];
842025b4:	b3 f0 01 88 	r1 = M[r9 + 4];

    do detect_mic_clipping;
842025b8:	11 4c       	do (m) $M.aanc2_clipping.clipping_peak_detect.detect_mic_clipping;
        r0 = M[I0, MK1], r2 = M[I4, MK1];
842025ba:	41 f1 32 d0 	Null = Null + Null, r0 = M[I0,4], r2 = M[I4,4];
        r0 = ABS r0; // Absolute value on DM1
842025be:	4f f2 42 ce 	r0 = ABS r0;
        r7 = MAX r0; // Peak detect DM1
842025c2:	6f f2 49 ce 	r7 = MAX r0;
        r2 = ABS r2; // Absolute value on DM2
842025c6:	4f f4 44 ce 	r2 = ABS r2;
        r1 = MAX r2; // Peak detect DM2
842025ca:	6f f4 43 ce 	r1 = MAX r2;
        Null = r0 - r3;
842025ce:	50 05       	Null = r0 - r3;
        if GE r5 = 1;
842025d0:	2a f0 47 ce 	if GE r5 = Null + 1;
        Null = r2 - r4;
842025d4:	a0 05       	Null = r2 - r4;
        if GE r6 = 1;
842025d6:	2a f0 48 ce 	if GE r6 = Null + 1;

842025da <$M.aanc2_clipping.clipping_peak_detect.detect_mic_clipping>:
    detect_mic_clipping:

    MB[r8 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.FRAME_DETECT_FIELD] = r5;
842025da:	a7 f0 10 8a 	MB[r8 + 16] = r5;
    MB[r9 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.FRAME_DETECT_FIELD] = r6;
842025de:	b8 f0 10 8a 	MB[r9 + 16] = r6;
    M[r8 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD] = r7;
842025e2:	a9 f0 01 8e 	M[r8 + 4] = r7;
    M[r9 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD] = r1;
842025e6:	b3 f0 01 8e 	M[r9 + 4] = r1;

    POP_ALL_C;
842025ea:	70 ff 60 e4 	popm <M0, M1, M2, L0, L1, L4, L5>;
842025ee:	07 f0 67 e4 	popm <I0, I1, I2, I4, I5, I6>;
842025f2:	fc fa 60 e0 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
    r0 = 1;
842025f6:	42 20       	r0 = Null + 1;

    rts;
842025f8:	d8 4c       	rts;

842025fa <$_aanc2_clipping_peak_detect_single>:
.MODULE $M.aanc2_clipping.clipping_peak_detect_single;
    .CODESEGMENT PM;

$_aanc2_clipping_peak_detect_single:

    PUSH_ALL_C;
842025fa:	fc fa 40 e0 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
842025fe:	07 f0 47 e4 	pushm <I0, I1, I2, I4, I5, I6>;
84202602:	70 ff 40 e4 	pushm <M0, M1, M2, L0, L1, L4, L5>;

    r4 = r0;    // DM1 struct
84202606:	16 00       	r4 = r0 + Null;
    r10 = r1;   // Number of samples to process
84202608:	1c 09       	r10 = r1 + Null;

    r5 = M[r4 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.THRESHOLD_FIELD];
8420260a:	b7 88       	r5 = M[r4 + 8];

    r0 = M[r4 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.P_DATA_FIELD];
8420260c:	32 88       	r0 = M[r4 + 0];
    call $cbuffer.get_read_address_and_size_and_start_address;
8420260e:	ff fd 5c f2 	call (m) 0x4df66;
84202612:	39 ea 
    push r2;
84202614:	00 f0 34 cf 	push r2;
    pop B0;
84202618:	00 f6 3a cf 	pop B0;
    I0 = r0;
8420261c:	10 0a       	I0 = r0 + Null;
    L0 = r1;
8420261e:	1c 0b       	L0 = r1 + Null;

    r3 = 0;
84202620:	05 00       	r3 = Null + Null;

    r1 = M[r4 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD];
84202622:	73 88       	r1 = M[r4 + 4];

    do detect_pb_clipping;
84202624:	0a 4c       	do (m) $M.aanc2_clipping.clipping_peak_detect_single.detect_pb_clipping;
        r0 = M[I0, MK1];
84202626:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];
        r0 = ABS r0;        // Absolute value
8420262a:	4f f2 42 ce 	r0 = ABS r0;
        r1 = MAX r0;        // Peak detect
8420262e:	6f f2 43 ce 	r1 = MAX r0;
        Null = r0 - r5;     // Threshold detect for clipping flag
84202632:	d0 05       	Null = r0 - r5;
        if GE r3 = 1;
84202634:	2a f0 45 ce 	if GE r3 = Null + 1;

84202638 <$M.aanc2_clipping.clipping_peak_detect_single.detect_pb_clipping>:
    detect_pb_clipping:

    MB[r4 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.FRAME_DETECT_FIELD] = r3;
84202638:	35 aa       	MB[r4 + 16] = r3;
    M[r4 + $aanc2_clipping._AANC2_CLIP_DETECT_struct.PEAK_VALUE_FIELD] = r1;
8420263a:	73 8e       	M[r4 + 4] = r1;

    POP_ALL_C;
8420263c:	70 ff 60 e4 	popm <M0, M1, M2, L0, L1, L4, L5>;
84202640:	07 f0 67 e4 	popm <I0, I1, I2, I4, I5, I6>;
84202644:	fc fa 60 e0 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
    r0 = 1;
84202648:	42 20       	r0 = Null + 1;

    rts;
8420264a:	d8 4c       	rts;
