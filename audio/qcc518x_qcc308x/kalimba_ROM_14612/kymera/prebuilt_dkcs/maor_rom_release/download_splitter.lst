
/home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/tools/KCSMaker/out/14612/maor_rom_release/download/debugbin/download_splitter.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_splitter_process_data>:
 * \brief The main data processing function only selects the
 *  right data processing based on the working mode.
 *
 */
void splitter_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200000:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200002:	42 de       	M[FP + 32] = r0;
84200004:	4b de       	M[FP + 36] = r1;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84200006:	ff fd 04 f0 	call (m) 0x8ea;
8420000a:	25 e7 
8420000c:	16 00       	r4 = r0 + Null;
     * for old implementations where the data type is not save in the elf. */
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data); /* old way = (SPLITTER_OP_DATA *)(op_data->extra_op_data);*/

    SPLITTER_MSG1("#### SPLITTER 0x%08x ####",base_op_get_ext_op_id(op_data));

    switch (splitter->working_mode)
8420000e:	33 81       	r1 = MBS[r4 + 4];
84200010:	19 00       	rMAC = r1 + Null;
84200012:	36 60       	if EQ jump (m) Lc_splitter_process_data_10;

84200014 <Lc_splitter_process_data_2>:
84200014:	48 24       	Null = rMAC - 1;
84200016:	54 62       	if NE jump (m) Lc_splitter_process_data_15;

84200018 <Lc_splitter_process_data_3>:
84200018:	42 d8       	r0 = M[FP + 32];
8420001a:	ff fd 04 f0 	call (m) 0x8ea;
8420001e:	31 e6 
84200020:	16 00       	r4 = r0 + Null;
static inline void splitter_process_data_buffering(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    /* Data to pack/copy. and the actual copies/packed data.*/
    unsigned data_to_pack;
    bool in_transition = splitter->in_transition;
84200022:	69 f0 07 88 	r7 = M[r4 + 28];
    TIME_INTERVAL kick_period;
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
84200026:	42 d8       	r0 = M[FP + 32];
84200028:	ff fd 04 f0 	call (m) 0x8f4;
8420002c:	2d e6 
8420002e:	10 09       	r6 = r0 + Null;
    patch_fn_shared(splitter);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
84200030:	37 31       	r5 = r4 + 36;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200032:	ff fd 74 f2 	call (m) 0x4e996;
84200036:	25 eb 
    if (*timer_id != TIMER_ID_INVALID)
84200038:	3a e8       	r0 = M[r5 + Null];
8420003a:	07 60       	if EQ jump (m) Lc_splitter_process_data_5;

8420003c <Lc_splitter_process_data_4>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
8420003c:	04 00       	r2 = Null + Null;
8420003e:	03 00       	r1 = Null + Null;
84200040:	ff fd 34 f0 	call (m) 0x6936;
84200044:	37 e7 
        *timer_id = TIMER_ID_INVALID;
84200046:	38 ee       	M[r5 + Null] = Null;

84200048 <Lc_splitter_process_data_5>:
    }
    interrupt_unblock();
84200048:	ff fd 74 f2 	call (m) 0x4e9b2;
8420004c:	2b eb 


    /*Calculate the min available data at the input */
    data_to_pack = amount_to_pack(splitter);
8420004e:	32 00       	r0 = r4 + Null;
84200050:	01 f0 29 ee 	call (m) Lc_amount_to_pack_1;
84200054:	13 00       	r1 = r0 + Null;

    SPLITTER_MSG1("Splitter data_to_pack 0x%08x!", data_to_pack);

    /* Try to finish the transition.*/
    if (in_transition)
84200056:	0f f9 00 c2 	Null = r7 - Null;
8420005a:	00 f0 c7 e4 	if EQ jump (m) Lc_splitter_process_data_65;

8420005e <Lc_splitter_process_data_6>:
    {

        SPLITTER_MSG("Splitter in transition!");
        /* Transition based on timestamp can wait for a specific timestamp.
         * Pack the input without offload to avoid dead lock. */
        if (data_to_pack != 0)
8420005e:	18 04       	Null = r1 - Null;
84200060:	06 60       	if EQ jump (m) Lc_splitter_process_data_8;

84200062 <Lc_splitter_process_data_7>:
        {
            SPLITTER_MSG1("Splitter in transition! First pack data %d", data_to_pack);
            pack_to_internal(splitter, data_to_pack, FALSE, opid);
84200062:	04 00       	r2 = Null + Null;
84200064:	45 08       	r3 = r6 + Null;
84200066:	32 00       	r0 = r4 + Null;
84200068:	02 f0 2f e3 	call (m) Lc_pack_to_internal_1;

8420006c <Lc_splitter_process_data_8>:
            /* No more data to pack. */
            data_to_pack = 0;
        }
        if (splitter_transition(splitter))
8420006c:	32 00       	r0 = r4 + Null;
8420006e:	01 f0 39 e4 	call (m) $_splitter_transition;
84200072:	10 04       	Null = r0 - Null;
84200074:	00 f0 c3 e4 	if EQ jump (m) Lc_splitter_process_data_68;

84200078 <Lc_splitter_process_data_9>:
        {
            /* This time we managed to finish transitioning .*/
            in_transition = FALSE;
            /* Save the new state. */
            splitter->in_transition = in_transition;
84200078:	f0 8f       	M[r4 + 28] = Null;
8420007a:	0f f0 b5 e4 	jump (m) Lc_splitter_process_data_67;

8420007e <Lc_splitter_process_data_10>:
8420007e:	42 d8       	r0 = M[FP + 32];
84200080:	ff fd 04 f0 	call (m) 0x8ea;
84200084:	2b e3 
84200086:	11 09       	r7 = r0 + Null;
    unsigned i, min_new_data, min_new_space;
    int *new_output_write_addr;
    int *new_input_read_addr;
    bool stream_active = FALSE;

    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
84200088:	96 f0 00 e8 	r4 = M[r7 + Null];
    patch_fn_shared(splitter);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
8420008c:	97 f0 24 20 	r5 = r7 + 36;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200090:	ff fd 74 f2 	call (m) 0x4e996;
84200094:	27 e8 
    if (*timer_id != TIMER_ID_INVALID)
84200096:	3a e8       	r0 = M[r5 + Null];
84200098:	07 60       	if EQ jump (m) Lc_splitter_process_data_12;

8420009a <Lc_splitter_process_data_11>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
8420009a:	04 00       	r2 = Null + Null;
8420009c:	03 00       	r1 = Null + Null;
8420009e:	ff fd 34 f0 	call (m) 0x6936;
842000a2:	39 e4 
        *timer_id = TIMER_ID_INVALID;
842000a4:	38 ee       	M[r5 + Null] = Null;

842000a6 <Lc_splitter_process_data_12>:
    }
    interrupt_unblock();
842000a6:	ff fd 74 f2 	call (m) 0x4e9b2;
842000aa:	2d e8 

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842000ac:	01 00       	rMAC = Null + Null;

842000ae <Lc_splitter_process_data_13>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842000ae:	92 f0 18 20 	r0 = r7 + 24;
842000b2:	52 e0       	r0 = MBS[r0 + rMAC];
    {
        if (get_current_output_state(splitter, i)== ACTIVE)
842000b4:	50 24       	Null = r0 - 1;
842000b6:	1a 62       	if NE jump (m) Lc_splitter_process_data_19;

842000b8 <Lc_splitter_process_data_14>:
    }
    /* This code is very naughty and reaches into the cbuffer structures. It can
     * be done safely because they have to be local, and it's lightning fast as
     * a result. Cbuffer API is subverted because it isn't designed for this.
     */
    min_new_data = min_new_space = UINT_MAX;
842000b8:	41 24       	rMAC = Null - 1;
842000ba:	0a 09       	r8 = rMAC + Null;
842000bc:	40 6e       	jump (m) Lc_splitter_process_data_26;

842000be <Lc_splitter_process_data_15>:
            break;
        case BUFFER_DATA:
            splitter_process_data_buffering(op_data, touched);
            break;
        default:
            SPLITTER_ERRORMSG1("SPLITTER Error, unsupported mode: %d.",splitter->working_mode);
842000be:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842000c2:	08 24       	Null = rMAC - 0;
842000c4:	07 6c       	if LE jump (m) Lc_splitter_process_data_17;

842000c6 <Lc_splitter_process_data_16>:
842000c6:	55 f1 02 f0 	r0 = Null + 357565486;
842000ca:	2e 48 
842000cc:	ff fd 07 f0 	call (m) 0x10c2;
842000d0:	37 ef 

842000d2 <Lc_splitter_process_data_17>:
            /* Check if the mode is valid one or is just unsupported.*/
            PL_ASSERT(splitter->working_mode < NR_OF_MODES);
842000d2:	31 81       	rMAC = MBS[r4 + 4];
842000d4:	88 24       	Null = rMAC - 2;
842000d6:	0b f0 ad e4 	if LT jump (m) Lc_splitter_process_data_73;

842000da <Lc_splitter_process_data_18>:
842000da:	03 f0 4c 4a 	r1 = Null + 1612;
842000de:	02 f0 13 60 	r0 = Null + 4115;
842000e2:	ff fd b5 f0 	call (m) 0x16bdc;
842000e6:	3b e7 
842000e8:	5b 6e       	jump (m) Lc_splitter_process_data_38;

842000ea <Lc_splitter_process_data_19>:
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
    patch_fn_shared(splitter);

    timer_cancel_event_atomic(&splitter->self_kick_timer);

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842000ea:	49 20       	rMAC = rMAC + 1;
842000ec:	88 24       	Null = rMAC - 2;
842000ee:	e0 65       	if NC jump (m) Lc_splitter_process_data_13;

842000f0 <Lc_splitter_process_data_20>:
    }
    if (!stream_active)
    {
        /* Nothing to do because there is no active output. Raise a timer and exit. */
        timer_schedule_event_in_atomic(SPLITTER_SELF_KICK_RATIO * stream_if_get_system_kick_period(),
            splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
842000f0:	ff fd 45 f0 	call (m) 0x8b3a;
842000f4:	2b e2 
842000f6:	96 f0 24 20 	r4 = r7 + 36;
842000fa:	42 f0 17 f0 	r5 = Null + 69214683;
842000fe:	db 41 
84200100:	00 f2 d8 d8 	r6 = r0 LSHIFT 1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer,
        tTimerId *id)
{
    interrupt_block();
84200104:	ff fd 74 f2 	call (m) 0x4e996;
84200108:	33 e4 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
8420010a:	ff fd 33 f0 	call (m) 0x679c;
8420010e:	33 e4 
84200110:	42 0c       	r0 = r6 + r0;
84200112:	3b 00       	r1 = r5 + Null;
84200114:	44 d8       	r2 = M[FP + 32];
84200116:	ff fd 33 f0 	call (m) 0x67a2;
8420011a:	2d e4 
}
8420011c:	32 ee       	M[r4 + Null] = r0;
8420011e:	b7 6e       	jump (m) Lc_splitter_process_data_63;

84200120 <Lc_splitter_process_data_21>:
        }
        /* Make sure at leas one output is active and connected. */
        PL_ASSERT(out != NULL);

        /* Find out minimum available data. */
        new_data =  (char *)in->write_ptr -  (char *)out->write_ptr;
84200120:	9b 88       	r1 = M[r1 + 8];
84200122:	94 88       	r2 = M[r0 + 8];
84200124:	1b 05       	r1 = r1 - r2;
        if (new_data < 0)
84200126:	18 04       	Null = r1 - Null;
84200128:	05 f0 89 e0 	if POS jump (m) Lc_splitter_process_data_23;

8420012c <Lc_splitter_process_data_22>:
        {
            new_data += out->size;
8420012c:	12 e8       	r0 = M[r0 + Null];
8420012e:	d3 00       	r1 = r0 + r1;

84200130 <Lc_splitter_process_data_23>:
        }

        if (new_data < min_new_data)
84200130:	af f3 00 c2 	Null = r1 - r8;
84200134:	02 f0 87 e0 	if C jump (m) Lc_splitter_process_data_25;

84200138 <Lc_splitter_process_data_24>:
        {
            min_new_data = new_data;
84200138:	1a 09       	r8 = r1 + Null;

8420013a <Lc_splitter_process_data_25>:
        }

        channel = channel->next;
8420013a:	36 e8       	r4 = M[r4 + Null];

8420013c <Lc_splitter_process_data_26>:
     * be done safely because they have to be local, and it's lightning fast as
     * a result. Cbuffer API is subverted because it isn't designed for this.
     */
    min_new_data = min_new_space = UINT_MAX;
    /* Iterate through the list of all active channels. */
    while (NULL != channel)
8420013c:	30 04       	Null = r4 - Null;
8420013e:	30 60       	if EQ jump (m) Lc_splitter_process_data_38;

84200140 <Lc_splitter_process_data_27>:
    {
        int new_data, new_space;
        tCbuffer *out = NULL; /* Initialise to keep the compiler happy. */
84200140:	02 00       	r0 = Null + Null;
        tCbuffer *in = channel->input_buffer;
84200142:	b3 88       	r1 = M[r4 + 8];

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200144:	04 00       	r2 = Null + Null;
84200146:	35 23       	r3 = r4 + 12;

84200148 <Lc_splitter_process_data_28>:
84200148:	97 f0 18 20 	r5 = r7 + 24;
8420014c:	3f e1       	r5 = MBS[r5 + r2];
        {
            if (get_current_output_state(splitter, i) == ACTIVE)
8420014e:	78 24       	Null = r5 - 1;
84200150:	1a 62       	if NE jump (m) Lc_splitter_process_data_35;

84200152 <Lc_splitter_process_data_29>:
            {
                out = channel->output_buffer[i];
                /* Make sure the output is connected. */
                PL_ASSERT(out != NULL);
84200152:	2a e8       	r0 = M[r3 + Null];
84200154:	09 62       	if NE jump (m) Lc_splitter_process_data_31;

84200156 <Lc_splitter_process_data_30>:
84200156:	03 f0 91 40 	r1 = Null + 145;
8420015a:	02 f0 13 60 	r0 = Null + 4115;
8420015e:	ff fd b5 f0 	call (m) 0x16bdc;
84200162:	3f e3 
84200164:	1d 6e       	jump (m) Lc_splitter_process_data_38;

84200166 <Lc_splitter_process_data_31>:

                /* Find out minimum available space. */
                new_space = (char *)out->read_ptr - (char *)in->read_ptr;
84200166:	57 88       	r5 = M[r0 + 4];
84200168:	38 f0 01 88 	r6 = M[r1 + 4];
8420016c:	00 f8 37 c2 	r5 = r5 - r6;
                if (new_space < 0)
84200170:	38 04       	Null = r5 - Null;
84200172:	05 f0 8b e0 	if POS jump (m) Lc_splitter_process_data_33;

84200176 <Lc_splitter_process_data_32>:
                {
                    new_space += in->size;
84200176:	38 f0 00 e8 	r6 = M[r1 + Null];
8420017a:	47 0c       	r5 = r6 + r5;

8420017c <Lc_splitter_process_data_33>:
                }

                if (new_space < min_new_space)
8420017c:	78 04       	Null = r5 - rMAC;
8420017e:	02 f0 87 e0 	if C jump (m) Lc_splitter_process_data_35;

84200182 <Lc_splitter_process_data_34>:
                {
                    min_new_space = new_space;
84200182:	39 00       	rMAC = r5 + Null;

84200184 <Lc_splitter_process_data_35>:
    {
        int new_data, new_space;
        tCbuffer *out = NULL; /* Initialise to keep the compiler happy. */
        tCbuffer *in = channel->input_buffer;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200184:	64 20       	r2 = r2 + 1;
84200186:	2d 21       	r3 = r3 + 4;
84200188:	a0 24       	Null = r2 - 2;
8420018a:	df 65       	if NC jump (m) Lc_splitter_process_data_28;

8420018c <Lc_splitter_process_data_36>:
                    min_new_space = new_space;
                }
            }
        }
        /* Make sure at leas one output is active and connected. */
        PL_ASSERT(out != NULL);
8420018c:	10 04       	Null = r0 - Null;
8420018e:	c9 63       	if NE jump (m) Lc_splitter_process_data_21;

84200190 <Lc_splitter_process_data_37>:
84200190:	03 f0 a1 40 	r1 = Null + 161;
84200194:	02 f0 13 60 	r0 = Null + 4115;
84200198:	ff fd b5 f0 	call (m) 0x16bdc;
8420019c:	25 e2 

8420019e <Lc_splitter_process_data_38>:
    }

    /* Typically only one of  min_new_space OR min_new_data are non zero on a
     * given kick so we separate the looping out to reduce the amount of work done.
     */
    if (min_new_space > 0)
8420019e:	08 04       	Null = rMAC - Null;
842001a0:	16 60       	if EQ jump (m) Lc_splitter_process_data_46;

842001a2 <Lc_splitter_process_data_40>:
    {
        channel = splitter->channel_list;
842001a2:	92 f0 00 e8 	r0 = M[r7 + Null];

842001a6 <Lc_splitter_process_data_41>:
        while (NULL != channel)
842001a6:	10 04       	Null = r0 - Null;
842001a8:	0e 60       	if EQ jump (m) Lc_splitter_process_data_45;

842001aa <Lc_splitter_process_data_42>:
        {
            tCbuffer *in = channel->input_buffer;
842001aa:	94 88       	r2 = M[r0 + 8];
            new_input_read_addr = (int *)((char *)in->read_ptr + min_new_space);
842001ac:	63 88       	r1 = M[r2 + 4];
842001ae:	cb 00       	r1 = rMAC + r1;
            if (new_input_read_addr >= (int *)((char *)in->base_addr + in->size))
842001b0:	25 e8       	r3 = M[r2 + Null];
842001b2:	e6 88       	r4 = M[r2 + 12];
842001b4:	ae 01       	r4 = r3 + r4;
842001b6:	98 05       	Null = r1 - r4;
842001b8:	03 64       	if NC jump (m) Lc_splitter_process_data_44;

842001ba <Lc_splitter_process_data_43>:
            {
                new_input_read_addr = (int *)((char *)new_input_read_addr - in->size);
842001ba:	45 05       	r3 = Null - r3;
842001bc:	eb 00       	r1 = r3 + r1;

842001be <Lc_splitter_process_data_44>:
            }
            in->read_ptr = new_input_read_addr;
842001be:	63 8e       	M[r2 + 4] = r1;
            channel = channel->next;
842001c0:	12 e8       	r0 = M[r0 + Null];
     * given kick so we separate the looping out to reduce the amount of work done.
     */
    if (min_new_space > 0)
    {
        channel = splitter->channel_list;
        while (NULL != channel)
842001c2:	f2 6f       	jump (m) Lc_splitter_process_data_41;

842001c4 <Lc_splitter_process_data_45>:
        }
        /* N.B. Because the splitter runs in place and is designed to be
         * cascaded, it is necessary to kick back whenever data is consumed so
         * that the input buffer pointers of a splitter that proceeds this one
         * are updated. */
        touched->sinks = splitter->touched_sinks;
842001c4:	91 f0 04 88 	rMAC = M[r7 + 16];
842001c8:	4a d8       	r0 = M[FP + 36];
842001ca:	51 8e       	M[r0 + 4] = rMAC;

842001cc <Lc_splitter_process_data_46>:
    }

    if (min_new_data > 0)
842001cc:	0f fa 00 c2 	Null = r8 - Null;
842001d0:	47 60       	if EQ jump (m) Lc_splitter_process_data_62;

842001d2 <Lc_splitter_process_data_47>:
    {
        unsigned octets_moved;
        tCbuffer *metadata_ip_buffer;
        tCbuffer *metadata_op_buffer;

        metadata_ip_buffer = get_metadata_buffer(splitter, TRUE, 0);
842001d2:	43 20       	r1 = Null + 1;
842001d4:	04 00       	r2 = Null + Null;
842001d6:	4a 08       	r0 = r7 + Null;
842001d8:	0d f0 27 ef 	call (m) $_get_metadata_buffer;
842001dc:	16 00       	r4 = r0 + Null;
        metadata_op_buffer = get_metadata_buffer(splitter, FALSE, 0);
842001de:	04 00       	r2 = Null + Null;
842001e0:	03 00       	r1 = Null + Null;
842001e2:	4a 08       	r0 = r7 + Null;
842001e4:	0d f0 3b ee 	call (m) $_get_metadata_buffer;
842001e8:	17 00       	r5 = r0 + Null;


        if ((NULL != metadata_ip_buffer) && buff_has_metadata(metadata_ip_buffer))
842001ea:	30 04       	Null = r4 - Null;
842001ec:	03 60       	if EQ jump (m) Lc_splitter_process_data_49;

842001ee <Lc_splitter_process_data_48>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(const tCbuffer *buff)
{
    if (buff->metadata != NULL)
842001ee:	b1 89       	rMAC = M[r4 + 24];
842001f0:	52 62       	if NE jump (m) Lc_splitter_process_data_64;

842001f2 <Lc_splitter_process_data_49>:
        else
        {
            /* There is no metadata for the input buffer, but still update the output
             * buffer metadata write index. Due to the lack of the metadata (so no info on
             * the usable octets) min_new_data is a fair approximation.  */
            octets_moved = min_new_data;
842001f2:	50 09       	r6 = r8 + Null;

842001f4 <Lc_splitter_process_data_50>:
        }

        /* Transport any metadata to the output. */
        metadata_strict_transport(metadata_ip_buffer,
                                    metadata_op_buffer,
                                    octets_moved);
842001f4:	44 08       	r2 = r6 + Null;
842001f6:	3b 00       	r1 = r5 + Null;
842001f8:	32 00       	r0 = r4 + Null;
842001fa:	ff fd a4 f0 	call (m) 0x14af0;
842001fe:	37 e7 
        channel = splitter->channel_list;
84200200:	9b f0 00 e8 	r9 = M[r7 + Null];
84200204:	12 6e       	jump (m) Lc_splitter_process_data_55;

84200206 <Lc_splitter_process_data_51>:
                    /* If the output is disabled and connected metadata is created
                     * for the output and not consumed by anyone. Delete those metadata.
                     * NOTE: It would be better not to create it in the first place, but
                     * that involves the splitter to take care of the metadata transport. */
                    tCbuffer *out = channel->output_buffer[i];
                    if (out)
84200206:	32 e8       	r0 = M[r4 + Null];
84200208:	0a 60       	if EQ jump (m) Lc_splitter_process_data_53;

8420020a <Lc_splitter_process_data_52>:
                    {
                        metadata_tag *ret_mtag;
                        unsigned b4idx, afteridx;
                        ret_mtag = buff_metadata_remove(out, octets_moved, &b4idx, &afteridx);
8420020a:	c5 12       	r3 = FP + 44;
8420020c:	84 12       	r2 = FP + 40;
8420020e:	43 08       	r1 = r6 + Null;
84200210:	ff fd a2 f0 	call (m) 0x147c0;
84200214:	31 ed 
                        buff_metadata_tag_list_delete(ret_mtag);
84200216:	ff fd a1 f0 	call (m) 0x14512;
8420021a:	3d e7 

8420021c <Lc_splitter_process_data_53>:
                                    metadata_op_buffer,
                                    octets_moved);
        channel = splitter->channel_list;
        while (NULL != channel)
        {
            for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420021c:	7f 20       	r5 = r5 + 1;
8420021e:	36 21       	r4 = r4 + 4;
84200220:	b8 24       	Null = r5 - 2;
84200222:	09 64       	if NC jump (m) Lc_splitter_process_data_57;

84200224 <Lc_splitter_process_data_54>:
                        ret_mtag = buff_metadata_remove(out, octets_moved, &b4idx, &afteridx);
                        buff_metadata_tag_list_delete(ret_mtag);
                    }
                }
            }
            channel = channel->next;
84200224:	bb f0 00 e8 	r9 = M[r9 + Null];

84200228 <Lc_splitter_process_data_55>:
        /* Transport any metadata to the output. */
        metadata_strict_transport(metadata_ip_buffer,
                                    metadata_op_buffer,
                                    octets_moved);
        channel = splitter->channel_list;
        while (NULL != channel)
84200228:	0f fb 00 c2 	Null = r9 - Null;
8420022c:	15 60       	if EQ jump (m) Lc_splitter_process_data_61;

8420022e <Lc_splitter_process_data_56>:
        {
            for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420022e:	07 00       	r5 = Null + Null;
84200230:	b6 f0 0c 20 	r4 = r9 + 12;

84200234 <Lc_splitter_process_data_57>:
84200234:	91 f0 18 20 	rMAC = r7 + 24;
84200238:	c9 e1       	rMAC = MBS[rMAC + r5];
            {
                if (get_current_output_state(splitter, i) == ACTIVE)
8420023a:	48 24       	Null = rMAC - 1;
8420023c:	e5 63       	if NE jump (m) Lc_splitter_process_data_51;

8420023e <Lc_splitter_process_data_58>:
                {
                    tCbuffer *out = channel->output_buffer[i];
8420023e:	32 e8       	r0 = M[r4 + Null];
                    new_output_write_addr = (int *)((char *)out->write_ptr + min_new_data);
84200240:	91 88       	rMAC = M[r0 + 8];
84200242:	51 0c       	rMAC = r8 + rMAC;
                    if (new_output_write_addr >= (int *)((char *)out->base_addr + out->size))
84200244:	13 e8       	r1 = M[r0 + Null];
84200246:	d4 88       	r2 = M[r0 + 12];
84200248:	1c 01       	r2 = r1 + r2;
8420024a:	08 05       	Null = rMAC - r2;
8420024c:	03 64       	if NC jump (m) Lc_splitter_process_data_60;

8420024e <Lc_splitter_process_data_59>:
                    {
                        new_output_write_addr = (int *)((char *)new_output_write_addr - out->size);
8420024e:	c3 04       	r1 = Null - r1;
84200250:	59 00       	rMAC = r1 + rMAC;

84200252 <Lc_splitter_process_data_60>:
                    }
                    out->write_ptr = new_output_write_addr;
84200252:	91 8e       	M[r0 + 8] = rMAC;
84200254:	e4 6f       	jump (m) Lc_splitter_process_data_53;

84200256 <Lc_splitter_process_data_61>:
                    }
                }
            }
            channel = channel->next;
        }
        touched->sources = splitter->touched_sources;
84200256:	91 f0 05 88 	rMAC = M[r7 + 20];
8420025a:	4a d8       	r0 = M[FP + 36];
8420025c:	11 ee       	M[r0 + Null] = rMAC;

8420025e <Lc_splitter_process_data_62>:
    }

    timer_schedule_event_in_atomic(SPLITTER_SELF_KICK_RATIO * stream_if_get_system_kick_period(),
        splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
8420025e:	ff fd 44 f0 	call (m) 0x8b3a;
84200262:	3d e6 
84200264:	96 f0 24 20 	r4 = r7 + 36;
84200268:	42 f0 17 f0 	r5 = Null + 69214683;
8420026c:	db 41 
8420026e:	00 f2 d8 d8 	r6 = r0 LSHIFT 1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer,
        tTimerId *id)
{
    interrupt_block();
84200272:	ff fd 73 f2 	call (m) 0x4e996;
84200276:	25 e9 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200278:	ff fd 32 f0 	call (m) 0x679c;
8420027c:	25 e9 
8420027e:	42 0c       	r0 = r6 + r0;
84200280:	3b 00       	r1 = r5 + Null;
84200282:	44 d8       	r2 = M[FP + 32];
84200284:	ff fd 32 f0 	call (m) 0x67a2;
84200288:	3f e8 
}
8420028a:	32 ee       	M[r4 + Null] = r0;

8420028c <Lc_splitter_process_data_63>:
        void *data_pointer,
        tTimerId *id)
{
    interrupt_block();
    *id = timer_schedule_event_in(time_in, TimerEventFunction, data_pointer);
    interrupt_unblock();
8420028c:	ff fd 73 f2 	call (m) 0x4e9b2;
84200290:	27 e9 
        case CLONE_BUFFER:
            splitter_process_data_clone(op_data, touched);
            break;
        case BUFFER_DATA:
            splitter_process_data_buffering(op_data, touched);
            break;
84200292:	38 6e       	jump (m) Lc_splitter_process_data_73;

84200294 <Lc_splitter_process_data_64>:
        if ((NULL != metadata_ip_buffer) && buff_has_metadata(metadata_ip_buffer))
        {
            /* Transport all the available metadata. The available tags will be limited by
             * the cbuffer available data. This will eliminate difference between
             * octet and _ex buffers. */
            octets_moved =  buff_metadata_available_octets(metadata_ip_buffer);
84200294:	32 00       	r0 = r4 + Null;
84200296:	ff fd a2 f0 	call (m) 0x14756;
8420029a:	21 e6 
8420029c:	10 09       	r6 = r0 + Null;
8420029e:	ab 6f       	jump (m) Lc_splitter_process_data_50;

842002a0 <Lc_splitter_process_data_65>:
        }
        else
#endif
        {
            /* Pack data to the internal buffer only if packing is not in progress. */
            if (data_to_pack != 0)
842002a0:	18 04       	Null = r1 - Null;
842002a2:	06 60       	if EQ jump (m) Lc_splitter_process_data_67;

842002a4 <Lc_splitter_process_data_66>:
            {
                /* Pack/Copy to internal buffer. */
                pack_to_internal(splitter, data_to_pack, FALSE, opid);
842002a4:	04 00       	r2 = Null + Null;
842002a6:	45 08       	r3 = r6 + Null;
842002a8:	32 00       	r0 = r4 + Null;
842002aa:	01 f0 2d e1 	call (m) Lc_pack_to_internal_1;

842002ae <Lc_splitter_process_data_67>:
            }
            /* Unpack/Copy from internal to the output as much as possible*/
            move_data_from_internal_to_output(splitter, opid);
842002ae:	43 08       	r1 = r6 + Null;
842002b0:	32 00       	r0 = r4 + Null;
842002b2:	01 f0 37 e2 	call (m) Lc_move_data_from_internal_to_output_1;

842002b6 <Lc_splitter_process_data_68>:
        /* If this is a debug build check if the buffers are still aligned. */
        SPLITTER_DEBUG_INSTR(check_buffers_validity(splitter));
    }

    /* Kick backwards and forwards */
    if (splitter->kick_backward)
842002b6:	61 f0 6c 82 	rMAC = MBU[r4 + 108];
842002ba:	06 60       	if EQ jump (m) Lc_splitter_process_data_70;

842002bc <Lc_splitter_process_data_69>:
    {
        splitter->kick_backward = FALSE;
842002bc:	60 f0 6c 8a 	MB[r4 + 108] = Null;
        touched->sinks = splitter->touched_sinks;
842002c0:	31 89       	rMAC = M[r4 + 16];
842002c2:	4a d8       	r0 = M[FP + 36];
842002c4:	51 8e       	M[r0 + 4] = rMAC;

842002c6 <Lc_splitter_process_data_70>:
    }
    if (splitter->kick_forward)
842002c6:	61 f0 6b 82 	rMAC = MBU[r4 + 107];
842002ca:	06 60       	if EQ jump (m) Lc_splitter_process_data_72;

842002cc <Lc_splitter_process_data_71>:
    {
        splitter->kick_forward = FALSE;
842002cc:	60 f0 6b 8a 	MB[r4 + 107] = Null;
        touched->sources = splitter->touched_sources;
842002d0:	71 89       	rMAC = M[r4 + 20];
842002d2:	4a d8       	r0 = M[FP + 36];
842002d4:	11 ee       	M[r0 + Null] = rMAC;

842002d6 <Lc_splitter_process_data_72>:
    }
    kick_period = stream_if_get_system_kick_period();
842002d6:	ff fd 44 f0 	call (m) 0x8b3a;
842002da:	25 e3 
842002dc:	17 00       	r5 = r0 + Null;
         * offloading is not enabled. */
        kick_period = kick_period * 2;
    }
#endif
    timer_schedule_event_in_atomic(kick_period,
        splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
842002de:	36 31       	r4 = r4 + 36;
842002e0:	42 f0 18 f0 	r6 = Null + 69214683;
842002e4:	db 41 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer,
        tTimerId *id)
{
    interrupt_block();
842002e6:	ff fd 73 f2 	call (m) 0x4e996;
842002ea:	31 e5 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
842002ec:	ff fd 32 f0 	call (m) 0x679c;
842002f0:	31 e5 
842002f2:	ba 00       	r0 = r5 + r0;
842002f4:	43 08       	r1 = r6 + Null;
842002f6:	44 d8       	r2 = M[FP + 32];
842002f8:	ff fd 32 f0 	call (m) 0x67a2;
842002fc:	2b e5 
}
842002fe:	32 ee       	M[r4 + Null] = r0;
84200300:	c6 6f       	jump (m) Lc_splitter_process_data_63;

84200302 <Lc_splitter_process_data_73>:
            /* Check if the mode is valid one or is just unsupported.*/
            PL_ASSERT(splitter->working_mode < NR_OF_MODES);
            break;
    }

}
84200302:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200304:	d8 4c       	rts;

84200306 <$_splitter_transition>:

/**
 * Function which handles the transitions for the splitter capability.
 */
bool splitter_transition(SPLITTER_OP_DATA *splitter)
{
84200306:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200308:	17 00       	r5 = r0 + Null;
    SPLITTER_CHANNEL_STRUC *channel;
    unsigned i;
    SPLITTER_OUTPUT_STATE next_state;
    SPLITTER_OUTPUT_STATE current_state;
    bool retval = TRUE;
8420030a:	08 71       	r6 = Null + 1;
    patch_fn_shared(splitter);

    channel = splitter->channel_list;
    if (channel == NULL)
8420030c:	39 e8       	rMAC = M[r5 + Null];
8420030e:	03 62       	if NE jump (m) Lc_splitter_transition_3;

84200310 <Lc_splitter_transition_2>:
    {
        /* There are no connections, the transition will
         * be handled by connect or channel creation.
         */
        return TRUE;
84200310:	42 08       	r0 = r6 + Null;
84200312:	3b 6e       	jump (m) Lc_splitter_transition_21;

84200314 <Lc_splitter_transition_3>:
    }

    SPLITTER_MSG("splitter_transition method called!");

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200314:	06 00       	r4 = Null + Null;

84200316 <Lc_splitter_transition_4>:
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84200316:	31 00       	rMAC = r4 + Null;
84200318:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
    if (splitter->active_streams & channel_mask)
8420031c:	bb b2       	r1 = MBU[r5 + 26];
8420031e:	99 10       	rMAC = r1 AND r0;
84200320:	89 c0       	rMAC = rMAC AND 0x3;
84200322:	2d 60       	if EQ jump (m) Lc_splitter_transition_19;

84200324 <Lc_splitter_transition_5>:
    {
        return ACTIVE;
84200324:	41 20       	rMAC = Null + 1;
84200326:	08 6e       	jump (m) Lc_splitter_transition_7;

84200328 <Lc_splitter_transition_6>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
    {
        return HOLD;
84200328:	db 50       	r1 = r1 LSHIFT -4;
8420032a:	99 10       	rMAC = r1 AND r0;
8420032c:	8a c0       	r0 = rMAC AND 0x3;
8420032e:	01 00       	rMAC = Null + Null;
84200330:	10 04       	Null = r0 - Null;
84200332:	a1 f0 41 ce 	if NE rMAC = Null + 2;

84200336 <Lc_splitter_transition_7>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200336:	3a 2a       	r0 = r5 + 24;
84200338:	92 e1       	r0 = MBS[r0 + r4];
        SPLITTER_MSG3("splitter_transition: Output stream %d transition from %d to %d "
                "(where 0 INACTIVE, 1 ACTIVE, 2 HOLD)",
                i, current_state, next_state);

        /* First metadata should be solved.*/
        if (current_state != next_state)
8420033a:	50 04       	Null = r0 - rMAC;
8420033c:	1b 60       	if EQ jump (m) Lc_splitter_transition_16;

8420033e <Lc_splitter_transition_8>:
        {
            bool transition;

            switch (next_state)
8420033e:	08 04       	Null = rMAC - Null;
84200340:	08 60       	if EQ jump (m) Lc_splitter_transition_11;

84200342 <Lc_splitter_transition_9>:
84200342:	48 24       	Null = rMAC - 1;
84200344:	0a 60       	if EQ jump (m) Lc_splitter_transition_12;

84200346 <Lc_splitter_transition_10>:
                    transition = splitter_transition_to_active(splitter, i);
                    break;
                }
                case HOLD:
                {
                    transition = splitter_transition_to_hold(splitter, i);
84200346:	33 00       	r1 = r4 + Null;
84200348:	3a 00       	r0 = r5 + Null;
8420034a:	04 f0 27 eb 	call (m) Lc_splitter_transition_to_hold_1;
                    break;
8420034e:	09 6e       	jump (m) Lc_splitter_transition_13;

84200350 <Lc_splitter_transition_11>:

            switch (next_state)
            {
                case INACTIVE:
                {
                    transition = splitter_transition_to_inactive(splitter, i);
84200350:	33 00       	r1 = r4 + Null;
84200352:	3a 00       	r0 = r5 + Null;
84200354:	1c 4e       	call (m) $_splitter_transition_to_inactive;
                    break;
84200356:	05 6e       	jump (m) Lc_splitter_transition_13;

84200358 <Lc_splitter_transition_12>:
                }
                case ACTIVE:
                {
                    transition = splitter_transition_to_active(splitter, i);
84200358:	33 00       	r1 = r4 + Null;
8420035a:	3a 00       	r0 = r5 + Null;
8420035c:	02 f0 2b ec 	call (m) Lc_splitter_transition_to_active_1;

84200360 <Lc_splitter_transition_13>:
                    PL_ASSERT(next_state < NR_OF_STATE);
                }
            }
            /* All channel transition must be terminated to
             * finish the overall transition. */
            retval = transition && retval;
84200360:	10 04       	Null = r0 - Null;
84200362:	07 60       	if EQ jump (m) Lc_splitter_transition_15;

84200364 <Lc_splitter_transition_14>:
84200364:	41 08       	rMAC = r6 + Null;
84200366:	00 09       	r6 = Null + Null;
84200368:	08 04       	Null = rMAC - Null;
8420036a:	21 f0 48 ce 	if NE r6 = Null + 1;
8420036e:	02 6e       	jump (m) Lc_splitter_transition_16;

84200370 <Lc_splitter_transition_15>:
84200370:	00 09       	r6 = Null + Null;

84200372 <Lc_splitter_transition_16>:
        return TRUE;
    }

    SPLITTER_MSG("splitter_transition method called!");

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200372:	76 20       	r4 = r4 + 1;
84200374:	b0 24       	Null = r4 - 2;
84200376:	d0 65       	if NC jump (m) Lc_splitter_transition_4;

84200378 <Lc_splitter_transition_18>:
        }/* end of state transition. */
    }
    SPLITTER_MSG1("splitter_transition: returns %d", retval);
    /* If this is a debug build check if the buffers are still aligned. */
    SPLITTER_DEBUG_INSTR(check_buffers_validity(splitter));
    return retval;
84200378:	42 08       	r0 = r6 + Null;
8420037a:	07 6e       	jump (m) Lc_splitter_transition_21;

8420037c <Lc_splitter_transition_19>:
    channel_mask = 1<<index;
    if (splitter->active_streams & channel_mask)
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
8420037c:	5c 50       	r2 = r1 LSHIFT -2;
8420037e:	a1 10       	rMAC = r2 AND r0;
84200380:	89 c0       	rMAC = rMAC AND 0x3;
84200382:	d3 61       	if EQ jump (m) Lc_splitter_transition_6;

84200384 <Lc_splitter_transition_20>:
    {
        return INACTIVE;
84200384:	01 00       	rMAC = Null + Null;
84200386:	d8 6f       	jump (m) Lc_splitter_transition_7;

84200388 <Lc_splitter_transition_21>:
}
84200388:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420038a:	d8 4c       	rts;

8420038c <$_splitter_transition_to_inactive>:
/**
 * Transition from any state to INACTIVE.
 *
 */
bool splitter_transition_to_inactive(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
8420038c:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420038e:	16 00       	r4 = r0 + Null;
84200390:	1f 00       	r5 = r1 + Null;
    unsigned data_to_remove;
    unsigned internal_data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];
    unsigned internal_data_after[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];
    patch_fn_shared(splitter);

    if (splitter->finish_last_tag)
84200392:	61 f0 68 82 	rMAC = MBU[r4 + 104];
84200396:	07 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_4;

84200398 <Lc_splitter_transition_to_inactive_2>:
    {
        /* If copying the last tag failed, return failure */
        if (!splitter_finish_copying_last_tag(splitter, output_index))
84200398:	04 f0 2f e1 	call (m) Lc_splitter_finish_copying_last_tag_1;
8420039c:	10 04       	Null = r0 - Null;
8420039e:	03 62       	if NE jump (m) Lc_splitter_transition_to_inactive_4;

842003a0 <Lc_splitter_transition_to_inactive_3>:
        {
            return FALSE;
842003a0:	02 00       	r0 = Null + Null;
842003a2:	39 6e       	jump (m) Lc_splitter_transition_to_inactive_16;

842003a4 <Lc_splitter_transition_to_inactive_4>:
        }
    }

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);
842003a4:	03 11       	r1 = FP + 16;
842003a6:	32 00       	r0 = r4 + Null;
842003a8:	02 f0 3b e0 	call (m) Lc_internal_buffer_data_1;

    /* set the metadata read index and head. */
    splitter->internal_metadata.prev_rd_indexes[output_index] = -1;
842003ac:	7a 54       	r0 = r5 LSHIFT 2;
842003ae:	31 00       	rMAC = r4 + Null;
842003b0:	51 00       	rMAC = r0 + rMAC;
842003b2:	42 24       	r0 = Null - 1;
842003b4:	8a af       	M[rMAC + 88] = r0;
    splitter->internal_metadata.head_tag[output_index] = (metadata_tag *)-1;
842003b6:	42 24       	r0 = Null - 1;
842003b8:	0a be       	M[rMAC + 96] = r0;

    /* Deactivate all output streams with index "output_index". */
    channel = splitter->channel_list;
842003ba:	31 e8       	rMAC = M[r4 + Null];
842003bc:	32 00       	r0 = r4 + Null;
842003be:	43 24       	r1 = Null - 1;
842003c0:	7c 54       	r2 = r5 LSHIFT 2;
842003c2:	ba 00       	r0 = r5 + r0;
842003c4:	24 2a       	r2 = r2 + 24;
842003c6:	12 2a       	r0 = r0 + 24;

842003c8 <Lc_splitter_transition_to_inactive_5>:
    while (channel != NULL)
842003c8:	08 04       	Null = rMAC - Null;
842003ca:	05 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_7;

842003cc <Lc_splitter_transition_to_inactive_6>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
842003cc:	10 ea       	MB[r0 + Null] = Null;
/**
 * Function which invalidates the read position.
 */
static inline void invalidate_read_offset(SPLITTER_CHANNEL_STRUC *channel, unsigned output_index)
{
    channel->internal.read_offset[output_index] = -1;
842003ce:	0b ef       	M[rMAC + r2] = r1;
        set_current_output_state(splitter, output_index, INACTIVE);

        /* For security invalidate the read position.*/
        invalidate_read_offset(channel, output_index);

        channel = channel->next;
842003d0:	09 e8       	rMAC = M[rMAC + Null];
    splitter->internal_metadata.prev_rd_indexes[output_index] = -1;
    splitter->internal_metadata.head_tag[output_index] = (metadata_tag *)-1;

    /* Deactivate all output streams with index "output_index". */
    channel = splitter->channel_list;
    while (channel != NULL)
842003d2:	fb 6f       	jump (m) Lc_splitter_transition_to_inactive_5;

842003d4 <Lc_splitter_transition_to_inactive_7>:

        channel = channel->next;
    }

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_after);
842003d4:	83 11       	r1 = FP + 24;
842003d6:	32 00       	r0 = r4 + Null;
842003d8:	01 f0 2b ef 	call (m) Lc_internal_buffer_data_1;
    /*
     * data_to_remove =
     *    MAX(internal_data_before[0], internal_data_before[1]) -
     *    MAX(internal_data_after[0], internal_data_after[1]);
     */
    data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
842003dc:	27 d8       	r5 = M[FP + 16];
842003de:	29 d8       	rMAC = M[FP + 20];
842003e0:	78 04       	Null = r5 - rMAC;
842003e2:	02 f0 89 e0 	if C jump (m) Lc_splitter_transition_to_inactive_10;

842003e6 <Lc_splitter_transition_to_inactive_8>:
842003e6:	0f 00       	r5 = rMAC + Null;
842003e8:	01 6e       	jump (m) Lc_splitter_transition_to_inactive_10;

842003ea <Lc_splitter_transition_to_inactive_10>:
    data_to_remove = data_to_remove - MAX(internal_data_after[0], internal_data_after[1]);
842003ea:	32 d8       	r0 = M[FP + 24];
842003ec:	39 d8       	rMAC = M[FP + 28];
842003ee:	50 04       	Null = r0 - rMAC;
842003f0:	02 f0 87 e0 	if C jump (m) Lc_splitter_transition_to_inactive_12;

842003f4 <Lc_splitter_transition_to_inactive_11>:
842003f4:	02 6e       	jump (m) Lc_splitter_transition_to_inactive_13;

842003f6 <Lc_splitter_transition_to_inactive_12>:
842003f6:	11 00       	rMAC = r0 + Null;

842003f8 <Lc_splitter_transition_to_inactive_13>:
842003f8:	7f 04       	r5 = r5 - rMAC;
            internal_data_after[0],
            internal_data_before[1],
            internal_data_after[1],
            data_to_remove);
    /* Now remove the data */
    if (data_to_remove !=0)
842003fa:	38 04       	Null = r5 - Null;
842003fc:	0b 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_15;

842003fe <Lc_splitter_transition_to_inactive_14>:
    {
        /* remove the metadata */
        remove_metadata_from_internal(splitter, data_to_remove);
842003fe:	3b 00       	r1 = r5 + Null;
84200400:	32 00       	r0 = r4 + Null;
84200402:	0e f0 21 e4 	call (m) $_remove_metadata_from_internal;
        /* remove the data by copying 0 0 but  removing data */
        unpack_data_from_internal_to_output(splitter, 0, 0, data_to_remove);
84200406:	04 00       	r2 = Null + Null;
84200408:	03 00       	r1 = Null + Null;
8420040a:	3d 00       	r3 = r5 + Null;
8420040c:	32 00       	r0 = r4 + Null;
8420040e:	01 f0 21 e1 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200412 <Lc_splitter_transition_to_inactive_15>:
    }

    return TRUE;
84200412:	42 20       	r0 = Null + 1;

84200414 <Lc_splitter_transition_to_inactive_16>:
}
84200414:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84200416:	d8 4c       	rts;

84200418 <Lc_amount_to_pack_1>:

/**
 * Helper function to calculate the amount to pack/copy to the internal buffer.
 */
static unsigned amount_to_pack(SPLITTER_OP_DATA *splitter)
{
84200418:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420041a:	10 09       	r6 = r0 + Null;
    patch_fn_shared(splitter);

    /* When reframing make sure that the we are not consuming less than
     * the minimum frame size. If in transition do not limit to
     * frame size to make the transition faster.  */
    if (splitter->reframe_enabled && !splitter->in_transition)
8420041c:	81 f0 69 82 	rMAC = MBU[r6 + 105];
84200420:	0e 60       	if EQ jump (m) Lc_amount_to_pack_6;

84200422 <Lc_amount_to_pack_2>:
84200422:	80 f0 07 88 	Null = M[r6 + 28];
84200426:	0b 62       	if NE jump (m) Lc_amount_to_pack_6;

84200428 <Lc_amount_to_pack_3>:
    {
        min_data = splitter->frame_size;
84200428:	89 f0 0b 88 	r7 = M[r6 + 44];
        /* covert the minimum data to octets if needed.*/
        if (splitter->cbuffer.data_size == 1)
8420042c:	81 f0 26 88 	rMAC = M[r6 + 152];
84200430:	48 24       	Null = rMAC - 1;
84200432:	03 62       	if NE jump (m) Lc_amount_to_pack_5;

84200434 <Lc_amount_to_pack_4>:

/** Converts words to octets */
static inline unsigned words_to_octets(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val * ADDR_PER_WORD;
84200434:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;

84200438 <Lc_amount_to_pack_5>:
        {
            min_data = words_to_octets(min_data);
        }
        data_to_pack = min_data;
84200438:	4e 08       	r4 = r7 + Null;
8420043a:	03 6e       	jump (m) Lc_amount_to_pack_7;

8420043c <Lc_amount_to_pack_6>:
    }
    else
    {
        /* If we have less than 1 word or octets just exit. */
        min_data = 1;
8420043c:	09 71       	r7 = Null + 1;
        data_to_pack = UINT_MAX;
8420043e:	46 24       	r4 = Null - 1;

84200440 <Lc_amount_to_pack_7>:
    }

    /* Get the minimum available data for all inputs. */
    channel = splitter->channel_list;
84200440:	87 f0 00 e8 	r5 = M[r6 + Null];
84200444:	16 6e       	jump (m) Lc_amount_to_pack_16;

84200446 <Lc_amount_to_pack_8>:
            {
                /* Exit early if there is not enough data. */
                return 0;
            }
            /* Limit data. */
            data_to_pack = new_data;
84200446:	16 00       	r4 = r0 + Null;

84200448 <Lc_amount_to_pack_9>:
84200448:	a1 f0 06 88 	rMAC = M[r8 + 24];
8420044c:	11 60       	if EQ jump (m) Lc_amount_to_pack_15;

8420044e <Lc_amount_to_pack_10>:
        }
        /* Calculate the minimum available metadata.*/
        if (buff_has_metadata(in))
        {
            new_data = buff_metadata_available_octets(in);
8420044e:	52 08       	r0 = r8 + Null;
84200450:	ff fd a1 f0 	call (m) 0x14756;
84200454:	27 e8 
            if (splitter->cbuffer.data_size == 4)
84200456:	81 f0 26 88 	rMAC = M[r6 + 152];
8420045a:	08 25       	Null = rMAC - 4;
8420045c:	02 62       	if NE jump (m) Lc_amount_to_pack_12;

8420045e <Lc_amount_to_pack_11>:

/** Converts octets to samples. The operation rounds down. */
static inline unsigned octets_to_samples(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val / OCTETS_PER_SAMPLE;
8420045e:	52 50       	r0 = r0 LSHIFT -2;

84200460 <Lc_amount_to_pack_12>:
            {
                new_data = octets_to_samples(new_data);
            }
            if (new_data < data_to_pack)
84200460:	90 05       	Null = r0 - r4;
84200462:	02 f0 8d e0 	if C jump (m) Lc_amount_to_pack_15;

84200466 <Lc_amount_to_pack_13>:
            {
                SPLITTER_MSG2("Splitter: Input limited by the available metadata!"
                        "\n limiting %d to %d", data_to_pack, new_data);
                if (new_data < min_data)
84200466:	9f f2 00 c2 	Null = r0 - r7;
8420046a:	14 64       	if NC jump (m) Lc_amount_to_pack_20;

8420046c <Lc_amount_to_pack_14>:
                {
                    /* Exit early if there is not enough data. */
                    return 0;
                }
                data_to_pack = new_data;
8420046c:	16 00       	r4 = r0 + Null;

8420046e <Lc_amount_to_pack_15>:
            }
        }
        channel = channel->next;
8420046e:	3f e8       	r5 = M[r5 + Null];

84200470 <Lc_amount_to_pack_16>:
    /* Get the minimum available data for all inputs. */
    channel = splitter->channel_list;
    /* We must have at least one channel. */
    SPLITTER_DEBUG_INSTR(PL_ASSERT(channel != NULL));

    while ((channel != NULL) && (data_to_pack != 0))
84200470:	38 04       	Null = r5 - Null;
84200472:	12 60       	if EQ jump (m) Lc_amount_to_pack_21;

84200474 <Lc_amount_to_pack_17>:
84200474:	30 04       	Null = r4 - Null;
84200476:	10 60       	if EQ jump (m) Lc_amount_to_pack_21;

84200478 <Lc_amount_to_pack_18>:
    {
        in = channel->input_buffer;
84200478:	7a f0 02 88 	r8 = M[r5 + 8];

        /* Calculate the minimum available data.*/
        new_data = splitter->cbuffer.data(in);
8420047c:	81 f0 1d 88 	rMAC = M[r6 + 116];
84200480:	52 08       	r0 = r8 + Null;
84200482:	d1 4c       	call rMAC;
        if (new_data < data_to_pack)
84200484:	90 05       	Null = r0 - r4;
84200486:	f2 ff c3 ef 	if C jump (m) Lc_amount_to_pack_9;

8420048a <Lc_amount_to_pack_19>:
        {
            if (new_data < min_data)
8420048a:	9f f2 00 c2 	Null = r0 - r7;
8420048e:	f2 ff b9 ef 	if C jump (m) Lc_amount_to_pack_8;

84200492 <Lc_amount_to_pack_20>:
            {
                /* Exit early if there is not enough data. */
                return 0;
84200492:	02 00       	r0 = Null + Null;
84200494:	1f 6e       	jump (m) Lc_amount_to_pack_29;

84200496 <Lc_amount_to_pack_21>:
/**
 * Returns the space in the metadat buffer.
 */
static inline unsigned get_interal_metadata_space(SPLITTER_OP_DATA *splitter)
{
    unsigned metadata_space_correction = 0;
84200496:	07 00       	r5 = Null + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200498:	82 f0 15 88 	r0 = M[r6 + 84];
    tCbuffer *metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Cbuffer leaves a word free to avoid overlaping read and write
     * pointers while the metadata works with offset. To avoid
     * differences the meadata space needs correction.*/
    if (splitter->tag_size_to_samples)
8420049c:	81 f0 6a 82 	rMAC = MBU[r6 + 106];
842004a0:	08 60       	if EQ jump (m) Lc_amount_to_pack_23;

842004a2 <Lc_amount_to_pack_22>:
    {
        if (splitter->packing == PACKED)
        {
            metadata_space_correction = 1;
842004a2:	81 f0 06 80 	rMAC = MBS[r6 + 6];
842004a6:	07 00       	r5 = Null + Null;
842004a8:	48 24       	Null = rMAC - 1;
842004aa:	20 f0 47 ce 	if EQ r5 = Null + 1;
842004ae:	06 6e       	jump (m) Lc_amount_to_pack_25;

842004b0 <Lc_amount_to_pack_23>:
        else
        {
            metadata_space_correction = 0;
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
842004b0:	81 f0 26 88 	rMAC = M[r6 + 152];
842004b4:	48 24       	Null = rMAC - 1;
842004b6:	02 62       	if NE jump (m) Lc_amount_to_pack_25;

842004b8 <Lc_amount_to_pack_24>:
    {
        metadata_space_correction = 3;
842004b8:	c7 20       	r5 = Null + 3;

842004ba <Lc_amount_to_pack_25>:
    }

    return (buff_metadata_available_space(metadata_buffer) - metadata_space_correction);
842004ba:	ff fd a1 f0 	call (m) 0x1478e;
842004be:	35 e6 
842004c0:	d1 05       	rMAC = r0 - r5;

    /* Calculate the internal space. It is enough to do it for one channel
     * because the internal buffer is synced. Also there is no need to check
     * for the data as we keep this buffer synced with the metadata.*/
    new_data = get_interal_metadata_space(splitter);
    if (new_data < data_to_pack)
842004c2:	88 05       	Null = rMAC - r4;
842004c4:	02 f0 8d e0 	if C jump (m) Lc_amount_to_pack_28;

842004c8 <Lc_amount_to_pack_26>:
    {
        if (new_data < min_data)
842004c8:	9f f1 00 c2 	Null = rMAC - r7;
842004cc:	e3 65       	if NC jump (m) Lc_amount_to_pack_20;

842004ce <Lc_amount_to_pack_27>:
        {
            /* Exit early if there is not enough data. */
            return 0;
        }
        /* Limit data. */
        data_to_pack = new_data;
842004ce:	0e 00       	r4 = rMAC + Null;

842004d0 <Lc_amount_to_pack_28>:
    {
        splitter->internal_buffer_full = FALSE;
#endif
    }

    return data_to_pack;
842004d0:	32 00       	r0 = r4 + Null;

842004d2 <Lc_amount_to_pack_29>:
}
842004d2:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842004d4:	d8 4c       	rts;

842004d6 <Lc_pack_to_internal_1>:

/**
 * Helper function which packs or copies data to the internal buffer.
 */
static void pack_to_internal(SPLITTER_OP_DATA *splitter, unsigned data_to_pack, bool offload_enabled, INT_OP_ID opid)
{
842004d6:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842004d8:	16 00       	r4 = r0 + Null;
842004da:	1f 00       	r5 = r1 + Null;

    /* Transport metadata to the internal buffer. */
    splitter_metadata_transport_to_internal(
            splitter,
            data_to_pack
    );
842004dc:	0c f0 2d e9 	call (m) $_splitter_metadata_transport_to_internal;
    }
    else
#endif
    {
        /* Just call the function directly. */
        pack_to_internal_data_buffer(splitter, data_to_pack);
842004e0:	3b 00       	r1 = r5 + Null;
842004e2:	32 00       	r0 = r4 + Null;
842004e4:	61 4e       	call (m) Lc_pack_to_internal_data_buffer_1;
     * Remove all the data from the internal buffer if both outputs
     * are disabled.
     * TODO make this more efficient by not copying at all, just
     * updating the appropriate pointer.
     */
    if (!splitter->in_transition)
842004e6:	f0 89       	Null = M[r4 + 28];
842004e8:	0e 62       	if NE jump (m) Lc_pack_to_internal_5;

842004ea <Lc_pack_to_internal_2>:
    {
        if ((get_current_output_state(splitter, 0) == INACTIVE)&&
            (get_current_output_state(splitter, 1) == INACTIVE))
842004ea:	31 b0       	rMAC = MBS[r4 + 24];
842004ec:	0c 62       	if NE jump (m) Lc_pack_to_internal_5;

842004ee <Lc_pack_to_internal_3>:
842004ee:	71 b0       	rMAC = MBS[r4 + 25];
842004f0:	0a 62       	if NE jump (m) Lc_pack_to_internal_5;

842004f2 <Lc_pack_to_internal_4>:
        {
            /* remove the metadata */
            remove_metadata_from_internal(splitter, data_to_pack);
842004f2:	3b 00       	r1 = r5 + Null;
842004f4:	32 00       	r0 = r4 + Null;
842004f6:	0d f0 2d ec 	call (m) $_remove_metadata_from_internal;
            /* remove the data by copying 0 0 but  removing data */
            unpack_data_from_internal_to_output(splitter, 0, 0, data_to_pack);
842004fa:	04 00       	r2 = Null + Null;
842004fc:	03 00       	r1 = Null + Null;
842004fe:	3d 00       	r3 = r5 + Null;
84200500:	32 00       	r0 = r4 + Null;
84200502:	96 4e       	call (m) Lc_unpack_data_from_internal_to_output_1;

84200504 <Lc_pack_to_internal_5>:
        }
    }


    return;
}
84200504:	f2 48       	popm <FP, r4, r5, rLink>;
84200506:	d8 4c       	rts;

84200508 <Lc_move_data_from_internal_to_output_1>:

/**
 * Helper function which moves data from the internal buffer to the output buffers
 */
static bool move_data_from_internal_to_output(SPLITTER_OP_DATA *splitter, INT_OP_ID opid)
{
84200508:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420050a:	16 00       	r4 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
8420050c:	72 a9       	r0 = M[r4 + 84];
    unsigned internal_data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];
    unsigned data_to_remove;
    patch_fn_shared(splitter);

    /* bail out early if the internal buffer is empty. */
    if (buff_metadata_available_octets(get_internal_metadata_buffer(splitter)) == 0)
8420050e:	ff fd a1 f0 	call (m) 0x14756;
84200512:	29 e2 
84200514:	10 04       	Null = r0 - Null;
84200516:	03 62       	if NE jump (m) Lc_move_data_from_internal_to_output_3;

84200518 <Lc_move_data_from_internal_to_output_2>:
        {
            splitter->internal_buffer_empty = TRUE;
            SPLITTER_MSG("Splitter: Internal buffer is empty, cannot copy to output!");
        }
#endif
        return FALSE;
84200518:	02 00       	r0 = Null + Null;
8420051a:	44 6e       	jump (m) Lc_move_data_from_internal_to_output_22;

8420051c <Lc_move_data_from_internal_to_output_3>:
    }
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);
8420051c:	83 11       	r1 = FP + 24;
8420051e:	32 00       	r0 = r4 + Null;
84200520:	01 f0 23 e5 	call (m) Lc_internal_buffer_data_1;

    if (MAX(internal_data_before[0], internal_data_before[1]) == 0 )
84200524:	37 d8       	r5 = M[FP + 24];
84200526:	39 d8       	rMAC = M[FP + 28];
84200528:	78 04       	Null = r5 - rMAC;
8420052a:	02 f0 9d e0 	if C jump (m) Lc_move_data_from_internal_to_output_9;

8420052e <Lc_move_data_from_internal_to_output_4>:
8420052e:	0a 00       	r0 = rMAC + Null;

84200530 <Lc_move_data_from_internal_to_output_5>:
        return FALSE;
    }
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    if((splitter->output_state[0] == INACTIVE)&&
       (splitter->output_state[1] == INACTIVE))
84200530:	32 b0       	r0 = MBS[r4 + 24];
84200532:	0e 62       	if NE jump (m) Lc_move_data_from_internal_to_output_11;

84200534 <Lc_move_data_from_internal_to_output_6>:
84200534:	72 b0       	r0 = MBS[r4 + 25];
84200536:	0c 62       	if NE jump (m) Lc_move_data_from_internal_to_output_11;

84200538 <Lc_move_data_from_internal_to_output_7>:
    {
        /* Both of the output streams are inactive. No need to copy to output */
        data_to_move[0] = 0;
84200538:	20 de       	M[FP + 16] = Null;
        data_to_move[1] = 0;
8420053a:	28 de       	M[FP + 20] = Null;
        /* Remove the maximum amount possible. */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
8420053c:	78 04       	Null = r5 - rMAC;
8420053e:	02 f0 8f e0 	if C jump (m) Lc_move_data_from_internal_to_output_10;

84200542 <Lc_move_data_from_internal_to_output_8>:
84200542:	0f 00       	r5 = rMAC + Null;
84200544:	24 6e       	jump (m) Lc_move_data_from_internal_to_output_21;

84200546 <Lc_move_data_from_internal_to_output_9>:
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);

    if (MAX(internal_data_before[0], internal_data_before[1]) == 0 )
84200546:	3a 00       	r0 = r5 + Null;
84200548:	e8 61       	if EQ jump (m) Lc_move_data_from_internal_to_output_2;

8420054a <Lc__ite_17>:
8420054a:	f3 6f       	jump (m) Lc_move_data_from_internal_to_output_5;

8420054c <Lc_move_data_from_internal_to_output_10>:
    {
        /* Both of the output streams are inactive. No need to copy to output */
        data_to_move[0] = 0;
        data_to_move[1] = 0;
        /* Remove the maximum amount possible. */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
8420054c:	20 6e       	jump (m) Lc_move_data_from_internal_to_output_21;

8420054e <Lc_move_data_from_internal_to_output_11>:
                data_to_remove);
    }
    else
    {
        /* Limit the amount to copy to the available data */
        data_to_move[0] = internal_data_before[0];
8420054e:	27 de       	M[FP + 16] = r5;
        data_to_move[1] = internal_data_before[1];
84200550:	29 de       	M[FP + 20] = rMAC;

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);
84200552:	03 11       	r1 = FP + 16;
84200554:	32 00       	r0 = r4 + Null;
84200556:	01 f0 25 e6 	call (m) Lc_limit_data_to_move_1;

        /* Exit early if there is no place to copy. */
        if (MAX(data_to_move[0], data_to_move[1]) == 0 )
8420055a:	22 d8       	r0 = M[FP + 16];
8420055c:	2b d8       	r1 = M[FP + 20];
8420055e:	d0 04       	Null = r0 - r1;
84200560:	02 f0 95 e0 	if C jump (m) Lc_move_data_from_internal_to_output_15;

84200564 <Lc_move_data_from_internal_to_output_12>:
84200564:	19 00       	rMAC = r1 + Null;

84200566 <Lc_move_data_from_internal_to_output_13>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
84200566:	31 d8       	rMAC = M[FP + 24];
84200568:	3c d8       	r2 = M[FP + 28];
8420056a:	08 05       	Null = rMAC - r2;
8420056c:	02 f0 8f e0 	if C jump (m) Lc_move_data_from_internal_to_output_16;

84200570 <Lc_move_data_from_internal_to_output_14>:
84200570:	27 00       	r5 = r2 + Null;
84200572:	05 6e       	jump (m) Lc_move_data_from_internal_to_output_17;

84200574 <Lc_move_data_from_internal_to_output_15>:

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);

        /* Exit early if there is no place to copy. */
        if (MAX(data_to_move[0], data_to_move[1]) == 0 )
84200574:	11 00       	rMAC = r0 + Null;
84200576:	d1 61       	if EQ jump (m) Lc_move_data_from_internal_to_output_2;

84200578 <Lc__ite_18>:
84200578:	f7 6f       	jump (m) Lc_move_data_from_internal_to_output_13;

8420057a <Lc_move_data_from_internal_to_output_16>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
8420057a:	0f 00       	r5 = rMAC + Null;

8420057c <Lc_move_data_from_internal_to_output_17>:
        data_to_remove = data_to_remove -  (
                MAX(internal_data_before[0] - data_to_move[0], internal_data_before[1] - data_to_move[1])
            );
8420057c:	8a 04       	r0 = rMAC - r0;
8420057e:	e1 04       	rMAC = r2 - r1;
84200580:	50 04       	Null = r0 - rMAC;
84200582:	02 f0 87 e0 	if C jump (m) Lc_move_data_from_internal_to_output_19;

84200586 <Lc_move_data_from_internal_to_output_18>:
84200586:	02 6e       	jump (m) Lc_move_data_from_internal_to_output_20;

84200588 <Lc_move_data_from_internal_to_output_19>:
84200588:	11 00       	rMAC = r0 + Null;

8420058a <Lc_move_data_from_internal_to_output_20>:
8420058a:	7f 04       	r5 = r5 - rMAC;

8420058c <Lc_move_data_from_internal_to_output_21>:
                data_to_remove);
    }


    /* copy the metadata to the active output streams */
    splitter_metadata_copy(splitter, data_to_move, data_to_remove);
8420058c:	03 11       	r1 = FP + 16;
8420058e:	3c 00       	r2 = r5 + Null;
84200590:	32 00       	r0 = r4 + Null;
84200592:	0d f0 27 e2 	call (m) $_splitter_metadata_copy;
    }
    else
#endif
    {
        /* Time to unpack/copy the data from the internal to the output */
        unpack_data_from_internal_to_output(splitter, data_to_move[0], data_to_move[1], data_to_remove);
84200596:	2c d8       	r2 = M[FP + 20];
84200598:	23 d8       	r1 = M[FP + 16];
8420059a:	3d 00       	r3 = r5 + Null;
8420059c:	32 00       	r0 = r4 + Null;
8420059e:	48 4e       	call (m) Lc_unpack_data_from_internal_to_output_1;
    }

    return TRUE;
842005a0:	42 20       	r0 = Null + 1;

842005a2 <Lc_move_data_from_internal_to_output_22>:

}
842005a2:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842005a4:	d8 4c       	rts;

842005a6 <Lc_pack_to_internal_data_buffer_1>:

/**
 * Helper function which packs for all channels to the internal buffer.
 */
static void pack_to_internal_data_buffer(SPLITTER_OP_DATA *splitter, unsigned data_to_pack)
{
842005a6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842005a8:	10 09       	r6 = r0 + Null;
842005aa:	1f 00       	r5 = r1 + Null;
            "data_pack = %d ",
            data_to_pack);
#endif

#ifdef INSTALL_EXTERNAL_MEM
    if (splitter->location == SRAM)
842005ac:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842005b0:	48 24       	Null = rMAC - 1;
842005b2:	06 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_3;

842005b4 <Lc_pack_to_internal_data_buffer_2>:
    {
        /* Get access to the SRAM.*/
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
842005b4:	03 00       	r1 = Null + Null;
842005b6:	02 00       	r0 = Null + Null;
842005b8:	ff fd b0 f0 	call (m) 0x16718;
842005bc:	21 eb 

842005be <Lc_pack_to_internal_data_buffer_3>:
    }
#endif

    channel = splitter->channel_list;
842005be:	86 f0 00 e8 	r4 = M[r6 + Null];
842005c2:	02 6e       	jump (m) Lc_pack_to_internal_data_buffer_5;

842005c4 <Lc_pack_to_internal_data_buffer_4>:
    {
        /* Pack to the internal data buffer which can be located
         * in the sram or internally in the dsp. */
        pack_to_data_buffer(splitter, channel, data_to_pack);

        channel = channel->next;
842005c4:	36 e8       	r4 = M[r4 + Null];

842005c6 <Lc_pack_to_internal_data_buffer_5>:
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
    }
#endif

    channel = splitter->channel_list;
    while (channel != NULL)
842005c6:	30 04       	Null = r4 - Null;
842005c8:	0c 60       	if EQ jump (m) Lc_pack_to_internal_data_buffer_8;

842005ca <Lc_pack_to_internal_data_buffer_6>:
static inline void pack_to_data_buffer(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned data_to_pack)
{
    unsigned packed;
    patch_fn_shared(splitter);

    tCbuffer *in = channel->input_buffer;
842005ca:	b3 88       	r1 = M[r4 + 8];

    /* Select the correct interface */
    if (splitter->location == INTERNAL)
842005cc:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842005d0:	14 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_11;

842005d2 <Lc_pack_to_internal_data_buffer_7>:
    {
        tCbuffer *internal = channel->internal.buffer.dsp;
842005d2:	72 89       	r0 = M[r4 + 20];
        packed = splitter->cbuffer.pack(internal, in, data_to_pack);
842005d4:	81 f0 1f 88 	rMAC = M[r6 + 124];
842005d8:	3c 00       	r2 = r5 + Null;
842005da:	d1 4c       	call rMAC;
842005dc:	13 00       	r1 = r0 + Null;
842005de:	13 6e       	jump (m) Lc_pack_to_internal_data_buffer_12;

842005e0 <Lc_pack_to_internal_data_buffer_8>:

        channel = channel->next;
    }

#ifdef INSTALL_EXTERNAL_MEM
    if (splitter->location == SRAM)
842005e0:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842005e4:	48 24       	Null = rMAC - 1;
842005e6:	05 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_10;

842005e8 <Lc_pack_to_internal_data_buffer_9>:
    {
        /* Release the SRAM */
        extmem_unlock(EXTMEM_SPI_RAM);
842005e8:	02 00       	r0 = Null + Null;
842005ea:	ff fd b0 f0 	call (m) 0x16790;
842005ee:	27 ed 

842005f0 <Lc_pack_to_internal_data_buffer_10>:
    }
#endif

    /* It is necessary to kick back whenever data is consumed so
     * so we can make full use of the internal buffer. */
    splitter->kick_backward = TRUE;
842005f0:	41 20       	rMAC = Null + 1;
842005f2:	81 f0 6c 8a 	MB[r6 + 108] = rMAC;
842005f6:	1a 6e       	jump (m) Lc_pack_to_internal_data_buffer_16;

842005f8 <Lc_pack_to_internal_data_buffer_11>:
        packed = splitter->cbuffer.pack(internal, in, data_to_pack);
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        EXT_BUFFER * internal = channel->internal.buffer.sram;
842005f8:	72 89       	r0 = M[r4 + 20];
        packed = splitter->cbuffer.sram_pack(internal, in, data_to_pack);
842005fa:	81 f0 23 88 	rMAC = M[r6 + 140];
842005fe:	3c 00       	r2 = r5 + Null;
84200600:	d1 4c       	call rMAC;
84200602:	13 00       	r1 = r0 + Null;

84200604 <Lc_pack_to_internal_data_buffer_12>:
    }
    /* If the amount of data pack is different to then
     * amount_to_pack is incorrect or another error occurred.
     * There is no reason handling this case because it will
     * cause metadata problems further down the chain. */
    if (packed != data_to_pack)
84200604:	d8 05       	Null = r1 - r5;
84200606:	df 61       	if EQ jump (m) Lc_pack_to_internal_data_buffer_4;

84200608 <Lc_pack_to_internal_data_buffer_13>:
    {
        SPLITTER_ERRORMSG1("Splitter Only packed = %d!",
                packed);
84200608:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420060c:	08 24       	Null = rMAC - 0;
8420060e:	07 6c       	if LE jump (m) Lc_pack_to_internal_data_buffer_15;

84200610 <Lc_pack_to_internal_data_buffer_14>:
84200610:	55 f1 02 f0 	r0 = Null + 357564416;
84200614:	00 40 
84200616:	ff fd 05 f0 	call (m) 0x10c2;
8420061a:	2d e5 

8420061c <Lc_pack_to_internal_data_buffer_15>:
    }
    PL_ASSERT(packed == data_to_pack);
8420061c:	03 f0 9d 41 	r1 = Null + 413;
84200620:	02 f0 13 60 	r0 = Null + 4115;
84200624:	ff fd b2 f0 	call (m) 0x16bdc;
84200628:	39 ed 

8420062a <Lc_pack_to_internal_data_buffer_16>:
#ifdef SPLITTER_OFFLOAD
    /* Processing finished! */
    splitter->buffer_access = FALSE;
    SPLITTER_MSG("Splitter: pack_to_internal_cbuffer finished");
#endif
}
8420062a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420062c:	d8 4c       	rts;

8420062e <Lc_unpack_data_from_internal_to_output_1>:

/**
 * Helper function to copy/unpack from the internal to the output.
 */
static void unpack_data_from_internal_to_output(SPLITTER_OP_DATA *splitter, unsigned data_0, unsigned data_1, unsigned data_to_remove)
{
8420062e:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200630:	4c 4c       	SP = SP + 48;
84200632:	13 09       	r9 = r0 + Null;
84200634:	43 de       	M[FP + 32] = r1;
84200636:	4c de       	M[FP + 36] = r2;
84200638:	55 de       	M[FP + 40] = r3;
    splitter->buffer_access = TRUE;
#endif


#ifdef INSTALL_EXTERNAL_MEM
    if (splitter->location == SRAM)
8420063a:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
8420063e:	48 24       	Null = rMAC - 1;
84200640:	06 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_3;

84200642 <Lc_unpack_data_from_internal_to_output_2>:
    {
        /* Get access to the SRAM.*/
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
84200642:	03 00       	r1 = Null + Null;
84200644:	02 00       	r0 = Null + Null;
84200646:	ff fd b0 f0 	call (m) 0x16718;
8420064a:	33 e6 

8420064c <Lc_unpack_data_from_internal_to_output_3>:
    }
#endif
    /* Time to unpack/copy the data from the internal to the output */
    channel = splitter->channel_list;
8420064c:	b1 f0 00 e8 	rMAC = M[r9 + Null];
84200650:	59 de       	M[FP + 44] = rMAC;
84200652:	14 6e       	jump (m) Lc_unpack_data_from_internal_to_output_9;

84200654 <Lc_unpack_data_from_internal_to_output_4>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
84200654:	63 d8       	r1 = M[FP + 48];
84200656:	6a d8       	r0 = M[FP + 52];
84200658:	ff fd 06 f0 	call (m) 0x133e;
8420065c:	27 e7 

8420065e <Lc_unpack_data_from_internal_to_output_5>:
    while (channel != NULL)
    {
        unpack_from_data_buffer(splitter, channel, data_0, data_1);

        if (data_to_remove)
8420065e:	51 d8       	rMAC = M[FP + 40];
84200660:	0a 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_8;

84200662 <Lc_unpack_data_from_internal_to_output_6>:
 * Function discards data from the internal data buffer.
 */
static inline void remove_from_data_buffer(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned data_to_remove)
{
    /* Select the correct interface */
    if (splitter->location == INTERNAL)
84200662:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200666:	a4 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_39;

84200668 <Lc_unpack_data_from_internal_to_output_7>:
    {
        splitter->cbuffer.discard(channel->internal.buffer.dsp, data_to_remove);
84200668:	b1 f0 21 88 	rMAC = M[r9 + 132];
8420066c:	5a d8       	r0 = M[FP + 44];
8420066e:	52 89       	r0 = M[r0 + 20];
84200670:	53 d8       	r1 = M[FP + 40];
84200672:	d1 4c       	call rMAC;

84200674 <Lc_unpack_data_from_internal_to_output_8>:
            /* Discard the unused data. */
            remove_from_data_buffer(splitter, channel, data_to_remove);
        }

        /* Move to next channel. */
        channel = channel->next;
84200674:	59 d8       	rMAC = M[FP + 44];
84200676:	09 e8       	rMAC = M[rMAC + Null];
84200678:	59 de       	M[FP + 44] = rMAC;

8420067a <Lc_unpack_data_from_internal_to_output_9>:
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
    }
#endif
    /* Time to unpack/copy the data from the internal to the output */
    channel = splitter->channel_list;
    while (channel != NULL)
8420067a:	59 d8       	rMAC = M[FP + 44];
8420067c:	12 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_12;

8420067e <Lc_unpack_data_from_internal_to_output_10>:
    data_buffer_t internal;
    unsigned read_offset;
    unsigned i;
    patch_fn_shared(splitter);

    internal = channel->internal.buffer;
8420067e:	5b d8       	r1 = M[FP + 44];
84200680:	59 89       	rMAC = M[r1 + 20];
84200682:	81 de       	M[FP + 64] = rMAC;
 * Returns the read offset of the internal buffer.
 */
static inline unsigned get_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer)
{

    if (splitter->location == INTERNAL)
84200684:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200688:	85 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_37;

8420068a <Lc_unpack_data_from_internal_to_output_11>:
    {
        unsigned int offset, ret_val;
        tCbuffer *cbuffer = buffer->dsp;
8420068a:	82 d8       	r0 = M[FP + 64];
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
8420068c:	d6 88       	r4 = M[r0 + 12];

        ret_val = (unsigned int)(uintptr_t)cbuffer_get_read_address_ex(cbuffer, &offset) - base_addr;
8420068e:	83 13       	r1 = FP + 56;
84200690:	ff fd 85 f2 	call (m) 0x5124a;
84200694:	3b ed 
84200696:	91 05       	rMAC = r0 - r4;
        ret_val += offset;
84200698:	72 d8       	r0 = M[FP + 56];
8420069a:	51 00       	rMAC = r0 + rMAC;
        return ret_val;
8420069c:	61 de       	M[FP + 48] = rMAC;
8420069e:	7f 6e       	jump (m) Lc_unpack_data_from_internal_to_output_38;

842006a0 <Lc_unpack_data_from_internal_to_output_12>:
        /* Move to next channel. */
        channel = channel->next;
    }/* END of channel loop. */

#ifdef INSTALL_EXTERNAL_MEM
    if (splitter->location == SRAM)
842006a0:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
842006a4:	48 24       	Null = rMAC - 1;
842006a6:	05 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_14;

842006a8 <Lc_unpack_data_from_internal_to_output_13>:
    {
        /* Release the SRAM */
        extmem_unlock(EXTMEM_SPI_RAM);
842006a8:	02 00       	r0 = Null + Null;
842006aa:	ff fd b0 f0 	call (m) 0x16790;
842006ae:	27 e7 

842006b0 <Lc_unpack_data_from_internal_to_output_14>:
    }
#endif

    /* It is necessary to kick forward whenever data is produced. */
    splitter->kick_forward = TRUE;
842006b0:	41 20       	rMAC = Null + 1;
842006b2:	b1 f0 6b 8a 	MB[r9 + 107] = rMAC;
842006b6:	83 6e       	jump (m) Lc_unpack_data_from_internal_to_output_40;

842006b8 <Lc_unpack_data_from_internal_to_output_15>:

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
    {
        unsigned data;
        /* Select the channel. */
        if (i==0)
842006b8:	0f fa 00 c2 	Null = r8 - Null;
842006bc:	03 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_17;

842006be <Lc_unpack_data_from_internal_to_output_16>:
        {
            data = data_0;
842006be:	46 d8       	r4 = M[FP + 32];
842006c0:	02 6e       	jump (m) Lc_unpack_data_from_internal_to_output_18;

842006c2 <Lc_unpack_data_from_internal_to_output_17>:
        }
        else
        {
            data = data_1;
842006c2:	4e d8       	r4 = M[FP + 36];

842006c4 <Lc_unpack_data_from_internal_to_output_18>:
        }

        /* Check if anythings needs to be done for the output stream*/
        if ((data != 0) && (get_current_output_state(splitter, i) == ACTIVE))
842006c4:	30 04       	Null = r4 - Null;
842006c6:	52 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_34;

842006c8 <Lc_unpack_data_from_internal_to_output_19>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842006c8:	b1 f0 18 20 	rMAC = r9 + 24;
842006cc:	11 f0 0a e0 	rMAC = MBS[rMAC + r8];
842006d0:	48 24       	Null = rMAC - 1;
842006d2:	4c 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_34;

842006d4 <Lc_unpack_data_from_internal_to_output_20>:
        {
            tCbuffer *out = channel->output_buffer[i];
            PL_ASSERT(out != NULL);
842006d4:	97 f3 fd b9 	r5 = M[r7 + -12];
842006d8:	09 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_22;

842006da <Lc_unpack_data_from_internal_to_output_21>:
842006da:	03 f0 a5 42 	r1 = Null + 677;
842006de:	02 f0 13 60 	r0 = Null + 4115;
842006e2:	ff fd b2 f0 	call (m) 0x16bdc;
842006e6:	3b e7 
842006e8:	27 6e       	jump (m) Lc_unpack_data_from_internal_to_output_28;

842006ea <Lc_unpack_data_from_internal_to_output_22>:

            /* Set up the internal buffer read pointers!*/
            set_buffer_rd_offset(splitter, &internal, channel->internal.read_offset[i]);
842006ea:	93 f0 00 e8 	r1 = M[r7 + Null];
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
842006ee:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
842006f2:	0c 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_24;

842006f4 <Lc_unpack_data_from_internal_to_output_23>:
    {
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
842006f4:	81 f0 03 88 	rMAC = M[r6 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
842006f8:	9c c0       	r2 = r1 AND 0x3;
842006fa:	59 00       	rMAC = r1 + rMAC;
842006fc:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
84200700:	42 08       	r0 = r6 + Null;
84200702:	ff fd 86 f2 	call (m) 0x513de;
84200706:	3d e6 
84200708:	05 6e       	jump (m) Lc_unpack_data_from_internal_to_output_25;

8420070a <Lc_unpack_data_from_internal_to_output_24>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
8420070a:	6a d8       	r0 = M[FP + 52];
8420070c:	ff fd 06 f0 	call (m) 0x133e;
84200710:	33 e1 

84200712 <Lc_unpack_data_from_internal_to_output_25>:

            /* Select the correct interface */
            if (splitter->location == INTERNAL)
84200712:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200716:	10 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_28;

84200718 <Lc_unpack_data_from_internal_to_output_26>:
            {
                unsigned unpacked;
                /* Unpack/copy the data to the output. */
                unpacked = splitter->cbuffer.unpack(out, internal.dsp, data);
84200718:	b1 f0 20 88 	rMAC = M[r9 + 128];
8420071c:	34 00       	r2 = r4 + Null;
8420071e:	43 08       	r1 = r6 + Null;
84200720:	3a 00       	r0 = r5 + Null;
84200722:	d1 4c       	call rMAC;
                /* If not all data could be unpacked something went wrong. */
                PL_ASSERT(unpacked == data);
84200724:	90 05       	Null = r0 - r4;
84200726:	0e 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_30;

84200728 <Lc_unpack_data_from_internal_to_output_27>:
84200728:	03 f0 b1 42 	r1 = Null + 689;
8420072c:	02 f0 13 60 	r0 = Null + 4115;
84200730:	ff fd b2 f0 	call (m) 0x16bdc;
84200734:	2d e5 

84200736 <Lc_unpack_data_from_internal_to_output_28>:
            }
            else
            {
#ifdef INSTALL_EXTERNAL_MEM
                /* Unpack the data to the output. */
                splitter->cbuffer.sram_unpack(out, internal.sram, data);
84200736:	b1 f0 24 88 	rMAC = M[r9 + 144];
8420073a:	34 00       	r2 = r4 + Null;
8420073c:	3a 00       	r0 = r5 + Null;
8420073e:	6b d8       	r1 = M[FP + 52];
84200740:	d1 4c       	call rMAC;

84200742 <Lc_unpack_data_from_internal_to_output_30>:
 * Returns the read offset of the internal buffer.
 */
static inline unsigned get_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer)
{

    if (splitter->location == INTERNAL)
84200742:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200746:	0c 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_32;

84200748 <Lc_unpack_data_from_internal_to_output_31>:
    {
        unsigned int offset, ret_val;
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
84200748:	86 f0 03 88 	r4 = M[r6 + 12];

        ret_val = (unsigned int)(uintptr_t)cbuffer_get_read_address_ex(cbuffer, &offset) - base_addr;
8420074c:	c3 13       	r1 = FP + 60;
8420074e:	42 08       	r0 = r6 + Null;
84200750:	ff fd 85 f2 	call (m) 0x5124a;
84200754:	3b e7 
84200756:	92 05       	r0 = r0 - r4;
        ret_val += offset;
84200758:	79 d8       	rMAC = M[FP + 60];
8420075a:	8a 00       	r0 = rMAC + r0;
        return ret_val;
8420075c:	05 6e       	jump (m) Lc_unpack_data_from_internal_to_output_33;

8420075e <Lc_unpack_data_from_internal_to_output_32>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        return ext_buffer_get_read_offset(buffer->sram);
8420075e:	6a d8       	r0 = M[FP + 52];
84200760:	ff fd 05 f0 	call (m) 0x12fe;
84200764:	3f ec 

84200766 <Lc_unpack_data_from_internal_to_output_33>:
        PL_ASSERT(splitter->location == INTERNAL);
        /* Stop the compiler complaining */
        return 0;
#endif
    }
}
84200766:	92 f0 00 ee 	M[r7 + Null] = r0;

8420076a <Lc_unpack_data_from_internal_to_output_34>:
    patch_fn_shared(splitter);

    internal = channel->internal.buffer;
    read_offset = get_buffer_rd_offset(splitter, &internal);

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420076a:	0a 75       	r8 = r8 + 1;
8420076c:	21 75       	r7 = r7 + 4;
8420076e:	a0 f0 02 24 	Null = r8 - 2;
84200772:	a3 65       	if NC jump (m) Lc_unpack_data_from_internal_to_output_15;

84200774 <Lc_unpack_data_from_internal_to_output_35>:
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
84200774:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200778:	6e 63       	if NE jump (m) Lc_unpack_data_from_internal_to_output_4;

8420077a <Lc_unpack_data_from_internal_to_output_36>:
    {
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
8420077a:	81 f0 03 88 	rMAC = M[r6 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
8420077e:	62 d8       	r0 = M[FP + 48];
84200780:	94 c0       	r2 = r0 AND 0x3;
84200782:	51 00       	rMAC = r0 + rMAC;
84200784:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
84200788:	42 08       	r0 = r6 + Null;
8420078a:	ff fd 86 f2 	call (m) 0x513de;
8420078e:	35 e2 
84200790:	67 6f       	jump (m) Lc_unpack_data_from_internal_to_output_5;

84200792 <Lc_unpack_data_from_internal_to_output_37>:
        return ret_val;
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        return ext_buffer_get_read_offset(buffer->sram);
84200792:	82 d8       	r0 = M[FP + 64];
84200794:	ff fd 05 f0 	call (m) 0x12fe;
84200798:	2b eb 
8420079a:	62 de       	M[FP + 48] = r0;

8420079c <Lc_unpack_data_from_internal_to_output_38>:
8420079c:	e8 f0 10 88 	r6 = M[FP + 64];
842007a0:	81 d8       	rMAC = M[FP + 64];
842007a2:	69 de       	M[FP + 52] = rMAC;
842007a4:	02 09       	r8 = Null + Null;
842007a6:	59 d8       	rMAC = M[FP + 44];
842007a8:	19 f0 18 20 	r7 = rMAC + 24;
842007ac:	89 6f       	jump (m) Lc_unpack_data_from_internal_to_output_16;

842007ae <Lc_unpack_data_from_internal_to_output_39>:
        splitter->cbuffer.discard(channel->internal.buffer.dsp, data_to_remove);
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        splitter->cbuffer.sram_discard(channel->internal.buffer.sram, data_to_remove);
842007ae:	b1 f0 25 88 	rMAC = M[r9 + 148];
842007b2:	5a d8       	r0 = M[FP + 44];
842007b4:	52 89       	r0 = M[r0 + 20];
842007b6:	53 d8       	r1 = M[FP + 40];
842007b8:	d1 4c       	call rMAC;
842007ba:	5d 6f       	jump (m) Lc_unpack_data_from_internal_to_output_8;

842007bc <Lc_unpack_data_from_internal_to_output_40>:
#ifdef SPLITTER_OFFLOAD
    /* Processing finished! */
    splitter->buffer_access = FALSE;
    SPLITTER_MSG("Splitter Upack/copy finished");
#endif
}
842007bc:	74 4c       	SP = SP + -48;
842007be:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842007c0:	d8 4c       	rts;

842007c2 <Lc_internal_buffer_data_1>:

/**
 * Helper function to get the amount of data per output streams.
 */
static void internal_buffer_data(SPLITTER_OP_DATA *splitter, unsigned *data)
{
842007c2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842007c4:	16 00       	r4 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
842007c6:	6a f0 15 88 	r8 = M[r4 + 84];
    patch_fn_shared(splitter);

    metadata_bufffer = get_internal_metadata_buffer(splitter);

    /* Save the read pointer */
    before_prev_rd_indexes = metadata_bufffer->metadata->prev_rd_index;
842007ca:	a1 f0 06 88 	rMAC = M[r8 + 24];
842007ce:	1b f0 03 88 	r9 = M[rMAC + 12];
    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842007d2:	07 00       	r5 = Null + Null;
842007d4:	18 09       	r6 = r1 + Null;
842007d6:	69 f0 58 20 	r7 = r4 + 88;

842007da <Lc_internal_buffer_data_2>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842007da:	31 2a       	rMAC = r4 + 24;
    {
        output_state = get_current_output_state(splitter, i);
        if (output_state == INACTIVE)
842007dc:	c9 e1       	rMAC = MBS[rMAC + r5];
842007de:	04 62       	if NE jump (m) Lc_internal_buffer_data_4;

842007e0 <Lc_internal_buffer_data_3>:
        {
            /* Inactive channels discards data instantaneously.*/
            data[i] = 0;
842007e0:	80 f0 00 ee 	M[r6 + Null] = Null;
842007e4:	10 6e       	jump (m) Lc_internal_buffer_data_7;

842007e6 <Lc_internal_buffer_data_4>:
        }
        else if ((output_state == ACTIVE) || (output_state == HOLD))
842007e6:	48 24       	Null = rMAC - 1;
842007e8:	03 60       	if EQ jump (m) Lc_internal_buffer_data_6;

842007ea <Lc_internal_buffer_data_5>:
842007ea:	88 24       	Null = rMAC - 2;
842007ec:	0c 62       	if NE jump (m) Lc_internal_buffer_data_7;

842007ee <Lc_internal_buffer_data_6>:
        {
            /* Set up the internal buffer metadata read indexes!*/
            metadata_bufffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[i];
842007ee:	91 f0 00 e8 	rMAC = M[r7 + Null];
842007f2:	a2 f0 06 88 	r0 = M[r8 + 24];
842007f6:	d1 8e       	M[r0 + 12] = rMAC;

            SPLITTER_MSG2("Splitter internal_buffer_data output index %d  available meta data 0x%08x  ",
                    i, buff_metadata_available_octets(metadata_bufffer));
            /* The internal buffer is always synchronised with the metadata
             * so there is no need to check both data and metadata. */
            data[i] = buff_metadata_available_octets(metadata_bufffer);
842007f8:	52 08       	r0 = r8 + Null;
842007fa:	ff fd 9f f0 	call (m) 0x14756;
842007fe:	3d ea 
84200800:	82 f0 00 ee 	M[r6 + Null] = r0;

84200804 <Lc_internal_buffer_data_7>:

    metadata_bufffer = get_internal_metadata_buffer(splitter);

    /* Save the read pointer */
    before_prev_rd_indexes = metadata_bufffer->metadata->prev_rd_index;
    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200804:	7f 20       	r5 = r5 + 1;
84200806:	20 75       	r6 = r6 + 4;
84200808:	21 75       	r7 = r7 + 4;
8420080a:	b8 24       	Null = r5 - 2;
8420080c:	e7 65       	if NC jump (m) Lc_internal_buffer_data_2;

8420080e <Lc_internal_buffer_data_8>:
            /* The internal buffer is always synchronised with the metadata
             * so there is no need to check both data and metadata. */
            data[i] = buff_metadata_available_octets(metadata_bufffer);
        }
    }/* END of output for loop. */
    metadata_bufffer->metadata->prev_rd_index = before_prev_rd_indexes;
8420080e:	a1 f0 06 88 	rMAC = M[r8 + 24];
84200812:	1b f0 03 8e 	M[rMAC + 12] = r9;

84200816 <Lc_internal_buffer_data_9>:
}
84200816:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200818:	d8 4c       	rts;

8420081a <Lc_limit_data_to_move_1>:
/**
 * Helper function to limit the amount of data per output streams which will
 * be unpacked/copied to the output buffers.
 */
static void limit_data_to_move(SPLITTER_OP_DATA *splitter, unsigned *data)
{
8420081a:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420081c:	17 00       	r5 = r0 + Null;
8420081e:	43 de       	M[FP + 32] = r1;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200820:	79 a9       	rMAC = M[r5 + 84];
84200822:	49 de       	M[FP + 36] = rMAC;
    SPLITTER_OUTPUT_STATE output_state;
    patch_fn_shared(splitter);

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* Limit the data based on the output space. */
    channel = splitter->channel_list;
84200824:	39 e8       	rMAC = M[r5 + Null];
84200826:	51 de       	M[FP + 40] = rMAC;
84200828:	10 6e       	jump (m) Lc_limit_data_to_move_5;

8420082a <Lc_limit_data_to_move_2>:
                    /* Leave three more words in case we are connected to a SBC decode.*/
                    data[i] = splitter->frame_size - space + 3;
                }
                else
                {
                    data[i] = 0;
8420082a:	30 ee       	M[r4 + Null] = Null;

8420082c <Lc_limit_data_to_move_3>:
    while (channel != NULL)
    {
        /* Save the read pointer */
        before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420082c:	08 75       	r6 = r6 + 1;
8420082e:	23 75       	r9 = r9 + 4;
84200830:	36 21       	r4 = r4 + 4;
84200832:	22 75       	r8 = r8 + 4;
84200834:	80 f0 02 24 	Null = r6 - 2;
84200838:	15 64       	if NC jump (m) Lc_limit_data_to_move_7;

8420083a <Lc_limit_data_to_move_4>:
                }
            }

        }/* END of output for loop. */

        metadata_buffer->metadata->prev_rd_index = before_prev_rd_indexes;
8420083a:	49 d8       	rMAC = M[FP + 36];
8420083c:	5a d8       	r0 = M[FP + 44];
8420083e:	89 89       	rMAC = M[rMAC + 24];
84200840:	ca 8e       	M[rMAC + 12] = r0;

        /* Move to next channel. */
        channel = channel->next;
84200842:	51 d8       	rMAC = M[FP + 40];
84200844:	09 e8       	rMAC = M[rMAC + Null];
84200846:	51 de       	M[FP + 40] = rMAC;

84200848 <Lc_limit_data_to_move_5>:
    patch_fn_shared(splitter);

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* Limit the data based on the output space. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200848:	51 d8       	rMAC = M[FP + 40];
8420084a:	4c 60       	if EQ jump (m) Lc_limit_data_to_move_21;

8420084c <Lc_limit_data_to_move_6>:
    {
        /* Save the read pointer */
        before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;
8420084c:	49 d8       	rMAC = M[FP + 36];
8420084e:	89 89       	rMAC = M[rMAC + 24];
84200850:	c9 88       	rMAC = M[rMAC + 12];
84200852:	59 de       	M[FP + 44] = rMAC;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200854:	00 09       	r6 = Null + Null;
84200856:	51 d8       	rMAC = M[FP + 40];
84200858:	46 d8       	r4 = M[FP + 32];
8420085a:	7a f0 58 20 	r8 = r5 + 88;
8420085e:	1b f0 0c 20 	r9 = rMAC + 12;

84200862 <Lc_limit_data_to_move_7>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200862:	39 2a       	rMAC = r5 + 24;
84200864:	11 f0 08 e0 	rMAC = MBS[rMAC + r6];
        {
            output_state = get_current_output_state(splitter, i);
            /* Inactive and hold output streams need no limiting. */
            if (output_state == ACTIVE)
84200868:	48 24       	Null = rMAC - 1;
8420086a:	18 62       	if NE jump (m) Lc_limit_data_to_move_14;

8420086c <Lc_limit_data_to_move_8>:
            {
                unsigned space;
                tCbuffer *output = channel->output_buffer[i];
8420086c:	b9 f0 00 e8 	r7 = M[r9 + Null];

                space = splitter->cbuffer.unpacked_space(output);
84200870:	39 b9       	rMAC = M[r5 + 112];
84200872:	4a 08       	r0 = r7 + Null;
84200874:	d1 4c       	call rMAC;
                data[i] = MIN(data[i], space);
84200876:	2f f6 00 c3 	Null = M[r4] - r0;
8420087a:	02 64       	if NC jump (m) Lc_limit_data_to_move_10;

8420087c <Lc_limit_data_to_move_9>:
8420087c:	32 ee       	M[r4 + Null] = r0;

8420087e <Lc_limit_data_to_move_10>:
                /* Now limit to the available metadata. */
                space = buff_metadata_available_space(output);
8420087e:	4a 08       	r0 = r7 + Null;
84200880:	ff fd 9f f0 	call (m) 0x1478e;
84200884:	2f e8 
                if (splitter->cbuffer.data_size == 4)
84200886:	71 f0 26 88 	rMAC = M[r5 + 152];
8420088a:	08 25       	Null = rMAC - 4;
8420088c:	02 62       	if NE jump (m) Lc_limit_data_to_move_12;

8420088e <Lc_limit_data_to_move_11>:

/** Converts octets to samples. The operation rounds down. */
static inline unsigned octets_to_samples(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val / OCTETS_PER_SAMPLE;
8420088e:	52 50       	r0 = r0 LSHIFT -2;

84200890 <Lc_limit_data_to_move_12>:
                {
                    space = octets_to_samples(space);
                }
                data[i] = MIN(data[i], space);
84200890:	2f f6 00 c3 	Null = M[r4] - r0;
84200894:	cc 65       	if NC jump (m) Lc_limit_data_to_move_3;

84200896 <Lc_limit_data_to_move_13>:
84200896:	32 ee       	M[r4 + Null] = r0;
84200898:	ca 6f       	jump (m) Lc_limit_data_to_move_3;

8420089a <Lc_limit_data_to_move_14>:
            }
            else if (output_state == HOLD)
8420089a:	88 24       	Null = rMAC - 2;
8420089c:	c8 63       	if NE jump (m) Lc_limit_data_to_move_3;

8420089e <Lc_limit_data_to_move_15>:
            {
                unsigned space;
                /* Set up the internal buffer metadata read indexes!*/
                metadata_buffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[i];
8420089e:	a1 f0 00 e8 	rMAC = M[r8 + Null];
842008a2:	4a d8       	r0 = M[FP + 36];
842008a4:	92 89       	r0 = M[r0 + 24];
842008a6:	d1 8e       	M[r0 + 12] = rMAC;
/**
 * Returns the space in the metadat buffer.
 */
static inline unsigned get_interal_metadata_space(SPLITTER_OP_DATA *splitter)
{
    unsigned metadata_space_correction = 0;
842008a8:	01 09       	r7 = Null + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
842008aa:	7a a9       	r0 = M[r5 + 84];
    tCbuffer *metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Cbuffer leaves a word free to avoid overlaping read and write
     * pointers while the metadata works with offset. To avoid
     * differences the meadata space needs correction.*/
    if (splitter->tag_size_to_samples)
842008ac:	71 f0 6a 82 	rMAC = MBU[r5 + 106];
842008b0:	07 60       	if EQ jump (m) Lc_limit_data_to_move_17;

842008b2 <Lc_limit_data_to_move_16>:
    {
        if (splitter->packing == PACKED)
        {
            metadata_space_correction = 1;
842008b2:	b9 81       	rMAC = MBS[r5 + 6];
842008b4:	01 09       	r7 = Null + Null;
842008b6:	48 24       	Null = rMAC - 1;
842008b8:	20 f0 49 ce 	if EQ r7 = Null + 1;
842008bc:	06 6e       	jump (m) Lc_limit_data_to_move_19;

842008be <Lc_limit_data_to_move_17>:
        else
        {
            metadata_space_correction = 0;
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
842008be:	71 f0 26 88 	rMAC = M[r5 + 152];
842008c2:	48 24       	Null = rMAC - 1;
842008c4:	02 62       	if NE jump (m) Lc_limit_data_to_move_19;

842008c6 <Lc_limit_data_to_move_18>:
    {
        metadata_space_correction = 3;
842008c6:	19 71       	r7 = Null + 3;

842008c8 <Lc_limit_data_to_move_19>:
    }

    return (buff_metadata_available_space(metadata_buffer) - metadata_space_correction);
842008c8:	ff fd 9f f0 	call (m) 0x1478e;
842008cc:	27 e6 
842008ce:	9f f2 01 c2 	rMAC = r0 - r7;

                space = get_interal_metadata_space(splitter);
                SPLITTER_DEBUG_INSTR(check_data_space(splitter, channel, space, i));
                /* discard enough data to hold a frame*/
                if (space < splitter->frame_size + 3)
842008d2:	fa 98       	r0 = M[r5 + 44];
842008d4:	d2 20       	r0 = r0 + 3;
842008d6:	88 04       	Null = rMAC - r0;
842008d8:	f2 ff d3 ee 	if C jump (m) Lc_limit_data_to_move_2;

842008dc <Lc_limit_data_to_move_20>:
                {
                    /* Leave three more words in case we are connected to a SBC decode.*/
                    data[i] = splitter->frame_size - space + 3;
842008dc:	1f f2 86 c3 	M[r4] = r0 - rMAC;
842008e0:	a6 6f       	jump (m) Lc_limit_data_to_move_3;

842008e2 <Lc_limit_data_to_move_21>:
    }/* END of channel loop. */

    SPLITTER_MSG2("Splitter limit data data[0],data[1]\n"
            " 0x%08x 0x%08x  ",
            data[0],data[1]);
}
842008e2:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842008e4:	d8 4c       	rts;

842008e6 <Lc_splitter_transition_to_active_1>:
 * Transition from INACTIVE to ACTIVE.
 *
 * Start copying to the output when the next metadata tag arrives.
 */
static bool splitter_transition_to_active(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
842008e6:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842008e8:	12 09       	r8 = r0 + Null;
842008ea:	43 de       	M[FP + 32] = r1;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
842008ec:	a6 f0 15 88 	r4 = M[r8 + 84];
    unsigned read_offset;
    patch_fn_shared(splitter);

    metadata_buffer = get_internal_metadata_buffer(splitter);

    tag_list = buff_metadata_peek_ex(metadata_buffer, &b4idx);
842008f0:	43 12       	r1 = FP + 36;
842008f2:	32 00       	r0 = r4 + Null;
842008f4:	ff fd 9e f0 	call (m) 0x146e0;
842008f8:	2d ef 
842008fa:	17 00       	r5 = r0 + Null;
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842008fc:	51 08       	rMAC = r8 + Null;
842008fe:	42 d8       	r0 = M[FP + 32];
84200900:	51 00       	rMAC = r0 + rMAC;
84200902:	1b f0 18 20 	r9 = rMAC + 24;
84200906:	b1 f0 00 e0 	rMAC = MBS[r9 + Null];

    output_state = get_current_output_state(splitter, output_index);
    if (output_state == HOLD)
8420090a:	88 24       	Null = rMAC - 2;
8420090c:	01 f0 9d e4 	if NE jump (m) Lc_splitter_transition_to_active_64;

84200910 <Lc_splitter_transition_to_active_2>:
        /* Go trough the metadata and discard unwanted tags.*/
        unsigned channel_data_to_remove, input_data;
        unsigned data_to_remove;
        unsigned internal_data[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];

        if (tag_list == NULL)
84200910:	38 04       	Null = r5 - Null;
84200912:	0f 62       	if NE jump (m) Lc_splitter_transition_to_active_6;

84200914 <Lc_splitter_transition_to_active_3>:
        {
            SPLITTER_ERRORMSG("splitter_transition_to_active: No tags to align to! Not enough data buffered. ");
84200914:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200918:	08 24       	Null = rMAC - 0;
8420091a:	07 6c       	if LE jump (m) Lc_splitter_transition_to_active_5;

8420091c <Lc_splitter_transition_to_active_4>:
8420091c:	55 f1 02 f0 	r0 = Null + 357564443;
84200920:	1b 40 
84200922:	ff fd 03 f0 	call (m) 0x10b0;
84200926:	2f ec 

84200928 <Lc_splitter_transition_to_active_5>:
            splitter->kick_backward = TRUE;
84200928:	41 20       	rMAC = Null + 1;
8420092a:	a1 f0 6c 8a 	MB[r8 + 108] = rMAC;
8420092e:	76 6e       	jump (m) Lc_splitter_transition_to_active_32;

84200930 <Lc_splitter_transition_to_active_6>:
        }
        else
        {
            SPLITTER_ERRORMSG3("splitter_transition_to_active"
                    "\n first buffered tag timestamp 0x%08x index 0x%08x b4idx %d " ,
                    tag_list->timestamp, tag_list->index, b4idx);
84200930:	08 f0 34 43 	r6 = Null + 820;
84200934:	81 f0 00 e0 	rMAC = MBS[r6 + Null];
84200938:	08 24       	Null = rMAC - 0;
8420093a:	21 6c       	if LE jump (m) Lc_splitter_transition_to_active_12;

8420093c <Lc_splitter_transition_to_active_7>:
8420093c:	4d d8       	r3 = M[FP + 36];
8420093e:	bc 88       	r2 = M[r5 + 8];
84200940:	3b 89       	r1 = M[r5 + 16];
84200942:	55 f1 02 f0 	r0 = Null + 357564522;
84200946:	6a 40 
84200948:	ff fd 03 f0 	call (m) 0x10ec;
8420094c:	25 ed 
        }
        /* Check if timestamp too far in past. */
        if (IS_TIME_TO_PLAY_TAG(tag_list) && time_ge(tag_list->timestamp, splitter->transition_point))
8420094e:	79 88       	rMAC = M[r5 + 4];
84200950:	12 f0 30 00 	r0 = rMAC AND 0x30;
84200954:	14 60       	if EQ jump (m) Lc_splitter_transition_to_active_12;

84200956 <Lc_splitter_transition_to_active_8>:
84200956:	c9 c2       	rMAC = rMAC AND 0x40;
84200958:	12 62       	if NE jump (m) Lc_splitter_transition_to_active_12;

8420095a <Lc_splitter_transition_to_active_9>:
8420095a:	39 89       	rMAC = M[r5 + 16];
8420095c:	a2 f0 0a 88 	r0 = M[r8 + 40];
84200960:	89 04       	rMAC = rMAC - r0;
84200962:	08 04       	Null = rMAC - Null;
84200964:	04 f0 99 e0 	if NEG jump (m) Lc_splitter_transition_to_active_12;

84200968 <Lc_splitter_transition_to_active_10>:
        {
            SPLITTER_ERRORMSG("Splitter: Timestamp too far in the past. Maybe you need a bigger buffer. ");
84200968:	81 f0 00 e0 	rMAC = MBS[r6 + Null];
8420096c:	08 24       	Null = rMAC - 0;
8420096e:	07 6c       	if LE jump (m) Lc_splitter_transition_to_active_12;

84200970 <Lc_splitter_transition_to_active_11>:
84200970:	55 f1 02 f0 	r0 = Null + 357564612;
84200974:	c4 40 
84200976:	ff fd 03 f0 	call (m) 0x10b0;
8420097a:	3b e9 

8420097c <Lc_splitter_transition_to_active_12>:
        }

        /* Discard the data from the previous tag for simplicity. */
        channel_data_to_remove = b4idx;
8420097c:	e9 f0 09 88 	r7 = M[FP + 36];
        /* Guard the amount discarded to avoid any wraps. */
        input_data = buff_metadata_available_octets(metadata_buffer);
84200980:	32 00       	r0 = r4 + Null;
84200982:	ff fd 9e f0 	call (m) 0x14756;
84200986:	35 ee 
84200988:	16 00       	r4 = r0 + Null;
        /* Account for the data before the first tag. */
        input_data -= b4idx;
8420098a:	49 d8       	rMAC = M[FP + 36];
8420098c:	76 04       	r4 = r4 - rMAC;

8420098e <Lc_splitter_transition_to_active_13>:
         * Make sure only timestamped tags are checked.
         * Only traverse the list until the last last tag. */
        while((tag_list->next != NULL) &&
              (input_data != 0) &&
              (IS_TIME_TO_PLAY_TAG(tag_list) || IS_TIME_OF_ARRIVAL_TAG(tag_list)) &&
              (time_lt(tag_list->timestamp, splitter->transition_point)))
8420098e:	39 e8       	rMAC = M[r5 + Null];
84200990:	2f 60       	if EQ jump (m) Lc_splitter_transition_to_active_27;

84200992 <Lc_splitter_transition_to_active_14>:
84200992:	30 04       	Null = r4 - Null;
84200994:	2b 60       	if EQ jump (m) Lc_splitter_transition_to_active_26;

84200996 <Lc_splitter_transition_to_active_15>:
84200996:	7a 88       	r0 = M[r5 + 4];
84200998:	23 f0 30 00 	r1 = r0 AND 0x30;
8420099c:	03 60       	if EQ jump (m) Lc_splitter_transition_to_active_17;

8420099e <Lc_splitter_transition_to_active_16>:
8420099e:	d3 c2       	r1 = r0 AND 0x40;
842009a0:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_18;

842009a2 <Lc_splitter_transition_to_active_17>:
842009a2:	22 f0 70 00 	r0 = r0 AND 0x70;
842009a6:	20 f0 40 24 	Null = r0 - 64;
842009aa:	20 62       	if NE jump (m) Lc_splitter_transition_to_active_26;

842009ac <Lc_splitter_transition_to_active_18>:
842009ac:	3b 89       	r1 = M[r5 + 16];
842009ae:	a2 f0 0a 88 	r0 = M[r8 + 40];
842009b2:	9a 04       	r0 = r1 - r0;
842009b4:	10 04       	Null = r0 - Null;
842009b6:	05 f0 b5 e0 	if POS jump (m) Lc_splitter_transition_to_active_26;

842009ba <Lc_splitter_transition_to_active_19>:
        {
            unsigned tag_data;
            /* tag_legth = tag_list->length / data_size */
            tag_data = MIN(input_data, tag_list->length);
842009ba:	f9 88       	rMAC = M[r5 + 12];
842009bc:	70 04       	Null = r4 - rMAC;
842009be:	02 f0 a7 e0 	if C jump (m) Lc_splitter_transition_to_active_25;

842009c2 <Lc_splitter_transition_to_active_20>:
842009c2:	30 09       	r6 = r4 + Null;

842009c4 <Lc_splitter_transition_to_active_21>:

            if (tag_data != 0)
            {
                SPLITTER_ERRORMSG2("Splitter: Metadata tag with timestamp 0x%08x and "
                        "index 0x%08x will be discarded.",
                        tag_list->timestamp, tag_list->index);
842009c4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842009c8:	08 24       	Null = rMAC - 0;
842009ca:	08 6c       	if LE jump (m) Lc_splitter_transition_to_active_23;

842009cc <Lc_splitter_transition_to_active_22>:
842009cc:	bc 88       	r2 = M[r5 + 8];
842009ce:	55 f1 02 f0 	r0 = Null + 357564686;
842009d2:	0e 41 
842009d4:	ff fd 03 f0 	call (m) 0x10d6;
842009d8:	23 e8 

842009da <Lc_splitter_transition_to_active_23>:
                /* Increase the discarded amount by the tag length. */
                channel_data_to_remove += tag_data;
842009da:	41 0d       	r7 = r6 + r7;
                /* ... decrease the amount of data. */
                input_data -= tag_data;
842009dc:	00 f8 36 c2 	r4 = r4 - r6;

842009e0 <Lc_splitter_transition_to_active_24>:
            }
            tag_list = tag_list->next;
842009e0:	3f e8       	r5 = M[r5 + Null];
842009e2:	d6 6f       	jump (m) Lc_splitter_transition_to_active_13;

842009e4 <Lc_splitter_transition_to_active_25>:
        {
            unsigned tag_data;
            /* tag_legth = tag_list->length / data_size */
            tag_data = MIN(input_data, tag_list->length);

            if (tag_data != 0)
842009e4:	08 09       	r6 = rMAC + Null;
842009e6:	ef 63       	if NE jump (m) Lc_splitter_transition_to_active_21;

842009e8 <Lc__ite_19>:
842009e8:	fc 6f       	jump (m) Lc_splitter_transition_to_active_24;

842009ea <Lc_splitter_transition_to_active_26>:
            tag_list = tag_list->next;

        }

        /* Check if all data was discarded.*/
        if (tag_list->next == NULL)
842009ea:	08 04       	Null = rMAC - Null;
842009ec:	0b 62       	if NE jump (m) Lc_splitter_transition_to_active_29;

842009ee <Lc_splitter_transition_to_active_27>:
        {
            SPLITTER_ERRORMSG("Splitter: All buffered data discarded. Timestamp in future? ");
842009ee:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842009f2:	08 24       	Null = rMAC - 0;
842009f4:	07 6c       	if LE jump (m) Lc_splitter_transition_to_active_29;

842009f6 <Lc_splitter_transition_to_active_28>:
842009f6:	55 f1 02 f0 	r0 = Null + 357564767;
842009fa:	5f 41 
842009fc:	ff fd 03 f0 	call (m) 0x10b0;
84200a00:	35 e5 

84200a02 <Lc_splitter_transition_to_active_29>:
        }
        /* Sanity check the result of the discard. */
        if (tag_list == NULL)
84200a02:	38 04       	Null = r5 - Null;
84200a04:	0d 62       	if NE jump (m) Lc_splitter_transition_to_active_33;

84200a06 <Lc_splitter_transition_to_active_30>:
        {
            SPLITTER_ERRORMSG("Splitter: No more metadata tag at the input buffer. Probably the buffering is too small. ");
84200a06:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a0a:	08 24       	Null = rMAC - 0;
84200a0c:	07 6c       	if LE jump (m) Lc_splitter_transition_to_active_32;

84200a0e <Lc_splitter_transition_to_active_31>:
84200a0e:	55 f1 02 f0 	r0 = Null + 357564828;
84200a12:	9c 41 
84200a14:	ff fd 03 f0 	call (m) 0x10b0;
84200a18:	3d e4 

84200a1a <Lc_splitter_transition_to_active_32>:

        if (tag_list == NULL)
        {
            SPLITTER_ERRORMSG("splitter_transition_to_active: No tags to align to! Not enough data buffered. ");
            splitter->kick_backward = TRUE;
            return FALSE;
84200a1a:	02 00       	r0 = Null + Null;
84200a1c:	d3 6e       	jump (m) Lc_splitter_transition_to_active_82;

84200a1e <Lc_splitter_transition_to_active_33>:
        if (tag_list == NULL)
        {
            SPLITTER_ERRORMSG("Splitter: No more metadata tag at the input buffer. Probably the buffering is too small. ");
            return FALSE;
        }
        else if (input_data == 0)
84200a1e:	30 04       	Null = r4 - Null;
84200a20:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_36;

84200a22 <Lc_splitter_transition_to_active_34>:
        {
            SPLITTER_ERRORMSG("Splitter: No data left to search for timestamp (probably the buffering is too small). "
                    "Activating output anyways.");
84200a22:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a26:	08 24       	Null = rMAC - 0;
84200a28:	23 6c       	if LE jump (m) Lc_splitter_transition_to_active_41;

84200a2a <Lc_splitter_transition_to_active_35>:
84200a2a:	55 f1 02 f0 	r0 = Null + 357564918;
84200a2e:	f6 41 
84200a30:	ff fd 03 f0 	call (m) 0x10b0;
84200a34:	21 e4 
84200a36:	1c 6e       	jump (m) Lc_splitter_transition_to_active_41;

84200a38 <Lc_splitter_transition_to_active_36>:
        }
        else if (!IS_TIME_TO_PLAY_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
84200a38:	79 88       	rMAC = M[r5 + 4];
84200a3a:	12 f0 30 00 	r0 = rMAC AND 0x30;
84200a3e:	03 60       	if EQ jump (m) Lc_splitter_transition_to_active_38;

84200a40 <Lc_splitter_transition_to_active_37>:
84200a40:	ca c2       	r0 = rMAC AND 0x40;
84200a42:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_39;

84200a44 <Lc_splitter_transition_to_active_38>:
84200a44:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200a48:	10 f0 40 24 	Null = rMAC - 64;
84200a4c:	1e 62       	if NE jump (m) Lc_splitter_transition_to_active_43;

84200a4e <Lc_splitter_transition_to_active_39>:
        else
        {
            SPLITTER_ERRORMSG4("Splitter: Tag with ttp 0x%08x and index 0x%08x "
                    "is the first valid tag after transition 0x%08x"
                    "\n Total discarded octets %d",
                    tag_list->timestamp, tag_list->index, splitter->transition_point, channel_data_to_remove);
84200a4e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a52:	08 24       	Null = rMAC - 0;
84200a54:	0d 6c       	if LE jump (m) Lc_splitter_transition_to_active_41;

84200a56 <Lc_splitter_transition_to_active_40>:
84200a56:	18 1c       	pushm <r7>;
84200a58:	a5 f0 0a 88 	r3 = M[r8 + 40];
84200a5c:	bc 88       	r2 = M[r5 + 8];
84200a5e:	3b 89       	r1 = M[r5 + 16];
84200a60:	55 f1 02 f0 	r0 = Null + 357565213;
84200a64:	1d 43 
84200a66:	ff fd 03 f0 	call (m) 0x1104;
84200a6a:	3f e4 
84200a6c:	7f 4c       	SP = SP + -4;

84200a6e <Lc_splitter_transition_to_active_41>:
        }


        /* get the available data in the internal buffer */
        internal_buffer_data(splitter, internal_data);
84200a6e:	83 12       	r1 = FP + 40;
84200a70:	52 08       	r0 = r8 + Null;
84200a72:	fe ff 31 ea 	call (m) Lc_internal_buffer_data_1;
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data[0], internal_data[1]);
84200a76:	e8 f0 0a 88 	r6 = M[FP + 40];
84200a7a:	59 d8       	rMAC = M[FP + 44];
84200a7c:	1f f8 00 c2 	Null = r6 - rMAC;
84200a80:	02 f0 dd e0 	if C jump (m) Lc_splitter_transition_to_active_54;

84200a84 <Lc_splitter_transition_to_active_42>:
84200a84:	08 09       	r6 = rMAC + Null;
84200a86:	2b 6e       	jump (m) Lc_splitter_transition_to_active_54;

84200a88 <Lc_splitter_transition_to_active_43>:
                    "Activating output anyways.");
        }
        else if (!IS_TIME_TO_PLAY_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
        {
            while((tag_list->next != NULL) &&
                  (input_data != 0))
84200a88:	39 e8       	rMAC = M[r5 + Null];
84200a8a:	1c 60       	if EQ jump (m) Lc_splitter_transition_to_active_52;

84200a8c <Lc_splitter_transition_to_active_44>:
84200a8c:	30 04       	Null = r4 - Null;
84200a8e:	1a 60       	if EQ jump (m) Lc_splitter_transition_to_active_52;

84200a90 <Lc_splitter_transition_to_active_45>:
            {
                unsigned tag_data;
                /* tag_legth = tag_list->length / data_size */
                tag_data = MIN(input_data, tag_list->length);
84200a90:	f9 88       	rMAC = M[r5 + 12];
84200a92:	70 04       	Null = r4 - rMAC;
84200a94:	02 f0 a9 e0 	if C jump (m) Lc_splitter_transition_to_active_51;

84200a98 <Lc_splitter_transition_to_active_46>:
84200a98:	30 09       	r6 = r4 + Null;

84200a9a <Lc_splitter_transition_to_active_47>:

                if (tag_data != 0)
                {
                    SPLITTER_ERRORMSG2("Splitter: Metadata tag with timestamp 0x%08x and "
                            "index 0x%08x will be discarded.",
                            tag_list->timestamp, tag_list->index);
84200a9a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a9e:	08 24       	Null = rMAC - 0;
84200aa0:	09 6c       	if LE jump (m) Lc_splitter_transition_to_active_49;

84200aa2 <Lc_splitter_transition_to_active_48>:
84200aa2:	bc 88       	r2 = M[r5 + 8];
84200aa4:	3b 89       	r1 = M[r5 + 16];
84200aa6:	55 f1 02 f0 	r0 = Null + 357564686;
84200aaa:	0e 41 
84200aac:	ff fd 03 f0 	call (m) 0x10d6;
84200ab0:	2b e1 

84200ab2 <Lc_splitter_transition_to_active_49>:
                    /* Increase the discarded amount by the tag length. */
                    channel_data_to_remove += tag_data;
84200ab2:	41 0d       	r7 = r6 + r7;
                    /* ... decrease the amount of data. */
                    input_data -= tag_data;
84200ab4:	00 f8 36 c2 	r4 = r4 - r6;

84200ab8 <Lc_splitter_transition_to_active_50>:
                }
                tag_list = tag_list->next;
84200ab8:	3f e8       	r5 = M[r5 + Null];
                    "Activating output anyways.");
        }
        else if (!IS_TIME_TO_PLAY_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
        {
            while((tag_list->next != NULL) &&
                  (input_data != 0))
84200aba:	e7 6f       	jump (m) Lc_splitter_transition_to_active_43;

84200abc <Lc_splitter_transition_to_active_51>:
            {
                unsigned tag_data;
                /* tag_legth = tag_list->length / data_size */
                tag_data = MIN(input_data, tag_list->length);

                if (tag_data != 0)
84200abc:	08 09       	r6 = rMAC + Null;
84200abe:	ee 63       	if NE jump (m) Lc_splitter_transition_to_active_47;

84200ac0 <Lc__ite_20>:
84200ac0:	fc 6f       	jump (m) Lc_splitter_transition_to_active_50;

84200ac2 <Lc_splitter_transition_to_active_52>:
            }
            SPLITTER_ERRORMSG2("Splitter: Non timestamped tag found.\n"
                    " All data will be discarded and output stream will be activated!\n"
                    " Tag with index 0x%08x is the last tag in the buffer"
                    "\n Total discarded octets %d",
                    tag_list->index, channel_data_to_remove);
84200ac2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200ac6:	08 24       	Null = rMAC - 0;
84200ac8:	d3 6d       	if LE jump (m) Lc_splitter_transition_to_active_41;

84200aca <Lc_splitter_transition_to_active_53>:
84200aca:	bb 88       	r1 = M[r5 + 8];
84200acc:	55 f1 02 f0 	r0 = Null + 357565031;
84200ad0:	67 42 
84200ad2:	4c 08       	r2 = r7 + Null;
84200ad4:	ff fd 03 f0 	call (m) 0x10d6;
84200ad8:	23 e0 
84200ada:	ca 6f       	jump (m) Lc_splitter_transition_to_active_41;

84200adc <Lc_splitter_transition_to_active_54>:
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data[0], internal_data[1]);
        /* remove the data from the current channel */
        internal_data[output_index] = internal_data[output_index] - channel_data_to_remove;
84200adc:	81 12       	rMAC = FP + 40;
84200ade:	42 d8       	r0 = M[FP + 32];
84200ae0:	52 54       	r0 = r0 LSHIFT 2;
84200ae2:	51 00       	rMAC = r0 + rMAC;
84200ae4:	0a e8       	r0 = M[rMAC + Null];
84200ae6:	9f f2 81 c3 	M[rMAC] = r0 - r7;
        data_to_remove = data_to_remove - MAX(internal_data[0], internal_data[1]);
84200aea:	52 d8       	r0 = M[FP + 40];
84200aec:	59 d8       	rMAC = M[FP + 44];
84200aee:	50 04       	Null = r0 - rMAC;
84200af0:	02 f0 87 e0 	if C jump (m) Lc_splitter_transition_to_active_57;

84200af4 <Lc_splitter_transition_to_active_56>:
84200af4:	02 6e       	jump (m) Lc_splitter_transition_to_active_58;

84200af6 <Lc_splitter_transition_to_active_57>:
84200af6:	11 00       	rMAC = r0 + Null;

84200af8 <Lc_splitter_transition_to_active_58>:
84200af8:	00 f1 38 c2 	r6 = r6 - rMAC;
                internal_data[0],
                internal_data[1],
                data_to_remove);

        /* This will remove data from all channels. */
        if (data_to_remove !=0)
84200afc:	0f f8 00 c2 	Null = r6 - Null;
84200b00:	12 60       	if EQ jump (m) Lc_splitter_transition_to_active_63;

84200b02 <Lc_splitter_transition_to_active_59>:
        {
            /* The channel is still in hold. so by moving data
             * the data will be discarded from the channel.
             */
            unsigned data_0 = 0, data_1 = 0;
84200b02:	01 09       	r7 = Null + Null;
84200b04:	06 00       	r4 = Null + Null;
            if (output_index == 0)
84200b06:	41 d8       	rMAC = M[FP + 32];
84200b08:	03 62       	if NE jump (m) Lc_splitter_transition_to_active_61;

84200b0a <Lc_splitter_transition_to_active_60>:
            {
                data_0 = data_to_remove;
84200b0a:	41 09       	r7 = r6 + Null;
84200b0c:	02 6e       	jump (m) Lc_splitter_transition_to_active_62;

84200b0e <Lc_splitter_transition_to_active_61>:
            }
            else
            {
                data_1 = data_to_remove;
84200b0e:	46 08       	r4 = r6 + Null;

84200b10 <Lc_splitter_transition_to_active_62>:
            }
            /* remove the metadata */
            remove_metadata_from_internal(splitter, data_to_remove);
84200b10:	43 08       	r1 = r6 + Null;
84200b12:	52 08       	r0 = r8 + Null;
84200b14:	0a f0 2f eb 	call (m) $_remove_metadata_from_internal;
            /* remove the data by copying 0 0 but  removing data */
            unpack_data_from_internal_to_output(splitter, data_0, data_1, data_to_remove);
84200b18:	45 08       	r3 = r6 + Null;
84200b1a:	34 00       	r2 = r4 + Null;
84200b1c:	4b 08       	r1 = r7 + Null;
84200b1e:	52 08       	r0 = r8 + Null;
84200b20:	fd ff 2f e8 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200b24 <Lc_splitter_transition_to_active_63>:
        }

        read_index = tag_list->index;
84200b24:	be 88       	r4 = M[r5 + 8];
84200b26:	27 6e       	jump (m) Lc_splitter_transition_to_active_72;

84200b28 <Lc_splitter_transition_to_active_64>:
    }
    else /* for: if (output_state == HOLD) */
    {
        /* make sure that the operator is in INACTIVE state. */
        SPLITTER_DEBUG_INSTR(PL_ASSERT(output_state == INACTIVE));
        if (tag_list == NULL)
84200b28:	38 04       	Null = r5 - Null;
84200b2a:	12 62       	if NE jump (m) Lc_splitter_transition_to_active_69;

84200b2c <Lc_splitter_transition_to_active_65>:
        {
            if (splitter->reframe_enabled)
84200b2c:	a1 f0 69 82 	rMAC = MBU[r8 + 105];
84200b30:	04 60       	if EQ jump (m) Lc_splitter_transition_to_active_67;

84200b32 <Lc_splitter_transition_to_active_66>:
            {
                /* Because re-frame is enabled the next tag will
                 * have no b4idx. in this manner we can use the
                 * write index. */
                read_index = metadata_buffer->metadata->prev_wr_index;
84200b32:	b1 89       	rMAC = M[r4 + 24];
84200b34:	8e 88       	r4 = M[rMAC + 8];
84200b36:	1f 6e       	jump (m) Lc_splitter_transition_to_active_72;

84200b38 <Lc_splitter_transition_to_active_67>:
            }
            else
            {
                SPLITTER_ERRORMSG("splitter_transition_to_active: "
                        "No tags to align to and re-frame is disabled. ");
84200b38:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200b3c:	08 24       	Null = rMAC - 0;
84200b3e:	6e 6d       	if LE jump (m) Lc_splitter_transition_to_active_32;

84200b40 <Lc_splitter_transition_to_active_68>:
84200b40:	55 f1 02 f0 	r0 = Null + 357565334;
84200b44:	96 43 
84200b46:	ff fd 02 f0 	call (m) 0x10b0;
84200b4a:	2b eb 
84200b4c:	67 6f       	jump (m) Lc_splitter_transition_to_active_32;

84200b4e <Lc_splitter_transition_to_active_69>:
        else
        {
            SPLITTER_MSG3("splitter_transition_to_active"
                    "\n tag_list 0x%08x  tag_list->index 0x%08x b4idx %d " ,
                    tag_list, tag_list->index, b4idx);
            read_index = tag_list->index;
84200b4e:	be 88       	r4 = M[r5 + 8];
/**
 * Returns the opposite output stream index.
 */
static inline unsigned opposite_output_index(unsigned output_index)
{
    return (output_index + 1) & 1;
84200b50:	41 d8       	rMAC = M[FP + 32];
84200b52:	49 20       	rMAC = rMAC + 1;
84200b54:	0a c0       	r0 = rMAC AND 0x1;
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200b56:	51 08       	rMAC = r8 + Null;
84200b58:	51 00       	rMAC = r0 + rMAC;
            /* Remove data until the tag start.*/
            if((get_current_output_state(splitter, opposite_output_index(output_index)) == INACTIVE)&&(b4idx != 0))
84200b5a:	09 b0       	rMAC = MBS[rMAC + 24];
84200b5c:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_72;

84200b5e <Lc_splitter_transition_to_active_70>:
84200b5e:	4b d8       	r1 = M[FP + 36];
84200b60:	0a 60       	if EQ jump (m) Lc_splitter_transition_to_active_72;

84200b62 <Lc_splitter_transition_to_active_71>:
            {
                /* remove the metadata */
                remove_metadata_from_internal(splitter, b4idx);
84200b62:	52 08       	r0 = r8 + Null;
84200b64:	0a f0 3f e8 	call (m) $_remove_metadata_from_internal;
                /* remove the data by copying 0 0 but  removing data */
                unpack_data_from_internal_to_output(splitter, 0, 0, b4idx);
84200b68:	4d d8       	r3 = M[FP + 36];
84200b6a:	04 00       	r2 = Null + Null;
84200b6c:	03 00       	r1 = Null + Null;
84200b6e:	52 08       	r0 = r8 + Null;
84200b70:	fd ff 3f e5 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200b74 <Lc_splitter_transition_to_active_72>:
            }
        }
    }

    /* set the metadata read index and head. */
    splitter->internal_metadata.prev_rd_indexes[output_index] = read_index;
84200b74:	42 d8       	r0 = M[FP + 32];
84200b76:	51 08       	rMAC = r8 + Null;
84200b78:	52 54       	r0 = r0 LSHIFT 2;
84200b7a:	51 00       	rMAC = r0 + rMAC;
84200b7c:	8e af       	M[rMAC + 88] = r4;
    splitter->internal_metadata.head_tag[output_index] = tag_list;
84200b7e:	0f be       	M[rMAC + 96] = r5;
/**
 * Converts metadata read index to buffer offset.
 */
static inline unsigned metadata_read_idx_to_buffer_offset(SPLITTER_OP_DATA *splitter, unsigned position)
{
    unsigned read_offset = -1;
84200b80:	42 24       	r0 = Null - 1;
    /* convert the index to read offset.*/
    if (splitter->tag_size_to_samples)
84200b82:	a1 f0 6a 82 	rMAC = MBU[r8 + 106];
84200b86:	12 60       	if EQ jump (m) Lc_splitter_transition_to_active_79;

84200b88 <Lc_splitter_transition_to_active_73>:
    {
        if (splitter->packing == PACKED)
84200b88:	a1 f0 06 80 	rMAC = MBS[r8 + 6];
84200b8c:	48 24       	Null = rMAC - 1;
84200b8e:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_78;

84200b90 <Lc_splitter_transition_to_active_74>:
        {
            read_offset = position<<1;
84200b90:	32 54       	r0 = r4 LSHIFT 1;
84200b92:	11 6e       	jump (m) Lc_splitter_transition_to_active_81;

84200b94 <Lc_splitter_transition_to_active_75>:
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
    while (channel != NULL)
84200b94:	08 04       	Null = rMAC - Null;
84200b96:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_77;

84200b98 <Lc_splitter_transition_to_active_76>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200b98:	b3 f0 00 ea 	MB[r9 + Null] = r1;
/**
 * Function which sets the read offset of one of the output streams.
 */
static inline void set_data_buffer_read_offset(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned output_index, unsigned read_offset)
{
    channel->internal.read_offset[output_index] = read_offset;
84200b9c:	0a ef       	M[rMAC + r2] = r0;
        set_current_output_state(splitter, output_index, ACTIVE);

        /* set the read offset in the buffer.*/
        set_data_buffer_read_offset(splitter, channel, output_index,  read_offset);

        channel = channel->next;
84200b9e:	09 e8       	rMAC = M[rMAC + Null];
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
    while (channel != NULL)
84200ba0:	fa 6f       	jump (m) Lc_splitter_transition_to_active_75;

84200ba2 <Lc_splitter_transition_to_active_77>:
        set_data_buffer_read_offset(splitter, channel, output_index,  read_offset);

        channel = channel->next;
    }

    return TRUE;
84200ba2:	1a 00       	r0 = r1 + Null;
84200ba4:	0f 6e       	jump (m) Lc_splitter_transition_to_active_82;

84200ba6 <Lc_splitter_transition_to_active_78>:
        {
            read_offset = position<<1;
        }
        else
        {
            read_offset = position<<2;
84200ba6:	72 54       	r0 = r4 LSHIFT 2;
84200ba8:	06 6e       	jump (m) Lc_splitter_transition_to_active_81;

84200baa <Lc_splitter_transition_to_active_79>:
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
84200baa:	a1 f0 26 88 	rMAC = M[r8 + 152];
84200bae:	48 24       	Null = rMAC - 1;
84200bb0:	02 62       	if NE jump (m) Lc_splitter_transition_to_active_81;

84200bb2 <Lc_splitter_transition_to_active_80>:
    {
        read_offset = position;
84200bb2:	32 00       	r0 = r4 + Null;

84200bb4 <Lc_splitter_transition_to_active_81>:

    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
84200bb4:	a1 f0 00 e8 	rMAC = M[r8 + Null];
84200bb8:	43 20       	r1 = Null + 1;
84200bba:	44 d8       	r2 = M[FP + 32];
84200bbc:	64 54       	r2 = r2 LSHIFT 2;
84200bbe:	24 2a       	r2 = r2 + 24;
84200bc0:	ea 6f       	jump (m) Lc_splitter_transition_to_active_75;

84200bc2 <Lc_splitter_transition_to_active_82>:

        channel = channel->next;
    }

    return TRUE;
}
84200bc2:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200bc4:	d8 4c       	rts;

84200bc6 <Lc_splitter_finish_copying_last_tag_1>:

static bool splitter_finish_copying_last_tag(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
84200bc6:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200bc8:	16 00       	r4 = r0 + Null;
84200bca:	1f 00       	r5 = r1 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200bcc:	69 f0 15 88 	r7 = M[r4 + 84];
    patch_fn_shared(splitter);

    metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Save the index value. */
    before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;
84200bd0:	92 f0 06 88 	r0 = M[r7 + 24];
84200bd4:	2a f0 03 88 	r8 = M[r0 + 12];
    before_head_tag = metadata_buffer->metadata->tags.head;
84200bd8:	28 f0 00 e8 	r6 = M[r0 + Null];

    /* Set up the internal buffer read pointers!*/
    metadata_buffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[output_index];
84200bdc:	7b 54       	r1 = r5 LSHIFT 2;
84200bde:	31 00       	rMAC = r4 + Null;
84200be0:	59 00       	rMAC = r1 + rMAC;
84200be2:	8b a9       	r1 = M[rMAC + 88];
84200be4:	d3 8e       	M[r0 + 12] = r1;
    metadata_buffer->metadata->tags.head = splitter->internal_metadata.head_tag[output_index];
84200be6:	09 b8       	rMAC = M[rMAC + 96];
84200be8:	92 f0 06 88 	r0 = M[r7 + 24];
84200bec:	11 ee       	M[r0 + Null] = rMAC;

    /* b4idx will indicate the octets remaining from the last tag. */
    tag_list = buff_metadata_peek_ex(metadata_buffer, &b4idx);
84200bee:	c3 11       	r1 = FP + 28;
84200bf0:	4a 08       	r0 = r7 + Null;
84200bf2:	ff fd 9d f0 	call (m) 0x146e0;
84200bf6:	2f e7 

    /* restore the index value. */
    metadata_buffer->metadata->prev_rd_index = before_prev_rd_indexes;
84200bf8:	91 f0 06 88 	rMAC = M[r7 + 24];
84200bfc:	1a f0 03 8e 	M[rMAC + 12] = r8;
    metadata_buffer->metadata->tags.head = before_head_tag;
84200c00:	91 f0 06 88 	rMAC = M[r7 + 24];
84200c04:	18 f0 00 ee 	M[rMAC + Null] = r6;

    SPLITTER_MSG3("splitter_finish_copying_last_tag"
            "\n tag_list 0x%08x  tag_list->index 0x%08x b4idx %d octets" ,
            tag_list, tag_list->index, b4idx);

    if (tag_list == NULL)
84200c08:	10 04       	Null = r0 - Null;
84200c0a:	31 60       	if EQ jump (m) Lc_splitter_finish_copying_last_tag_6;

84200c0c <Lc_splitter_finish_copying_last_tag_2>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200c0c:	31 00       	rMAC = r4 + Null;
84200c0e:	79 00       	rMAC = r5 + rMAC;
84200c10:	09 b0       	rMAC = MBS[rMAC + 24];
        /* Would be nice to code against this. */
        return FALSE;
    }

    output_state = get_current_output_state(splitter, output_index);
    if (output_state == ACTIVE)
84200c12:	48 24       	Null = rMAC - 1;
84200c14:	4b 62       	if NE jump (m) Lc_splitter_finish_copying_last_tag_14;

84200c16 <Lc_splitter_finish_copying_last_tag_3>:
    {
        unsigned data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL] = {0,0};
84200c16:	01 f0 01 f3 	rMAC = Null + 1441984;
84200c1a:	c0 40 
84200c1c:	0a 88       	r0 = M[rMAC + 0];
84200c1e:	4b 88       	r1 = M[rMAC + 4];
84200c20:	42 de       	M[FP + 32] = r0;
84200c22:	4b de       	M[FP + 36] = r1;
        unsigned data_to_move[SPLITTER_MAX_OUTPUTS_PER_CHANNEL] = {0,0};
84200c24:	01 f0 01 f3 	rMAC = Null + 1441992;
84200c28:	c8 40 
84200c2a:	0a 88       	r0 = M[rMAC + 0];
84200c2c:	4b 88       	r1 = M[rMAC + 4];
84200c2e:	52 de       	M[FP + 40] = r0;
84200c30:	5b de       	M[FP + 44] = r1;
        unsigned data_to_remove = 0;

        /* Get the amount of date buffered internally. */
        internal_buffer_data(splitter, data_before);
84200c32:	03 12       	r1 = FP + 32;
84200c34:	32 00       	r0 = r4 + Null;
84200c36:	fd ff 2d ec 	call (m) Lc_internal_buffer_data_1;

        /* finish copying the current tag. */
        data_to_move[output_index] = b4idx;
84200c3a:	e8 f0 28 20 	r6 = FP + 40;
84200c3e:	7a 54       	r0 = r5 LSHIFT 2;
84200c40:	39 d8       	rMAC = M[FP + 28];
84200c42:	10 0d       	r6 = r0 + r6;
84200c44:	81 f0 00 ee 	M[r6 + Null] = rMAC;
        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n output_index %d  data_to_move[0] %d data_to_move[1] %d" ,
                   output_index, data_to_move[0], data_to_move[1]);

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);
84200c48:	83 12       	r1 = FP + 40;
84200c4a:	32 00       	r0 = r4 + Null;
84200c4c:	fd ff 2f ee 	call (m) Lc_limit_data_to_move_1;

        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n after limit: data_to_move[0] %d data_to_move[1] %d b4idx %d " ,
                   data_to_move[0], data_to_move[1], b4idx);
        if (data_to_move[output_index] != b4idx)
84200c50:	39 d8       	rMAC = M[FP + 28];
84200c52:	1f f8 00 c3 	Null = M[r6] - rMAC;
84200c56:	0d 60       	if EQ jump (m) Lc_splitter_finish_copying_last_tag_7;

84200c58 <Lc_splitter_finish_copying_last_tag_4>:
        {
            SPLITTER_ERRORMSG("splitter_finish_copying_last_tag:"
                       " Not enough space to finish copying tag!" );
84200c58:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200c5c:	08 24       	Null = rMAC - 0;
84200c5e:	07 6c       	if LE jump (m) Lc_splitter_finish_copying_last_tag_6;

84200c60 <Lc_splitter_finish_copying_last_tag_5>:
84200c60:	55 f1 02 f0 	r0 = Null + 357565412;
84200c64:	e4 43 
84200c66:	ff fd 02 f0 	call (m) 0x10b0;
84200c6a:	2b e2 

84200c6c <Lc_splitter_finish_copying_last_tag_6>:
            tag_list, tag_list->index, b4idx);

    if (tag_list == NULL)
    {
        /* Would be nice to code against this. */
        return FALSE;
84200c6c:	02 00       	r0 = Null + Null;
84200c6e:	1f 6e       	jump (m) Lc_splitter_finish_copying_last_tag_15;

84200c70 <Lc_splitter_finish_copying_last_tag_7>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(data_before[0], data_before[1]);
84200c70:	41 d8       	rMAC = M[FP + 32];
84200c72:	4b d8       	r1 = M[FP + 36];
84200c74:	c8 04       	Null = rMAC - r1;
84200c76:	02 f0 89 e0 	if C jump (m) Lc_splitter_finish_copying_last_tag_9;

84200c7a <Lc_splitter_finish_copying_last_tag_8>:
84200c7a:	1f 00       	r5 = r1 + Null;
84200c7c:	02 6e       	jump (m) Lc_splitter_finish_copying_last_tag_10;

84200c7e <Lc_splitter_finish_copying_last_tag_9>:
84200c7e:	0f 00       	r5 = rMAC + Null;

84200c80 <Lc_splitter_finish_copying_last_tag_10>:
        data_to_remove = data_to_remove -  (
                MAX(data_before[0] - data_to_move[0], data_before[1] - data_to_move[1])
            );
84200c80:	52 d8       	r0 = M[FP + 40];
84200c82:	8a 04       	r0 = rMAC - r0;
84200c84:	59 d8       	rMAC = M[FP + 44];
84200c86:	59 04       	rMAC = r1 - rMAC;
84200c88:	50 04       	Null = r0 - rMAC;
84200c8a:	02 f0 87 e0 	if C jump (m) Lc_splitter_finish_copying_last_tag_12;

84200c8e <Lc_splitter_finish_copying_last_tag_11>:
84200c8e:	02 6e       	jump (m) Lc_splitter_finish_copying_last_tag_13;

84200c90 <Lc_splitter_finish_copying_last_tag_12>:
84200c90:	11 00       	rMAC = r0 + Null;

84200c92 <Lc_splitter_finish_copying_last_tag_13>:
84200c92:	7f 04       	r5 = r5 - rMAC;
        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n BATTER: data_before[0] %d data_before[1] %d data_to_remove %d " ,
                   data_before[0], data_before[1], data_to_remove);

        /* copy the metadata to the active output streams */
        splitter_metadata_copy(splitter, data_to_move, data_to_remove);
84200c94:	83 12       	r1 = FP + 40;
84200c96:	3c 00       	r2 = r5 + Null;
84200c98:	32 00       	r0 = r4 + Null;
84200c9a:	09 f0 3f e9 	call (m) $_splitter_metadata_copy;

        /* Finish copying last tag. */
        unpack_data_from_internal_to_output(splitter, data_to_move[0], data_to_move[1], data_to_remove);
84200c9e:	5c d8       	r2 = M[FP + 44];
84200ca0:	53 d8       	r1 = M[FP + 40];
84200ca2:	3d 00       	r3 = r5 + Null;
84200ca4:	32 00       	r0 = r4 + Null;
84200ca6:	fc ff 29 ec 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200caa <Lc_splitter_finish_copying_last_tag_14>:
    }

    SPLITTER_MSG("splitter_finish_copying_last_tag: finished");
    return TRUE;
84200caa:	42 20       	r0 = Null + 1;

84200cac <Lc_splitter_finish_copying_last_tag_15>:

}
84200cac:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200cae:	d8 4c       	rts;

84200cb0 <Lc_splitter_transition_to_hold_1>:

/**
 * Transition to HOLD.
 */
static bool splitter_transition_to_hold(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
84200cb0:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200cb2:	10 09       	r6 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200cb4:	84 f0 15 88 	r2 = M[r6 + 84];
    unsigned read_offset;
    patch_fn_shared(splitter);

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* set the metadata read index and head. */
    read_index = metadata_buffer->metadata->prev_rd_index;
84200cb8:	a1 89       	rMAC = M[r2 + 24];
84200cba:	ca 88       	r0 = M[rMAC + 12];
    splitter->internal_metadata.prev_rd_indexes[output_index] = read_index;
84200cbc:	5d 54       	r3 = r1 LSHIFT 2;
84200cbe:	41 08       	rMAC = r6 + Null;
84200cc0:	69 00       	rMAC = r3 + rMAC;
84200cc2:	8a af       	M[rMAC + 88] = r0;
    splitter->internal_metadata.head_tag[output_index] = metadata_buffer->metadata->tags.head;
84200cc4:	a4 89       	r2 = M[r2 + 24];
84200cc6:	24 e8       	r2 = M[r2 + Null];
84200cc8:	0c be       	M[rMAC + 96] = r2;
/**
 * Converts metadata read index to buffer offset.
 */
static inline unsigned metadata_read_idx_to_buffer_offset(SPLITTER_OP_DATA *splitter, unsigned position)
{
    unsigned read_offset = -1;
84200cca:	47 24       	r5 = Null - 1;
    /* convert the index to read offset.*/
    if (splitter->tag_size_to_samples)
84200ccc:	81 f0 6a 82 	rMAC = MBU[r6 + 106];
84200cd0:	24 60       	if EQ jump (m) Lc_splitter_transition_to_hold_11;

84200cd2 <Lc_splitter_transition_to_hold_2>:
    {
        if (splitter->packing == PACKED)
84200cd2:	81 f0 06 80 	rMAC = MBS[r6 + 6];
84200cd6:	48 24       	Null = rMAC - 1;
84200cd8:	1e 62       	if NE jump (m) Lc_splitter_transition_to_hold_10;

84200cda <Lc_splitter_transition_to_hold_3>:
        {
            read_offset = position<<1;
84200cda:	17 54       	r5 = r0 LSHIFT 1;
84200cdc:	23 6e       	jump (m) Lc_splitter_transition_to_hold_13;

84200cde <Lc_splitter_transition_to_hold_4>:
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200cde:	30 04       	Null = r4 - Null;
84200ce0:	18 60       	if EQ jump (m) Lc_splitter_transition_to_hold_9;

84200ce2 <Lc_splitter_transition_to_hold_5>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200ce2:	41 d8       	rMAC = M[FP + 32];
84200ce4:	1b f0 00 ea 	MB[rMAC + Null] = r9;
/**
 * Function which sets the read offset of one of the output streams.
 */
static inline void set_data_buffer_read_offset(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned output_index, unsigned read_offset)
{
    channel->internal.read_offset[output_index] = read_offset;
84200ce8:	67 f0 09 ee 	M[r4 + r7] = r5;
        set_current_output_state(splitter, output_index, HOLD);

        /* set the read offset in the buffer.*/
        set_data_buffer_read_offset(splitter, channel, output_index, read_offset);
        /* If the other output is disconnected set the new read offset.*/
        if (get_current_output_state(splitter, opposite_output_index(output_index)) == INACTIVE)
84200cec:	a1 f0 00 e0 	rMAC = MBS[r8 + Null];
84200cf0:	0e 62       	if NE jump (m) Lc_splitter_transition_to_hold_8;

84200cf2 <Lc_splitter_transition_to_hold_6>:
        {
            set_buffer_rd_offset(splitter, &channel->internal.buffer, read_offset);
84200cf2:	31 29       	rMAC = r4 + 20;
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
84200cf4:	82 f0 05 80 	r0 = MBS[r6 + 5];
84200cf8:	26 62       	if NE jump (m) Lc_splitter_transition_to_hold_14;

84200cfa <Lc_splitter_transition_to_hold_7>:
    {
        tCbuffer *cbuffer = buffer->dsp;
84200cfa:	0a e8       	r0 = M[rMAC + Null];
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
84200cfc:	d1 88       	rMAC = M[r0 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
84200cfe:	bc c0       	r2 = r5 AND 0x3;
84200d00:	79 00       	rMAC = r5 + rMAC;
84200d02:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
84200d06:	ff fd 83 f2 	call (m) 0x513de;
84200d0a:	39 e6 

84200d0c <Lc_splitter_transition_to_hold_8>:
        }

        channel = channel->next;
84200d0c:	36 e8       	r4 = M[r4 + Null];
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200d0e:	e8 6f       	jump (m) Lc_splitter_transition_to_hold_4;

84200d10 <Lc_splitter_transition_to_hold_9>:
        }

        channel = channel->next;
    }

    return TRUE;
84200d10:	42 20       	r0 = Null + 1;
84200d12:	1f 6e       	jump (m) Lc_splitter_transition_to_hold_15;

84200d14 <Lc_splitter_transition_to_hold_10>:
        {
            read_offset = position<<1;
        }
        else
        {
            read_offset = position<<2;
84200d14:	57 54       	r5 = r0 LSHIFT 2;
84200d16:	06 6e       	jump (m) Lc_splitter_transition_to_hold_13;

84200d18 <Lc_splitter_transition_to_hold_11>:
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
84200d18:	81 f0 26 88 	rMAC = M[r6 + 152];
84200d1c:	48 24       	Null = rMAC - 1;
84200d1e:	02 62       	if NE jump (m) Lc_splitter_transition_to_hold_13;

84200d20 <Lc_splitter_transition_to_hold_12>:
    {
        read_offset = position;
84200d20:	17 00       	r5 = r0 + Null;

84200d22 <Lc_splitter_transition_to_hold_13>:

    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
84200d22:	86 f0 00 e8 	r4 = M[r6 + Null];
84200d26:	41 08       	rMAC = r6 + Null;
84200d28:	13 71       	r9 = Null + 2;
84200d2a:	59 00       	rMAC = r1 + rMAC;
84200d2c:	09 2a       	rMAC = rMAC + 24;
84200d2e:	41 de       	M[FP + 32] = rMAC;
84200d30:	59 20       	rMAC = r1 + 1;
84200d32:	0a c0       	r0 = rMAC AND 0x1;
84200d34:	41 08       	rMAC = r6 + Null;
84200d36:	51 00       	rMAC = r0 + rMAC;
84200d38:	1a f0 18 20 	r8 = rMAC + 24;
84200d3c:	5a 54       	r0 = r1 LSHIFT 2;
84200d3e:	29 f0 18 20 	r7 = r0 + 24;
84200d42:	ce 6f       	jump (m) Lc_splitter_transition_to_hold_4;

84200d44 <Lc_splitter_transition_to_hold_14>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
84200d44:	0a e8       	r0 = M[rMAC + Null];
84200d46:	3b 00       	r1 = r5 + Null;
84200d48:	ff fd 02 f0 	call (m) 0x133e;
84200d4c:	37 ef 
84200d4e:	df 6f       	jump (m) Lc_splitter_transition_to_hold_8;

84200d50 <Lc_splitter_transition_to_hold_15>:

        channel = channel->next;
    }

    return TRUE;
}
84200d50:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200d52:	d8 4c       	rts;

84200d54 <$_splitter_create>:
84200d54:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200d56:	16 00       	r4 = r0 + Null;
84200d58:	28 09       	r6 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84200d5a:	ef fd fd ff 	call (m) 0x8ea;
84200d5e:	31 ec 
84200d60:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    if (!base_op_create_lite(op_data, response_data))
84200d62:	43 08       	r1 = r6 + Null;
84200d64:	32 00       	r0 = r4 + Null;
84200d66:	ef fd fd ff 	call (m) 0x850;
84200d6a:	2b e7 
84200d6c:	10 04       	Null = r0 - Null;
84200d6e:	03 62       	if NE jump (m) Lc_splitter_create_3;

84200d70 <Lc_splitter_create_2>:
    {
        return FALSE;
84200d70:	02 00       	r0 = Null + Null;
84200d72:	17 6e       	jump (m) Lc_splitter_create_4;

84200d74 <Lc_splitter_create_3>:
    }

    splitter->buffer_size = SPLITTER_MIN_INTERNAL_BUFFER_SIZE;
84200d74:	01 f0 00 48 	rMAC = Null + 1024;
84200d78:	b9 8e       	M[r5 + 8] = rMAC;
    splitter->data_format = AUDIO_DATA_FORMAT_FIXP;
84200d7a:	41 20       	rMAC = Null + 1;
84200d7c:	f9 8e       	M[r5 + 12] = rMAC;
    splitter->active_streams = OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1;
84200d7e:	b9 b2       	rMAC = MBU[r5 + 26];
84200d80:	89 c8       	rMAC = rMAC OR 0x3;
84200d82:	b9 ba       	MB[r5 + 26] = rMAC;
    splitter->self_kick_timer = TIMER_ID_INVALID;
84200d84:	78 9e       	M[r5 + 36] = Null;
    splitter->working_mode = CLONE_BUFFER;
84200d86:	38 8b       	MB[r5 + 4] = Null;
#ifdef SPLITTER_OFFLOAD
    /* Check if the operator needs to run in offload mode. */
    splitter->offload_enabled = opmgr_op_thread_offload(op_data) && thread_offload_is_active();
#endif

    set_cbuffer_functions(splitter);
84200d88:	3a 00       	r0 = r5 + Null;
84200d8a:	0a f0 39 e5 	call (m) $_set_cbuffer_functions;

    splitter->frame_size = SPLITTER_MIN_FRAME_SIZE;
84200d8e:	01 f0 80 40 	rMAC = Null + 128;
84200d92:	f9 9e       	M[r5 + 44] = rMAC;
    splitter->reframe_data.last_tag_samples       = LAST_TAG_SAMPLES_INVALID;
84200d94:	41 24       	rMAC = Null - 1;
84200d96:	79 ae       	M[r5 + 68] = rMAC;
    splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
84200d98:	b8 ae       	M[r5 + 72] = Null;
    splitter->reframe_enabled = FALSE;
84200d9a:	70 f0 69 8a 	MB[r5 + 105] = Null;

    return TRUE;
84200d9e:	42 20       	r0 = Null + 1;

84200da0 <Lc_splitter_create_4>:
}
84200da0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200da2:	d8 4c       	rts;

84200da4 <$_splitter_buffer_details>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200da4:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200da6:	16 00       	r4 = r0 + Null;
84200da8:	1f 00       	r5 = r1 + Null;
84200daa:	2a 09       	r8 = r3 + Null;
84200dac:	ef fd fd ff 	call (m) 0x8ea;
84200db0:	3f e9 
84200db2:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200db4:	3f e8       	r5 = M[r5 + Null];
    OP_BUF_DETAILS_RSP *buf_details;
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    if (!base_op_buffer_details_lite(op_data, response_data))
84200db6:	53 08       	r1 = r8 + Null;
84200db8:	32 00       	r0 = r4 + Null;
84200dba:	ef fd fd ff 	call (m) 0x842;
84200dbe:	29 e4 
84200dc0:	10 04       	Null = r0 - Null;
84200dc2:	03 62       	if NE jump (m) Lc_splitter_buffer_details_3;

84200dc4 <Lc_splitter_buffer_details_2>:
    {
        return FALSE;
84200dc4:	02 00       	r0 = Null + Null;
84200dc6:	64 6e       	jump (m) Lc_splitter_buffer_details_21;

84200dc8 <Lc_splitter_buffer_details_3>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
84200dc8:	c4 11       	r2 = FP + 28;
84200dca:	05 00       	r3 = Null + Null;
84200dcc:	03 00       	r1 = Null + Null;
84200dce:	3a 00       	r0 = r5 + Null;
84200dd0:	0a f0 23 e1 	call (m) $_get_terminal_info;
84200dd4:	10 04       	Null = r0 - Null;
84200dd6:	07 62       	if NE jump (m) Lc_splitter_buffer_details_5;

84200dd8 <Lc_splitter_buffer_details_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
84200dd8:	01 f0 03 60 	rMAC = Null + 4099;
84200ddc:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200de0:	51 8e       	M[r0 + 4] = rMAC;
84200de2:	55 6e       	jump (m) Lc_splitter_buffer_details_20;

84200de4 <Lc_splitter_buffer_details_5>:
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* Alias the void* to the actual structure to make it easier to work with */
    buf_details = (OP_BUF_DETAILS_RSP*)*response_data;
84200de4:	a7 f0 00 e8 	r5 = M[r8 + Null];
    buf_details->supports_metadata = TRUE;
84200de8:	09 71       	r7 = Null + 1;
84200dea:	79 f0 0c 8a 	MB[r5 + 12] = r7;
    buf_details->metadata_buffer = get_metadata_buffer(splitter, terminal_info.is_input, terminal_info.index);
84200dee:	54 d8       	r2 = M[FP + 40];
84200df0:	43 d8       	r1 = M[FP + 32];
84200df2:	42 08       	r0 = r6 + Null;
84200df4:	07 f0 2b ee 	call (m) $_get_metadata_buffer;
84200df8:	3a 8f       	M[r5 + 16] = r0;

    if (splitter->working_mode == CLONE_BUFFER)
84200dfa:	81 f0 04 80 	rMAC = MBS[r6 + 4];
84200dfe:	42 62       	if NE jump (m) Lc_splitter_buffer_details_19;

84200e00 <Lc_splitter_buffer_details_6>:
    {
        if (terminal_info.is_input)
84200e00:	40 d8       	Null = M[FP + 32];
84200e02:	06 60       	if EQ jump (m) Lc_splitter_buffer_details_9;

84200e04 <Lc_splitter_buffer_details_7>:
        {
            if (splitter->buffer_size != 0)
84200e04:	81 f0 02 88 	rMAC = M[r6 + 8];
84200e08:	42 60       	if EQ jump (m) Lc_splitter_buffer_details_20;

84200e0a <Lc_splitter_buffer_details_8>:
            {
                /* Override the calculated buffer size if one has been set */
                buf_details->b.buffer_size = splitter->buffer_size;
84200e0a:	79 8f       	M[r5 + 20] = rMAC;
84200e0c:	40 6e       	jump (m) Lc_splitter_buffer_details_20;

84200e0e <Lc_splitter_buffer_details_9>:
            }
        }
        else
        {
            channel = get_channel_struct(splitter, terminal_info.channel_id);
84200e0e:	3b d8       	r1 = M[FP + 28];
84200e10:	42 08       	r0 = r6 + Null;
84200e12:	0b f0 33 e0 	call (m) $_get_channel_struct;
            /* The channel should be created during connecting the input buffer. */
            if ((channel == NULL) || (channel->input_buffer == NULL))
84200e16:	10 04       	Null = r0 - Null;
84200e18:	03 60       	if EQ jump (m) Lc_splitter_buffer_details_11;

84200e1a <Lc_splitter_buffer_details_10>:
84200e1a:	96 88       	r4 = M[r0 + 8];
84200e1c:	07 62       	if NE jump (m) Lc_splitter_buffer_details_12;

84200e1e <Lc_splitter_buffer_details_11>:
84200e1e:	01 f0 00 60 	rMAC = Null + 4096;
84200e22:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200e26:	51 8e       	M[r0 + 4] = rMAC;
84200e28:	32 6e       	jump (m) Lc_splitter_buffer_details_20;

84200e2a <Lc_splitter_buffer_details_12>:
            }
            else
            {
                tCbuffer *buffer_to_wrap = channel->input_buffer;

                buf_details->supplies_buffer = TRUE;
84200e2a:	79 f0 08 8a 	MB[r5 + 8] = r7;

                if (channel->output_buffer[terminal_info.index] != NULL)
84200e2e:	53 d8       	r1 = M[FP + 40];
84200e30:	5b 54       	r1 = r1 LSHIFT 2;
84200e32:	9a 00       	r0 = r1 + r0;
84200e34:	d1 88       	rMAC = M[r0 + 12];
84200e36:	03 60       	if EQ jump (m) Lc_splitter_buffer_details_14;

84200e38 <Lc_splitter_buffer_details_13>:
                {
                    /* If this terminal is already connected then make sure the buffer that
                     * is in use is returned to the caller. */
                    buf_details->b.buffer = channel->output_buffer[terminal_info.index];
84200e38:	79 8f       	M[r5 + 20] = rMAC;
84200e3a:	29 6e       	jump (m) Lc_splitter_buffer_details_20;

84200e3c <Lc_splitter_buffer_details_14>:
                }
                else
                {
                    /* If buffer details is requested during connect for the same channel
                     * return the buffer being used for connect */
                    if (splitter->curr_connecting == NULL || splitter->curr_connecting->base_addr != buffer_to_wrap->base_addr)
84200e3c:	82 f0 08 88 	r0 = M[r6 + 32];
84200e40:	05 60       	if EQ jump (m) Lc_splitter_buffer_details_16;

84200e42 <Lc_splitter_buffer_details_15>:
84200e42:	d1 88       	rMAC = M[r0 + 12];
84200e44:	f3 88       	r1 = M[r4 + 12];
84200e46:	c8 04       	Null = rMAC - r1;
84200e48:	19 60       	if EQ jump (m) Lc_splitter_buffer_details_18;

84200e4a <Lc_splitter_buffer_details_16>:
                    {
                        /* A buffer orphaned in a previously aborted connect might exist, free it
                         * before we create a new buffer that might get orphaned that we want to track. */
                        cbuffer_destroy_struct(splitter->curr_connecting);
84200e4a:	ff fd 9a f0 	call (m) 0x1432e;
84200e4e:	25 e7 
                        splitter->curr_connecting =
                                cbuffer_create_with_cbuf_preference(
                                        buffer_to_wrap->base_addr,
                                        cbuffer_get_size_in_words(buffer_to_wrap),
                                        BUF_DESC_SW_BUFFER,
                                        MALLOC_PREFERENCE_SHARED);
84200e50:	32 00       	r0 = r4 + Null;
84200e52:	ff fd 9a f0 	call (m) 0x143a8;
84200e56:	37 ea 
84200e58:	13 00       	r1 = r0 + Null;
84200e5a:	45 21       	r3 = Null + 5;
84200e5c:	f2 88       	r0 = M[r4 + 12];
84200e5e:	04 00       	r2 = Null + Null;
84200e60:	ff fd 99 f0 	call (m) 0x141f0;
84200e64:	31 ec 
84200e66:	82 f0 08 8e 	M[r6 + 32] = r0;
                        /* Store the buffer created here in case it gets orphaned by connect failing */
                        splitter->curr_connecting = cbuffer_create(buffer_to_wrap->base_addr,
                            cbuffer_get_size_in_words(buffer_to_wrap), BUF_DESC_SW_BUFFER);
#endif /* COMMON_SHARED_HEAP */

                        if (splitter->curr_connecting != NULL)
84200e6a:	82 f0 08 88 	r0 = M[r6 + 32];
84200e6e:	d8 61       	if EQ jump (m) Lc_splitter_buffer_details_11;

84200e70 <Lc_splitter_buffer_details_17>:
                        {
                            int *input_read_ptr = buffer_to_wrap->read_ptr;
84200e70:	71 88       	rMAC = M[r4 + 4];
                            /* Due to metadata which always copies from the input metadata read
                             * (metadata strict transport is used) the output should point to
                             * the input read too.
                             * The metadata will be created later so there is no need to set
                             * the read and write index for it. */
                            splitter->curr_connecting->write_ptr = input_read_ptr;
84200e72:	91 8e       	M[r0 + 8] = rMAC;
                            splitter->curr_connecting->read_ptr = input_read_ptr;
84200e74:	82 f0 08 88 	r0 = M[r6 + 32];
84200e78:	51 8e       	M[r0 + 4] = rMAC;

84200e7a <Lc_splitter_buffer_details_18>:
                            /* There wasn't enough RAM so we have to fail */
                            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                            return TRUE;
                        }
                    }
                    buf_details->b.buffer = splitter->curr_connecting;
84200e7a:	81 f0 08 88 	rMAC = M[r6 + 32];
84200e7e:	79 8f       	M[r5 + 20] = rMAC;
84200e80:	06 6e       	jump (m) Lc_splitter_buffer_details_20;

84200e82 <Lc_splitter_buffer_details_19>:
        }

    }
    else
    {
        buf_details->supplies_buffer = FALSE;
84200e82:	38 9a       	MB[r5 + 8] = Null;
        /* The splitter capability will have an internal or external buffer.
         * Use a transform buffer which can fit two frames. */
        buf_details->b.buffer_size = splitter->frame_size * 2 ;
84200e84:	82 f0 0b 88 	r0 = M[r6 + 44];
84200e88:	12 54       	r0 = r0 LSHIFT 1;
84200e8a:	7a 8f       	M[r5 + 20] = r0;

84200e8c <Lc_splitter_buffer_details_20>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200e8c:	42 20       	r0 = Null + 1;

84200e8e <Lc_splitter_buffer_details_21>:
        buf_details->b.buffer_size = splitter->frame_size * 2 ;
    }


    return TRUE;
}
84200e8e:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200e90:	d8 4c       	rts;

84200e92 <$_splitter_connect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200e92:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200e94:	12 09       	r8 = r0 + Null;
84200e96:	1e 00       	r4 = r1 + Null;
84200e98:	20 09       	r6 = r2 + Null;
84200e9a:	29 09       	r7 = r3 + Null;
84200e9c:	ef fd fd ff 	call (m) 0x8ea;
84200ea0:	2f e2 
84200ea2:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84200ea4:	6b f0 00 e8 	r9 = M[r4 + Null];
    tCbuffer* buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200ea8:	76 88       	r4 = M[r4 + 4];
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_connect",base_op_get_ext_op_id(op_data));

    *response_id = OPCMD_CONNECT;
84200eaa:	41 21       	rMAC = Null + 5;
84200eac:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200eb0:	03 00       	r1 = Null + Null;
84200eb2:	4c 08       	r2 = r7 + Null;
84200eb4:	52 08       	r0 = r8 + Null;
84200eb6:	ef fd fd ff 	call (m) 0x8c0;
84200eba:	2b e0 
84200ebc:	10 04       	Null = r0 - Null;
84200ebe:	03 62       	if NE jump (m) Lc_splitter_connect_3;

84200ec0 <Lc_splitter_connect_2>:
    {
        return FALSE;
84200ec0:	02 00       	r0 = Null + Null;
84200ec2:	ec 6e       	jump (m) Lc_splitter_connect_41;

84200ec4 <Lc_splitter_connect_3>:
    }

    if (!get_terminal_info(terminal_id, buffer, &terminal_info, TRUE))
84200ec4:	45 20       	r3 = Null + 1;
84200ec6:	04 12       	r2 = FP + 32;
84200ec8:	33 00       	r1 = r4 + Null;
84200eca:	5a 08       	r0 = r9 + Null;
84200ecc:	09 f0 27 e9 	call (m) $_get_terminal_info;
84200ed0:	10 04       	Null = r0 - Null;
84200ed2:	07 62       	if NE jump (m) Lc_splitter_connect_5;

84200ed4 <Lc_splitter_connect_4>:
84200ed4:	01 f0 03 60 	rMAC = Null + 4099;
84200ed8:	92 f0 00 e8 	r0 = M[r7 + Null];
84200edc:	51 8e       	M[r0 + 4] = rMAC;
84200ede:	c0 6e       	jump (m) Lc_splitter_connect_35;

84200ee0 <Lc_splitter_connect_5>:
    }

    SPLITTER_MSG1("#### SPLITTER 0x%08x ####",base_op_get_ext_op_id(op_data));
    SPLITTER_MSG2("connect is_input = %d, index = %d",terminal_info.is_input, terminal_info.index);

    channel = get_channel_struct(splitter, terminal_info.channel_id);
84200ee0:	43 d8       	r1 = M[FP + 32];
84200ee2:	3a 00       	r0 = r5 + Null;
84200ee4:	0a f0 21 ea 	call (m) $_get_channel_struct;
84200ee8:	16 00       	r4 = r0 + Null;
    if (channel == NULL)
84200eea:	0d 62       	if NE jump (m) Lc_splitter_connect_8;

84200eec <Lc_splitter_connect_6>:
    {
        /* Try to create the channel. */
        channel = create_channel(splitter, terminal_info.channel_id);
84200eec:	43 d8       	r1 = M[FP + 32];
84200eee:	3a 00       	r0 = r5 + Null;
84200ef0:	0a f0 2f e2 	call (m) $_create_channel;
84200ef4:	16 00       	r4 = r0 + Null;
    }
    if (channel == NULL)
84200ef6:	07 62       	if NE jump (m) Lc_splitter_connect_8;

84200ef8 <Lc_splitter_connect_7>:
84200ef8:	01 f0 00 60 	rMAC = Null + 4096;
84200efc:	92 f0 00 e8 	r0 = M[r7 + Null];
84200f00:	51 8e       	M[r0 + 4] = rMAC;
84200f02:	ae 6e       	jump (m) Lc_splitter_connect_35;

84200f04 <Lc_splitter_connect_8>:
        /* Unable to create the channel.*/
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (terminal_info.is_input)
84200f04:	4b d8       	r1 = M[FP + 36];
84200f06:	27 60       	if EQ jump (m) Lc_splitter_connect_15;

84200f08 <Lc_splitter_connect_9>:
    {
        SPLITTER_MSG2("Splitter: Connecting sink terminal %4d to buff 0x%08x!", terminal_info.terminal_num, terminal_info.buffer);
        if (channel->input_buffer == NULL)
84200f08:	b1 88       	rMAC = M[r4 + 8];
84200f0a:	aa 62       	if NE jump (m) Lc_splitter_connect_35;

84200f0c <Lc_splitter_connect_10>:
        {
            tCbuffer *metadata_buf = get_metadata_buffer(splitter, terminal_info.is_input, terminal_info.index);
84200f0c:	5c d8       	r2 = M[FP + 44];
84200f0e:	3a 00       	r0 = r5 + Null;
84200f10:	07 f0 2f e5 	call (m) $_get_metadata_buffer;

            if ((metadata_buf != NULL) && (metadata_buf->metadata != terminal_info.buffer->metadata))
84200f14:	10 04       	Null = r0 - Null;
84200f16:	16 60       	if EQ jump (m) Lc_splitter_connect_14;

84200f18 <Lc_splitter_connect_11>:
84200f18:	91 89       	rMAC = M[r0 + 24];
84200f1a:	62 d8       	r0 = M[FP + 48];
84200f1c:	92 89       	r0 = M[r0 + 24];
84200f1e:	88 04       	Null = rMAC - r0;
84200f20:	11 60       	if EQ jump (m) Lc_splitter_connect_14;

84200f22 <Lc_splitter_connect_12>:
84200f22:	01 f0 00 60 	rMAC = Null + 4096;
84200f26:	92 f0 00 e8 	r0 = M[r7 + Null];
84200f2a:	51 8e       	M[r0 + 4] = rMAC;
            {
                base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                SPLITTER_ERRORMSG("Splitter: The two input has different metadata!");
84200f2c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200f30:	08 24       	Null = rMAC - 0;
84200f32:	96 6c       	if LE jump (m) Lc_splitter_connect_35;

84200f34 <Lc_splitter_connect_13>:
84200f34:	55 f1 02 f0 	r0 = Null + 357566593;
84200f38:	81 50 
84200f3a:	ff fd 00 f0 	call (m) 0x10b0;
84200f3e:	37 eb 
84200f40:	8f 6e       	jump (m) Lc_splitter_connect_35;

84200f42 <Lc_splitter_connect_14>:
                return TRUE;
            }
            channel->input_buffer = terminal_info.buffer;
84200f42:	61 d8       	rMAC = M[FP + 48];
84200f44:	b1 8e       	M[r4 + 8] = rMAC;

            /* Set the active sinks. */
            splitter->touched_sinks |= TOUCHED_SINK_0 << terminal_info.terminal_num;
84200f46:	51 d8       	rMAC = M[FP + 40];
84200f48:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200f4c:	39 89       	rMAC = M[r5 + 16];
84200f4e:	89 12       	rMAC = rMAC OR r0;
84200f50:	39 8f       	M[r5 + 16] = rMAC;
84200f52:	86 6e       	jump (m) Lc_splitter_connect_35;

84200f54 <Lc_splitter_connect_15>:
        }
    }
    else
    {
        SPLITTER_MSG2("Splitter: Connecting source terminal %4d to buff 0x%08x!", terminal_info.terminal_num, terminal_info.buffer);
        if (channel->output_buffer[terminal_info.index] != NULL)
84200f54:	5a d8       	r0 = M[FP + 44];
84200f56:	31 00       	rMAC = r4 + Null;
84200f58:	52 54       	r0 = r0 LSHIFT 2;
84200f5a:	51 00       	rMAC = r0 + rMAC;
84200f5c:	c9 88       	rMAC = M[rMAC + 12];
84200f5e:	13 60       	if EQ jump (m) Lc_splitter_connect_18;

84200f60 <Lc_splitter_connect_16>:
84200f60:	01 f0 00 60 	rMAC = Null + 4096;
84200f64:	92 f0 00 e8 	r0 = M[r7 + Null];
84200f68:	51 8e       	M[r0 + 4] = rMAC;
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            SPLITTER_ERRORMSG2("Splitter: Channel %d Output %d is already connected!",
                    terminal_info.channel_id, terminal_info.index);
84200f6a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200f6e:	08 24       	Null = rMAC - 0;
84200f70:	77 6c       	if LE jump (m) Lc_splitter_connect_35;

84200f72 <Lc_splitter_connect_17>:
84200f72:	5c d8       	r2 = M[FP + 44];
84200f74:	43 d8       	r1 = M[FP + 32];
84200f76:	55 f1 02 f0 	r0 = Null + 357566641;
84200f7a:	b1 50 
84200f7c:	ff fd 00 f0 	call (m) 0x10d6;
84200f80:	3b ea 
84200f82:	6e 6e       	jump (m) Lc_splitter_connect_35;

84200f84 <Lc_splitter_connect_18>:
            return TRUE;
        }
        if (opmgr_op_is_running(op_data) &&(get_current_output_state(splitter, terminal_info.index) == ACTIVE))
84200f84:	52 08       	r0 = r8 + Null;
84200f86:	ff fd 26 f0 	call (m) 0x5ca4;
84200f8a:	3f e8 
84200f8c:	10 04       	Null = r0 - Null;
84200f8e:	19 60       	if EQ jump (m) Lc_splitter_connect_22;

84200f90 <Lc_splitter_connect_19>:
84200f90:	5a d8       	r0 = M[FP + 44];
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200f92:	39 00       	rMAC = r5 + Null;
84200f94:	51 00       	rMAC = r0 + rMAC;
84200f96:	09 b0       	rMAC = MBS[rMAC + 24];
84200f98:	48 24       	Null = rMAC - 1;
84200f9a:	13 62       	if NE jump (m) Lc_splitter_connect_22;

84200f9c <Lc_splitter_connect_20>:
84200f9c:	01 f0 00 60 	rMAC = Null + 4096;
84200fa0:	92 f0 00 e8 	r0 = M[r7 + Null];
84200fa4:	51 8e       	M[r0 + 4] = rMAC;
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            SPLITTER_ERRORMSG2("Splitter: Channel %d Output %d is already active and operator is running!",
                    terminal_info.channel_id, terminal_info.index);
84200fa6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200faa:	08 24       	Null = rMAC - 0;
84200fac:	59 6c       	if LE jump (m) Lc_splitter_connect_35;

84200fae <Lc_splitter_connect_21>:
84200fae:	5c d8       	r2 = M[FP + 44];
84200fb0:	43 d8       	r1 = M[FP + 32];
84200fb2:	55 f1 02 f0 	r0 = Null + 357566694;
84200fb6:	e6 50 
84200fb8:	ff fd 00 f0 	call (m) 0x10d6;
84200fbc:	3f e8 
84200fbe:	50 6e       	jump (m) Lc_splitter_connect_35;

84200fc0 <Lc_splitter_connect_22>:
            return TRUE;
        }

        channel->output_buffer[terminal_info.index] = terminal_info.buffer;
84200fc0:	62 d8       	r0 = M[FP + 48];
84200fc2:	5b d8       	r1 = M[FP + 44];
84200fc4:	31 00       	rMAC = r4 + Null;
84200fc6:	5b 54       	r1 = r1 LSHIFT 2;
84200fc8:	59 00       	rMAC = r1 + rMAC;
84200fca:	ca 8e       	M[rMAC + 12] = r0;

        if(splitter->working_mode == CLONE_BUFFER)
84200fcc:	39 81       	rMAC = MBS[r5 + 4];
84200fce:	19 62       	if NE jump (m) Lc_splitter_connect_28;

84200fd0 <Lc_splitter_connect_23>:
        {
            /* This should be the curr_connecting buffer that buffer_details
             * stashed. If it isn't fail the request as something went wrong,
             * otherwise it's not in danger of being orphaned any more. */
            PL_ASSERT(terminal_info.buffer == splitter->curr_connecting);
84200fd0:	61 d8       	rMAC = M[FP + 48];
84200fd2:	3a 98       	r0 = M[r5 + 32];
84200fd4:	88 04       	Null = rMAC - r0;
84200fd6:	09 60       	if EQ jump (m) Lc_splitter_connect_25;

84200fd8 <Lc_splitter_connect_24>:
84200fd8:	03 f0 c7 42 	r1 = Null + 711;
84200fdc:	02 f0 13 60 	r0 = Null + 4115;
84200fe0:	ff fd ad f0 	call (m) 0x16bdc;
84200fe4:	3d ef 
84200fe6:	5a 6e       	jump (m) Lc_splitter_connect_41;

84200fe8 <Lc_splitter_connect_25>:
            splitter->curr_connecting = NULL;
84200fe8:	38 9e       	M[r5 + 32] = Null;
            /* Set both metadata read/write indices on the new stream
            * to match the read index for the input stream.
            * This ensures that new tags have the same indices on both
            * streams.
            */
            metadata_list *input_metadata = channel->input_buffer->metadata;
84200fea:	b1 88       	rMAC = M[r4 + 8];
84200fec:	89 89       	rMAC = M[rMAC + 24];
            metadata_list *cur_metadata = terminal_info.buffer->metadata;
84200fee:	62 d8       	r0 = M[FP + 48];
            if (cur_metadata != NULL && input_metadata != NULL)
84200ff0:	92 89       	r0 = M[r0 + 24];
84200ff2:	07 60       	if EQ jump (m) Lc_splitter_connect_28;

84200ff4 <Lc_splitter_connect_26>:
84200ff4:	08 04       	Null = rMAC - Null;
84200ff6:	05 60       	if EQ jump (m) Lc_splitter_connect_28;

84200ff8 <Lc_splitter_connect_27>:
            {
                cur_metadata->prev_wr_index = input_metadata->prev_rd_index;
84200ff8:	cb 88       	r1 = M[rMAC + 12];
84200ffa:	93 8e       	M[r0 + 8] = r1;
                cur_metadata->prev_rd_index = input_metadata->prev_rd_index;
84200ffc:	c9 88       	rMAC = M[rMAC + 12];
84200ffe:	d1 8e       	M[r0 + 12] = rMAC;

84201000 <Lc_splitter_connect_28>:
            }
        }

        if (buff_has_metadata(terminal_info.buffer))
84201000:	61 d8       	rMAC = M[FP + 48];
84201002:	89 89       	rMAC = M[rMAC + 24];
84201004:	0d 60       	if EQ jump (m) Lc_splitter_connect_30;

84201006 <Lc_splitter_connect_29>:
        {
            /* Set the usable octet */
            cbuffer_set_usable_octets(channel->output_buffer[terminal_info.index],
                    cbuffer_get_usable_octets(channel->input_buffer));
84201006:	b2 88       	r0 = M[r4 + 8];
84201008:	ff fd 99 f0 	call (m) 0x142ec;
8420100c:	25 e7 
8420100e:	13 00       	r1 = r0 + Null;
84201010:	5a d8       	r0 = M[FP + 44];
84201012:	52 54       	r0 = r0 LSHIFT 2;
84201014:	96 01       	r4 = r0 + r4;
84201016:	f2 88       	r0 = M[r4 + 12];
84201018:	ff fd 99 f0 	call (m) 0x14296;
8420101c:	3f e3 

8420101e <Lc_splitter_connect_30>:
        }
        /* Activate the stream if needed if the operator is not running. */
        if (get_next_output_state(splitter, terminal_info.index) == ACTIVE)
8420101e:	59 d8       	rMAC = M[FP + 44];
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84201020:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
    if (splitter->active_streams & channel_mask)
84201024:	b9 b2       	rMAC = MBU[r5 + 26];
84201026:	89 10       	rMAC = rMAC AND r0;
84201028:	89 c0       	rMAC = rMAC AND 0x3;
8420102a:	0c 60       	if EQ jump (m) Lc_splitter_connect_33;

8420102c <Lc_splitter_connect_31>:
        {
            PL_ASSERT(!opmgr_op_is_running(op_data));
8420102c:	52 08       	r0 = r8 + Null;
8420102e:	ff fd 26 f0 	call (m) 0x5ca4;
84201032:	37 e3 
84201034:	10 04       	Null = r0 - Null;
84201036:	16 62       	if NE jump (m) Lc_splitter_connect_36;

84201038 <Lc_splitter_connect_32>:
            set_current_output_state(splitter, terminal_info.index, ACTIVE);
84201038:	5a d8       	r0 = M[FP + 44];
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
8420103a:	43 20       	r1 = Null + 1;
8420103c:	39 00       	rMAC = r5 + Null;
8420103e:	51 00       	rMAC = r0 + rMAC;
84201040:	0b ba       	MB[rMAC + 24] = r1;

84201042 <Lc_splitter_connect_33>:
        }
        /* Check if the channel is already on hold. */
        if (get_next_output_state(splitter, terminal_info.index) == HOLD)
84201042:	59 d8       	rMAC = M[FP + 44];
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84201044:	0a 00       	r0 = rMAC + Null;
84201046:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
    if (splitter->active_streams & channel_mask)
8420104a:	bb b2       	r1 = MBU[r5 + 26];
8420104c:	9c 10       	r2 = r1 AND r0;
8420104e:	a4 c0       	r2 = r2 AND 0x3;
84201050:	11 60       	if EQ jump (m) Lc_splitter_connect_37;

84201052 <Lc_splitter_connect_34>:
        {
            PL_ASSERT(get_current_output_state(splitter, terminal_info.index) == HOLD);
        }
        /* Set the active sources.*/
        splitter->touched_sources |= TOUCHED_SOURCE_0 << terminal_info.terminal_num;
84201052:	51 d8       	rMAC = M[FP + 40];
84201054:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201058:	79 89       	rMAC = M[r5 + 20];
8420105a:	89 12       	rMAC = rMAC OR r0;
8420105c:	79 8f       	M[r5 + 20] = rMAC;

8420105e <Lc_splitter_connect_35>:
    }

    if (!get_terminal_info(terminal_id, buffer, &terminal_info, TRUE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
8420105e:	42 20       	r0 = Null + 1;
84201060:	1d 6e       	jump (m) Lc_splitter_connect_41;

84201062 <Lc_splitter_connect_36>:
                    cbuffer_get_usable_octets(channel->input_buffer));
        }
        /* Activate the stream if needed if the operator is not running. */
        if (get_next_output_state(splitter, terminal_info.index) == ACTIVE)
        {
            PL_ASSERT(!opmgr_op_is_running(op_data));
84201062:	03 f0 e1 42 	r1 = Null + 737;
84201066:	02 f0 13 60 	r0 = Null + 4115;
8420106a:	ff fd ad f0 	call (m) 0x16bdc;
8420106e:	33 eb 
84201070:	15 6e       	jump (m) Lc_splitter_connect_41;

84201072 <Lc_splitter_connect_37>:
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
84201072:	5c 50       	r2 = r1 LSHIFT -2;
84201074:	a4 10       	r2 = r2 AND r0;
84201076:	a4 c0       	r2 = r2 AND 0x3;
84201078:	ed 63       	if NE jump (m) Lc_splitter_connect_34;

8420107a <Lc_splitter_connect_38>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
8420107a:	db 50       	r1 = r1 LSHIFT -4;
8420107c:	d2 10       	r0 = r0 AND r1;
8420107e:	92 c0       	r0 = r0 AND 0x3;
84201080:	e9 61       	if EQ jump (m) Lc_splitter_connect_34;

84201082 <Lc_splitter_connect_39>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84201082:	3a 00       	r0 = r5 + Null;
84201084:	8a 00       	r0 = rMAC + r0;
84201086:	11 b0       	rMAC = MBS[r0 + 24];
            set_current_output_state(splitter, terminal_info.index, ACTIVE);
        }
        /* Check if the channel is already on hold. */
        if (get_next_output_state(splitter, terminal_info.index) == HOLD)
        {
            PL_ASSERT(get_current_output_state(splitter, terminal_info.index) == HOLD);
84201088:	88 24       	Null = rMAC - 2;
8420108a:	e4 61       	if EQ jump (m) Lc_splitter_connect_34;

8420108c <Lc_splitter_connect_40>:
8420108c:	03 f0 e7 42 	r1 = Null + 743;
84201090:	02 f0 13 60 	r0 = Null + 4115;
84201094:	ff fd ad f0 	call (m) 0x16bdc;
84201098:	29 ea 

8420109a <Lc_splitter_connect_41>:
        /* Set the active sources.*/
        splitter->touched_sources |= TOUCHED_SOURCE_0 << terminal_info.terminal_num;
    }

    return TRUE;
}
8420109a:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420109c:	d8 4c       	rts;

8420109e <$_splitter_start>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420109e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842010a0:	16 00       	r4 = r0 + Null;
842010a2:	1a 09       	r8 = r1 + Null;
842010a4:	27 00       	r5 = r2 + Null;
842010a6:	28 09       	r6 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
842010a8:	ef fd fc ff 	call (m) 0x8ea;
842010ac:	23 e2 
842010ae:	11 09       	r7 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_start",base_op_get_ext_op_id(op_data));

    *response_id = OPCMD_START;
842010b0:	81 20       	rMAC = Null + 2;
842010b2:	39 ee       	M[r5 + Null] = rMAC;
    /* Check if the operator is already running */
    if (opmgr_op_is_running(op_data))
842010b4:	32 00       	r0 = r4 + Null;
842010b6:	ff fd 25 f0 	call (m) 0x5ca4;
842010ba:	2f ef 
842010bc:	10 04       	Null = r0 - Null;
842010be:	0b 60       	if EQ jump (m) Lc_splitter_start_4;

842010c0 <Lc_splitter_start_2>:
    {
        if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842010c0:	03 00       	r1 = Null + Null;
842010c2:	44 08       	r2 = r6 + Null;
842010c4:	32 00       	r0 = r4 + Null;
842010c6:	ef fd fb ff 	call (m) 0x8c0;
842010ca:	3b ef 
842010cc:	10 04       	Null = r0 - Null;
842010ce:	14 62       	if NE jump (m) Lc_splitter_start_7;

842010d0 <Lc_splitter_start_3>:
        {
            return FALSE;
842010d0:	02 00       	r0 = Null + Null;
842010d2:	13 6e       	jump (m) Lc_splitter_start_8;

842010d4 <Lc_splitter_start_4>:
            return TRUE;
        }
    }

    /* Start the operator. */
    if (!base_op_start(op_data, message_data, response_id, response_data))
842010d4:	45 08       	r3 = r6 + Null;
842010d6:	3c 00       	r2 = r5 + Null;
842010d8:	53 08       	r1 = r8 + Null;
842010da:	32 00       	r0 = r4 + Null;
842010dc:	ef fd fb ff 	call (m) 0x730;
842010e0:	35 e2 
842010e2:	10 04       	Null = r0 - Null;
842010e4:	f6 61       	if EQ jump (m) Lc_splitter_start_3;

842010e6 <Lc_splitter_start_5>:
    {
        return FALSE;
    }

    /* Splitter cannot run without channels. */
    if (splitter->channel_list == NULL)
842010e6:	91 f0 00 e8 	rMAC = M[r7 + Null];
842010ea:	06 62       	if NE jump (m) Lc_splitter_start_7;

842010ec <Lc_splitter_start_6>:
842010ec:	01 f0 00 60 	rMAC = Null + 4096;
842010f0:	82 f0 00 e8 	r0 = M[r6 + Null];
842010f4:	51 8e       	M[r0 + 4] = rMAC;

842010f6 <Lc_splitter_start_7>:
        {
            return FALSE;
        }
        else
        {
            return TRUE;
842010f6:	42 20       	r0 = Null + 1;

842010f8 <Lc_splitter_start_8>:
        /* At least one input and its corresponding output(s)
           need to be connected */
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    }
    return TRUE;
}
842010f8:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842010fa:	d8 4c       	rts;

842010fc <$_splitter_disconnect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842010fc:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
842010fe:	10 09       	r6 = r0 + Null;
84201100:	19 09       	r7 = r1 + Null;
84201102:	26 00       	r4 = r2 + Null;
84201104:	2a 09       	r8 = r3 + Null;
84201106:	ef fd fb ff 	call (m) 0x8ea;
8420110a:	25 ef 
8420110c:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
8420110e:	99 f0 00 e8 	r7 = M[r7 + Null];
    unsigned i;
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    *response_id = OPCMD_DISCONNECT;
84201112:	81 21       	rMAC = Null + 6;
84201114:	31 ee       	M[r4 + Null] = rMAC;
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84201116:	03 00       	r1 = Null + Null;
84201118:	54 08       	r2 = r8 + Null;
8420111a:	42 08       	r0 = r6 + Null;
8420111c:	ef fd fb ff 	call (m) 0x8c0;
84201120:	25 ed 
84201122:	10 04       	Null = r0 - Null;
84201124:	03 62       	if NE jump (m) Lc_splitter_disconnect_3;

84201126 <Lc_splitter_disconnect_2>:
    {
        return FALSE;
84201126:	02 00       	r0 = Null + Null;
84201128:	87 6e       	jump (m) Lc_splitter_disconnect_31;

8420112a <Lc_splitter_disconnect_3>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
8420112a:	c4 11       	r2 = FP + 28;
8420112c:	05 00       	r3 = Null + Null;
8420112e:	03 00       	r1 = Null + Null;
84201130:	4a 08       	r0 = r7 + Null;
84201132:	08 f0 21 e6 	call (m) $_get_terminal_info;
84201136:	10 04       	Null = r0 - Null;
84201138:	07 62       	if NE jump (m) Lc_splitter_disconnect_5;

8420113a <Lc_splitter_disconnect_4>:
8420113a:	01 f0 03 60 	rMAC = Null + 4099;
8420113e:	a2 f0 00 e8 	r0 = M[r8 + Null];
84201142:	51 8e       	M[r0 + 4] = rMAC;
84201144:	78 6e       	jump (m) Lc_splitter_disconnect_30;

84201146 <Lc_splitter_disconnect_5>:
    }

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_disconnect",base_op_get_ext_op_id(op_data));
    SPLITTER_MSG2("disconnect is_input = %d, index = %d",terminal_info.is_input, terminal_info.index);

    channel = get_channel_struct(splitter, terminal_info.channel_id);
84201146:	3b d8       	r1 = M[FP + 28];
84201148:	3a 00       	r0 = r5 + Null;
8420114a:	09 f0 3b e6 	call (m) $_get_channel_struct;
8420114e:	16 00       	r4 = r0 + Null;
    if (channel == NULL)
84201150:	13 60       	if EQ jump (m) Lc_splitter_disconnect_10;

84201152 <Lc_splitter_disconnect_6>:
        /* Unable to find the channel. Something is wrong. */
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
84201152:	42 08       	r0 = r6 + Null;
84201154:	ff fd 25 f0 	call (m) 0x5ca4;
84201158:	31 ea 
8420115a:	10 04       	Null = r0 - Null;
8420115c:	35 60       	if EQ jump (m) Lc_splitter_disconnect_19;

8420115e <Lc_splitter_disconnect_7>:
    {
        bool error = FALSE;
        if (terminal_info.is_input)
8420115e:	40 d8       	Null = M[FP + 32];
84201160:	11 60       	if EQ jump (m) Lc_splitter_disconnect_11;

84201162 <Lc_splitter_disconnect_8>:
        {
            SPLITTER_ERRORMSG("Splitter: Input buffers cannot be disconnected even if the data is buffered.");
84201162:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201166:	08 24       	Null = rMAC - 0;
84201168:	07 6c       	if LE jump (m) Lc_splitter_disconnect_10;

8420116a <Lc_splitter_disconnect_9>:
8420116a:	55 f1 02 f0 	r0 = Null + 357566768;
8420116e:	30 51 
84201170:	ef fd ff ff 	call (m) 0x10b0;
84201174:	21 ea 

84201176 <Lc_splitter_disconnect_10>:
84201176:	01 f0 00 60 	rMAC = Null + 4096;
8420117a:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420117e:	51 8e       	M[r0 + 4] = rMAC;
84201180:	5a 6e       	jump (m) Lc_splitter_disconnect_30;

84201182 <Lc_splitter_disconnect_11>:
            error = TRUE;
        }
        else
        {
            if (get_current_output_state(splitter, terminal_info.index) == ACTIVE)
84201182:	52 d8       	r0 = M[FP + 40];
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84201184:	39 00       	rMAC = r5 + Null;
84201186:	51 00       	rMAC = r0 + rMAC;
84201188:	09 b0       	rMAC = MBS[rMAC + 24];
8420118a:	48 24       	Null = rMAC - 1;
8420118c:	1d 62       	if NE jump (m) Lc_splitter_disconnect_19;

8420118e <Lc_splitter_disconnect_12>:
            {
                SPLITTER_STREAMS streams;
                SPLITTER_STREAMS to_do_running_streams = OUT_STREAM__0_OFF__1_OFF;
                if (terminal_info.terminal_num  & 0x1)
8420118e:	49 d8       	rMAC = M[FP + 36];
84201190:	09 c0       	rMAC = rMAC AND 0x1;
84201192:	05 60       	if EQ jump (m) Lc_splitter_disconnect_14;

84201194 <Lc_splitter_disconnect_13>:
                {
                    /* clear OPMSG_SPLITTER_STREAM_1 */
                    streams = splitter->active_streams & OUT_STREAM__0_ON___1_OFF;
84201194:	b9 b2       	rMAC = MBU[r5 + 26];
84201196:	0b c0       	r1 = rMAC AND 0x1;
                    to_do_running_streams = splitter->active_streams & OUT_STREAM__0_OFF__1_ON;
84201198:	49 c0       	rMAC = rMAC AND 0x2;
8420119a:	04 6e       	jump (m) Lc_splitter_disconnect_15;

8420119c <Lc_splitter_disconnect_14>:
                }
                else
                {
                    /* clear OPMSG_SPLITTER_STREAM_0 */
                    streams = splitter->active_streams & OUT_STREAM__0_OFF__1_ON;
8420119c:	b9 b2       	rMAC = MBU[r5 + 26];
8420119e:	4b c0       	r1 = rMAC AND 0x2;
                    to_do_running_streams = splitter->active_streams & OUT_STREAM__0_ON___1_OFF;
842011a0:	09 c0       	rMAC = rMAC AND 0x1;

842011a2 <Lc_splitter_disconnect_15>:
                }

                if (to_do_running_streams)
842011a2:	08 04       	Null = rMAC - Null;
842011a4:	11 60       	if EQ jump (m) Lc_splitter_disconnect_19;

842011a6 <Lc_splitter_disconnect_16>:
                {
                    if (!set_running_streams(op_data, streams))
842011a6:	42 08       	r0 = r6 + Null;
842011a8:	04 f0 21 ec 	call (m) Lc_set_running_streams_1;
842011ac:	10 04       	Null = r0 - Null;
842011ae:	0c 62       	if NE jump (m) Lc_splitter_disconnect_19;

842011b0 <Lc_splitter_disconnect_17>:
                    {
                        SPLITTER_ERRORMSG("Splitter: Active outputs cannot be disconnected.");
842011b0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842011b4:	08 24       	Null = rMAC - 0;
842011b6:	e0 6d       	if LE jump (m) Lc_splitter_disconnect_10;

842011b8 <Lc_splitter_disconnect_18>:
842011b8:	55 f1 02 f0 	r0 = Null + 357566845;
842011bc:	7d 51 
842011be:	ef fd ff ff 	call (m) 0x10b0;
842011c2:	33 e7 
842011c4:	d9 6f       	jump (m) Lc_splitter_disconnect_10;

842011c6 <Lc_splitter_disconnect_19>:
            return TRUE;
        }
    }


    if (terminal_info.is_input)
842011c6:	40 d8       	Null = M[FP + 32];
842011c8:	1d 60       	if EQ jump (m) Lc_splitter_disconnect_26;

842011ca <Lc_splitter_disconnect_20>:
    {
        SPLITTER_MSG1("Splitter: Disconnecting sink terminal %4d!", terminal_info.terminal_num);
        channel->input_buffer = NULL;
842011ca:	b0 8e       	M[r4 + 8] = Null;
        splitter->touched_sinks &= ~(TOUCHED_SINK_0 << terminal_info.terminal_num);
842011cc:	49 d8       	rMAC = M[FP + 36];
842011ce:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
842011d2:	ff f2 51 d6 	rMAC = -1 - r0;
842011d6:	3a 89       	r0 = M[r5 + 16];
842011d8:	89 10       	rMAC = rMAC AND r0;
842011da:	39 8f       	M[r5 + 16] = rMAC;

        if (splitter->working_mode == CLONE_BUFFER)
842011dc:	39 81       	rMAC = MBS[r5 + 4];
842011de:	28 62       	if NE jump (m) Lc_splitter_disconnect_29;

842011e0 <Lc_splitter_disconnect_21>:
        {
            /* If there are outputs connected we need to make them look empty.
             * This shouldn't be done by the user, but we can't reject the
             * scenario when we're stopped as destroy operator needs to
             * disconnect all terminals before the operator are destroyed. */
            opmgr_op_suspend_processing(op_data);
842011e0:	42 08       	r0 = r6 + Null;
842011e2:	ff fd 25 f0 	call (m) 0x5cb0;
842011e6:	2f e6 
842011e8:	32 23       	r0 = r4 + 12;
            for (i = 0; i < SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842011ea:	14 71       	r10 = Null + 2;
842011ec:	06 4c       	do (m) Lc__loop0;

842011ee <Lc_splitter_disconnect_22>:
            {
                tCbuffer *out = channel->output_buffer[i];
                if (out != NULL)
842011ee:	11 e8       	rMAC = M[r0 + Null];
842011f0:	03 60       	if EQ jump (m) Lc_splitter_disconnect_24;

842011f2 <Lc_splitter_disconnect_23>:
                {
                    out->write_ptr = out->read_ptr;
842011f2:	4b 88       	r1 = M[rMAC + 4];
842011f4:	8b 8e       	M[rMAC + 8] = r1;

842011f6 <Lc_splitter_disconnect_24>:
842011f6:	12 21       	r0 = r0 + 4;

842011f8 <Lc__loop0>:
            /* If there are outputs connected we need to make them look empty.
             * This shouldn't be done by the user, but we can't reject the
             * scenario when we're stopped as destroy operator needs to
             * disconnect all terminals before the operator are destroyed. */
            opmgr_op_suspend_processing(op_data);
            for (i = 0; i < SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842011f8:	42 08       	r0 = r6 + Null;
842011fa:	ff fd 25 f0 	call (m) 0x5ce0;
842011fe:	27 e7 
84201200:	17 6e       	jump (m) Lc_splitter_disconnect_29;

84201202 <Lc_splitter_disconnect_26>:
        }
    }
    else
    {
        SPLITTER_MSG1("Splitter: Disconnecting source terminal %4d!", terminal_info.terminal_num);
        splitter->touched_sinks &= ~(TOUCHED_SINK_0 << terminal_info.terminal_num);
84201202:	49 d8       	rMAC = M[FP + 36];
84201204:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201208:	ff f2 51 d6 	rMAC = -1 - r0;
8420120c:	3a 89       	r0 = M[r5 + 16];
8420120e:	89 10       	rMAC = rMAC AND r0;
84201210:	39 8f       	M[r5 + 16] = rMAC;

        if (splitter->working_mode == CLONE_BUFFER)
84201212:	39 81       	rMAC = MBS[r5 + 4];
84201214:	09 62       	if NE jump (m) Lc_splitter_disconnect_28;

84201216 <Lc_splitter_disconnect_27>:
        {
            tCbuffer* buff;
            buff = channel->output_buffer[terminal_info.index];
84201216:	52 d8       	r0 = M[FP + 40];
84201218:	31 00       	rMAC = r4 + Null;
8420121a:	52 54       	r0 = r0 LSHIFT 2;
8420121c:	51 00       	rMAC = r0 + rMAC;
8420121e:	ca 88       	r0 = M[rMAC + 12];
            cbuffer_destroy_struct(buff);
84201220:	ff fd 98 f0 	call (m) 0x1432e;
84201224:	2f e8 

84201226 <Lc_splitter_disconnect_28>:
        }
        channel->output_buffer[terminal_info.index] = NULL;
84201226:	52 d8       	r0 = M[FP + 40];
84201228:	52 54       	r0 = r0 LSHIFT 2;
8420122a:	96 01       	r4 = r0 + r4;
8420122c:	f0 8e       	M[r4 + 12] = Null;

8420122e <Lc_splitter_disconnect_29>:
    }

    delete_disconnected_channel(splitter);
8420122e:	3a 00       	r0 = r5 + Null;
84201230:	09 f0 2b e0 	call (m) $_delete_disconnected_channel;

84201234 <Lc_splitter_disconnect_30>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84201234:	42 20       	r0 = Null + 1;

84201236 <Lc_splitter_disconnect_31>:
        channel->output_buffer[terminal_info.index] = NULL;
    }

    delete_disconnected_channel(splitter);
    return TRUE;
}
84201236:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84201238:	d8 4c       	rts;

8420123a <$_splitter_destroy>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420123a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420123c:	10 09       	r6 = r0 + Null;
8420123e:	29 09       	r7 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201240:	ef fd fb ff 	call (m) 0x8ea;
84201244:	2b e5 
84201246:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
84201248:	37 31       	r5 = r4 + 36;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
8420124a:	ff fd 6b f2 	call (m) 0x4e996;
8420124e:	2d ea 
    if (*timer_id != TIMER_ID_INVALID)
84201250:	3a e8       	r0 = M[r5 + Null];
84201252:	07 60       	if EQ jump (m) Lc_splitter_destroy_3;

84201254 <Lc_splitter_destroy_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84201254:	04 00       	r2 = Null + Null;
84201256:	03 00       	r1 = Null + Null;
84201258:	ff fd 2b f0 	call (m) 0x6936;
8420125c:	3f e6 
        *timer_id = TIMER_ID_INVALID;
8420125e:	38 ee       	M[r5 + Null] = Null;

84201260 <Lc_splitter_destroy_3>:
    }
    interrupt_unblock();
84201260:	ff fd 6b f2 	call (m) 0x4e9b2;
84201264:	33 ea 

    if (splitter->curr_connecting)
84201266:	32 98       	r0 = M[r4 + 32];
84201268:	04 60       	if EQ jump (m) Lc_splitter_destroy_5;

8420126a <Lc_splitter_destroy_4>:
    {
        /* Clear up the capability specific data. */
        /* A buffer may have been orphaned during a failed connect make sure it
         * gets freed. */
        cbuffer_destroy_struct(splitter->curr_connecting);
8420126a:	ff fd 98 f0 	call (m) 0x1432e;
8420126e:	25 e6 

84201270 <Lc_splitter_destroy_5>:
    }
#ifdef INSTALL_EXTERNAL_MEM
    /* Check if SRAM need disabling. */
    if (splitter->location == SRAM)
84201270:	71 81       	rMAC = MBS[r4 + 5];
84201272:	48 24       	Null = rMAC - 1;
84201274:	09 62       	if NE jump (m) Lc_splitter_destroy_7;

84201276 <Lc_splitter_destroy_6>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_OFF, NULL, EXT_MEM_WAIT);
84201276:	15 f0 10 4b 	r3 = Null + 10000;
8420127a:	04 00       	r2 = Null + Null;
8420127c:	03 00       	r1 = Null + Null;
8420127e:	02 00       	r0 = Null + Null;
84201280:	ff fd aa f0 	call (m) 0x166ca;
84201284:	2b e2 

84201286 <Lc_splitter_destroy_7>:
    }
#endif

    return base_op_destroy_lite(op_data, response_data);
84201286:	4b 08       	r1 = r7 + Null;
84201288:	42 08       	r0 = r6 + Null;
8420128a:	ef fd fa ff 	call (m) 0x834;
8420128e:	2b ed 

84201290 <Lc_splitter_destroy_8>:
}
84201290:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201292:	d8 4c       	rts;

84201294 <$_splitter_get_data_format>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84201294:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201296:	17 00       	r5 = r0 + Null;
84201298:	20 09       	r6 = r2 + Null;
8420129a:	2e 00       	r4 = r3 + Null;
8420129c:	ef fd fb ff 	call (m) 0x8ea;
842012a0:	2f e2 
842012a2:	11 09       	r7 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    *response_id = OPCMD_DATA_FORMAT;
842012a4:	01 22       	rMAC = Null + 8;
842012a6:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    /* Set up the a default success response information */
    if (base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842012aa:	03 00       	r1 = Null + Null;
842012ac:	34 00       	r2 = r4 + Null;
842012ae:	3a 00       	r0 = r5 + Null;
842012b0:	ef fd fb ff 	call (m) 0x8c0;
842012b4:	31 e0 
842012b6:	10 04       	Null = r0 - Null;
842012b8:	07 60       	if EQ jump (m) Lc_splitter_get_data_format_3;

842012ba <Lc_splitter_get_data_format_2>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = splitter->data_format;
842012ba:	91 f0 03 88 	rMAC = M[r7 + 12];
842012be:	32 e8       	r0 = M[r4 + Null];
842012c0:	91 8e       	M[r0 + 8] = rMAC;
        return TRUE;
842012c2:	42 20       	r0 = Null + 1;
842012c4:	02 6e       	jump (m) Lc_splitter_get_data_format_4;

842012c6 <Lc_splitter_get_data_format_3>:
    }
    else
    {
        return FALSE;
842012c6:	02 00       	r0 = Null + Null;

842012c8 <Lc_splitter_get_data_format_4>:
    }
}
842012c8:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842012ca:	d8 4c       	rts;

842012cc <$_splitter_set_working_mode>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_working_mode(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012cc:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842012ce:	17 00       	r5 = r0 + Null;
842012d0:	1e 00       	r4 = r1 + Null;
842012d2:	ef fd fb ff 	call (m) 0x8ea;
842012d6:	39 e0 
842012d8:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_MODES working_mode;
    if (opmgr_op_is_running(op_data))
842012da:	3a 00       	r0 = r5 + Null;
842012dc:	ff fd 24 f0 	call (m) 0x5ca4;
842012e0:	29 ee 
842012e2:	10 04       	Null = r0 - Null;
842012e4:	0d 60       	if EQ jump (m) Lc_splitter_set_working_mode_5;

842012e6 <Lc_splitter_set_working_mode_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_working_mode: Cannot configure working mode while running!");
842012e6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842012ea:	08 24       	Null = rMAC - 0;
842012ec:	07 6c       	if LE jump (m) Lc_splitter_set_working_mode_4;

842012ee <Lc_splitter_set_working_mode_3>:
842012ee:	55 f1 02 f0 	r0 = Null + 357567162;
842012f2:	ba 52 
842012f4:	ef fd fe ff 	call (m) 0x10b0;
842012f8:	3d ed 

842012fa <Lc_splitter_set_working_mode_4>:
        return FALSE;
842012fa:	02 00       	r0 = Null + Null;
842012fc:	2e 6e       	jump (m) Lc_splitter_set_working_mode_14;

842012fe <Lc_splitter_set_working_mode_5>:
    }
    if  (splitter->channel_list != NULL)
842012fe:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201302:	0c 60       	if EQ jump (m) Lc_splitter_set_working_mode_8;

84201304 <Lc_splitter_set_working_mode_6>:
    {
        SPLITTER_ERRORMSG("splitter_set_working_mode: Cannot set working mode with connected terminals!");
84201304:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201308:	08 24       	Null = rMAC - 0;
8420130a:	f8 6d       	if LE jump (m) Lc_splitter_set_working_mode_4;

8420130c <Lc_splitter_set_working_mode_7>:
8420130c:	55 f1 02 f0 	r0 = Null + 357567234;
84201310:	02 53 
84201312:	ef fd fe ff 	call (m) 0x10b0;
84201316:	3f ec 
84201318:	f1 6f       	jump (m) Lc_splitter_set_working_mode_4;

8420131a <Lc_splitter_set_working_mode_8>:
        return FALSE;
    }
    working_mode = (SPLITTER_MODES)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_WORKING_MODE, WORKING_MODE);
8420131a:	f1 88       	rMAC = M[r4 + 12];
8420131c:	89 c6       	rMAC = rMAC AND 0xffff;
8420131e:	0b 08       	r1 = SE8 rMAC;
    if  (working_mode >= NR_OF_MODES)
84201320:	98 24       	Null = r1 - 2;
84201322:	0c 68       	if LT jump (m) Lc_splitter_set_working_mode_11;

84201324 <Lc_splitter_set_working_mode_9>:
    {
        SPLITTER_ERRORMSG1("splitter_set_working_mode: %d is an unknonw working mode!", working_mode);
84201324:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201328:	08 24       	Null = rMAC - 0;
8420132a:	e8 6d       	if LE jump (m) Lc_splitter_set_working_mode_4;

8420132c <Lc_splitter_set_working_mode_10>:
8420132c:	55 f1 02 f0 	r0 = Null + 357567311;
84201330:	4f 53 
84201332:	ef fd fe ff 	call (m) 0x10c2;
84201336:	31 ec 
84201338:	e1 6f       	jump (m) Lc_splitter_set_working_mode_4;

8420133a <Lc_splitter_set_working_mode_11>:
        return FALSE;
    }
    if(working_mode == BUFFER_DATA)
8420133a:	58 24       	Null = r1 - 1;
8420133c:	0b 62       	if NE jump (m) Lc_splitter_set_working_mode_13;

8420133e <Lc_splitter_set_working_mode_12>:
    {
        /* Deactivate all output streams. */
        splitter->active_streams = OUT_STREAM__0_OFF__1_OFF;
8420133e:	81 f0 1a 82 	rMAC = MBU[r6 + 26];
84201342:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
        splitter->inactive_streams = OUT_STREAM__0_ON___1_ON;
84201346:	06 f1 51 c8 	rMAC = rMAC OR 0xc;
        splitter->hold_streams = OUT_STREAM__0_OFF__1_OFF;
8420134a:	11 ff cf 1f 	rMAC = rMAC AND 0xffffffcf;
8420134e:	81 f0 1a 8a 	MB[r6 + 26] = rMAC;

84201352 <Lc_splitter_set_working_mode_13>:
    }
    splitter->working_mode = working_mode;
84201352:	83 f0 04 8a 	MB[r6 + 4] = r1;
    SPLITTER_MSG1("splitter: Working mode set to %d (0 CLONE_BUFFER, 1 BUFFER_DATA)!",working_mode);
    return TRUE;
84201356:	42 20       	r0 = Null + 1;

84201358 <Lc_splitter_set_working_mode_14>:
}
84201358:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420135a:	d8 4c       	rts;

8420135c <$_splitter_set_location>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_location(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420135c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420135e:	16 00       	r4 = r0 + Null;
84201360:	18 09       	r6 = r1 + Null;
84201362:	ef fd fa ff 	call (m) 0x8ea;
84201366:	29 ec 
84201368:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_BUFFER_LOCATION location;
    if (opmgr_op_is_running(op_data))
8420136a:	32 00       	r0 = r4 + Null;
8420136c:	ff fd 24 f0 	call (m) 0x5ca4;
84201370:	39 e9 
84201372:	10 04       	Null = r0 - Null;
84201374:	0d 60       	if EQ jump (m) Lc_splitter_set_location_5;

84201376 <Lc_splitter_set_location_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_location: Cannot configure buffering location mode while running!");
84201376:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420137a:	08 24       	Null = rMAC - 0;
8420137c:	07 6c       	if LE jump (m) Lc_splitter_set_location_4;

8420137e <Lc_splitter_set_location_3>:
8420137e:	55 f1 02 f0 	r0 = Null + 357567369;
84201382:	89 53 
84201384:	ef fd fe ff 	call (m) 0x10b0;
84201388:	2d e9 

8420138a <Lc_splitter_set_location_4>:
        return FALSE;
8420138a:	02 00       	r0 = Null + Null;
8420138c:	3c 6e       	jump (m) Lc_splitter_set_location_18;

8420138e <Lc_splitter_set_location_5>:
    }
    if (splitter->working_mode != BUFFER_DATA)
8420138e:	39 81       	rMAC = MBS[r5 + 4];
84201390:	48 24       	Null = rMAC - 1;
84201392:	0c 60       	if EQ jump (m) Lc_splitter_set_location_8;

84201394 <Lc_splitter_set_location_6>:
    {
        SPLITTER_ERRORMSG("splitter_set_location: Cannot set location when input buffer is cloned!");
84201394:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201398:	08 24       	Null = rMAC - 0;
8420139a:	f8 6d       	if LE jump (m) Lc_splitter_set_location_4;

8420139c <Lc_splitter_set_location_7>:
8420139c:	55 f1 02 f0 	r0 = Null + 357567448;
842013a0:	d8 53 
842013a2:	ef fd fe ff 	call (m) 0x10b0;
842013a6:	2f e8 
842013a8:	f1 6f       	jump (m) Lc_splitter_set_location_4;

842013aa <Lc_splitter_set_location_8>:
        return FALSE;
    }
    location = (SPLITTER_BUFFER_LOCATION)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_LOCATION, LOCATION);
842013aa:	81 f0 03 88 	rMAC = M[r6 + 12];
842013ae:	89 c6       	rMAC = rMAC AND 0xffff;
842013b0:	0e 08       	r4 = SE8 rMAC;
    if (location >= NR_OF_LOCATIONS)
842013b2:	b0 24       	Null = r4 - 2;
842013b4:	0d 68       	if LT jump (m) Lc_splitter_set_location_11;

842013b6 <Lc_splitter_set_location_9>:
    {
        SPLITTER_ERRORMSG1("splitter_set_location: %d is a unknown location for SPLITTER_BUFFER_LOCATION!", location);
842013b6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842013ba:	08 24       	Null = rMAC - 0;
842013bc:	e7 6d       	if LE jump (m) Lc_splitter_set_location_4;

842013be <Lc_splitter_set_location_10>:
842013be:	55 f1 02 f0 	r0 = Null + 357567520;
842013c2:	20 58 
842013c4:	33 00       	r1 = r4 + Null;
842013c6:	ef fd fe ff 	call (m) 0x10c2;
842013ca:	3d e7 
842013cc:	df 6f       	jump (m) Lc_splitter_set_location_4;

842013ce <Lc_splitter_set_location_11>:
        return FALSE;
    }

#ifdef INSTALL_EXTERNAL_MEM
    /* Check if SRAM need enabling */
    if ((splitter->location == INTERNAL) && (location == SRAM))
842013ce:	79 81       	rMAC = MBS[r5 + 5];
842013d0:	0b 62       	if NE jump (m) Lc_splitter_set_location_14;

842013d2 <Lc_splitter_set_location_12>:
842013d2:	70 24       	Null = r4 - 1;
842013d4:	09 62       	if NE jump (m) Lc_splitter_set_location_14;

842013d6 <Lc_splitter_set_location_13>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_ON, NULL, EXT_MEM_WAIT);
842013d6:	15 f0 10 4b 	r3 = Null + 10000;
842013da:	43 20       	r1 = Null + 1;
842013dc:	04 00       	r2 = Null + Null;
842013de:	02 00       	r0 = Null + Null;
842013e0:	ff fd a9 f0 	call (m) 0x166ca;
842013e4:	2b e7 

842013e6 <Lc_splitter_set_location_14>:
    }
    /* Check if SRAM need disabling. */
    if ((splitter->location == SRAM) && (location == INTERNAL))
842013e6:	79 81       	rMAC = MBS[r5 + 5];
842013e8:	48 24       	Null = rMAC - 1;
842013ea:	0b 62       	if NE jump (m) Lc_splitter_set_location_17;

842013ec <Lc_splitter_set_location_15>:
842013ec:	30 04       	Null = r4 - Null;
842013ee:	09 62       	if NE jump (m) Lc_splitter_set_location_17;

842013f0 <Lc_splitter_set_location_16>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_OFF, NULL, EXT_MEM_WAIT);
842013f0:	15 f0 10 4b 	r3 = Null + 10000;
842013f4:	04 00       	r2 = Null + Null;
842013f6:	03 00       	r1 = Null + Null;
842013f8:	02 00       	r0 = Null + Null;
842013fa:	ff fd a9 f0 	call (m) 0x166ca;
842013fe:	31 e6 

84201400 <Lc_splitter_set_location_17>:
    }
#else
     PL_ASSERT(location == INTERNAL);
#endif

    splitter->location = location;
84201400:	7e 8b       	MB[r5 + 5] = r4;
    SPLITTER_MSG1("splitter_set_location: Location set to %d (0 INTERNAL, 1 SRAM)!", location);
    return TRUE;
84201402:	42 20       	r0 = Null + 1;

84201404 <Lc_splitter_set_location_18>:
}
84201404:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201406:	d8 4c       	rts;

84201408 <$_splitter_set_packing>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_packing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201408:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420140a:	17 00       	r5 = r0 + Null;
8420140c:	1e 00       	r4 = r1 + Null;
8420140e:	ef fd fa ff 	call (m) 0x8ea;
84201412:	3d e6 
84201414:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_PACKING packing;
    if (opmgr_op_is_running(op_data))
84201416:	3a 00       	r0 = r5 + Null;
84201418:	ff fd 24 f0 	call (m) 0x5ca4;
8420141c:	2d e4 
8420141e:	10 04       	Null = r0 - Null;
84201420:	0d 60       	if EQ jump (m) Lc_splitter_set_packing_5;

84201422 <Lc_splitter_set_packing_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot configure working packing while running!");
84201422:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201426:	08 24       	Null = rMAC - 0;
84201428:	07 6c       	if LE jump (m) Lc_splitter_set_packing_4;

8420142a <Lc_splitter_set_packing_3>:
8420142a:	55 f1 02 f0 	r0 = Null + 357567598;
8420142e:	6e 58 
84201430:	ef fd fe ff 	call (m) 0x10b0;
84201434:	21 e4 

84201436 <Lc_splitter_set_packing_4>:
        return FALSE;
84201436:	02 00       	r0 = Null + Null;
84201438:	34 6e       	jump (m) Lc_splitter_set_packing_16;

8420143a <Lc_splitter_set_packing_5>:
    }
    if (splitter->working_mode != BUFFER_DATA)
8420143a:	81 f0 04 80 	rMAC = MBS[r6 + 4];
8420143e:	48 24       	Null = rMAC - 1;
84201440:	0c 60       	if EQ jump (m) Lc_splitter_set_packing_8;

84201442 <Lc_splitter_set_packing_6>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot set packing when input buffer is cloned!");
84201442:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201446:	08 24       	Null = rMAC - 0;
84201448:	f7 6d       	if LE jump (m) Lc_splitter_set_packing_4;

8420144a <Lc_splitter_set_packing_7>:
8420144a:	55 f1 02 f0 	r0 = Null + 357567668;
8420144e:	b4 58 
84201450:	ef fd fe ff 	call (m) 0x10b0;
84201454:	21 e3 
84201456:	f0 6f       	jump (m) Lc_splitter_set_packing_4;

84201458 <Lc_splitter_set_packing_8>:
        return FALSE;
    }
    if ((splitter->data_format != AUDIO_DATA_FORMAT_FIXP) && (splitter->data_format != AUDIO_DATA_FORMAT_FIXP_WITH_METADATA))
84201458:	81 f0 03 88 	rMAC = M[r6 + 12];
8420145c:	48 24       	Null = rMAC - 1;
8420145e:	0e 60       	if EQ jump (m) Lc_splitter_set_packing_12;

84201460 <Lc_splitter_set_packing_9>:
84201460:	c8 24       	Null = rMAC - 3;
84201462:	0c 60       	if EQ jump (m) Lc_splitter_set_packing_12;

84201464 <Lc_splitter_set_packing_10>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot set packing when data format is different than audio!");
84201464:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201468:	08 24       	Null = rMAC - 0;
8420146a:	e6 6d       	if LE jump (m) Lc_splitter_set_packing_4;

8420146c <Lc_splitter_set_packing_11>:
8420146c:	55 f1 02 f0 	r0 = Null + 357567738;
84201470:	fa 58 
84201472:	ef fd fe ff 	call (m) 0x10b0;
84201476:	3f e1 
84201478:	df 6f       	jump (m) Lc_splitter_set_packing_4;

8420147a <Lc_splitter_set_packing_12>:
        return FALSE;
    }
    packing = (SPLITTER_MODES)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_PACKING, PACKING);
8420147a:	f1 88       	rMAC = M[r4 + 12];
8420147c:	89 c6       	rMAC = rMAC AND 0xffff;
8420147e:	0b 08       	r1 = SE8 rMAC;
    if (packing >= NR_OF_PACKING)
84201480:	98 24       	Null = r1 - 2;
84201482:	0c 68       	if LT jump (m) Lc_splitter_set_packing_15;

84201484 <Lc_splitter_set_packing_13>:
    {
        SPLITTER_ERRORMSG1("splitter_set_packing: %d is an invalid packing!", packing);
84201484:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201488:	08 24       	Null = rMAC - 0;
8420148a:	d6 6d       	if LE jump (m) Lc_splitter_set_packing_4;

8420148c <Lc_splitter_set_packing_14>:
8420148c:	55 f1 02 f0 	r0 = Null + 357567821;
84201490:	4d 59 
84201492:	ef fd fe ff 	call (m) 0x10c2;
84201496:	31 e1 
84201498:	cf 6f       	jump (m) Lc_splitter_set_packing_4;

8420149a <Lc_splitter_set_packing_15>:
        return FALSE;
    }

    splitter->packing = packing;
8420149a:	83 f0 06 8a 	MB[r6 + 6] = r1;
    SPLITTER_MSG1("splitter_set_packing: Packing set to %d (0 UNPACKED, 1 PACKED)!", packing);
    return TRUE;
8420149e:	42 20       	r0 = Null + 1;

842014a0 <Lc_splitter_set_packing_16>:
}
842014a0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842014a2:	d8 4c       	rts;

842014a4 <$_splitter_set_buffer_size>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842014a4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842014a6:	16 00       	r4 = r0 + Null;
842014a8:	18 09       	r6 = r1 + Null;
842014aa:	ef fd fa ff 	call (m) 0x8ea;
842014ae:	21 e2 
842014b0:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned buffer_size;
    if (opmgr_op_is_running(op_data))
842014b2:	32 00       	r0 = r4 + Null;
842014b4:	ff fd 23 f0 	call (m) 0x5ca4;
842014b8:	31 ef 
842014ba:	10 04       	Null = r0 - Null;
842014bc:	0d 60       	if EQ jump (m) Lc_splitter_set_buffer_size_5;

842014be <Lc_splitter_set_buffer_size_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Operator running!");
842014be:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842014c2:	08 24       	Null = rMAC - 0;
842014c4:	07 6c       	if LE jump (m) Lc_splitter_set_buffer_size_4;

842014c6 <Lc_splitter_set_buffer_size_3>:
842014c6:	55 f1 02 f0 	r0 = Null + 357566894;
842014ca:	ae 51 
842014cc:	ef fd fd ff 	call (m) 0x10b0;
842014d0:	25 ef 

842014d2 <Lc_splitter_set_buffer_size_4>:
        return FALSE;
842014d2:	02 00       	r0 = Null + Null;
842014d4:	23 6e       	jump (m) Lc_splitter_set_buffer_size_12;

842014d6 <Lc_splitter_set_buffer_size_5>:
    }
    /* Channels are created on demand so if there is any the operaor is connected. */
    if  (splitter->channel_list != NULL)
842014d6:	39 e8       	rMAC = M[r5 + Null];
842014d8:	0c 60       	if EQ jump (m) Lc_splitter_set_buffer_size_8;

842014da <Lc_splitter_set_buffer_size_6>:
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Cannot set the buffer size for an operator with connected terminals!");
842014da:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842014de:	08 24       	Null = rMAC - 0;
842014e0:	f9 6d       	if LE jump (m) Lc_splitter_set_buffer_size_4;

842014e2 <Lc_splitter_set_buffer_size_7>:
842014e2:	55 f1 02 f0 	r0 = Null + 357566938;
842014e6:	da 51 
842014e8:	ef fd fd ff 	call (m) 0x10b0;
842014ec:	29 ee 
842014ee:	f2 6f       	jump (m) Lc_splitter_set_buffer_size_4;

842014f0 <Lc_splitter_set_buffer_size_8>:
        return FALSE;
    }
    buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
842014f0:	81 f0 03 88 	rMAC = M[r6 + 12];
842014f4:	8e c6       	r4 = rMAC AND 0xffff;
    if (buffer_size < SPLITTER_MIN_INTERNAL_BUFFER_SIZE)
842014f6:	60 f0 00 2c 	Null = r4 - 1024;
842014fa:	02 f0 9d e0 	if C jump (m) Lc_splitter_set_buffer_size_11;

842014fe <Lc_splitter_set_buffer_size_9>:
    {
        SPLITTER_ERRORMSG1("splitter_set_buffer_size: Buffer size too small! "
                "Please use an internal buffer size of at least %d words to increase efficiency.",
                SPLITTER_MIN_INTERNAL_BUFFER_SIZE);
842014fe:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201502:	08 24       	Null = rMAC - 0;
84201504:	09 6c       	if LE jump (m) Lc_splitter_set_buffer_size_11;

84201506 <Lc_splitter_set_buffer_size_10>:
84201506:	03 f0 00 48 	r1 = Null + 1024;
8420150a:	55 f1 02 f0 	r0 = Null + 357567033;
8420150e:	39 52 
84201510:	ef fd fd ff 	call (m) 0x10c2;
84201514:	33 ed 

84201516 <Lc_splitter_set_buffer_size_11>:
        /* This could be a valid settings in some cases so continue with no errors.*/
    }
    splitter->buffer_size = buffer_size;
84201516:	be 8e       	M[r5 + 8] = r4;
    SPLITTER_MSG1("splitter_set_buffer_size: Internal buffer size set to %d words!", splitter->buffer_size);
    return TRUE;
84201518:	42 20       	r0 = Null + 1;

8420151a <Lc_splitter_set_buffer_size_12>:
}
8420151a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420151c:	d8 4c       	rts;

8420151e <$_splitter_set_data_format>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420151e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201520:	17 00       	r5 = r0 + Null;
84201522:	1e 00       	r4 = r1 + Null;
84201524:	ef fd f9 ff 	call (m) 0x8ea;
84201528:	27 ee 
8420152a:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    AUDIO_DATA_FORMAT data_format;

    if (opmgr_op_is_running(op_data))
8420152c:	3a 00       	r0 = r5 + Null;
8420152e:	ff fd 23 f0 	call (m) 0x5ca4;
84201532:	37 eb 
84201534:	10 04       	Null = r0 - Null;
84201536:	0d 60       	if EQ jump (m) Lc_splitter_set_data_format_5;

84201538 <Lc_splitter_set_data_format_2>:
    {
        SPLITTER_ERRORMSG("splitter: Cannot set data format while running!");
84201538:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420153c:	08 24       	Null = rMAC - 0;
8420153e:	07 6c       	if LE jump (m) Lc_splitter_set_data_format_4;

84201540 <Lc_splitter_set_data_format_3>:
84201540:	55 f1 02 f0 	r0 = Null + 357567869;
84201544:	7d 59 
84201546:	ef fd fd ff 	call (m) 0x10b0;
8420154a:	2b eb 

8420154c <Lc_splitter_set_data_format_4>:
        return FALSE;
8420154c:	02 00       	r0 = Null + Null;
8420154e:	15 6e       	jump (m) Lc_splitter_set_data_format_9;

84201550 <Lc_splitter_set_data_format_5>:
    }
    data_format = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_DATA_FORMAT, DATA_TYPE);
84201550:	f1 88       	rMAC = M[r4 + 12];
84201552:	89 c6       	rMAC = rMAC AND 0xffff;

    /* Always activate tag reframing when the data format is audio.*/
    if ((data_format == AUDIO_DATA_FORMAT_FIXP) || (data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA))
84201554:	48 24       	Null = rMAC - 1;
84201556:	05 62       	if NE jump (m) Lc_splitter_set_data_format_7;

84201558 <Lc_splitter_set_data_format_6>:
    {
        splitter->tag_size_to_samples = TRUE;
84201558:	42 20       	r0 = Null + 1;
8420155a:	82 f0 6a 8a 	MB[r6 + 106] = r0;
8420155e:	07 6e       	jump (m) Lc_splitter_set_data_format_8;

84201560 <Lc_splitter_set_data_format_7>:
    }
    else
    {
        splitter->tag_size_to_samples = FALSE;
84201560:	02 00       	r0 = Null + Null;
84201562:	c8 24       	Null = rMAC - 3;
84201564:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201568:	82 f0 6a 8a 	MB[r6 + 106] = r0;

8420156c <Lc_splitter_set_data_format_8>:
    }

    splitter->data_format = data_format;
8420156c:	81 f0 03 8e 	M[r6 + 12] = rMAC;
    set_cbuffer_functions(splitter);
84201570:	42 08       	r0 = r6 + Null;
84201572:	06 f0 31 e6 	call (m) $_set_cbuffer_functions;
    SPLITTER_MSG1("splitter: Data format set to %d!", splitter->data_format);
    return TRUE;
84201576:	42 20       	r0 = Null + 1;

84201578 <Lc_splitter_set_data_format_9>:
}
84201578:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420157a:	d8 4c       	rts;

8420157c <$_splitter_set_running_streams>:
 * response
 */
bool splitter_set_running_streams(OPERATOR_DATA *op_data, void *message_data,
                                  unsigned *resp_length,
                                  OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420157c:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_RUNNING_STREAMS, RUNNING_STREAMS);
8420157e:	d9 88       	rMAC = M[r1 + 12];
84201580:	89 c6       	rMAC = rMAC AND 0xffff;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_set_running_streams",base_op_get_ext_op_id(op_data));

    return set_running_streams(op_data, (SPLITTER_STREAMS)bitfield);
84201582:	0b 08       	r1 = SE8 rMAC;
84201584:	02 f0 25 ed 	call (m) Lc_set_running_streams_1;

84201588 <Lc_splitter_set_running_streams_2>:

}
84201588:	c8 48       	popm <FP, rLink>;
8420158a:	d8 4c       	rts;

8420158c <$_splitter_activate_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_activate_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420158c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420158e:	10 09       	r6 = r0 + Null;
84201590:	1f 00       	r5 = r1 + Null;
84201592:	ef fd f9 ff 	call (m) 0x8ea;
84201596:	39 ea 
84201598:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams",base_op_get_ext_op_id(op_data));
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS, STREAMS);
8420159a:	f9 88       	rMAC = M[r5 + 12];
8420159c:	8f c6       	r5 = rMAC AND 0xffff;

    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
8420159e:	3b 00       	r1 = r5 + Null;
842015a0:	01 f0 35 ea 	call (m) Lc_validate_input_and_splitter_state_1;
842015a4:	10 04       	Null = r0 - Null;
842015a6:	24 60       	if EQ jump (m) Lc_splitter_activate_streams_9;

842015a8 <Lc_splitter_activate_streams_2>:
    {
        return FALSE;
    }
    streams = (SPLITTER_STREAMS)bitfield;
842015a8:	3f 08       	r5 = SE8 r5;
    if (splitter->active_streams == streams)
842015aa:	b2 b2       	r0 = MBU[r4 + 26];
842015ac:	91 c0       	rMAC = r0 AND 0x3;
842015ae:	c8 05       	Null = rMAC - r5;
842015b0:	0d 62       	if NE jump (m) Lc_splitter_activate_streams_6;

842015b2 <Lc_splitter_activate_streams_3>:
    {
        SPLITTER_ERRORMSG("splitter_activate_streams: Config ignored.");
842015b2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842015b6:	08 24       	Null = rMAC - 0;
842015b8:	07 6c       	if LE jump (m) Lc_splitter_activate_streams_5;

842015ba <Lc_splitter_activate_streams_4>:
842015ba:	55 f1 02 f0 	r0 = Null + 357567917;
842015be:	ad 59 
842015c0:	ef fd fd ff 	call (m) 0x10b0;
842015c4:	31 e7 

842015c6 <Lc_splitter_activate_streams_5>:
        return TRUE;
842015c6:	42 20       	r0 = Null + 1;
842015c8:	35 6e       	jump (m) Lc_splitter_activate_streams_13;

842015ca <Lc_splitter_activate_streams_6>:
    }
    /* Check if the transition is possible. */
    if ((splitter->inactive_streams & streams) != streams)
842015ca:	53 50       	r1 = r0 LSHIFT -2;
842015cc:	9c c0       	r2 = r1 AND 0x3;
842015ce:	39 11       	rMAC = r5 AND r2;
842015d0:	c8 05       	Null = rMAC - r5;
842015d2:	10 60       	if EQ jump (m) Lc_splitter_activate_streams_10;

842015d4 <Lc_splitter_activate_streams_7>:
    {
        SPLITTER_ERRORMSG3("splitter_activate_streams: Only inactive streams can be activated."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
842015d4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842015d8:	08 24       	Null = rMAC - 0;
842015da:	0a 6c       	if LE jump (m) Lc_splitter_activate_streams_9;

842015dc <Lc_splitter_activate_streams_8>:
842015dc:	d3 50       	r1 = r0 LSHIFT -4;
842015de:	9d c0       	r3 = r1 AND 0x3;
842015e0:	93 c0       	r1 = r0 AND 0x3;
842015e2:	55 f1 02 f0 	r0 = Null + 357567960;
842015e6:	d8 59 
842015e8:	ef fd fd ff 	call (m) 0x10ec;
842015ec:	25 e8 

842015ee <Lc_splitter_activate_streams_9>:
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS, STREAMS);

    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
842015ee:	02 00       	r0 = Null + Null;
842015f0:	21 6e       	jump (m) Lc_splitter_activate_streams_13;

842015f2 <Lc_splitter_activate_streams_10>:
    /* Note: It doesn't matter if the operator is in transition because
     * we can only activate an inactive streams so it doesn't matter if
     * the other stream did not finish transitioning.*/

    /* Check if all output terminals are connected. */
    if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
842015f2:	42 08       	r0 = r6 + Null;
842015f4:	ff fd 23 f0 	call (m) 0x5ca4;
842015f8:	31 e5 
842015fa:	10 04       	Null = r0 - Null;
842015fc:	07 60       	if EQ jump (m) Lc_splitter_activate_streams_12;

842015fe <Lc_splitter_activate_streams_11>:
842015fe:	3b 00       	r1 = r5 + Null;
84201600:	32 00       	r0 = r4 + Null;
84201602:	02 f0 21 e7 	call (m) Lc_splitter_output_stream_connected_1;
84201606:	10 04       	Null = r0 - Null;
84201608:	f3 61       	if EQ jump (m) Lc_splitter_activate_streams_9;

8420160a <Lc_splitter_activate_streams_12>:
    {
        return FALSE;
    }
    /* Activate streams. */
    splitter->active_streams = splitter->active_streams | streams;
8420160a:	b1 b2       	rMAC = MBU[r4 + 26];
8420160c:	8a c0       	r0 = rMAC AND 0x3;
8420160e:	d2 13       	r0 = r0 OR r5;
84201610:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
84201614:	92 c0       	r0 = r0 AND 0x3;
84201616:	52 12       	r0 = r0 OR rMAC;
    /* Update the inactive output streams to reflect the changes. */
    splitter->inactive_streams = splitter->inactive_streams & ~streams;
84201618:	21 ff f3 1f 	rMAC = r0 AND 0xfffffff3;
8420161c:	ff f7 53 d6 	r1 = -1 - r5;
84201620:	52 50       	r0 = r0 LSHIFT -2;
84201622:	d2 10       	r0 = r0 AND r1;
84201624:	92 c0       	r0 = r0 AND 0x3;
84201626:	52 54       	r0 = r0 LSHIFT 2;
84201628:	89 12       	rMAC = rMAC OR r0;
8420162a:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    return validate_new_splitter_state(op_data);
8420162c:	42 08       	r0 = r6 + Null;
8420162e:	01 f0 31 e8 	call (m) Lc_validate_new_splitter_state_1;

84201632 <Lc_splitter_activate_streams_13>:
}
84201632:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201634:	d8 4c       	rts;

84201636 <$_splitter_activate_streams_after_timestamp>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_activate_streams_after_timestamp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201636:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201638:	10 09       	r6 = r0 + Null;
8420163a:	1f 00       	r5 = r1 + Null;
8420163c:	ef fd f9 ff 	call (m) 0x8ea;
84201640:	2f e5 
84201642:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, STREAMS);
84201644:	f9 88       	rMAC = M[r5 + 12];
84201646:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;
    splitter->transition_point = (TIME_INTERVAL)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_LS) +
                                 ((TIME_INTERVAL)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_MS) << 16);
8420164a:	39 89       	rMAC = M[r5 + 16];
8420164c:	8a c6       	r0 = rMAC AND 0xffff;
8420164e:	92 56       	r0 = r0 LSHIFT 16;
84201650:	79 89       	rMAC = M[r5 + 20];
84201652:	89 c6       	rMAC = rMAC AND 0xffff;
84201654:	51 00       	rMAC = r0 + rMAC;
84201656:	b1 9e       	M[r4 + 40] = rMAC;


    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams_after_timestamp",base_op_get_ext_op_id(op_data));
    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
84201658:	4b 08       	r1 = r7 + Null;
8420165a:	32 00       	r0 = r4 + Null;
8420165c:	01 f0 39 e4 	call (m) Lc_validate_input_and_splitter_state_1;
84201660:	10 04       	Null = r0 - Null;
84201662:	25 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_9;

84201664 <Lc_splitter_activate_streams_after_timestamp_2>:
    {
        return FALSE;
    }

    streams = (SPLITTER_STREAMS)bitfield;
84201664:	ef f9 47 ce 	r5 = SE8 r7;
    if (splitter->active_streams == streams)
84201668:	b2 b2       	r0 = MBU[r4 + 26];
8420166a:	91 c0       	rMAC = r0 AND 0x3;
8420166c:	c8 05       	Null = rMAC - r5;
8420166e:	0d 62       	if NE jump (m) Lc_splitter_activate_streams_after_timestamp_6;

84201670 <Lc_splitter_activate_streams_after_timestamp_3>:
    {
        SPLITTER_ERRORMSG("splitter_activate_streams_after_timestamp: Config ignored.");
84201670:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201674:	08 24       	Null = rMAC - 0;
84201676:	07 6c       	if LE jump (m) Lc_splitter_activate_streams_after_timestamp_5;

84201678 <Lc_splitter_activate_streams_after_timestamp_4>:
84201678:	55 f1 02 f0 	r0 = Null + 357568060;
8420167c:	3c 5a 
8420167e:	ef fd fd ff 	call (m) 0x10b0;
84201682:	33 e1 

84201684 <Lc_splitter_activate_streams_after_timestamp_5>:
        return TRUE;
84201684:	42 20       	r0 = Null + 1;
84201686:	35 6e       	jump (m) Lc_splitter_activate_streams_after_timestamp_13;

84201688 <Lc_splitter_activate_streams_after_timestamp_6>:
    }
    /* Check if the transition is possible. */
    if ((splitter->hold_streams & streams) != streams)
84201688:	d3 50       	r1 = r0 LSHIFT -4;
8420168a:	9d c0       	r3 = r1 AND 0x3;
8420168c:	79 11       	rMAC = r5 AND r3;
8420168e:	c8 05       	Null = rMAC - r5;
84201690:	10 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_10;

84201692 <Lc_splitter_activate_streams_after_timestamp_7>:
    {
        SPLITTER_ERRORMSG3("splitter_activate_streams_after_timestamp: Only streams on hold (streams buffered) can be activated."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
84201692:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201696:	08 24       	Null = rMAC - 0;
84201698:	0a 6c       	if LE jump (m) Lc_splitter_activate_streams_after_timestamp_9;

8420169a <Lc_splitter_activate_streams_after_timestamp_8>:
8420169a:	53 50       	r1 = r0 LSHIFT -2;
8420169c:	9c c0       	r2 = r1 AND 0x3;
8420169e:	93 c0       	r1 = r0 AND 0x3;
842016a0:	55 f1 02 f0 	r0 = Null + 357568119;
842016a4:	77 5a 
842016a6:	ef fd fd ff 	call (m) 0x10ec;
842016aa:	27 e2 

842016ac <Lc_splitter_activate_streams_after_timestamp_9>:

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams_after_timestamp",base_op_get_ext_op_id(op_data));
    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
842016ac:	02 00       	r0 = Null + Null;
842016ae:	21 6e       	jump (m) Lc_splitter_activate_streams_after_timestamp_13;

842016b0 <Lc_splitter_activate_streams_after_timestamp_10>:
    /* Note: It doesn't matter if the operator is in transition because
     * we can only activate an hold streams so it doesn't matter if
     * the other stream did not finish transitioning.*/

    /* Check if all output terminals are connected. */
    if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
842016b0:	42 08       	r0 = r6 + Null;
842016b2:	ff fd 22 f0 	call (m) 0x5ca4;
842016b6:	33 ef 
842016b8:	10 04       	Null = r0 - Null;
842016ba:	07 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_12;

842016bc <Lc_splitter_activate_streams_after_timestamp_11>:
842016bc:	3b 00       	r1 = r5 + Null;
842016be:	32 00       	r0 = r4 + Null;
842016c0:	02 f0 23 e1 	call (m) Lc_splitter_output_stream_connected_1;
842016c4:	10 04       	Null = r0 - Null;
842016c6:	f3 61       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_9;

842016c8 <Lc_splitter_activate_streams_after_timestamp_12>:
    {
        return FALSE;
    }
    /* Activate streams after timestamp. */
    splitter->active_streams = splitter->active_streams | streams;
842016c8:	b1 b2       	rMAC = MBU[r4 + 26];
842016ca:	8a c0       	r0 = rMAC AND 0x3;
842016cc:	d2 13       	r0 = r0 OR r5;
842016ce:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
842016d2:	92 c0       	r0 = r0 AND 0x3;
842016d4:	52 12       	r0 = r0 OR rMAC;
    /* Update the hold output streams to reflect the changes. */
    splitter->hold_streams = splitter->hold_streams & ~streams;
842016d6:	21 ff cf 1f 	rMAC = r0 AND 0xffffffcf;
842016da:	ff f7 53 d6 	r1 = -1 - r5;
842016de:	d2 50       	r0 = r0 LSHIFT -4;
842016e0:	d2 10       	r0 = r0 AND r1;
842016e2:	92 c0       	r0 = r0 AND 0x3;
842016e4:	d2 54       	r0 = r0 LSHIFT 4;
842016e6:	89 12       	rMAC = rMAC OR r0;
842016e8:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    return validate_new_splitter_state(op_data);
842016ea:	42 08       	r0 = r6 + Null;
842016ec:	01 f0 33 e2 	call (m) Lc_validate_new_splitter_state_1;

842016f0 <Lc_splitter_activate_streams_after_timestamp_13>:
}
842016f0:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842016f2:	d8 4c       	rts;

842016f4 <$_splitter_deactivate_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_deactivate_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842016f4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842016f6:	10 09       	r6 = r0 + Null;
842016f8:	1f 00       	r5 = r1 + Null;
842016fa:	ef fd f8 ff 	call (m) 0x8ea;
842016fe:	31 ef 
84201700:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_DEACTIVATE_STREAMS, STREAMS);
84201702:	f9 88       	rMAC = M[r5 + 12];
84201704:	8f c6       	r5 = rMAC AND 0xffff;


    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_deactivate_streams",base_op_get_ext_op_id(op_data));
    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
84201706:	3b 00       	r1 = r5 + Null;
84201708:	f6 4e       	call (m) Lc_validate_input_and_splitter_state_1;
8420170a:	10 04       	Null = r0 - Null;
8420170c:	03 62       	if NE jump (m) Lc_splitter_deactivate_streams_3;

8420170e <Lc_splitter_deactivate_streams_2>:
    {
        return FALSE;
8420170e:	02 00       	r0 = Null + Null;
84201710:	3d 6e       	jump (m) Lc_splitter_deactivate_streams_12;

84201712 <Lc_splitter_deactivate_streams_3>:
    }
    streams = (SPLITTER_STREAMS)bitfield;
84201712:	3b 08       	r1 = SE8 r5;
    if (splitter->inactive_streams == streams)
84201714:	b2 b2       	r0 = MBU[r4 + 26];
84201716:	54 50       	r2 = r0 LSHIFT -2;
84201718:	a1 c0       	rMAC = r2 AND 0x3;
8420171a:	c8 04       	Null = rMAC - r1;
8420171c:	0d 62       	if NE jump (m) Lc_splitter_deactivate_streams_7;

8420171e <Lc_splitter_deactivate_streams_4>:
    {
        SPLITTER_ERRORMSG("splitter_deactivate_streams: Config ignored.");
8420171e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201722:	08 24       	Null = rMAC - 0;
84201724:	07 6c       	if LE jump (m) Lc_splitter_deactivate_streams_6;

84201726 <Lc_splitter_deactivate_streams_5>:
84201726:	55 f1 02 f0 	r0 = Null + 357568253;
8420172a:	fd 5a 
8420172c:	ef fd fc ff 	call (m) 0x10b0;
84201730:	25 ec 

84201732 <Lc_splitter_deactivate_streams_6>:
        /* Switching to inactive is instant */
        if (splitter_transition(splitter))
        {
            /* successful transition */
            splitter->in_transition = FALSE;
            return TRUE;
84201732:	42 20       	r0 = Null + 1;
84201734:	2b 6e       	jump (m) Lc_splitter_deactivate_streams_12;

84201736 <Lc_splitter_deactivate_streams_7>:
        SPLITTER_ERRORMSG("splitter_deactivate_streams: Config ignored.");
        return TRUE;
    }
    /* Transition is always possible because any stream in any state can be deactivate. */
    /* Exit from transition if switching to active did not finish. */
    if (splitter->in_transition)
84201736:	f0 89       	Null = M[r4 + 28];
84201738:	07 60       	if EQ jump (m) Lc_splitter_deactivate_streams_9;

8420173a <Lc_splitter_deactivate_streams_8>:
    {
        /* DEACTIVATE_STREAMS deactivates streams set to 1.*/
        return transitions_while_pending_state_change(splitter, streams, INACTIVE, INVALID);
8420173a:	c5 20       	r3 = Null + 3;
8420173c:	04 00       	r2 = Null + Null;
8420173e:	32 00       	r0 = r4 + Null;
84201740:	01 f0 3b e2 	call (m) Lc_transitions_while_pending_state_change_1;
84201744:	23 6e       	jump (m) Lc_splitter_deactivate_streams_12;

84201746 <Lc_splitter_deactivate_streams_9>:
    }

    /* Deactivate streams. */
    splitter->inactive_streams = splitter->inactive_streams | streams;
84201746:	22 ff f3 1f 	r0 = r0 AND 0xfffffff3;
8420174a:	c9 12       	rMAC = rMAC OR r1;
8420174c:	8c c0       	r2 = rMAC AND 0x3;
8420174e:	64 54       	r2 = r2 LSHIFT 2;
84201750:	11 13       	rMAC = r0 OR r2;
    /* Update the active and hold output streams to reflect the changes. */
    splitter->active_streams = splitter->active_streams & ~streams;
84201752:	ff f3 52 d6 	r0 = -1 - r1;
84201756:	52 10       	r0 = r0 AND rMAC;
84201758:	92 c0       	r0 = r0 AND 0x3;
8420175a:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
8420175e:	52 12       	r0 = r0 OR rMAC;
    splitter->hold_streams = splitter->hold_streams & ~streams;
84201760:	21 ff cf 1f 	rMAC = r0 AND 0xffffffcf;
84201764:	ff f3 53 d6 	r1 = -1 - r1;
84201768:	d2 50       	r0 = r0 LSHIFT -4;
8420176a:	d2 10       	r0 = r0 AND r1;
8420176c:	92 c0       	r0 = r0 AND 0x3;
8420176e:	d2 54       	r0 = r0 LSHIFT 4;
84201770:	89 12       	rMAC = rMAC OR r0;
84201772:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    if (validate_new_splitter_state(op_data))
84201774:	42 08       	r0 = r6 + Null;
84201776:	e4 4e       	call (m) Lc_validate_new_splitter_state_1;
84201778:	10 04       	Null = r0 - Null;
8420177a:	ca 61       	if EQ jump (m) Lc_splitter_deactivate_streams_2;

8420177c <Lc_splitter_deactivate_streams_10>:
    {
        /* Switching to inactive is instant */
        if (splitter_transition(splitter))
8420177c:	32 00       	r0 = r4 + Null;
8420177e:	f5 ff 29 ec 	call (m) $_splitter_transition;
84201782:	10 04       	Null = r0 - Null;
84201784:	c5 61       	if EQ jump (m) Lc_splitter_deactivate_streams_2;

84201786 <Lc_splitter_deactivate_streams_11>:
        {
            /* successful transition */
            splitter->in_transition = FALSE;
84201786:	f0 8f       	M[r4 + 28] = Null;
84201788:	d5 6f       	jump (m) Lc_splitter_deactivate_streams_6;

8420178a <Lc_splitter_deactivate_streams_12>:
    }
    else
    {
        return FALSE;
    }
}
8420178a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420178c:	d8 4c       	rts;

8420178e <$_splitter_buffer_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_buffer_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420178e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201790:	10 09       	r6 = r0 + Null;
84201792:	1f 00       	r5 = r1 + Null;
84201794:	ef fd f8 ff 	call (m) 0x8ea;
84201798:	37 ea 
8420179a:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_BUFFER_STREAMS, STREAMS);
8420179c:	f9 88       	rMAC = M[r5 + 12];
8420179e:	8f c6       	r5 = rMAC AND 0xffff;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_buffer_streams",base_op_get_ext_op_id(op_data));
    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
842017a0:	3b 00       	r1 = r5 + Null;
842017a2:	a9 4e       	call (m) Lc_validate_input_and_splitter_state_1;
842017a4:	10 04       	Null = r0 - Null;
842017a6:	23 60       	if EQ jump (m) Lc_splitter_buffer_streams_9;

842017a8 <Lc_splitter_buffer_streams_2>:
    {
        return FALSE;
    }
    streams = (SPLITTER_STREAMS)bitfield;
842017a8:	39 08       	rMAC = SE8 r5;
    if (splitter->hold_streams == streams)
842017aa:	b2 b2       	r0 = MBU[r4 + 26];
842017ac:	d3 50       	r1 = r0 LSHIFT -4;
842017ae:	9d c0       	r3 = r1 AND 0x3;
842017b0:	68 04       	Null = r3 - rMAC;
842017b2:	0d 62       	if NE jump (m) Lc_splitter_buffer_streams_6;

842017b4 <Lc_splitter_buffer_streams_3>:
    {
        SPLITTER_ERRORMSG("splitter_buffer_streams: Config ignored.");
842017b4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842017b8:	08 24       	Null = rMAC - 0;
842017ba:	07 6c       	if LE jump (m) Lc_splitter_buffer_streams_5;

842017bc <Lc_splitter_buffer_streams_4>:
842017bc:	55 f1 02 f0 	r0 = Null + 357568298;
842017c0:	2a 5b 
842017c2:	ef fd fc ff 	call (m) 0x10b0;
842017c6:	2f e7 

842017c8 <Lc_splitter_buffer_streams_5>:
        /* Switching to hold is instant */
        if (splitter_transition(splitter))
        {
            /* successful transition */
            splitter->in_transition = FALSE;
            return TRUE;
842017c8:	42 20       	r0 = Null + 1;
842017ca:	2e 6e       	jump (m) Lc_splitter_buffer_streams_13;

842017cc <Lc_splitter_buffer_streams_6>:
    {
        SPLITTER_ERRORMSG("splitter_buffer_streams: Config ignored.");
        return TRUE;
    }
    /* Check if the transition is possible. */
    if ((splitter->inactive_streams & streams) != streams)
842017cc:	53 50       	r1 = r0 LSHIFT -2;
842017ce:	9c c0       	r2 = r1 AND 0x3;
842017d0:	0b 11       	r1 = rMAC AND r2;
842017d2:	58 04       	Null = r1 - rMAC;
842017d4:	0e 60       	if EQ jump (m) Lc_splitter_buffer_streams_10;

842017d6 <Lc_splitter_buffer_streams_7>:
    {
        SPLITTER_ERRORMSG3("splitter_buffer_streams: Only inactive streams can be put on hold (buffered)."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
842017d6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842017da:	08 24       	Null = rMAC - 0;
842017dc:	08 6c       	if LE jump (m) Lc_splitter_buffer_streams_9;

842017de <Lc_splitter_buffer_streams_8>:
842017de:	93 c0       	r1 = r0 AND 0x3;
842017e0:	55 f1 02 f0 	r0 = Null + 357568339;
842017e4:	53 5b 
842017e6:	ef fd fc ff 	call (m) 0x10ec;
842017ea:	27 e8 

842017ec <Lc_splitter_buffer_streams_9>:

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_buffer_streams",base_op_get_ext_op_id(op_data));
    /* Check if the new configuration is correct. */
    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
842017ec:	02 00       	r0 = Null + Null;
842017ee:	1c 6e       	jump (m) Lc_splitter_buffer_streams_13;

842017f0 <Lc_splitter_buffer_streams_10>:
     * we can only put on hold an inactive streams so it doesn't matter if
     * the other stream did not finish transitioning.*/

    /* Terminals on hold can stay unconnected. */
    /* Hold streams. */
    splitter->hold_streams = splitter->hold_streams | streams;
842017f0:	22 ff cf 1f 	r0 = r0 AND 0xffffffcf;
842017f4:	4b 13       	r1 = rMAC OR r3;
842017f6:	9b c0       	r1 = r1 AND 0x3;
842017f8:	db 54       	r1 = r1 LSHIFT 4;
842017fa:	d2 12       	r0 = r0 OR r1;
    /* Update the inactive output streams to reflect the changes. */
    splitter->inactive_streams = splitter->inactive_streams & ~streams;
842017fc:	23 ff f3 1f 	r1 = r0 AND 0xfffffff3;
84201800:	ff f1 51 d6 	rMAC = -1 - rMAC;
84201804:	52 50       	r0 = r0 LSHIFT -2;
84201806:	89 10       	rMAC = rMAC AND r0;
84201808:	8a c0       	r0 = rMAC AND 0x3;
8420180a:	52 54       	r0 = r0 LSHIFT 2;
8420180c:	99 12       	rMAC = r1 OR r0;
8420180e:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    if (validate_new_splitter_state(op_data))
84201810:	42 08       	r0 = r6 + Null;
84201812:	96 4e       	call (m) Lc_validate_new_splitter_state_1;
84201814:	10 04       	Null = r0 - Null;
84201816:	eb 61       	if EQ jump (m) Lc_splitter_buffer_streams_9;

84201818 <Lc_splitter_buffer_streams_11>:
    {
        /* Switching to hold is instant */
        if (splitter_transition(splitter))
84201818:	32 00       	r0 = r4 + Null;
8420181a:	f5 ff 2d e7 	call (m) $_splitter_transition;
8420181e:	10 04       	Null = r0 - Null;
84201820:	e6 61       	if EQ jump (m) Lc_splitter_buffer_streams_9;

84201822 <Lc_splitter_buffer_streams_12>:
        {
            /* successful transition */
            splitter->in_transition = FALSE;
84201822:	f0 8f       	M[r4 + 28] = Null;
84201824:	d2 6f       	jump (m) Lc_splitter_buffer_streams_5;

84201826 <Lc_splitter_buffer_streams_13>:
    }
    else
    {
        return FALSE;
    }
}
84201826:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201828:	d8 4c       	rts;

8420182a <$_splitter_set_reframing>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_reframing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420182a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420182c:	1e 00       	r4 = r1 + Null;
8420182e:	ef fd f8 ff 	call (m) 0x8ea;
84201832:	3d e5 
84201834:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    bool enabled;
    unsigned size;

    enabled = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_REFRAMING, MODE) == OPMSG_SPLITTER_REFRAMING_ENABLED;
84201836:	f1 88       	rMAC = M[r4 + 12];
84201838:	00 09       	r6 = Null + Null;
8420183a:	89 c6       	rMAC = rMAC AND 0xffff;
8420183c:	48 24       	Null = rMAC - 1;
8420183e:	20 f0 48 ce 	if EQ r6 = Null + 1;
    size = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_REFRAMING, SIZE);
84201842:	31 89       	rMAC = M[r4 + 16];
84201844:	8e c6       	r4 = rMAC AND 0xffff;

    if (enabled)
84201846:	0f f8 00 c2 	Null = r6 - Null;
8420184a:	2f 60       	if EQ jump (m) Lc_splitter_set_reframing_12;

8420184c <Lc_splitter_set_reframing_2>:
    {
        if (splitter->reframe_data.sample_rate == 0)
8420184c:	b8 99       	Null = M[r5 + 56];
8420184e:	0d 62       	if NE jump (m) Lc_splitter_set_reframing_6;

84201850 <Lc_splitter_set_reframing_3>:
        {
            SPLITTER_ERRORMSG("splitter_set_reframing: Sampling rate not set! "
                    "Please set the sampling rate first.");
84201850:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201854:	08 24       	Null = rMAC - 0;
84201856:	07 6c       	if LE jump (m) Lc_splitter_set_reframing_5;

84201858 <Lc_splitter_set_reframing_4>:
84201858:	55 f1 02 f0 	r0 = Null + 357568450;
8420185c:	c2 5b 
8420185e:	ef fd fc ff 	call (m) 0x10b0;
84201862:	33 e2 

84201864 <Lc_splitter_set_reframing_5>:
            return FALSE;
84201864:	02 00       	r0 = Null + Null;
84201866:	25 6e       	jump (m) Lc_splitter_set_reframing_13;

84201868 <Lc_splitter_set_reframing_6>:
        }
        if (size < SPLITTER_MIN_FRAME_SIZE)
84201868:	60 f0 80 24 	Null = r4 - 128;
8420186c:	02 f0 9d e0 	if C jump (m) Lc_splitter_set_reframing_9;

84201870 <Lc_splitter_set_reframing_7>:
        {
            SPLITTER_ERRORMSG1("splitter_set_reframing: "
                    "Frame %d size too small!",size);
84201870:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201874:	08 24       	Null = rMAC - 0;
84201876:	f7 6d       	if LE jump (m) Lc_splitter_set_reframing_5;

84201878 <Lc_splitter_set_reframing_8>:
84201878:	55 f1 02 f0 	r0 = Null + 357568533;
8420187c:	15 60 
8420187e:	33 00       	r1 = r4 + Null;
84201880:	ef fd fc ff 	call (m) 0x10c2;
84201884:	23 e2 
84201886:	ef 6f       	jump (m) Lc_splitter_set_reframing_5;

84201888 <Lc_splitter_set_reframing_9>:
            return FALSE;
        }
        /* Make sure at least eight frames can be saved at the internal buffer. */
        if (size > splitter->buffer_size / SPLITTER_MIN_TAGS)
84201888:	ba 88       	r0 = M[r5 + 8];
8420188a:	92 50       	r0 = r0 LSHIFT -3;
8420188c:	b0 04       	Null = r4 - r0;
8420188e:	09 f0 9b e0 	if LS jump (m) Lc_splitter_set_reframing_12;

84201892 <Lc_splitter_set_reframing_10>:
        {
            SPLITTER_ERRORMSG1("splitter_set_reframing: "
                    "Frame %d size too big! Consider using a smaller reframe size.",size);
84201892:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201896:	08 24       	Null = rMAC - 0;
84201898:	08 6c       	if LE jump (m) Lc_splitter_set_reframing_12;

8420189a <Lc_splitter_set_reframing_11>:
8420189a:	55 f1 02 f0 	r0 = Null + 357568582;
8420189e:	46 60 
842018a0:	33 00       	r1 = r4 + Null;
842018a2:	ef fd fc ff 	call (m) 0x10c2;
842018a6:	21 e1 

842018a8 <Lc_splitter_set_reframing_12>:
        }
    }

    splitter->reframe_enabled = enabled;
842018a8:	78 f0 69 8a 	MB[r5 + 105] = r6;
    splitter->frame_size = size;
842018ac:	fe 9e       	M[r5 + 44] = r4;
    return TRUE;
842018ae:	42 20       	r0 = Null + 1;

842018b0 <Lc_splitter_set_reframing_13>:
}
842018b0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842018b2:	d8 4c       	rts;

842018b4 <$_splitter_set_sample_rate>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842018b4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842018b6:	1e 00       	r4 = r1 + Null;
842018b8:	ef fd f8 ff 	call (m) 0x8ea;
842018bc:	33 e1 
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned sample_rate = SAMPLE_RATE_FROM_COMMON_OPMSG(message_data);
842018be:	f1 88       	rMAC = M[r4 + 12];
842018c0:	89 c6       	rMAC = rMAC AND 0xffff;
842018c2:	4b 46       	r1 = rMAC * 25 (int);

    if ((sample_rate < 8000) || (sample_rate > 192000))
842018c4:	30 f1 40 3f 	Null = r1 - 8000;
842018c8:	06 64       	if NC jump (m) Lc_splitter_set_sample_rate_3;

842018ca <Lc_splitter_set_sample_rate_2>:
842018ca:	0b f0 30 f2 	Null = r1 - 192000;
842018ce:	00 3e 
842018d0:	09 f0 9d e0 	if LS jump (m) Lc_splitter_set_sample_rate_6;

842018d4 <Lc_splitter_set_sample_rate_3>:
    {
        SPLITTER_ERRORMSG1("splitter_set_reframing: Invalid sampling rate %d!", sample_rate);
842018d4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842018d8:	08 24       	Null = rMAC - 0;
842018da:	07 6c       	if LE jump (m) Lc_splitter_set_sample_rate_5;

842018dc <Lc_splitter_set_sample_rate_4>:
842018dc:	55 f1 02 f0 	r0 = Null + 357568668;
842018e0:	9c 60 
842018e2:	ef fd fb ff 	call (m) 0x10c2;
842018e6:	21 ef 

842018e8 <Lc_splitter_set_sample_rate_5>:
        return FALSE;
842018e8:	02 00       	r0 = Null + Null;
842018ea:	03 6e       	jump (m) Lc_splitter_set_sample_rate_7;

842018ec <Lc_splitter_set_sample_rate_6>:
    }
    splitter->reframe_data.sample_rate = sample_rate;
842018ec:	93 9f       	M[r0 + 56] = r1;
    return TRUE;
842018ee:	42 20       	r0 = Null + 1;

842018f0 <Lc_splitter_set_sample_rate_7>:
}
842018f0:	f1 48       	popm <FP, r4, rLink>;
842018f2:	d8 4c       	rts;

842018f4 <Lc_validate_input_and_splitter_state_1>:
/****************************************************************************
Private Function Declaration
*/
/* Checks if the operator state is valid together with the bitfiled. */
static bool validate_input_and_splitter_state(SPLITTER_OP_DATA *splitter, unsigned bitfield)
{
842018f4:	c8 1c       	pushm <FP(=SP), rLink>;
    if(splitter->working_mode != BUFFER_DATA)
842018f6:	11 81       	rMAC = MBS[r0 + 4];
842018f8:	48 24       	Null = rMAC - 1;
842018fa:	0e 60       	if EQ jump (m) Lc_validate_input_and_splitter_state_5;

842018fc <Lc_validate_input_and_splitter_state_2>:
    {
        SPLITTER_ERRORMSG1("Splitter: Wrong working mode %d (0 Clone, 1 Buffer Data).",
                splitter->working_mode);
842018fc:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84201900:	10 24       	Null = r0 - 0;
84201902:	08 6c       	if LE jump (m) Lc_validate_input_and_splitter_state_4;

84201904 <Lc_validate_input_and_splitter_state_3>:
84201904:	55 f1 02 f0 	r0 = Null + 357565524;
84201908:	54 48 
8420190a:	0b 00       	r1 = rMAC + Null;
8420190c:	ef fd fb ff 	call (m) 0x10c2;
84201910:	37 ed 

84201912 <Lc_validate_input_and_splitter_state_4>:
        return FALSE;
84201912:	02 00       	r0 = Null + Null;
84201914:	13 6e       	jump (m) Lc_validate_input_and_splitter_state_9;

84201916 <Lc_validate_input_and_splitter_state_5>:
/**
 * Checks if the bitfield received is within range.
 */
static inline bool invalid_stream_setting(unsigned stream_bitfield)
{
    return (stream_bitfield > (OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1));
84201916:	01 00       	rMAC = Null + Null;
84201918:	d8 24       	Null = r1 - 3;
8420191a:	28 f0 41 ce 	if HI rMAC = Null + 1;
    }

    if (invalid_stream_setting(bitfield))
8420191e:	08 04       	Null = rMAC - Null;
84201920:	0c 60       	if EQ jump (m) Lc_validate_input_and_splitter_state_8;

84201922 <Lc_validate_input_and_splitter_state_6>:
    {
        SPLITTER_ERRORMSG("Splitter: Invalid bitfield.");
84201922:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201926:	08 24       	Null = rMAC - 0;
84201928:	f5 6d       	if LE jump (m) Lc_validate_input_and_splitter_state_4;

8420192a <Lc_validate_input_and_splitter_state_7>:
8420192a:	55 f1 02 f0 	r0 = Null + 357565582;
8420192e:	8e 48 
84201930:	ef fd fb ff 	call (m) 0x10b0;
84201934:	21 ec 
84201936:	ee 6f       	jump (m) Lc_validate_input_and_splitter_state_4;

84201938 <Lc_validate_input_and_splitter_state_8>:
            return FALSE;
        }
        SPLITTER_MSG("Splitter: Waiting finished.");
    }
#endif
    return TRUE;
84201938:	42 20       	r0 = Null + 1;

8420193a <Lc_validate_input_and_splitter_state_9>:
}
8420193a:	c8 48       	popm <FP, rLink>;
8420193c:	d8 4c       	rts;

8420193e <Lc_validate_new_splitter_state_1>:

/* Checks if the operator state is valid. Self kicks the operator where needed.*/
static bool validate_new_splitter_state(OPERATOR_DATA *op_data)
{
8420193e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201940:	16 00       	r4 = r0 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201942:	ef fd f7 ff 	call (m) 0x8ea;
84201946:	29 ed 
    /* Check if flags for the output stream indexes are only set for state only. */
    return (
            splitter->active_streams ^ splitter->inactive_streams ^ splitter->hold_streams
           ) == (
            (1<<SPLITTER_MAX_OUTPUTS_PER_CHANNEL) - 1
           );
84201948:	93 b2       	r1 = MBU[r0 + 26];
8420194a:	5c 50       	r2 = r1 LSHIFT -2;
8420194c:	dd 50       	r3 = r1 LSHIFT -4;
8420194e:	e9 14       	rMAC = r3 XOR r1;
84201950:	09 15       	rMAC = rMAC XOR r2;
84201952:	8b c0       	r1 = rMAC AND 0x3;
84201954:	01 00       	rMAC = Null + Null;
84201956:	d8 24       	Null = r1 - 3;
84201958:	20 f0 41 ce 	if EQ rMAC = Null + 1;
            "\n   Inactive streams %d"
            "\n   Hold  streams %d!",
            splitter->output_state[0],splitter->output_state[1],
            splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);

    if(!check_next_output_state_validity(splitter))
8420195c:	08 04       	Null = rMAC - Null;
8420195e:	0d 62       	if NE jump (m) Lc_validate_new_splitter_state_5;

84201960 <Lc_validate_new_splitter_state_2>:
    {
        SPLITTER_ERRORMSG("Splitter: Wrong splitter state!");
84201960:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201964:	08 24       	Null = rMAC - 0;
84201966:	07 6c       	if LE jump (m) Lc_validate_new_splitter_state_4;

84201968 <Lc_validate_new_splitter_state_3>:
84201968:	55 f1 02 f0 	r0 = Null + 357565610;
8420196c:	aa 48 
8420196e:	ef fd fb ff 	call (m) 0x10b0;
84201972:	23 ea 

84201974 <Lc_validate_new_splitter_state_4>:
        return FALSE;
84201974:	02 00       	r0 = Null + Null;
84201976:	10 6e       	jump (m) Lc_validate_new_splitter_state_10;

84201978 <Lc_validate_new_splitter_state_5>:
    }

    /* No need to transition if the splitter is not connected yet. */
    if (splitter->channel_list != NULL)
84201978:	11 e8       	rMAC = M[r0 + Null];
8420197a:	03 60       	if EQ jump (m) Lc_validate_new_splitter_state_7;

8420197c <Lc_validate_new_splitter_state_6>:
    {
        splitter->in_transition = TRUE;
8420197c:	41 20       	rMAC = Null + 1;
8420197e:	d1 8f       	M[r0 + 28] = rMAC;

84201980 <Lc_validate_new_splitter_state_7>:
    }

    if (opmgr_op_is_running(op_data))
84201980:	32 00       	r0 = r4 + Null;
84201982:	ff fd 21 f0 	call (m) 0x5ca4;
84201986:	23 e9 
84201988:	10 04       	Null = r0 - Null;
8420198a:	05 60       	if EQ jump (m) Lc_validate_new_splitter_state_9;

8420198c <Lc_validate_new_splitter_state_8>:
    {
        /* A switch is needed. Try to kick the operator to perform the switch. */
        opmgr_kick_operator(op_data);
8420198c:	32 00       	r0 = r4 + Null;
8420198e:	ff fd 12 f0 	call (m) 0x3f30;
84201992:	23 ed 

84201994 <Lc_validate_new_splitter_state_9>:
    }
    return TRUE;
84201994:	42 20       	r0 = Null + 1;

84201996 <Lc_validate_new_splitter_state_10>:
}
84201996:	f1 48       	popm <FP, r4, rLink>;
84201998:	d8 4c       	rts;

8420199a <Lc_transitions_while_pending_state_change_1>:
 *  - Nothing to do = INVALID
 *
 */
static bool transitions_while_pending_state_change(SPLITTER_OP_DATA *splitter, SPLITTER_STREAMS streams,
                    SPLITTER_OUTPUT_STATE instr_stream_set_one, SPLITTER_OUTPUT_STATE instr_stream_set_zero)
{
8420199a:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420199c:	17 00       	r5 = r0 + Null;
8420199e:	1b 09       	r9 = r1 + Null;
842019a0:	22 09       	r8 = r2 + Null;
842019a2:	29 09       	r7 = r3 + Null;
    unsigned int index;
    SPLITTER_STREAMS current_stream;
    SPLITTER_OUTPUT_STATE current, next, instruction;
    bool in_transition = FALSE;
842019a4:	00 09       	r6 = Null + Null;
     * - transition to ACTIVE.
     * This means that only the following transitional states are possible:
     * - current = (HOLD | INACTIVE) and  next = ACTIVE
     */

    for (index=0; index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL;index++)
842019a6:	06 00       	r4 = Null + Null;

842019a8 <Lc_transitions_while_pending_state_change_2>:
    {
        current_stream = (SPLITTER_STREAMS) 1<<index;
842019a8:	31 00       	rMAC = r4 + Null;
842019aa:	00 f1 93 de 	r1 = 0x1 LSHIFT rMAC;
842019ae:	1a 00       	r0 = r1 + Null;
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
    if (splitter->active_streams & channel_mask)
842019b0:	bd b2       	r3 = MBU[r5 + 26];
842019b2:	e9 10       	rMAC = r3 AND r1;
842019b4:	89 c0       	rMAC = rMAC AND 0x3;
842019b6:	8e 60       	if EQ jump (m) Lc_transitions_while_pending_state_change_29;

842019b8 <Lc_transitions_while_pending_state_change_3>:
    {
        return ACTIVE;
842019b8:	44 20       	r2 = Null + 1;
842019ba:	07 6e       	jump (m) Lc_transitions_while_pending_state_change_5;

842019bc <Lc_transitions_while_pending_state_change_4>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
    {
        return HOLD;
842019bc:	ec 50       	r2 = r3 LSHIFT -4;
842019be:	e1 10       	rMAC = r2 AND r1;
842019c0:	04 00       	r2 = Null + Null;
842019c2:	89 c0       	rMAC = rMAC AND 0x3;
842019c4:	a1 f0 44 ce 	if NE r2 = Null + 2;

842019c8 <Lc_transitions_while_pending_state_change_5>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842019c8:	39 2a       	rMAC = r5 + 24;
842019ca:	89 e1       	rMAC = MBS[rMAC + r4];
        current = get_current_output_state(splitter, index);

        /* SET_RUNNING_STREAMS activates the output streams set to 1
         *  and deactivates the output streams set to 0.
         *  While DEACTIVATE_STREAMS deactivates streams set to 1.*/
        if (streams & current_stream)
842019cc:	bf f2 03 c8 	r1 = r0 AND r9;
842019d0:	03 60       	if EQ jump (m) Lc_transitions_while_pending_state_change_7;

842019d2 <Lc_transitions_while_pending_state_change_6>:
        {
            instruction = instr_stream_set_one;
842019d2:	53 08       	r1 = r8 + Null;
842019d4:	02 6e       	jump (m) Lc_transitions_while_pending_state_change_8;

842019d6 <Lc_transitions_while_pending_state_change_7>:
        }
        else
        {
            instruction = instr_stream_set_zero;
842019d6:	4b 08       	r1 = r7 + Null;

842019d8 <Lc_transitions_while_pending_state_change_8>:
        }

        if (instruction == ACTIVE)
842019d8:	58 24       	Null = r1 - 1;
842019da:	28 62       	if NE jump (m) Lc_transitions_while_pending_state_change_18;

842019dc <Lc_transitions_while_pending_state_change_9>:
             *                                               activate didn't finish anyways.
             * (all other transitions are not possible   )
             */

            /** Check if all there is no need to transition because it's not supported. */
            if (next != ACTIVE)
842019dc:	60 24       	Null = r2 - 1;
842019de:	0f 60       	if EQ jump (m) Lc_transitions_while_pending_state_change_13;

842019e0 <Lc_transitions_while_pending_state_change_10>:
            {
                SPLITTER_ERRORMSG3("Splitter transitions_while_pending_state_change:\n"
                                  "  Output index %d in state %d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) with next state "
                                  "%d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) cannot be activated",
                                  index, next, current);
842019e0:	02 f0 34 91 	r0 = MBS[Null + 0x334];
842019e4:	10 24       	Null = r0 - 0;
842019e6:	09 6c       	if LE jump (m) Lc_transitions_while_pending_state_change_12;

842019e8 <Lc_transitions_while_pending_state_change_11>:
842019e8:	55 f1 02 f0 	r0 = Null + 357565642;
842019ec:	ca 48 
842019ee:	0d 00       	r3 = rMAC + Null;
842019f0:	33 00       	r1 = r4 + Null;
842019f2:	ef fd fb ff 	call (m) 0x10ec;
842019f6:	3b e7 

842019f8 <Lc_transitions_while_pending_state_change_12>:
                return FALSE;
842019f8:	02 00       	r0 = Null + Null;
842019fa:	72 6e       	jump (m) Lc_transitions_while_pending_state_change_31;

842019fc <Lc_transitions_while_pending_state_change_13>:
            }

            /* Since (current == HOLD) && (next == ACTIVE ) and
             * (current == INACTIVE) && (next == ACTIVE ) transition is possible */
            if (next != current)
842019fc:	48 24       	Null = rMAC - 1;
842019fe:	0f 60       	if EQ jump (m) Lc_transitions_while_pending_state_change_16;

84201a00 <Lc_transitions_while_pending_state_change_14>:
            {
                /* We have at least one output stream still in transition.*/
                in_transition = TRUE;
84201a00:	08 71       	r6 = Null + 1;
                SPLITTER_ERRORMSG3("Splitter transitions_while_pending_state_change:\n"
                                  "  Output index %d in state %d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) with next state "
                                  "%d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) cstill in transition.",
                                  index, next, current);
84201a02:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84201a06:	10 24       	Null = r0 - 0;
84201a08:	0a 6c       	if LE jump (m) Lc_transitions_while_pending_state_change_16;

84201a0a <Lc_transitions_while_pending_state_change_15>:
84201a0a:	55 f1 02 f0 	r0 = Null + 357565834;
84201a0e:	8a 49 
84201a10:	0d 00       	r3 = rMAC + Null;
84201a12:	44 08       	r2 = r6 + Null;
84201a14:	33 00       	r1 = r4 + Null;
84201a16:	ef fd fb ff 	call (m) 0x10ec;
84201a1a:	37 e6 

84201a1c <Lc_transitions_while_pending_state_change_16>:
     * - transition to ACTIVE.
     * This means that only the following transitional states are possible:
     * - current = (HOLD | INACTIVE) and  next = ACTIVE
     */

    for (index=0; index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL;index++)
84201a1c:	76 20       	r4 = r4 + 1;
84201a1e:	b0 24       	Null = r4 - 2;
84201a20:	c4 65       	if NC jump (m) Lc_transitions_while_pending_state_change_2;

84201a22 <Lc_transitions_while_pending_state_change_17>:
        }/* end of deactivate. */

    }

    /* Update the transitional state. */
    splitter->in_transition = in_transition;
84201a22:	78 f0 07 8e 	M[r5 + 28] = r6;
    return TRUE;
84201a26:	42 20       	r0 = Null + 1;
84201a28:	5b 6e       	jump (m) Lc_transitions_while_pending_state_change_31;

84201a2a <Lc_transitions_while_pending_state_change_18>:
                                  "%d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) cstill in transition.",
                                  index, next, current);
            }

        }/* end of activate. */
        else if (instruction == INACTIVE)
84201a2a:	18 04       	Null = r1 - Null;
84201a2c:	f8 63       	if NE jump (m) Lc_transitions_while_pending_state_change_16;

84201a2e <Lc_transitions_while_pending_state_change_19>:
             *                                               This in not a revert but it is possible why not allow it.
             * (current == INACTIVE) && (next == ACTIVE  ) - Revert activation. Which is deactivate (transition instant).
             * (all other transitions are not possible   )
             */

            if ((next == ACTIVE) || (next == HOLD))
84201a2e:	60 24       	Null = r2 - 1;
84201a30:	03 60       	if EQ jump (m) Lc_transitions_while_pending_state_change_21;

84201a32 <Lc_transitions_while_pending_state_change_20>:
84201a32:	a0 24       	Null = r2 - 2;
84201a34:	f4 63       	if NE jump (m) Lc_transitions_while_pending_state_change_16;

84201a36 <Lc_transitions_while_pending_state_change_21>:
            {
                /* Deactivate the output stream.  */
                splitter->inactive_streams = splitter->inactive_streams | current_stream;
84201a36:	53 ff f3 1f 	r1 = r3 AND 0xfffffff3;
84201a3a:	6d 50       	r3 = r3 LSHIFT -2;
84201a3c:	ad c0       	r3 = r3 AND 0x3;
84201a3e:	ad 12       	r3 = r3 OR r0;
84201a40:	ad c0       	r3 = r3 AND 0x3;
84201a42:	6d 54       	r3 = r3 LSHIFT 2;
84201a44:	5b 13       	r1 = r1 OR r3;
                splitter->active_streams = splitter->active_streams & ~current_stream;
84201a46:	ff f2 55 d6 	r3 = -1 - r0;
84201a4a:	ed 10       	r3 = r3 AND r1;
84201a4c:	ad c0       	r3 = r3 AND 0x3;
84201a4e:	33 ff fc 1f 	r1 = r1 AND 0xfffffffc;
84201a52:	ed 12       	r3 = r3 OR r1;
                splitter->hold_streams = splitter->hold_streams & ~current_stream;
84201a54:	53 ff cf 1f 	r1 = r3 AND 0xffffffcf;
84201a58:	ff f2 52 d6 	r0 = -1 - r0;
84201a5c:	ed 50       	r3 = r3 LSHIFT -4;
84201a5e:	52 11       	r0 = r0 AND r3;
84201a60:	92 c0       	r0 = r0 AND 0x3;
84201a62:	d2 54       	r0 = r0 LSHIFT 4;
84201a64:	d2 12       	r0 = r0 OR r1;
84201a66:	ba ba       	MB[r5 + 26] = r0;

                SPLITTER_ERRORMSG3("Splitter transitions_while_pending_state_change:\n"
                                  "  Output index %d in state %d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) with next state "
                                  "%d (where 0 INACTIVE, 1 ACTIVE, 2 HOLD) will be deactivated",
                                  index, current, next);
84201a68:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84201a6c:	10 24       	Null = r0 - 0;
84201a6e:	0a 6c       	if LE jump (m) Lc_transitions_while_pending_state_change_23;

84201a70 <Lc_transitions_while_pending_state_change_22>:
84201a70:	55 f1 02 f0 	r0 = Null + 357566028;
84201a74:	4c 4a 
84201a76:	25 00       	r3 = r2 + Null;
84201a78:	0c 00       	r2 = rMAC + Null;
84201a7a:	33 00       	r1 = r4 + Null;
84201a7c:	ef fd fb ff 	call (m) 0x10ec;
84201a80:	31 e3 

84201a82 <Lc_transitions_while_pending_state_change_23>:
    /* Check if flags for the output stream indexes are only set for state only. */
    return (
            splitter->active_streams ^ splitter->inactive_streams ^ splitter->hold_streams
           ) == (
            (1<<SPLITTER_MAX_OUTPUTS_PER_CHANNEL) - 1
           );
84201a82:	ba b2       	r0 = MBU[r5 + 26];
84201a84:	53 50       	r1 = r0 LSHIFT -2;
84201a86:	d4 50       	r2 = r0 LSHIFT -4;
84201a88:	a1 14       	rMAC = r2 XOR r0;
84201a8a:	c9 14       	rMAC = rMAC XOR r1;
84201a8c:	8a c0       	r0 = rMAC AND 0x3;
84201a8e:	01 00       	rMAC = Null + Null;
84201a90:	d0 24       	Null = r0 - 3;
84201a92:	20 f0 41 ce 	if EQ rMAC = Null + 1;

                if (!check_next_output_state_validity(splitter))
84201a96:	08 04       	Null = rMAC - Null;
84201a98:	0c 62       	if NE jump (m) Lc_transitions_while_pending_state_change_26;

84201a9a <Lc_transitions_while_pending_state_change_24>:
                {
                    SPLITTER_ERRORMSG("Splitter transitions_while_pending_state_change: check_next_output_state_validity failed");
84201a9a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201a9e:	08 24       	Null = rMAC - 0;
84201aa0:	ac 6d       	if LE jump (m) Lc_transitions_while_pending_state_change_12;

84201aa2 <Lc_transitions_while_pending_state_change_25>:
84201aa2:	55 f1 02 f0 	r0 = Null + 357566220;
84201aa6:	0c 4b 
84201aa8:	ef fd fb ff 	call (m) 0x10b0;
84201aac:	29 e0 
84201aae:	a5 6f       	jump (m) Lc_transitions_while_pending_state_change_12;

84201ab0 <Lc_transitions_while_pending_state_change_26>:
                    return FALSE;
                }
                /* Only transition the current output stream,
                 * because the other might still be transitioning.*/
                if (!splitter_transition_to_inactive(splitter, index))
84201ab0:	33 00       	r1 = r4 + Null;
84201ab2:	3a 00       	r0 = r5 + Null;
84201ab4:	f4 ff 39 e6 	call (m) $_splitter_transition_to_inactive;
84201ab8:	10 04       	Null = r0 - Null;
84201aba:	b1 63       	if NE jump (m) Lc_transitions_while_pending_state_change_16;

84201abc <Lc_transitions_while_pending_state_change_27>:
                {
                    SPLITTER_ERRORMSG("Splitter transitions_while_pending_state_change: splitter_transition_to_inactive failed");
84201abc:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201ac0:	08 24       	Null = rMAC - 0;
84201ac2:	9b 6d       	if LE jump (m) Lc_transitions_while_pending_state_change_12;

84201ac4 <Lc_transitions_while_pending_state_change_28>:
84201ac4:	55 f1 02 f0 	r0 = Null + 357566309;
84201ac8:	65 4b 
84201aca:	ef fd fa ff 	call (m) 0x10b0;
84201ace:	27 ef 
84201ad0:	94 6f       	jump (m) Lc_transitions_while_pending_state_change_12;

84201ad2 <Lc_transitions_while_pending_state_change_29>:
    channel_mask = 1<<index;
    if (splitter->active_streams & channel_mask)
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
84201ad2:	6c 50       	r2 = r3 LSHIFT -2;
84201ad4:	e1 10       	rMAC = r2 AND r1;
84201ad6:	89 c0       	rMAC = rMAC AND 0x3;
84201ad8:	72 61       	if EQ jump (m) Lc_transitions_while_pending_state_change_4;

84201ada <Lc_transitions_while_pending_state_change_30>:
    {
        return INACTIVE;
84201ada:	04 00       	r2 = Null + Null;
84201adc:	76 6f       	jump (m) Lc_transitions_while_pending_state_change_5;

84201ade <Lc_transitions_while_pending_state_change_31>:
    }

    /* Update the transitional state. */
    splitter->in_transition = in_transition;
    return TRUE;
}
84201ade:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201ae0:	d8 4c       	rts;

84201ae2 <Lc_splitter_output_stream_connected_1>:

/* Check if the outputs are connected for the given bitfield. */
static bool splitter_output_stream_connected(SPLITTER_OP_DATA *splitter, SPLITTER_STREAMS streams)
{
84201ae2:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned channel_mask, i;
    SPLITTER_CHANNEL_STRUC *channel;

    channel = splitter->channel_list;
84201ae4:	11 e8       	rMAC = M[r0 + Null];
84201ae6:	06 6e       	jump (m) Lc_splitter_output_stream_connected_4;

84201ae8 <Lc_splitter_output_stream_connected_2>:
    while (channel != NULL)
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201ae8:	64 20       	r2 = r2 + 1;
84201aea:	2d 21       	r3 = r3 + 4;
84201aec:	a0 24       	Null = r2 - 2;
84201aee:	06 64       	if NC jump (m) Lc_splitter_output_stream_connected_6;

84201af0 <Lc_splitter_output_stream_connected_3>:
                SPLITTER_ERRORMSG2("Splitter: Channel %d output %d not connected", channel->id ,i);
                return FALSE;
            }
        }

        channel = channel->next;
84201af0:	09 e8       	rMAC = M[rMAC + Null];

84201af2 <Lc_splitter_output_stream_connected_4>:
{
    unsigned channel_mask, i;
    SPLITTER_CHANNEL_STRUC *channel;

    channel = splitter->channel_list;
    while (channel != NULL)
84201af2:	08 04       	Null = rMAC - Null;
84201af4:	17 60       	if EQ jump (m) Lc_splitter_output_stream_connected_11;

84201af6 <Lc_splitter_output_stream_connected_5>:
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201af6:	04 00       	r2 = Null + Null;
84201af8:	0d 23       	r3 = rMAC + 12;

84201afa <Lc_splitter_output_stream_connected_6>:
        {
            channel_mask = 1<<i;
84201afa:	22 00       	r0 = r2 + Null;
84201afc:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
            if ((streams & channel_mask) && (channel->output_buffer[i] == NULL))
84201b00:	d2 10       	r0 = r0 AND r1;
84201b02:	f3 61       	if EQ jump (m) Lc_splitter_output_stream_connected_2;

84201b04 <Lc_splitter_output_stream_connected_7>:
84201b04:	2a e8       	r0 = M[r3 + Null];
84201b06:	f1 63       	if NE jump (m) Lc_splitter_output_stream_connected_2;

84201b08 <Lc_splitter_output_stream_connected_8>:
            {
                SPLITTER_ERRORMSG2("Splitter: Channel %d output %d not connected", channel->id ,i);
84201b08:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84201b0c:	10 24       	Null = r0 - 0;
84201b0e:	08 6c       	if LE jump (m) Lc_splitter_output_stream_connected_10;

84201b10 <Lc_splitter_output_stream_connected_9>:
84201b10:	4b 88       	r1 = M[rMAC + 4];
84201b12:	55 f1 02 f0 	r0 = Null + 357566397;
84201b16:	bd 4b 
84201b18:	ef fd fa ff 	call (m) 0x10d6;
84201b1c:	3f ed 

84201b1e <Lc_splitter_output_stream_connected_10>:
                return FALSE;
84201b1e:	02 00       	r0 = Null + Null;
84201b20:	02 6e       	jump (m) Lc_splitter_output_stream_connected_12;

84201b22 <Lc_splitter_output_stream_connected_11>:

        channel = channel->next;
    }

    /* All output channels are connected. */
    return TRUE;
84201b22:	42 20       	r0 = Null + 1;

84201b24 <Lc_splitter_output_stream_connected_12>:
}
84201b24:	c8 48       	popm <FP, rLink>;
84201b26:	d8 4c       	rts;

84201b28 <Lc_set_running_streams_1>:
 *                OPMSG_SPLITTER_STREAM_0 and/or OPMSG_SPLITTER_STREAM_1
 *
 * \return TRUE for success, FALSE otherwise
 */
static bool set_running_streams(OPERATOR_DATA *op_data, SPLITTER_STREAMS streams)
{
84201b28:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201b2a:	42 de       	M[FP + 32] = r0;
84201b2c:	4b de       	M[FP + 36] = r1;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201b2e:	ef fd f6 ff 	call (m) 0x8ea;
84201b32:	3d ed 
84201b34:	52 de       	M[FP + 40] = r0;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    if (invalid_stream_setting(streams))
84201b36:	49 d8       	rMAC = M[FP + 36];
/**
 * Checks if the bitfield received is within range.
 */
static inline bool invalid_stream_setting(unsigned stream_bitfield)
{
    return (stream_bitfield > (OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1));
84201b38:	02 00       	r0 = Null + Null;
84201b3a:	c8 24       	Null = rMAC - 3;
84201b3c:	28 f0 42 ce 	if HI r0 = Null + 1;
84201b40:	10 04       	Null = r0 - Null;
84201b42:	13 62       	if NE jump (m) Lc_set_running_streams_6;

84201b44 <Lc_set_running_streams_2>:
    {
        return FALSE;
    }

    if (splitter->working_mode == CLONE_BUFFER)
84201b44:	51 d8       	rMAC = M[FP + 40];
84201b46:	09 81       	rMAC = MBS[rMAC + 4];
84201b48:	8b 62       	if NE jump (m) Lc_set_running_streams_28;

84201b4a <Lc_set_running_streams_3>:
    {

        unsigned    current_out_index, new_out_index;
        bool        align_buffs = FALSE;
84201b4a:	03 09       	r9 = Null + Null;
        SPLITTER_CHANNEL_STRUC *channel;
        /* Before setting the stream active make all the channels buffer pointers
         * look empty like it's just been connected, BUT aligned with the write
         * pointer of the other stream so that there is no chance of stalls. */
        if ((splitter->active_streams ^ streams) == OPMSG_SPLITTER_STREAM_1)
84201b4c:	51 d8       	rMAC = M[FP + 40];
84201b4e:	4a d8       	r0 = M[FP + 36];
84201b50:	89 b2       	rMAC = MBU[rMAC + 26];
84201b52:	89 c0       	rMAC = rMAC AND 0x3;
84201b54:	52 14       	r0 = r0 XOR rMAC;
84201b56:	90 24       	Null = r0 - 2;
84201b58:	0a 62       	if NE jump (m) Lc_set_running_streams_7;

84201b5a <Lc_set_running_streams_4>:
        {
            new_out_index = 1;
84201b5a:	42 20       	r0 = Null + 1;
84201b5c:	5a de       	M[FP + 44] = r0;
            current_out_index = 0;
84201b5e:	07 00       	r5 = Null + Null;
84201b60:	08 6e       	jump (m) Lc_set_running_streams_8;

84201b62 <Lc_set_running_streams_5>:
                            new_metadata->prev_rd_index = cur_metadata->prev_wr_index;
                        }
                    }
                    else
                    {
                        UNLOCK_INTERRUPTS;
84201b62:	ff fd 67 f2 	call (m) 0x4e9b2;
84201b66:	31 e2 

84201b68 <Lc_set_running_streams_6>:
{
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    if (invalid_stream_setting(streams))
    {
        return FALSE;
84201b68:	02 00       	r0 = Null + Null;
84201b6a:	d5 6e       	jump (m) Lc_set_running_streams_42;

84201b6c <Lc_set_running_streams_7>:
            new_out_index = 1;
            current_out_index = 0;
        }
        else
        {
            new_out_index = 0;
84201b6c:	58 de       	M[FP + 44] = Null;
            current_out_index = 1;
84201b6e:	47 20       	r5 = Null + 1;

84201b70 <Lc_set_running_streams_8>:
        }

        if ((splitter->active_streams | streams) == OUT_STREAM__0_ON___1_ON)
84201b70:	4a d8       	r0 = M[FP + 36];
84201b72:	52 12       	r0 = r0 OR rMAC;
84201b74:	d0 24       	Null = r0 - 3;
84201b76:	04 62       	if NE jump (m) Lc_set_running_streams_11;

84201b78 <Lc_set_running_streams_9>:
        {
            if (splitter->active_streams == OUT_STREAM__0_ON___1_OFF)
84201b78:	48 24       	Null = rMAC - 1;
84201b7a:	19 62       	if NE jump (m) Lc_set_running_streams_13;

84201b7c <Lc_set_running_streams_10>:
            {
                align_buffs = TRUE;
84201b7c:	0b 71       	r9 = Null + 1;

84201b7e <Lc_set_running_streams_11>:
        }
        /* Prevent processing while the read and write ptrs for the stream that is
         * coming online is aligned to the current write pointer of the running
         * stream.
         */
        opmgr_op_suspend_processing(op_data);
84201b7e:	42 d8       	r0 = M[FP + 32];
84201b80:	ff fd 20 f0 	call (m) 0x5cb0;
84201b84:	31 e9 
        channel = splitter->channel_list;
84201b86:	51 d8       	rMAC = M[FP + 40];
84201b88:	0e e8       	r4 = M[rMAC + Null];

        /* Align the buffers if the output goes active. */
        if ((streams & (1<<new_out_index)) != 0)
84201b8a:	59 d8       	rMAC = M[FP + 44];
84201b8c:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201b90:	49 d8       	rMAC = M[FP + 36];
84201b92:	89 10       	rMAC = rMAC AND r0;
84201b94:	4b 60       	if EQ jump (m) Lc_set_running_streams_26;

84201b96 <Lc_set_running_streams_12>:
        {
            LOCK_INTERRUPTS;
84201b96:	ff fd 67 f2 	call (m) 0x4e996;
84201b9a:	21 e0 
84201b9c:	5a d8       	r0 = M[FP + 44];
84201b9e:	52 54       	r0 = r0 LSHIFT 2;
84201ba0:	28 f0 0c 20 	r6 = r0 + 12;
84201ba4:	7a 54       	r0 = r5 LSHIFT 2;
84201ba6:	29 f0 0c 20 	r7 = r0 + 12;
84201baa:	04 6e       	jump (m) Lc_set_running_streams_14;

84201bac <Lc_set_running_streams_13>:
        {
            if (splitter->active_streams == OUT_STREAM__0_ON___1_OFF)
            {
                align_buffs = TRUE;
            }
            else if (splitter->active_streams == OUT_STREAM__0_OFF__1_ON)
84201bac:	88 24       	Null = rMAC - 2;
84201bae:	e7 61       	if EQ jump (m) Lc_set_running_streams_10;

84201bb0 <Lc__ite_42>:
84201bb0:	e7 6f       	jump (m) Lc_set_running_streams_11;

84201bb2 <Lc_set_running_streams_14>:

        /* Align the buffers if the output goes active. */
        if ((streams & (1<<new_out_index)) != 0)
        {
            LOCK_INTERRUPTS;
            while (channel)
84201bb2:	30 04       	Null = r4 - Null;
84201bb4:	32 60       	if EQ jump (m) Lc_set_running_streams_25;

84201bb6 <Lc_set_running_streams_15>:
            {
                tCbuffer *new_out_buffer = channel->output_buffer[new_out_index];
84201bb6:	6a f0 08 e8 	r8 = M[r4 + r6];
                tCbuffer *cur_out_buffer = channel->output_buffer[current_out_index];
84201bba:	67 f0 09 e8 	r5 = M[r4 + r7];
                if (align_buffs)
84201bbe:	0f fb 00 c2 	Null = r9 - Null;
84201bc2:	29 60       	if EQ jump (m) Lc_set_running_streams_24;

84201bc4 <Lc_set_running_streams_16>:
                {
                    if (new_out_buffer != NULL && cur_out_buffer != NULL)
84201bc4:	0f fa 00 c2 	Null = r8 - Null;
84201bc8:	cd 61       	if EQ jump (m) Lc_set_running_streams_5;

84201bca <Lc_set_running_streams_17>:
84201bca:	38 04       	Null = r5 - Null;
84201bcc:	cb 61       	if EQ jump (m) Lc_set_running_streams_5;

84201bce <Lc_set_running_streams_18>:
                    {
                        new_out_buffer->write_ptr = cur_out_buffer->write_ptr;
84201bce:	b9 88       	rMAC = M[r5 + 8];
84201bd0:	a1 f0 02 8e 	M[r8 + 8] = rMAC;
                        new_out_buffer->read_ptr = new_out_buffer->write_ptr;
84201bd4:	a1 f0 01 8e 	M[r8 + 4] = rMAC;
                        /* The write pointer may be rounded up if previous operator(s) used
                         * cbuffer_ex. If the 2 LSBs of the write pointer are non-zero,
                         * the read pointer must be 1 word less to make the buffer look empty.
                         */
                        if (((uintptr_t)new_out_buffer->write_ptr) & 0x3)
84201bd8:	8a c0       	r0 = rMAC AND 0x3;
84201bda:	13 60       	if EQ jump (m) Lc_set_running_streams_21;

84201bdc <Lc_set_running_streams_19>:
                        {
                            new_out_buffer->read_ptr -= 1;
84201bdc:	09 25       	rMAC = rMAC - 4;
84201bde:	a1 f0 01 8e 	M[r8 + 4] = rMAC;
                            if (new_out_buffer->read_ptr < new_out_buffer->base_addr)
84201be2:	a2 f0 03 88 	r0 = M[r8 + 12];
84201be6:	88 04       	Null = rMAC - r0;
84201be8:	02 f0 99 e0 	if C jump (m) Lc_set_running_streams_21;

84201bec <Lc_set_running_streams_20>:
                            {
                               new_out_buffer->read_ptr += cbuffer_get_size_in_words(new_out_buffer);
84201bec:	52 08       	r0 = r8 + Null;
84201bee:	ff fd 93 f0 	call (m) 0x143a8;
84201bf2:	3b ed 
84201bf4:	a1 f0 01 88 	rMAC = M[r8 + 4];
84201bf8:	52 54       	r0 = r0 LSHIFT 2;
84201bfa:	51 00       	rMAC = r0 + rMAC;
84201bfc:	a1 f0 01 8e 	M[r8 + 4] = rMAC;

84201c00 <Lc_set_running_streams_21>:
                        * Note that the write index of the running stream is the
                        * same as the read index of the input stream.
                        * This ensures that new tags have the same indices on both
                        * streams.
                        */
                        metadata_list *new_metadata = new_out_buffer->metadata;
84201c00:	a1 f0 06 88 	rMAC = M[r8 + 24];
                        metadata_list *cur_metadata = cur_out_buffer->metadata;
                        if (cur_metadata != NULL && new_metadata != NULL)
84201c04:	ba 89       	r0 = M[r5 + 24];
84201c06:	07 60       	if EQ jump (m) Lc_set_running_streams_24;

84201c08 <Lc_set_running_streams_22>:
84201c08:	08 04       	Null = rMAC - Null;
84201c0a:	05 60       	if EQ jump (m) Lc_set_running_streams_24;

84201c0c <Lc_set_running_streams_23>:
                        {
                            new_metadata->prev_wr_index = cur_metadata->prev_wr_index;
84201c0c:	93 88       	r1 = M[r0 + 8];
84201c0e:	8b 8e       	M[rMAC + 8] = r1;
                            new_metadata->prev_rd_index = cur_metadata->prev_wr_index;
84201c10:	92 88       	r0 = M[r0 + 8];
84201c12:	ca 8e       	M[rMAC + 12] = r0;

84201c14 <Lc_set_running_streams_24>:
                    {
                        UNLOCK_INTERRUPTS;
                        return FALSE;
                    }
                }
                channel = channel->next;
84201c14:	36 e8       	r4 = M[r4 + Null];
84201c16:	ce 6f       	jump (m) Lc_set_running_streams_14;

84201c18 <Lc_set_running_streams_25>:
            }
            UNLOCK_INTERRUPTS;
84201c18:	ff fd 66 f2 	call (m) 0x4e9b2;
84201c1c:	3b ec 
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84201c1e:	41 20       	rMAC = Null + 1;
84201c20:	52 d8       	r0 = M[FP + 40];
84201c22:	5b d8       	r1 = M[FP + 44];
84201c24:	9a 00       	r0 = r1 + r0;
84201c26:	11 ba       	MB[r0 + 24] = rMAC;
84201c28:	05 6e       	jump (m) Lc_set_running_streams_27;

84201c2a <Lc_set_running_streams_26>:
84201c2a:	51 d8       	rMAC = M[FP + 40];
84201c2c:	5a d8       	r0 = M[FP + 44];
84201c2e:	51 00       	rMAC = r0 + rMAC;
84201c30:	08 ba       	MB[rMAC + 24] = Null;

84201c32 <Lc_set_running_streams_27>:
        else
        {
            /* Just inactivate the output channel. */
            set_current_output_state(splitter, new_out_index, INACTIVE);
        }
        opmgr_op_resume_processing(op_data);
84201c32:	42 d8       	r0 = M[FP + 32];
84201c34:	ff fd 20 f0 	call (m) 0x5ce0;
84201c38:	2d e5 
        splitter->active_streams = (SPLITTER_STREAMS)streams;
84201c3a:	51 d8       	rMAC = M[FP + 40];
84201c3c:	4a d8       	r0 = M[FP + 36];
84201c3e:	89 b2       	rMAC = MBU[rMAC + 26];
84201c40:	92 c0       	r0 = r0 AND 0x3;
84201c42:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
84201c46:	89 12       	rMAC = rMAC OR r0;
        splitter->inactive_streams = ~(SPLITTER_STREAMS)streams;
84201c48:	11 ff f3 1f 	rMAC = rMAC AND 0xfffffff3;
84201c4c:	4a d8       	r0 = M[FP + 36];
84201c4e:	ff f2 52 d6 	r0 = -1 - r0;
84201c52:	92 c0       	r0 = r0 AND 0x3;
84201c54:	52 54       	r0 = r0 LSHIFT 2;
84201c56:	89 12       	rMAC = rMAC OR r0;
84201c58:	52 d8       	r0 = M[FP + 40];
84201c5a:	91 ba       	MB[r0 + 26] = rMAC;
84201c5c:	1f 6e       	jump (m) Lc_set_running_streams_33;

84201c5e <Lc_set_running_streams_28>:
        return TRUE;
    }
    else /* splitter->working_mode != CLONE_BUFFER*/
    {
        /* Check if the new configuration is correct. */
        if (!validate_input_and_splitter_state(splitter, streams))
84201c5e:	4b d8       	r1 = M[FP + 36];
84201c60:	52 d8       	r0 = M[FP + 40];
84201c62:	fe ff 33 e4 	call (m) Lc_validate_input_and_splitter_state_1;
84201c66:	10 04       	Null = r0 - Null;
84201c68:	80 61       	if EQ jump (m) Lc_set_running_streams_6;

84201c6a <Lc_set_running_streams_29>:
        {
            return FALSE;
        }
        if ((splitter->active_streams == streams) && (splitter->inactive_streams == SPLITTER_CHANNEL_MAKS(~streams)))
84201c6a:	51 d8       	rMAC = M[FP + 40];
84201c6c:	8a b2       	r0 = MBU[rMAC + 26];
84201c6e:	91 c0       	rMAC = r0 AND 0x3;
84201c70:	4b d8       	r1 = M[FP + 36];
84201c72:	c8 04       	Null = rMAC - r1;
84201c74:	15 62       	if NE jump (m) Lc_set_running_streams_34;

84201c76 <Lc_set_running_streams_30>:
84201c76:	53 50       	r1 = r0 LSHIFT -2;
84201c78:	99 c0       	rMAC = r1 AND 0x3;
84201c7a:	4b d8       	r1 = M[FP + 36];
84201c7c:	ff f3 53 d6 	r1 = -1 - r1;
84201c80:	9b c0       	r1 = r1 AND 0x3;
84201c82:	c8 04       	Null = rMAC - r1;
84201c84:	0d 62       	if NE jump (m) Lc_set_running_streams_34;

84201c86 <Lc_set_running_streams_31>:
        {
            SPLITTER_ERRORMSG("splitter_set_running_streams: Config ignored.");
84201c86:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201c8a:	08 24       	Null = rMAC - 0;
84201c8c:	07 6c       	if LE jump (m) Lc_set_running_streams_33;

84201c8e <Lc_set_running_streams_32>:
84201c8e:	55 f1 02 f0 	r0 = Null + 357566442;
84201c92:	ea 4b 
84201c94:	ef fd fa ff 	call (m) 0x10b0;
84201c98:	3d e0 

84201c9a <Lc_set_running_streams_33>:
        }
        opmgr_op_resume_processing(op_data);
        splitter->active_streams = (SPLITTER_STREAMS)streams;
        splitter->inactive_streams = ~(SPLITTER_STREAMS)streams;

        return TRUE;
84201c9a:	42 20       	r0 = Null + 1;
84201c9c:	3c 6e       	jump (m) Lc_set_running_streams_42;

84201c9e <Lc_set_running_streams_34>:
        {
            SPLITTER_ERRORMSG("splitter_set_running_streams: Config ignored.");
            return TRUE;
        }
        /* Check if the transition is possible. */
        if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
84201c9e:	d3 50       	r1 = r0 LSHIFT -4;
84201ca0:	9d c0       	r3 = r1 AND 0x3;
84201ca2:	0f 60       	if EQ jump (m) Lc_set_running_streams_37;

84201ca4 <Lc_set_running_streams_35>:
        {
            SPLITTER_ERRORMSG3("splitter_set_running_streams: Streams on hold! cannot use this command."
                    "\n Active %d\n Inactive %d\n Hold %d",
                    splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
84201ca4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201ca8:	08 24       	Null = rMAC - 0;
84201caa:	5f 6d       	if LE jump (m) Lc_set_running_streams_6;

84201cac <Lc_set_running_streams_36>:
84201cac:	53 50       	r1 = r0 LSHIFT -2;
84201cae:	9c c0       	r2 = r1 AND 0x3;
84201cb0:	93 c0       	r1 = r0 AND 0x3;
84201cb2:	55 f1 02 f0 	r0 = Null + 357566488;
84201cb6:	18 50 
84201cb8:	ef fd fa ff 	call (m) 0x10ec;
84201cbc:	35 e1 
84201cbe:	55 6f       	jump (m) Lc_set_running_streams_6;

84201cc0 <Lc_set_running_streams_37>:
            return FALSE;
        }
        /* If the operator is in transition, we only accept reverting.*/
        if (splitter->in_transition)
84201cc0:	51 d8       	rMAC = M[FP + 40];
84201cc2:	c8 89       	Null = M[rMAC + 28];
84201cc4:	08 60       	if EQ jump (m) Lc_set_running_streams_39;

84201cc6 <Lc_set_running_streams_38>:
        {
            /* SET_RUNNING_STREAMS activates the output streams set to 1 and
             * deactivates the output streams set to 0. */
            return transitions_while_pending_state_change(splitter, streams, ACTIVE, INACTIVE);
84201cc6:	44 20       	r2 = Null + 1;
84201cc8:	05 00       	r3 = Null + Null;
84201cca:	4b d8       	r1 = M[FP + 36];
84201ccc:	52 d8       	r0 = M[FP + 40];
84201cce:	fe ff 2d e6 	call (m) Lc_transitions_while_pending_state_change_1;
84201cd2:	21 6e       	jump (m) Lc_set_running_streams_42;

84201cd4 <Lc_set_running_streams_39>:
        }
        /* Check if all output terminals are connected. */
        if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
84201cd4:	42 d8       	r0 = M[FP + 32];
84201cd6:	ff fd 1f f0 	call (m) 0x5ca4;
84201cda:	2f ee 
84201cdc:	10 04       	Null = r0 - Null;
84201cde:	07 60       	if EQ jump (m) Lc_set_running_streams_41;

84201ce0 <Lc_set_running_streams_40>:
84201ce0:	4b d8       	r1 = M[FP + 36];
84201ce2:	52 d8       	r0 = M[FP + 40];
84201ce4:	fe ff 3f ef 	call (m) Lc_splitter_output_stream_connected_1;
84201ce8:	10 04       	Null = r0 - Null;
84201cea:	3f 61       	if EQ jump (m) Lc_set_running_streams_6;

84201cec <Lc_set_running_streams_41>:
        {
            return FALSE;
        }
        /* Change the three main stream. */
        splitter->active_streams = streams;
84201cec:	51 d8       	rMAC = M[FP + 40];
84201cee:	4a d8       	r0 = M[FP + 36];
84201cf0:	89 b2       	rMAC = MBU[rMAC + 26];
84201cf2:	92 c0       	r0 = r0 AND 0x3;
84201cf4:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
84201cf8:	89 12       	rMAC = rMAC OR r0;
        splitter->inactive_streams = ~streams;
84201cfa:	11 ff f3 1f 	rMAC = rMAC AND 0xfffffff3;
84201cfe:	4a d8       	r0 = M[FP + 36];
84201d00:	ff f2 52 d6 	r0 = -1 - r0;
84201d04:	92 c0       	r0 = r0 AND 0x3;
84201d06:	52 54       	r0 = r0 LSHIFT 2;
84201d08:	89 12       	rMAC = rMAC OR r0;
84201d0a:	52 d8       	r0 = M[FP + 40];
84201d0c:	91 ba       	MB[r0 + 26] = rMAC;

        /* verify the new state validity. */
        return validate_new_splitter_state(op_data);
84201d0e:	42 d8       	r0 = M[FP + 32];
84201d10:	fe ff 2f e1 	call (m) Lc_validate_new_splitter_state_1;

84201d14 <Lc_set_running_streams_42>:
    }
}
84201d14:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201d16:	d8 4c       	rts;

84201d18 <$_create_internal_metadata>:
84201d18:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;

/**
 * Helper function which creates the metadata buffer.
 */
bool create_internal_metadata(SPLITTER_OP_DATA *splitter, data_buffer_t* internal_buff, unsigned buffer_size)
{
84201d1a:	16 00       	r4 = r0 + Null;
84201d1c:	23 00       	r1 = r2 + Null;
    tCbuffer *metadata_buffer;
    metadata_list *meta_p;

    patch_fn_shared(splitter);

    if (splitter->working_mode == CLONE_BUFFER)
84201d1e:	31 81       	rMAC = MBS[r4 + 4];
84201d20:	2b 60       	if EQ jump (m) Lc_create_internal_metadata_13;

84201d22 <Lc_create_internal_metadata_2>:

    /* Make sure that metadata is only created once. */
    SPLITTER_DEBUG_INSTR(PL_ASSERT(splitter->internal_metadata.buffer == NULL));

    /* Reduce the buffer size to samples.*/
    if (splitter->tag_size_to_samples)
84201d22:	61 f0 6a 82 	rMAC = MBU[r4 + 106];
84201d26:	02 60       	if EQ jump (m) Lc_create_internal_metadata_4;

84201d28 <Lc_create_internal_metadata_3>:
    {
        buffer_size = buffer_size>>2;
84201d28:	5b 50       	r1 = r1 LSHIFT -2;

84201d2a <Lc_create_internal_metadata_4>:
    }

    /* This buffer is only used for metadata.*/
    metadata_buffer = cbuffer_create(NULL, buffer_size, BUF_DESC_SW_BUFFER);
84201d2a:	04 00       	r2 = Null + Null;
84201d2c:	02 00       	r0 = Null + Null;
84201d2e:	ff fd 92 f0 	call (m) 0x141c4;
84201d32:	37 e4 
84201d34:	17 00       	r5 = r0 + Null;

    if (metadata_buffer == NULL)
84201d36:	22 62       	if NE jump (m) Lc_create_internal_metadata_14;

84201d38 <Lc_create_internal_metadata_5>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata buffer for internal data!" );
84201d38:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201d3c:	08 24       	Null = rMAC - 0;
84201d3e:	07 6c       	if LE jump (m) Lc_create_internal_metadata_7;

84201d40 <Lc_create_internal_metadata_6>:
84201d40:	55 f1 02 f0 	r0 = Null + 357568718;
84201d44:	ce 60 
84201d46:	ef fd f9 ff 	call (m) 0x10b0;
84201d4a:	2b eb 

84201d4c <Lc_create_internal_metadata_7>:
        return FALSE;
84201d4c:	02 00       	r0 = Null + Null;
84201d4e:	2a 6e       	jump (m) Lc_create_internal_metadata_18;

84201d50 <Lc_create_internal_metadata_8>:
    }

    /* Set the usable octets based on the packing.
     * cbuffer_set_usable_octets will also sets the metadata buffer size
     * based on the cbuffer buffer size! */
    cbuffer_set_usable_octets(metadata_buffer, OCTETS_PER_SAMPLE);
84201d50:	03 21       	r1 = Null + 4;
84201d52:	3a 00       	r0 = r5 + Null;
84201d54:	ff fd 92 f0 	call (m) 0x14296;
84201d58:	23 ea 

    if (splitter->packing == PACKED&&
        ((splitter->data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA) ||
         (splitter->data_format == AUDIO_DATA_FORMAT_FIXP)))
84201d5a:	b1 81       	rMAC = MBS[r4 + 6];
84201d5c:	48 24       	Null = rMAC - 1;
84201d5e:	0b 62       	if NE jump (m) Lc_create_internal_metadata_12;

84201d60 <Lc_create_internal_metadata_9>:
84201d60:	f1 88       	rMAC = M[r4 + 12];
84201d62:	c8 24       	Null = rMAC - 3;
84201d64:	03 60       	if EQ jump (m) Lc_create_internal_metadata_11;

84201d66 <Lc_create_internal_metadata_10>:
84201d66:	48 24       	Null = rMAC - 1;
84201d68:	06 62       	if NE jump (m) Lc_create_internal_metadata_12;

84201d6a <Lc_create_internal_metadata_11>:
        /* To avoid manipulating the tag length when packing audio
         * just double the metadata buffer size.
         * internal_metadata_buff->metadata->buffer_size is change by
         * cbuffer_set_usable_octets as all internal buffer has
         * the same metadata*/
        meta_p->buffer_size = meta_p->buffer_size * 2;
84201d6a:	82 f0 06 88 	r0 = M[r6 + 24];
84201d6e:	12 54       	r0 = r0 LSHIFT 1;
84201d70:	82 f0 06 8e 	M[r6 + 24] = r0;

84201d74 <Lc_create_internal_metadata_12>:
    }

    /* Save the created metadata buffer*/
    splitter->internal_metadata.buffer = metadata_buffer;
84201d74:	77 af       	M[r4 + 84] = r5;

84201d76 <Lc_create_internal_metadata_13>:
    patch_fn_shared(splitter);

    if (splitter->working_mode == CLONE_BUFFER)
    {
        SPLITTER_MSG("Splitter: No need to create internal metadata when cloning!");
        return TRUE;
84201d76:	42 20       	r0 = Null + 1;
84201d78:	15 6e       	jump (m) Lc_create_internal_metadata_18;

84201d7a <Lc_create_internal_metadata_14>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata buffer for internal data!" );
        return FALSE;
    }

    meta_p = buff_metadata_enable(metadata_buffer);
84201d7a:	ff fd 95 f0 	call (m) 0x148f2;
84201d7e:	39 eb 
84201d80:	10 09       	r6 = r0 + Null;
    if (meta_p == NULL)
84201d82:	e7 63       	if NE jump (m) Lc_create_internal_metadata_8;

84201d84 <Lc_create_internal_metadata_15>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata for internal buffer.!" );
84201d84:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201d88:	08 24       	Null = rMAC - 0;
84201d8a:	07 6c       	if LE jump (m) Lc_create_internal_metadata_17;

84201d8c <Lc_create_internal_metadata_16>:
84201d8c:	55 f1 02 f0 	r0 = Null + 357568782;
84201d90:	0e 61 
84201d92:	ef fd f9 ff 	call (m) 0x10b0;
84201d96:	3f e8 

84201d98 <Lc_create_internal_metadata_17>:
        cbuffer_destroy_struct(metadata_buffer);
84201d98:	3a 00       	r0 = r5 + Null;
84201d9a:	ff fd 92 f0 	call (m) 0x1432e;
84201d9e:	35 ec 
84201da0:	d6 6f       	jump (m) Lc_create_internal_metadata_7;

84201da2 <Lc_create_internal_metadata_18>:
    }

    /* Save the created metadata buffer*/
    splitter->internal_metadata.buffer = metadata_buffer;
    return TRUE;
}
84201da2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201da4:	d8 4c       	rts;

84201da6 <$_delete_internal_metadata>:

/**
 * Helper function which deleted the metadata buffer.
 */
void delete_internal_metadata(SPLITTER_OP_DATA *splitter)
{
84201da6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201da8:	16 00       	r4 = r0 + Null;
    patch_fn_shared(splitter);

    if (splitter->working_mode == CLONE_BUFFER)
84201daa:	31 81       	rMAC = MBS[r4 + 4];
84201dac:	07 60       	if EQ jump (m) Lc_delete_internal_metadata_4;

84201dae <Lc_delete_internal_metadata_2>:
    {
        SPLITTER_MSG("Splitter: No internal metadata when cloning!");
        return;
    }
    if (splitter->internal_metadata.buffer == NULL)
84201dae:	72 a9       	r0 = M[r4 + 84];
84201db0:	05 60       	if EQ jump (m) Lc_delete_internal_metadata_4;

84201db2 <Lc_delete_internal_metadata_3>:
        SPLITTER_MSG("Splitter: No internal metadata!");
        return;
    }

    SPLITTER_MSG1("Deleting internal metadata buffer 0x%08x", splitter->internal_metadata.buffer);
    cbuffer_destroy_struct(splitter->internal_metadata.buffer);
84201db2:	ff fd 92 f0 	call (m) 0x1432e;
84201db6:	3d eb 
    
    splitter->internal_metadata.buffer = NULL;
84201db8:	70 af       	M[r4 + 84] = Null;

84201dba <Lc_delete_internal_metadata_4>:
}
84201dba:	f1 48       	popm <FP, r4, rLink>;
84201dbc:	d8 4c       	rts;

84201dbe <$_get_metadata_buffer>:
/**
 * Helper function to get the metadata buffers for the input and outputs.
 */
tCbuffer* get_metadata_buffer(SPLITTER_OP_DATA *splitter, bool is_input, unsigned index)
{
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
84201dbe:	11 e8       	rMAC = M[r0 + Null];

    patch_fn_shared(splitter);

    if (splitter->working_mode == CLONE_BUFFER)/* Cloning mode */
84201dc0:	12 81       	r0 = MBS[r0 + 4];
84201dc2:	14 60       	if EQ jump (m) Lc_get_metadata_buffer_10;

84201dc4 <Lc_get_metadata_buffer_2>:
        }
    }
    else /* Buffering mode */
    {
        /* All inputs and output streams must have the same metadata.*/
        if (channel != NULL)
84201dc4:	08 04       	Null = rMAC - Null;
84201dc6:	1b 60       	if EQ jump (m) Lc_get_metadata_buffer_14;

84201dc8 <Lc_get_metadata_buffer_3>:
        {
            if (is_input)
84201dc8:	18 04       	Null = r1 - Null;
84201dca:	17 62       	if NE jump (m) Lc_get_metadata_buffer_13;

84201dcc <Lc_get_metadata_buffer_4>:
                /* Return the medata input buffer. */
                return channel->input_buffer;
            }
            else
            {
                return channel->output_buffer[index];
84201dcc:	62 54       	r0 = r2 LSHIFT 2;
84201dce:	51 00       	rMAC = r0 + rMAC;
84201dd0:	ca 88       	r0 = M[rMAC + 12];
84201dd2:	1a 6e       	jump (m) Lc_get_metadata_buffer_16;

84201dd4 <Lc_get_metadata_buffer_5>:
            else
            {
                unsigned i;
                /* When splitter is in cloning mode each output has the same
                 * metadata so use the one which is connected. */
                for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201dd4:	02 00       	r0 = Null + Null;
84201dd6:	0c 23       	r2 = rMAC + 12;

84201dd8 <Lc_get_metadata_buffer_6>:
                {
                    if ((channel->output_buffer[i] != NULL) && buff_has_metadata(channel->output_buffer[i]))
84201dd8:	25 e8       	r3 = M[r2 + Null];
84201dda:	03 60       	if EQ jump (m) Lc_get_metadata_buffer_8;

84201ddc <Lc_get_metadata_buffer_7>:
84201ddc:	ad 89       	r3 = M[r3 + 24];
84201dde:	11 62       	if NE jump (m) Lc_get_metadata_buffer_15;

84201de0 <Lc_get_metadata_buffer_8>:
            else
            {
                unsigned i;
                /* When splitter is in cloning mode each output has the same
                 * metadata so use the one which is connected. */
                for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201de0:	52 20       	r0 = r0 + 1;
84201de2:	24 21       	r2 = r2 + 4;
84201de4:	90 24       	Null = r0 - 2;
84201de6:	f9 65       	if NC jump (m) Lc_get_metadata_buffer_6;

84201de8 <Lc_get_metadata_buffer_9>:
                    {
                        return channel->output_buffer[i];
                    }
                }
            }
            channel = channel->next;
84201de8:	09 e8       	rMAC = M[rMAC + Null];

84201dea <Lc_get_metadata_buffer_10>:
    if (splitter->working_mode == CLONE_BUFFER)/* Cloning mode */
    {
        /* There could be inputs and outputs without metadata
         * (for example if the splitter is between AEC and CVC)
         * so check all channels for it. */
        while (channel != NULL)
84201dea:	08 04       	Null = rMAC - Null;
84201dec:	08 60       	if EQ jump (m) Lc_get_metadata_buffer_14;

84201dee <Lc_get_metadata_buffer_11>:
        {
            if (is_input)
84201dee:	18 04       	Null = r1 - Null;
84201df0:	f2 61       	if EQ jump (m) Lc_get_metadata_buffer_5;

84201df2 <Lc_get_metadata_buffer_12>:
            {
                /* A channel cannot exist without input
                 * so no need to check if input_buffer is NULL*/
                if (buff_has_metadata(channel->input_buffer))
84201df2:	8a 88       	r0 = M[rMAC + 8];
84201df4:	92 89       	r0 = M[r0 + 24];
84201df6:	f9 61       	if EQ jump (m) Lc_get_metadata_buffer_9;

84201df8 <Lc_get_metadata_buffer_13>:
                {
                    /* Return the medata input buffer. */
                    return channel->input_buffer;
84201df8:	8a 88       	r0 = M[rMAC + 8];
84201dfa:	06 6e       	jump (m) Lc_get_metadata_buffer_16;

84201dfc <Lc_get_metadata_buffer_14>:
            }
        }
    }

    /* Couldn't find anything. */
    return NULL;
84201dfc:	02 00       	r0 = Null + Null;
84201dfe:	04 6e       	jump (m) Lc_get_metadata_buffer_16;

84201e00 <Lc_get_metadata_buffer_15>:
                 * metadata so use the one which is connected. */
                for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
                {
                    if ((channel->output_buffer[i] != NULL) && buff_has_metadata(channel->output_buffer[i]))
                    {
                        return channel->output_buffer[i];
84201e00:	52 54       	r0 = r0 LSHIFT 2;
84201e02:	51 00       	rMAC = r0 + rMAC;
84201e04:	ca 88       	r0 = M[rMAC + 12];

84201e06 <Lc_get_metadata_buffer_16>:
84201e06:	d8 4c       	rts;

84201e08 <$_splitter_metadata_transport_to_internal>:
 * Transports the metadata form the input to the internal buffer.
 * Very similar to metadata_strict_transport, with the exception that this function sets
 * the new metadata tag head for the channel for tracking reasons.
 */
void splitter_metadata_transport_to_internal(SPLITTER_OP_DATA *splitter,  unsigned trans_octets)
{
84201e08:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201e0a:	4c 4c       	SP = SP + 48;
84201e0c:	16 00       	r4 = r0 + Null;
84201e0e:	19 09       	r7 = r1 + Null;
    unsigned b4idx, afteridx;
    unsigned i;

    patch_fn_shared(splitter);

    src = get_metadata_buffer(splitter, TRUE, 0);
84201e10:	43 20       	r1 = Null + 1;
84201e12:	04 00       	r2 = Null + Null;
84201e14:	d5 4f       	call (m) $_get_metadata_buffer;
    dst = splitter->internal_metadata.buffer;
84201e16:	71 a9       	rMAC = M[r4 + 84];
84201e18:	41 de       	M[FP + 32] = rMAC;

    if (trans_octets == 0)
84201e1a:	0f f9 00 c2 	Null = r7 - Null;
84201e1e:	da 60       	if EQ jump (m) Lc__loop0;

84201e20 <Lc_splitter_metadata_transport_to_internal_2>:
        SPLITTER_MSG("splitter_metadata_transport_to_internal: ignoring zero transfer");
        return;
    }

    /* convert the consumed octets.*/
    if (splitter->cbuffer.data_size == 4)
84201e20:	61 f0 26 88 	rMAC = M[r4 + 152];
84201e24:	08 25       	Null = rMAC - 4;
84201e26:	03 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_4;

84201e28 <Lc_splitter_metadata_transport_to_internal_3>:

/** Converts samples to octets */
static inline unsigned samples_to_octets(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val * OCTETS_PER_SAMPLE;
84201e28:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;

84201e2c <Lc_splitter_metadata_transport_to_internal_4>:
    {
        trans_octets = samples_to_octets(trans_octets);
    }

    if (src != NULL)
84201e2c:	10 04       	Null = r0 - Null;
84201e2e:	09 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_6;

84201e30 <Lc_splitter_metadata_transport_to_internal_5>:
        /* transport metadata, first (attempt to) consume tag associated with src */
#ifdef METADATA_DEBUG_TRANSPORT
        ret_mtag = buff_metadata_remove_dbg(src, trans_octets, &b4idx,
                                            &afteridx, return_addr);
#else /* METADATA_DEBUG_TRANSPORT */
        ret_mtag = buff_metadata_remove(src, trans_octets, &b4idx, &afteridx);
84201e30:	85 12       	r3 = FP + 40;
84201e32:	44 12       	r2 = FP + 36;
84201e34:	4b 08       	r1 = r7 + Null;
84201e36:	ff fd 94 f0 	call (m) 0x147c0;
84201e3a:	2b ec 
84201e3c:	17 00       	r5 = r0 + Null;
84201e3e:	05 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_7;

84201e40 <Lc_splitter_metadata_transport_to_internal_6>:
#endif /* METADATA_DEBUG_TRANSPORT */
    }
    else
    {
        b4idx = 0;
84201e40:	48 de       	M[FP + 36] = Null;
        afteridx = trans_octets;
84201e42:	e9 f0 0a 8e 	M[FP + 40] = r7;
        ret_mtag = NULL;
84201e46:	07 00       	r5 = Null + Null;

84201e48 <Lc_splitter_metadata_transport_to_internal_7>:
                    splitter->frame_size);
        }
    }
#endif

    if (splitter->reframe_enabled)
84201e48:	61 f0 69 82 	rMAC = MBU[r4 + 105];
84201e4c:	98 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_35;

84201e4e <Lc_splitter_metadata_transport_to_internal_8>:
    {
        metadata_tag *mtag_ip, *mtag;
        unsigned new_ttp, base_ttp = 0, sample_offset = 0;
84201e4e:	03 09       	r9 = Null + Null;
84201e50:	02 09       	r8 = Null + Null;
        ttp_status status;

        /* Find the first timestamped tag */
        mtag_ip = ret_mtag;
84201e52:	38 09       	r6 = r5 + Null;

84201e54 <Lc_splitter_metadata_transport_to_internal_9>:
        while (mtag_ip != NULL)
84201e54:	0f f8 00 c2 	Null = r6 - Null;
84201e58:	37 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_19;

84201e5a <Lc_splitter_metadata_transport_to_internal_10>:
        {
            if (IS_TIME_TO_PLAY_TAG(mtag_ip))
84201e5a:	81 f0 01 88 	rMAC = M[r6 + 4];
84201e5e:	12 f0 30 00 	r0 = rMAC AND 0x30;
84201e62:	03 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_12;

84201e64 <Lc_splitter_metadata_transport_to_internal_11>:
84201e64:	c9 c2       	rMAC = rMAC AND 0x40;
84201e66:	13 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_15;

84201e68 <Lc_splitter_metadata_transport_to_internal_12>:
            }
            else
            {
                SPLITTER_ERRORMSG(
                    "splitter_metadata_transport_to_internal: Tag not timestamped!"
                        "\n Splitter cannot reframe timestamped tags.");
84201e68:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201e6c:	08 24       	Null = rMAC - 0;
84201e6e:	07 6c       	if LE jump (m) Lc_splitter_metadata_transport_to_internal_14;

84201e70 <Lc_splitter_metadata_transport_to_internal_13>:
84201e70:	55 f1 02 f0 	r0 = Null + 357568842;
84201e74:	4a 61 
84201e76:	ef fd f9 ff 	call (m) 0x10b0;
84201e7a:	3b e1 

84201e7c <Lc_splitter_metadata_transport_to_internal_14>:
                b4idx += mtag_ip->length;
84201e7c:	81 f0 03 88 	rMAC = M[r6 + 12];
84201e80:	4a d8       	r0 = M[FP + 36];
84201e82:	51 00       	rMAC = r0 + rMAC;
84201e84:	49 de       	M[FP + 36] = rMAC;
                mtag_ip = mtag_ip->next;
84201e86:	88 f0 00 e8 	r6 = M[r6 + Null];
84201e8a:	e5 6f       	jump (m) Lc_splitter_metadata_transport_to_internal_9;

84201e8c <Lc_splitter_metadata_transport_to_internal_15>:
            }
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84201e8c:	48 d8       	Null = M[FP + 36];
84201e8e:	1c 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_19;

84201e90 <Lc_splitter_metadata_transport_to_internal_16>:
        {
            /* If the old tag is already at the start of the encoded frame,
             * Just use its timestamp directly
             */
            base_ttp = mtag_ip->timestamp;
84201e90:	8b f0 04 88 	r9 = M[r6 + 16];
            sample_offset = 0;
84201e94:	02 09       	r8 = Null + Null;

84201e96 <Lc_splitter_metadata_transport_to_internal_17>:
        if (mtag_ip != NULL)
        {
            unsigned *err_offset_id;
            unsigned length;
            /* Save the timestamp info from the incoming metadata */
            splitter->reframe_data.last_tag_timestamp = mtag_ip->timestamp;
84201e96:	81 f0 04 88 	rMAC = M[r6 + 16];
84201e9a:	f1 9f       	M[r4 + 60] = rMAC;
            splitter->reframe_data.last_tag_spa = mtag_ip->sp_adjust;
84201e9c:	81 f0 05 88 	rMAC = M[r6 + 20];
84201ea0:	31 ae       	M[r4 + 64] = rMAC;
            splitter->reframe_data.last_tag_samples = (trans_octets - b4idx) / OCTETS_PER_SAMPLE;
84201ea2:	49 d8       	rMAC = M[FP + 36];
84201ea4:	1f f9 02 c2 	r0 = r7 - rMAC;
84201ea8:	52 50       	r0 = r0 LSHIFT -2;
84201eaa:	72 ae       	M[r4 + 68] = r0;
            if (buff_metadata_find_private_data(mtag_ip, META_PRIV_KEY_TTP_OFFSET, &length, (void **)&err_offset_id))
84201eac:	c5 12       	r3 = FP + 44;
84201eae:	04 13       	r2 = FP + 48;
84201eb0:	43 20       	r1 = Null + 1;
84201eb2:	42 08       	r0 = r6 + Null;
84201eb4:	ff fd 97 f0 	call (m) 0x14db4;
84201eb8:	21 e8 
84201eba:	10 04       	Null = r0 - Null;
84201ebc:	35 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_27;

84201ebe <Lc_splitter_metadata_transport_to_internal_18>:
            {
                splitter->reframe_data.last_tag_err_offset_id = (*err_offset_id);
84201ebe:	59 d8       	rMAC = M[FP + 44];
84201ec0:	09 e8       	rMAC = M[rMAC + Null];
84201ec2:	b1 ae       	M[r4 + 72] = rMAC;
84201ec4:	10 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_24;

84201ec6 <Lc_splitter_metadata_transport_to_internal_19>:
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp.
             * There had better be one ! */
            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201ec6:	71 a8       	rMAC = M[r4 + 68];
84201ec8:	48 20       	Null = rMAC + 1;
84201eca:	04 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_21;

84201ecc <Lc_splitter_metadata_transport_to_internal_20>:
            {
                base_ttp = splitter->reframe_data.last_tag_timestamp;
84201ecc:	6b f0 0f 88 	r9 = M[r4 + 60];
                sample_offset = splitter->reframe_data.last_tag_samples;
84201ed0:	0a 09       	r8 = rMAC + Null;

84201ed2 <Lc_splitter_metadata_transport_to_internal_21>:
            }
        }

        /* Save the tag for future reference when not tag was found. */
        if (mtag_ip != NULL)
84201ed2:	0f f8 00 c2 	Null = r6 - Null;
84201ed6:	e0 63       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_17;

84201ed8 <Lc_splitter_metadata_transport_to_internal_22>:
                splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
            }
        }
        else
        {
            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201ed8:	48 20       	Null = rMAC + 1;
84201eda:	05 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_24;

84201edc <Lc_splitter_metadata_transport_to_internal_23>:
            {
                splitter->reframe_data.last_tag_samples += trans_octets / OCTETS_PER_SAMPLE;
84201edc:	7f f9 d2 c8 	r0 = r7 LSHIFT -2;
84201ee0:	51 00       	rMAC = r0 + rMAC;
84201ee2:	71 ae       	M[r4 + 68] = rMAC;

84201ee4 <Lc_splitter_metadata_transport_to_internal_24>:
            }
        }

        status.sp_adjustment = splitter->reframe_data.last_tag_spa;
84201ee4:	31 a8       	rMAC = M[r4 + 64];
84201ee6:	71 de       	M[FP + 56] = rMAC;
        status.err_offset_id = splitter->reframe_data.last_tag_err_offset_id;
84201ee8:	b1 a8       	rMAC = M[r4 + 72];
84201eea:	79 de       	M[FP + 60] = rMAC;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);
84201eec:	81 f0 01 88 	rMAC = M[r6 + 4];
84201ef0:	09 c0       	rMAC = rMAC AND 0x1;
84201ef2:	81 de       	M[FP + 64] = rMAC;

        /* Create a new tag for the output */
        mtag = buff_metadata_new_tag();
84201ef4:	ff fd 92 f0 	call (m) 0x144be;
84201ef8:	2b ee 
84201efa:	10 09       	r6 = r0 + Null;

        if (mtag != NULL)
84201efc:	22 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_30;

84201efe <Lc_splitter_metadata_transport_to_internal_25>:
        {
            /* create a tag which covers the newly generated output. */
            mtag->length = trans_octets;
84201efe:	89 f0 03 8e 	M[r6 + 12] = r7;

            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201f02:	71 a8       	rMAC = M[r4 + 68];
84201f04:	48 20       	Null = rMAC + 1;
84201f06:	12 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_28;

84201f08 <Lc_splitter_metadata_transport_to_internal_26>:
            {
                /* Calculate new TTP from incoming data and sample offset */
                new_ttp = ttp_get_next_timestamp(base_ttp, sample_offset,
                        splitter->reframe_data.sample_rate, splitter->reframe_data.last_tag_spa);
84201f08:	35 a8       	r3 = M[r4 + 64];
84201f0a:	b4 99       	r2 = M[r4 + 56];
84201f0c:	53 08       	r1 = r8 + Null;
84201f0e:	5a 08       	r0 = r9 + Null;
84201f10:	ff fd bc f0 	call (m) 0x19780;
84201f14:	31 e3 
                status.ttp = new_ttp;
84201f16:	6a de       	M[FP + 52] = r0;
                ttp_utils_populate_tag(mtag, &status);
84201f18:	43 13       	r1 = FP + 52;
84201f1a:	42 08       	r0 = r6 + Null;
84201f1c:	ef fd f8 ff 	call (m) 0xfc8;
84201f20:	2d e5 
                status.stream_restart = FALSE;
84201f22:	80 de       	M[FP + 64] = Null;
84201f24:	18 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_32;

84201f26 <Lc_splitter_metadata_transport_to_internal_27>:
            {
                splitter->reframe_data.last_tag_err_offset_id = (*err_offset_id);
            }
            else
            {
                splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
84201f26:	b0 ae       	M[r4 + 72] = Null;
84201f28:	de 6f       	jump (m) Lc_splitter_metadata_transport_to_internal_24;

84201f2a <Lc_splitter_metadata_transport_to_internal_28>:
                status.stream_restart = FALSE;
            }
            else
            {
                SPLITTER_ERRORMSG(
                    "splitter_metadata_transport_to_internal: Last tag samples invalid");
84201f2a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201f2e:	08 24       	Null = rMAC - 0;
84201f30:	12 6c       	if LE jump (m) Lc_splitter_metadata_transport_to_internal_32;

84201f32 <Lc_splitter_metadata_transport_to_internal_29>:
84201f32:	55 f1 02 f0 	r0 = Null + 357568947;
84201f36:	b3 61 
84201f38:	ef fd f8 ff 	call (m) 0x10b0;
84201f3c:	39 eb 
84201f3e:	0b 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_32;

84201f40 <Lc_splitter_metadata_transport_to_internal_30>:
            }
        }
        else
        {
            SPLITTER_ERRORMSG(
                "splitter_metadata_transport_to_internal: Failed to allocate tag");
84201f40:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201f44:	08 24       	Null = rMAC - 0;
84201f46:	07 6c       	if LE jump (m) Lc_splitter_metadata_transport_to_internal_32;

84201f48 <Lc_splitter_metadata_transport_to_internal_31>:
84201f48:	55 f1 02 f0 	r0 = Null + 357569013;
84201f4c:	f5 61 
84201f4e:	ef fd f8 ff 	call (m) 0x10b0;
84201f52:	23 eb 

84201f54 <Lc_splitter_metadata_transport_to_internal_32>:
        }

        if (splitter->tag_size_to_samples)
84201f54:	61 f0 6a 82 	rMAC = MBU[r4 + 106];
84201f58:	05 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_34;

84201f5a <Lc_splitter_metadata_transport_to_internal_33>:
        {
            /* convert the the sizes to samples. */
            convert_tags_length_to_samples(mtag);
84201f5a:	42 08       	r0 = r6 + Null;
84201f5c:	b6 4e       	call (m) Lc_convert_tags_length_to_samples_1;
            trans_octets = trans_octets>>2;
84201f5e:	7f f9 d9 c8 	r7 = r7 LSHIFT -2;

84201f62 <Lc_splitter_metadata_transport_to_internal_34>:
        }

        buff_metadata_append(dst, mtag, 0, trans_octets);
84201f62:	04 00       	r2 = Null + Null;
84201f64:	4d 08       	r3 = r7 + Null;
84201f66:	43 08       	r1 = r6 + Null;
84201f68:	42 d8       	r0 = M[FP + 32];
84201f6a:	ff fd 93 f0 	call (m) 0x1457c;
84201f6e:	33 e0 

        /* Free all the incoming tags */
        buff_metadata_tag_list_delete(ret_mtag);
84201f70:	3a 00       	r0 = r5 + Null;
84201f72:	ff fd 92 f0 	call (m) 0x14512;
84201f76:	21 ed 

        /* Set the created tag as potential new head. */
        ret_mtag = mtag;
84201f78:	47 08       	r5 = r6 + Null;
84201f7a:	1a 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_40;

84201f7c <Lc_splitter_metadata_transport_to_internal_35>:
    }
    else
    {
        if (dst != NULL)
84201f7c:	41 d8       	rMAC = M[FP + 32];
84201f7e:	14 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_39;

84201f80 <Lc_splitter_metadata_transport_to_internal_36>:
        {
            if (splitter->tag_size_to_samples)
84201f80:	61 f0 6a 82 	rMAC = MBU[r4 + 106];
84201f84:	09 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_38;

84201f86 <Lc_splitter_metadata_transport_to_internal_37>:
            {
                /* convert the the sizes to samples. */
                convert_tags_length_to_samples(ret_mtag);
84201f86:	3a 00       	r0 = r5 + Null;
84201f88:	a0 4e       	call (m) Lc_convert_tags_length_to_samples_1;
                b4idx = b4idx>>2;
84201f8a:	4a d8       	r0 = M[FP + 36];
84201f8c:	52 50       	r0 = r0 LSHIFT -2;
84201f8e:	4a de       	M[FP + 36] = r0;
                afteridx = afteridx>>2;
84201f90:	52 d8       	r0 = M[FP + 40];
84201f92:	52 50       	r0 = r0 LSHIFT -2;
84201f94:	52 de       	M[FP + 40] = r0;

84201f96 <Lc_splitter_metadata_transport_to_internal_38>:
             * later to the src which does support metadata the dst metadata write
             * pointer needs to be at the right offset. */
#ifdef METADATA_DEBUG_TRANSPORT
            buff_metadata_append_dbg(dst, ret_mtag, b4idx, afteridx, return_addr);
#else /* METADATA_DEBUG_TRANSPORT */
            buff_metadata_append(dst, ret_mtag, b4idx, afteridx);
84201f96:	55 d8       	r3 = M[FP + 40];
84201f98:	4c d8       	r2 = M[FP + 36];
84201f9a:	3b 00       	r1 = r5 + Null;
84201f9c:	42 d8       	r0 = M[FP + 32];
84201f9e:	ff fd 92 f0 	call (m) 0x1457c;
84201fa2:	3f ee 
84201fa4:	05 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_40;

84201fa6 <Lc_splitter_metadata_transport_to_internal_39>:
#endif /* METADATA_DEBUG_TRANSPORT */
        }
        else
        {
            buff_metadata_tag_list_delete(ret_mtag);
84201fa6:	3a 00       	r0 = r5 + Null;
84201fa8:	ff fd 92 f0 	call (m) 0x14512;
84201fac:	2b eb 

84201fae <Lc_splitter_metadata_transport_to_internal_40>:
        }
    }

    /* Check if ret_mtag is a new head for any of the output streams. */
    if (ret_mtag != NULL)
84201fae:	38 04       	Null = r5 - Null;
84201fb0:	11 60       	if EQ jump (m) Lc__loop0;

84201fb2 <Lc_splitter_metadata_transport_to_internal_41>:
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201fb2:	01 00       	rMAC = Null + Null;
84201fb4:	62 f0 60 20 	r0 = r4 + 96;
84201fb8:	14 71       	r10 = Null + 2;
84201fba:	0c 4c       	do (m) Lc__loop0;

84201fbc <Lc_splitter_metadata_transport_to_internal_42>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84201fbc:	33 2a       	r1 = r4 + 24;
84201fbe:	5b e0       	r1 = MBS[r1 + rMAC];
        {
            SPLITTER_OUTPUT_STATE output_state;
            output_state = get_current_output_state(splitter, i);
            if ((output_state == ACTIVE) || (output_state == HOLD))
84201fc0:	58 24       	Null = r1 - 1;
84201fc2:	03 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_44;

84201fc4 <Lc_splitter_metadata_transport_to_internal_43>:
84201fc4:	98 24       	Null = r1 - 2;
84201fc6:	04 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_46;

84201fc8 <Lc_splitter_metadata_transport_to_internal_44>:
            {
                if (splitter->internal_metadata.head_tag[i] == NULL)
84201fc8:	13 e8       	r1 = M[r0 + Null];
84201fca:	02 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_46;

84201fcc <Lc_splitter_metadata_transport_to_internal_45>:
                {

                    SPLITTER_MSG2("Splitter: Setting head for out %d head 0x%08x",
                            i, ret_mtag);
                    splitter->internal_metadata.head_tag[i] = ret_mtag;
84201fcc:	17 ee       	M[r0 + Null] = r5;

84201fce <Lc_splitter_metadata_transport_to_internal_46>:
    }

    /* Check if ret_mtag is a new head for any of the output streams. */
    if (ret_mtag != NULL)
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201fce:	49 20       	rMAC = rMAC + 1;
84201fd0:	12 21       	r0 = r0 + 4;

84201fd2 <Lc__loop0>:
84201fd2:	74 4c       	SP = SP + -48;
84201fd4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201fd6:	d8 4c       	rts;

84201fd8 <$_splitter_metadata_copy>:

/**
 * Copies metadata from the internal buffer to the output buffer.
 */
void splitter_metadata_copy(SPLITTER_OP_DATA *splitter, unsigned* data_to_copy, unsigned data_to_remove)
{
84201fd8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201fda:	13 09       	r9 = r0 + Null;
84201fdc:	44 de       	M[FP + 32] = r2;

    patch_fn_shared(splitter);

    /* the internal buffer is the metadata source. */
    internal = get_internal_metadata_buffer(splitter);
    PL_ASSERT(internal != NULL);
84201fde:	b9 f0 15 88 	r7 = M[r9 + 84];
84201fe2:	08 62       	if NE jump (m) Lc_splitter_metadata_copy_3;

84201fe4 <Lc_splitter_metadata_copy_2>:
84201fe4:	03 f0 22 42 	r1 = Null + 546;
84201fe8:	02 f0 13 60 	r0 = Null + 4115;
84201fec:	ff fd a5 f0 	call (m) 0x16bdc;
84201ff0:	31 ef 

84201ff2 <Lc_splitter_metadata_copy_3>:


    /* Save the index value. */
    before_prev_rd_indexes = internal->metadata->prev_rd_index;
84201ff2:	91 f0 06 88 	rMAC = M[r7 + 24];
84201ff6:	ca 88       	r0 = M[rMAC + 12];
84201ff8:	4a de       	M[FP + 36] = r0;
    before_head_tag = internal->metadata->tags.head;
84201ffa:	09 e8       	rMAC = M[rMAC + Null];
84201ffc:	51 de       	M[FP + 40] = rMAC;

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201ffe:	00 09       	r6 = Null + Null;
84202000:	1a 09       	r8 = r1 + Null;
84202002:	b7 f0 58 20 	r5 = r9 + 88;

84202006 <Lc_splitter_metadata_copy_4>:
84202006:	b1 f0 18 20 	rMAC = r9 + 24;
8420200a:	11 f0 08 e0 	rMAC = MBS[rMAC + r6];
    {
        SPLITTER_OUTPUT_STATE output_state;
        output_state = get_current_output_state(splitter, i);
        if ((data_to_copy[i] != 0) && (output_state == ACTIVE))
8420200e:	a0 f0 00 e8 	Null = M[r8 + Null];
84202012:	23 60       	if EQ jump (m) Lc_splitter_metadata_copy_9;

84202014 <Lc_splitter_metadata_copy_5>:
84202014:	48 24       	Null = rMAC - 1;
84202016:	21 62       	if NE jump (m) Lc_splitter_metadata_copy_9;

84202018 <Lc_splitter_metadata_copy_6>:
        {
            unsigned dst_data;
            /* Set up the internal buffer read pointers!*/
            output_prev_rd_indexes = splitter->internal_metadata.prev_rd_indexes[i];
84202018:	3e e8       	r4 = M[r5 + Null];
            internal->metadata->prev_rd_index = output_prev_rd_indexes;
8420201a:	91 f0 06 88 	rMAC = M[r7 + 24];
8420201e:	ce 8e       	M[rMAC + 12] = r4;

            out_head_tag = splitter->internal_metadata.head_tag[i];
84202020:	b9 88       	rMAC = M[r5 + 8];
            internal->metadata->tags.head = out_head_tag;
84202022:	92 f0 06 88 	r0 = M[r7 + 24];
84202026:	11 ee       	M[r0 + Null] = rMAC;

            SPLITTER_MSG4("Splitter: output index %d"
                            "\n read_index before 0x%08x\n head tag 0x%08x\n head index 0x%08x",
                            i, output_prev_rd_indexes, out_head_tag, out_head_tag->index);

            dst_data = data_to_copy[i];
84202028:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420202c:	59 de       	M[FP + 44] = rMAC;

            out_head_tag = metadata_copy_without_changing_src(
                    internal, get_metadata_buffer(splitter, FALSE, i), dst_data, splitter->tag_size_to_samples);
8420202e:	03 00       	r1 = Null + Null;
84202030:	44 08       	r2 = r6 + Null;
84202032:	5a 08       	r0 = r9 + Null;
84202034:	fe ff 2b ec 	call (m) $_get_metadata_buffer;
84202038:	b5 f0 6a 82 	r3 = MBU[r9 + 106];
8420203c:	13 00       	r1 = r0 + Null;
8420203e:	4a 08       	r0 = r7 + Null;
84202040:	5c d8       	r2 = M[FP + 44];
84202042:	53 4e       	call (m) Lc_metadata_copy_without_changing_src_1;

            SPLITTER_MSG1("Splitter will continue from tag 0x%08x",
                    out_head_tag);
            splitter->internal_metadata.head_tag[i] = out_head_tag;
84202044:	ba 8e       	M[r5 + 8] = r0;

            /* Calculate the read index of the output metadata. */
            output_prev_rd_indexes += dst_data;
84202046:	59 d8       	rMAC = M[FP + 44];
84202048:	8e 01       	r4 = rMAC + r4;
            if (output_prev_rd_indexes >= internal->metadata->buffer_size)
8420204a:	91 f0 06 88 	rMAC = M[r7 + 24];
8420204e:	89 89       	rMAC = M[rMAC + 24];
84202050:	70 04       	Null = r4 - rMAC;
84202052:	02 64       	if NC jump (m) Lc_splitter_metadata_copy_8;

84202054 <Lc_splitter_metadata_copy_7>:
            {
                output_prev_rd_indexes -= internal->metadata->buffer_size;
84202054:	76 04       	r4 = r4 - rMAC;

84202056 <Lc_splitter_metadata_copy_8>:
            }
            /* Update the read index for the output.*/
            splitter->internal_metadata.prev_rd_indexes[i] = output_prev_rd_indexes;
84202056:	3e ee       	M[r5 + Null] = r4;

84202058 <Lc_splitter_metadata_copy_9>:

    /* Save the index value. */
    before_prev_rd_indexes = internal->metadata->prev_rd_index;
    before_head_tag = internal->metadata->tags.head;

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84202058:	08 75       	r6 = r6 + 1;
8420205a:	22 75       	r8 = r8 + 4;
8420205c:	3f 21       	r5 = r5 + 4;
8420205e:	80 f0 02 24 	Null = r6 - 2;
84202062:	d2 65       	if NC jump (m) Lc_splitter_metadata_copy_4;

84202064 <Lc_splitter_metadata_copy_10>:
            splitter->internal_metadata.prev_rd_indexes[i] = output_prev_rd_indexes;
        }
    }

    /* restore the index value. */
    internal->metadata->prev_rd_index = before_prev_rd_indexes;
84202064:	91 f0 06 88 	rMAC = M[r7 + 24];
84202068:	4a d8       	r0 = M[FP + 36];
8420206a:	ca 8e       	M[rMAC + 12] = r0;
    internal->metadata->tags.head = before_head_tag;
8420206c:	91 f0 06 88 	rMAC = M[r7 + 24];
84202070:	52 d8       	r0 = M[FP + 40];
84202072:	0a ee       	M[rMAC + Null] = r0;

    if (data_to_remove !=0)
84202074:	41 d8       	rMAC = M[FP + 32];
84202076:	04 60       	if EQ jump (m) Lc_splitter_metadata_copy_12;

84202078 <Lc_splitter_metadata_copy_11>:
    {
        remove_metadata_from_internal(splitter, data_to_remove);
84202078:	5a 08       	r0 = r9 + Null;
8420207a:	43 d8       	r1 = M[FP + 32];
8420207c:	03 4e       	call (m) $_remove_metadata_from_internal;

8420207e <Lc_splitter_metadata_copy_12>:
    }

}
8420207e:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202080:	d8 4c       	rts;

84202082 <$_remove_metadata_from_internal>:

/**
 * Helper function to remove unnecessary data from the internal buffer.
 */
void remove_metadata_from_internal(SPLITTER_OP_DATA *splitter, unsigned data_to_remove)
{
84202082:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84202084:	17 00       	r5 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84202086:	7e a9       	r4 = M[r5 + 84];
    patch_fn_shared(splitter);

    /* remove the associated metadata too. */
    ret_mtag = buff_metadata_remove(
            internal_metadata_buffer,
            data_to_remove, &b4idx, &afteridx);
84202088:	45 11       	r3 = FP + 20;
8420208a:	04 11       	r2 = FP + 16;
8420208c:	32 00       	r0 = r4 + Null;
8420208e:	ff fd 93 f0 	call (m) 0x147c0;
84202092:	33 e9 
    buff_metadata_tag_list_delete(ret_mtag);
84202094:	ff fd 92 f0 	call (m) 0x14512;
84202098:	3f e3 

    /* Update channels on hold */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
8420209a:	ba b2       	r0 = MBU[r5 + 26];
8420209c:	d2 50       	r0 = r0 LSHIFT -4;
8420209e:	91 c0       	rMAC = r0 AND 0x3;
842020a0:	12 60       	if EQ jump (m) Lc__loop1;

842020a2 <Lc_remove_metadata_from_internal_2>:
    {
        unsigned i;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842020a2:	01 00       	rMAC = Null + Null;
842020a4:	72 f0 58 20 	r0 = r5 + 88;
842020a8:	14 71       	r10 = Null + 2;
842020aa:	0d 4c       	do (m) Lc__loop1;

842020ac <Lc_remove_metadata_from_internal_3>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842020ac:	3b 2a       	r1 = r5 + 24;
842020ae:	5b e0       	r1 = MBS[r1 + rMAC];
        {
            SPLITTER_OUTPUT_STATE output_state;
            output_state = get_current_output_state(splitter, i);
            if (output_state == HOLD)
842020b0:	98 24       	Null = r1 - 2;
842020b2:	07 62       	if NE jump (m) Lc_remove_metadata_from_internal_5;

842020b4 <Lc_remove_metadata_from_internal_4>:
            {
                /* Set up the internal buffer metadata read indexes!*/
                splitter->internal_metadata.prev_rd_indexes[i] = internal_metadata_buffer->metadata->prev_rd_index;
842020b4:	b3 89       	r1 = M[r4 + 24];
842020b6:	db 88       	r1 = M[r1 + 12];
842020b8:	13 ee       	M[r0 + Null] = r1;
                splitter->internal_metadata.head_tag[i] = internal_metadata_buffer->metadata->tags.head;
842020ba:	b3 89       	r1 = M[r4 + 24];
842020bc:	1b e8       	r1 = M[r1 + Null];
842020be:	93 8e       	M[r0 + 8] = r1;

842020c0 <Lc_remove_metadata_from_internal_5>:
    /* Update channels on hold */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
    {
        unsigned i;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842020c0:	49 20       	rMAC = rMAC + 1;
842020c2:	12 21       	r0 = r0 + 4;

842020c4 <Lc__loop1>:
842020c4:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842020c6:	d8 4c       	rts;

842020c8 <Lc_convert_tags_length_to_samples_1>:
 * As the name suggests this function converts the tag sizes
 * to samples.
 */
static void convert_tags_length_to_samples(metadata_tag *mtag)
{
    while (mtag != NULL)
842020c8:	10 04       	Null = r0 - Null;
842020ca:	06 60       	if EQ jump (m) Lc_convert_tags_length_to_samples_4;

842020cc <Lc_convert_tags_length_to_samples_3>:
    {
        SPLITTER_DEBUG_INSTR(PL_ASSERT((mtag->length&(OCTETS_PER_SAMPLE-1)) == 0));
        mtag->length = mtag->length/OCTETS_PER_SAMPLE;
842020cc:	d3 88       	r1 = M[r0 + 12];
842020ce:	5b 50       	r1 = r1 LSHIFT -2;
842020d0:	d3 8e       	M[r0 + 12] = r1;
        mtag = mtag->next;
842020d2:	12 e8       	r0 = M[r0 + Null];
 * As the name suggests this function converts the tag sizes
 * to samples.
 */
static void convert_tags_length_to_samples(metadata_tag *mtag)
{
    while (mtag != NULL)
842020d4:	fa 6f       	jump (m) Lc_convert_tags_length_to_samples_1;

842020d6 <Lc_convert_tags_length_to_samples_4>:
842020d6:	d8 4c       	rts;

842020d8 <Lc_convert_tags_length_to_octets_1>:
 * Just like convert_tags_length_to_samples, but this function transforms
 * the tag sizes to octets.
 */
static void convert_tags_length_to_octets(metadata_tag *mtag)
{
    while (mtag != NULL)
842020d8:	10 04       	Null = r0 - Null;
842020da:	06 60       	if EQ jump (m) Lc_convert_tags_length_to_octets_4;

842020dc <Lc_convert_tags_length_to_octets_3>:
    {
        mtag->length = mtag->length*OCTETS_PER_SAMPLE;
842020dc:	d3 88       	r1 = M[r0 + 12];
842020de:	5b 54       	r1 = r1 LSHIFT 2;
842020e0:	d3 8e       	M[r0 + 12] = r1;
        mtag = mtag->next;
842020e2:	12 e8       	r0 = M[r0 + Null];
 * Just like convert_tags_length_to_samples, but this function transforms
 * the tag sizes to octets.
 */
static void convert_tags_length_to_octets(metadata_tag *mtag)
{
    while (mtag != NULL)
842020e4:	fa 6f       	jump (m) Lc_convert_tags_length_to_octets_1;

842020e6 <Lc_convert_tags_length_to_octets_4>:
842020e6:	d8 4c       	rts;

842020e8 <Lc_metadata_copy_without_changing_src_1>:

/**
 * Copies metadata to the destination without removing it from the source.
 */
static metadata_tag *metadata_copy_without_changing_src(tCbuffer *src, tCbuffer *dest, unsigned data_copied_octets, bool sample_to_octets)
{
842020e8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842020ea:	11 09       	r7 = r0 + Null;
842020ec:	43 de       	M[FP + 32] = r1;
842020ee:	20 09       	r6 = r2 + Null;
842020f0:	46 08       	r4 = r6 + Null;
842020f2:	2b 09       	r9 = r3 + Null;
    metadata_tag *head_tag;
    unsigned src_data = data_copied_octets;

    patch_fn_shared(splitter);

    if (sample_to_octets)
842020f4:	03 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_3;

842020f6 <Lc_metadata_copy_without_changing_src_2>:
    {
        /* convert the the sizes to octets. */
        data_copied_octets = data_copied_octets << 2;
842020f6:	01 f8 d8 c8 	r6 = r6 LSHIFT 2;

842020fa <Lc_metadata_copy_without_changing_src_3>:
    }

    /* Check if we have enough data/space. */
    PL_ASSERT(buff_metadata_available_octets(src) >= src_data);
842020fa:	ff fd 93 f0 	call (m) 0x14756;
842020fe:	3d e2 
84202100:	90 05       	Null = r0 - r4;
84202102:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_5;

84202106 <Lc_metadata_copy_without_changing_src_4>:
84202106:	03 f0 c6 41 	r1 = Null + 454;
8420210a:	02 f0 13 60 	r0 = Null + 4115;
8420210e:	ff fd a5 f0 	call (m) 0x16bdc;
84202112:	2f e6 
84202114:	25 6e       	jump (m) Lc_metadata_copy_without_changing_src_10;

84202116 <Lc_metadata_copy_without_changing_src_5>:
    PL_ASSERT(buff_metadata_available_space(dest) >= data_copied_octets);
84202116:	42 d8       	r0 = M[FP + 32];
84202118:	ff fd 93 f0 	call (m) 0x1478e;
8420211c:	37 e3 
8420211e:	8f f2 00 c2 	Null = r0 - r6;
84202122:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_7;

84202126 <Lc_metadata_copy_without_changing_src_6>:
84202126:	03 f0 c7 41 	r1 = Null + 455;
8420212a:	02 f0 13 60 	r0 = Null + 4115;
8420212e:	ff fd a5 f0 	call (m) 0x16bdc;
84202132:	2f e5 
84202134:	15 6e       	jump (m) Lc_metadata_copy_without_changing_src_10;

84202136 <Lc_metadata_copy_without_changing_src_7>:

    /* Transport the metadata to the output buffer. */
    tag_list = buff_metadata_peek_ex(src, &b4idx);
84202136:	43 12       	r1 = FP + 36;
84202138:	4a 08       	r0 = r7 + Null;
8420213a:	ff fd 92 f0 	call (m) 0x146e0;
8420213e:	27 ed 
84202140:	17 00       	r5 = r0 + Null;
    SPLITTER_MSG5("Splitter: buff_metadata_available_space(out) %d data_copied %d octets"
            "\n tag_list 0x%08x  tag_list->next 0x%08x b4idx %d octets " ,
            buff_metadata_available_space(dest), data_copied_octets, tag_list, tag_list->next, b4idx);

    /* Check the before index validity */
    if (tag_list != NULL)
84202142:	11 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_12;

84202144 <Lc_metadata_copy_without_changing_src_8>:
    {
        PL_ASSERT(b4idx < src->metadata->buffer_size);
84202144:	49 d8       	rMAC = M[FP + 36];
84202146:	92 f0 06 88 	r0 = M[r7 + 24];
8420214a:	92 89       	r0 = M[r0 + 24];
8420214c:	88 04       	Null = rMAC - r0;
8420214e:	08 64       	if NC jump (m) Lc_metadata_copy_without_changing_src_10;

84202150 <Lc_metadata_copy_without_changing_src_9>:
84202150:	03 f0 d3 41 	r1 = Null + 467;
84202154:	02 f0 13 60 	r0 = Null + 4115;
84202158:	ff fd a5 f0 	call (m) 0x16bdc;
8420215c:	25 e4 

8420215e <Lc_metadata_copy_without_changing_src_10>:
    }

    /* check if we will consume one tag at all?
     * Note: When tag_list is NULL b4idx is not set by buff_metadata_peek_ex */
    if ((tag_list == NULL) || (src_data < b4idx))
8420215e:	70 04       	Null = r4 - rMAC;
84202160:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_13;

84202164 <Lc_metadata_copy_without_changing_src_12>:
    {
        /* continuing to consume the previous tag. */
        buff_metadata_append(dest, NULL, 0, data_copied_octets);
84202164:	04 00       	r2 = Null + Null;
84202166:	03 00       	r1 = Null + Null;
84202168:	45 08       	r3 = r6 + Null;
8420216a:	42 d8       	r0 = M[FP + 32];
8420216c:	ff fd 92 f0 	call (m) 0x1457c;
84202170:	31 e0 
84202172:	31 6e       	jump (m) Lc_metadata_copy_without_changing_src_26;

84202174 <Lc_metadata_copy_without_changing_src_13>:
        return tag_list;
    }

    /* Decrement the data before the first tag. */
    src_data -= b4idx;
84202174:	76 04       	r4 = r4 - rMAC;

    tail_tag = NULL;
84202176:	01 09       	r7 = Null + Null;
    head_tag = NULL;
84202178:	00 09       	r6 = Null + Null;
    afteridx = 0;
8420217a:	02 09       	r8 = Null + Null;

8420217c <Lc_metadata_copy_without_changing_src_14>:

    while((tag_list != NULL) && (src_data != 0))
8420217c:	30 04       	Null = r4 - Null;
8420217e:	1a 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_23;

84202180 <Lc_metadata_copy_without_changing_src_15>:
    {

        SPLITTER_MSG2("Splitter tag copy \n tag_list->index 0x%08x \n tag_list->length 0x%08x " ,
                tag_list->index, tag_list->length );

        tag_length = tag_list->length;
84202180:	f9 88       	rMAC = M[r5 + 12];
        if (src_data <= tag_length)
84202182:	70 04       	Null = r4 - rMAC;
84202184:	08 f0 8b e0 	if HI jump (m) Lc_metadata_copy_without_changing_src_17;

84202188 <Lc_metadata_copy_without_changing_src_16>:
        {
            afteridx = src_data;
84202188:	32 09       	r8 = r4 + Null;
            src_data = 0;
8420218a:	06 00       	r4 = Null + Null;
8420218c:	02 6e       	jump (m) Lc_metadata_copy_without_changing_src_18;

8420218e <Lc_metadata_copy_without_changing_src_17>:
        }
        else
        {
            src_data -= tag_length;
8420218e:	76 04       	r4 = r4 - rMAC;

84202190 <Lc_metadata_copy_without_changing_src_18>:
        }
        /* Create a new tag. */
        new_tag = buff_metadata_copy_tag(tag_list);
84202190:	3a 00       	r0 = r5 + Null;
84202192:	ff fd 91 f0 	call (m) 0x14528;
84202196:	37 ec 
        /* Make sure the next pointer is NULL. */
        new_tag->next = NULL;
84202198:	10 ee       	M[r0 + Null] = Null;
        /* The new tag will be the head if the list is not created yet */
        if (head_tag == NULL)
8420219a:	0f f8 00 c2 	Null = r6 - Null;
8420219e:	02 62       	if NE jump (m) Lc_metadata_copy_without_changing_src_20;

842021a0 <Lc_metadata_copy_without_changing_src_19>:
        {
            head_tag = new_tag;
842021a0:	10 09       	r6 = r0 + Null;

842021a2 <Lc_metadata_copy_without_changing_src_20>:
        }
        /* Add the tag to the end of the tag list. */
        if (tail_tag != NULL)
842021a2:	0f f9 00 c2 	Null = r7 - Null;
842021a6:	03 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_22;

842021a8 <Lc_metadata_copy_without_changing_src_21>:
        {
            tail_tag->next = new_tag;
842021a8:	92 f0 00 ee 	M[r7 + Null] = r0;

842021ac <Lc_metadata_copy_without_changing_src_22>:
        }
        tail_tag = new_tag;
842021ac:	11 09       	r7 = r0 + Null;

    tail_tag = NULL;
    head_tag = NULL;
    afteridx = 0;

    while((tag_list != NULL) && (src_data != 0))
842021ae:	3f e8       	r5 = M[r5 + Null];
842021b0:	e6 63       	if NE jump (m) Lc_metadata_copy_without_changing_src_14;

842021b2 <Lc_metadata_copy_without_changing_src_23>:
        tail_tag = new_tag;

        tag_list = tag_list->next;
    }

    if (sample_to_octets)
842021b2:	0f fb 00 c2 	Null = r9 - Null;
842021b6:	08 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_25;

842021b8 <Lc_metadata_copy_without_changing_src_24>:
    {
        /* convert the the sizes to octets. */
        convert_tags_length_to_octets(head_tag);
842021b8:	42 08       	r0 = r6 + Null;
842021ba:	8f 4f       	call (m) Lc_convert_tags_length_to_octets_1;
        b4idx = b4idx<<2;
842021bc:	4a d8       	r0 = M[FP + 36];
842021be:	52 54       	r0 = r0 LSHIFT 2;
842021c0:	4a de       	M[FP + 36] = r0;
        afteridx = afteridx<<2;
842021c2:	01 fa da c8 	r8 = r8 LSHIFT 2;

842021c6 <Lc_metadata_copy_without_changing_src_25>:
    }

    buff_metadata_append(dest, head_tag, b4idx, afteridx);
842021c6:	4c d8       	r2 = M[FP + 36];
842021c8:	55 08       	r3 = r8 + Null;
842021ca:	43 08       	r1 = r6 + Null;
842021cc:	42 d8       	r0 = M[FP + 32];
842021ce:	ff fd 91 f0 	call (m) 0x1457c;
842021d2:	2f ed 

842021d4 <Lc_metadata_copy_without_changing_src_26>:
     * Note: When tag_list is NULL b4idx is not set by buff_metadata_peek_ex */
    if ((tag_list == NULL) || (src_data < b4idx))
    {
        /* continuing to consume the previous tag. */
        buff_metadata_append(dest, NULL, 0, data_copied_octets);
        return tag_list;
842021d4:	3a 00       	r0 = r5 + Null;

842021d6 <Lc_metadata_copy_without_changing_src_27>:
        afteridx = afteridx<<2;
    }

    buff_metadata_append(dest, head_tag, b4idx, afteridx);
    return tag_list;
}
842021d6:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842021d8:	d8 4c       	rts;

842021da <$_splitter_timer_task>:
842021da:	f1 1c       	pushm <FP(=SP), r4, rLink>;
 * This prevents a stall when buffers fill up
 *
 * \param timer_data Pointer to the operator instance data.
 */
void splitter_timer_task(void *timer_data)
{
842021dc:	16 00       	r4 = r0 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
842021de:	ef fd f3 ff 	call (m) 0x8ea;
842021e2:	2d e8 
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) timer_data;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    splitter->self_kick_timer = TIMER_ID_INVALID;
842021e4:	50 9e       	M[r0 + 36] = Null;
    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
842021e6:	32 00       	r0 = r4 + Null;
842021e8:	ff fd 0e f0 	call (m) 0x3f30;
842021ec:	29 ea 

842021ee <Lc_splitter_timer_task_2>:
}
842021ee:	f1 48       	popm <FP, r4, rLink>;
842021f0:	d8 4c       	rts;

842021f2 <$_get_terminal_info>:
 * \param save_buffer If true, the input buffer will be saved into the terminal info.
 *
 * \return TRUE if the call is correct, FALSE otherwise.
 */
bool get_terminal_info(unsigned terminal_id, tCbuffer *buffer, terminal_info_t *terminal_info, bool save_buffer)
{
842021f2:	f1 1c       	pushm <FP(=SP), r4, rLink>;

    patch_fn_shared(splitter);
    terminal_info->terminal_num = terminal_id & TERMINAL_NUM_MASK;
842021f4:	96 c2       	r4 = r0 AND 0x3f;
842021f6:	a6 8e       	M[r2 + 8] = r4;
    terminal_info->is_input = terminal_id & TERMINAL_SINK_MASK;
842021f8:	40 f0 21 f0 	rMAC = r0 AND 0x800000;
842021fc:	00 00 
842021fe:	61 8e       	M[r2 + 4] = rMAC;

    if(save_buffer)
84202200:	28 04       	Null = r3 - Null;
84202202:	02 60       	if EQ jump (m) Lc_get_terminal_info_3;

84202204 <Lc_get_terminal_info_2>:
    {
        terminal_info->buffer = buffer;
84202204:	23 8f       	M[r2 + 16] = r1;

84202206 <Lc_get_terminal_info_3>:
    }

    if (terminal_info->is_input)
84202206:	08 04       	Null = rMAC - Null;
84202208:	13 60       	if EQ jump (m) Lc_get_terminal_info_9;

8420220a <Lc_get_terminal_info_4>:
    {
        if (terminal_info->terminal_num >= SPLITTER_MAX_INPUTS)
8420220a:	30 26       	Null = r4 - 8;
8420220c:	0e 64       	if NC jump (m) Lc_get_terminal_info_8;

8420220e <Lc_get_terminal_info_5>:
        {
            SPLITTER_ERRORMSG1("Splitter: Incorrect terminal number %4d!", terminal_info->terminal_num);
8420220e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202212:	08 24       	Null = rMAC - 0;
84202214:	08 6c       	if LE jump (m) Lc_get_terminal_info_7;

84202216 <Lc_get_terminal_info_6>:
84202216:	55 f1 02 f0 	r0 = Null + 357569077;
8420221a:	35 62 
8420221c:	33 00       	r1 = r4 + Null;
8420221e:	ef fd f7 ff 	call (m) 0x10c2;
84202222:	25 e5 

84202224 <Lc_get_terminal_info_7>:
            return FALSE;
84202224:	02 00       	r0 = Null + Null;
84202226:	0c 6e       	jump (m) Lc_get_terminal_info_12;

84202228 <Lc_get_terminal_info_8>:
        }
        /* For input terminals the channel id is equal to the terminal ID. */
        terminal_info->channel_id = terminal_info->terminal_num;
84202228:	26 ee       	M[r2 + Null] = r4;
        /* Input index is always 0 . */
        terminal_info->index = 0;
8420222a:	e0 8e       	M[r2 + 12] = Null;
8420222c:	08 6e       	jump (m) Lc_get_terminal_info_11;

8420222e <Lc_get_terminal_info_9>:
    }
    else
    {
        if (terminal_info->terminal_num >= SPLITTER_MAX_OUTPUTS)
8420222e:	30 2c       	Null = r4 - 16;
84202230:	f2 ff df ef 	if C jump (m) Lc_get_terminal_info_5;

84202234 <Lc_get_terminal_info_10>:
            SPLITTER_ERRORMSG1("Splitter: Incorrect terminal number %4d!", terminal_info->terminal_num);
            return FALSE;
        }
        /* For outp terminals the channel id is the terminal ID shifted
         * with the number of outputs. */
        terminal_info->channel_id = terminal_info->terminal_num >> 1;
84202234:	32 50       	r0 = r4 LSHIFT -1;
84202236:	22 ee       	M[r2 + Null] = r0;

        terminal_info->index = terminal_info->terminal_num & 1;
84202238:	31 c0       	rMAC = r4 AND 0x1;
8420223a:	e1 8e       	M[r2 + 12] = rMAC;

8420223c <Lc_get_terminal_info_11>:
    }

    return TRUE;
8420223c:	42 20       	r0 = Null + 1;

8420223e <Lc_get_terminal_info_12>:
}
8420223e:	f1 48       	popm <FP, r4, rLink>;
84202240:	d8 4c       	rts;

84202242 <$_set_cbuffer_functions>:
 */
void set_cbuffer_functions(SPLITTER_OP_DATA *splitter)
{
    patch_fn_shared(splitter);

    if ((splitter->data_format == AUDIO_DATA_FORMAT_FIXP) || (splitter->data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA))
84202242:	d1 88       	rMAC = M[r0 + 12];
84202244:	48 24       	Null = rMAC - 1;
84202246:	03 60       	if EQ jump (m) Lc_set_cbuffer_functions_3;

84202248 <Lc_set_cbuffer_functions_2>:
84202248:	c8 24       	Null = rMAC - 3;
8420224a:	56 62       	if NE jump (m) Lc_set_cbuffer_functions_7;

8420224c <Lc_set_cbuffer_functions_3>:
    {

        if (splitter->packing == UNPACKED)
8420224c:	91 81       	rMAC = MBS[r0 + 6];
8420224e:	26 62       	if NE jump (m) Lc_set_cbuffer_functions_5;

84202250 <Lc_set_cbuffer_functions_4>:
        {
            /* Just copy the audio*/
            splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_in_words;
84202250:	61 f2 15 73 	rMAC = Null + 318229;
84202254:	11 bf       	M[r0 + 112] = rMAC;
            splitter->cbuffer.data = cbuffer_calc_amount_data_in_words;
84202256:	63 f2 5b 73 	r1 = Null + 318299;
8420225a:	53 bf       	M[r0 + 116] = r1;

            splitter->cbuffer.packed_space = cbuffer_calc_amount_space_in_words;
8420225c:	91 bf       	M[r0 + 120] = rMAC;
            splitter->cbuffer.pack = cbuffer_copy;
8420225e:	61 f2 a5 79 	rMAC = Null + 318885;
84202262:	d1 bf       	M[r0 + 124] = rMAC;
            splitter->cbuffer.unpack = cbuffer_copy;
84202264:	21 f0 20 8e 	M[r0 + 128] = rMAC;
            splitter->cbuffer.discard = cbuffer_advance_read_ptr;
84202268:	61 f2 69 73 	rMAC = Null + 318313;
8420226c:	21 f0 21 8e 	M[r0 + 132] = rMAC;
#ifdef INSTALL_EXTERNAL_MEM
            splitter->cbuffer.sram_packed_space = audio_ext_buffer_amount_space;
84202270:	42 f0 11 f0 	rMAC = Null + 69215759;
84202274:	0f 4a 
84202276:	21 f0 22 8e 	M[r0 + 136] = rMAC;
            splitter->cbuffer.sram_pack = audio_ext_buffer_circ_write;
8420227a:	42 f0 11 f0 	rMAC = Null + 69215789;
8420227e:	2d 4a 
84202280:	21 f0 23 8e 	M[r0 + 140] = rMAC;
            splitter->cbuffer.sram_unpack = audio_ext_buffer_circ_read;
84202284:	42 f0 11 f0 	rMAC = Null + 69215773;
84202288:	1d 4a 
8420228a:	21 f0 24 8e 	M[r0 + 144] = rMAC;
            splitter->cbuffer.sram_discard = audio_ext_buffer_discard_data;
8420228e:	42 f0 11 f0 	rMAC = Null + 69215731;
84202292:	f3 49 
84202294:	21 f0 25 8e 	M[r0 + 148] = rMAC;
84202298:	2b 6e       	jump (m) Lc_set_cbuffer_functions_6;

8420229a <Lc_set_cbuffer_functions_5>:
            return;
        }
        else
        {
            /* Pack the audio. */
            splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_in_words;
8420229a:	61 f2 15 73 	rMAC = Null + 318229;
8420229e:	11 bf       	M[r0 + 112] = rMAC;
            splitter->cbuffer.data = cbuffer_calc_amount_data_in_words;
842022a0:	61 f2 5b 73 	rMAC = Null + 318299;
842022a4:	51 bf       	M[r0 + 116] = rMAC;

            splitter->cbuffer.packed_space = packed_space;
842022a6:	42 f0 11 f0 	rMAC = Null + 69215703;
842022aa:	d7 49 
842022ac:	91 bf       	M[r0 + 120] = rMAC;
            splitter->cbuffer.pack = pack_audio; /* cbuffer_copy_ex will pack the data when needed because it know about the usable octets.*/
842022ae:	42 f0 11 f0 	rMAC = Null + 69215629;
842022b2:	8d 49 
842022b4:	d1 bf       	M[r0 + 124] = rMAC;
            splitter->cbuffer.unpack = un_pack_audio; /* same applies for unpacking. */
842022b6:	42 f0 11 f0 	rMAC = Null + 69215545;
842022ba:	39 49 
842022bc:	21 f0 20 8e 	M[r0 + 128] = rMAC;
            splitter->cbuffer.discard = advance_packed;
842022c0:	42 f0 11 f0 	rMAC = Null + 69215689;
842022c4:	c9 49 
842022c6:	21 f0 21 8e 	M[r0 + 132] = rMAC;
#ifdef INSTALL_EXTERNAL_MEM
            splitter->cbuffer.sram_packed_space = pack_ext_buffer_amount_space;
842022ca:	42 f0 11 f0 	rMAC = Null + 69215745;
842022ce:	01 4a 
842022d0:	21 f0 22 8e 	M[r0 + 136] = rMAC;
            splitter->cbuffer.sram_pack = ext_buffer_pack;
842022d4:	01 f0 c9 6b 	rMAC = Null + 6089;
842022d8:	21 f0 23 8e 	M[r0 + 140] = rMAC;
            splitter->cbuffer.sram_unpack = ext_buffer_unpack;
842022dc:	01 f0 65 70 	rMAC = Null + 6245;
842022e0:	21 f0 24 8e 	M[r0 + 144] = rMAC;
            splitter->cbuffer.sram_discard = pack_ext_buffer_discard_data;
842022e4:	42 f0 11 f0 	rMAC = Null + 69215717;
842022e8:	e5 49 
842022ea:	21 f0 25 8e 	M[r0 + 148] = rMAC;

842022ee <Lc_set_cbuffer_functions_6>:
            splitter->cbuffer.sram_packed_space = audio_ext_buffer_amount_space;
            splitter->cbuffer.sram_pack = audio_ext_buffer_circ_write;
            splitter->cbuffer.sram_unpack = audio_ext_buffer_circ_read;
            splitter->cbuffer.sram_discard = audio_ext_buffer_discard_data;
#endif
            splitter->cbuffer.data_size = 4;
842022ee:	01 21       	rMAC = Null + 4;
842022f0:	21 f0 26 8e 	M[r0 + 152] = rMAC;
842022f4:	24 6e       	jump (m) Lc_set_cbuffer_functions_8;

842022f6 <Lc_set_cbuffer_functions_7>:
            return;
        }
    }
    /* Data will be packed and unpacked if the
     * usable octets are different. */
    splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_ex;
842022f6:	81 f2 61 63 	rMAC = Null + 332641;
842022fa:	11 bf       	M[r0 + 112] = rMAC;
    splitter->cbuffer.data = cbuffer_calc_amount_data_ex;
842022fc:	83 f2 f9 62 	r1 = Null + 332537;
84202300:	53 bf       	M[r0 + 116] = r1;

    splitter->cbuffer.packed_space = cbuffer_calc_amount_space_ex;
84202302:	91 bf       	M[r0 + 120] = rMAC;
    splitter->cbuffer.pack = cbuffer_copy_ex; /* cbuffer_copy_ex will pack the data when needed because it know about the usable octets.*/
84202304:	71 f1 e3 6a 	rMAC = Null + 194275;
84202308:	d1 bf       	M[r0 + 124] = rMAC;
    splitter->cbuffer.unpack = cbuffer_copy_ex; /* same applies for unpacking. */
8420230a:	21 f0 20 8e 	M[r0 + 128] = rMAC;
    splitter->cbuffer.discard = cbuffer_advance_read_ptr_ex;
8420230e:	81 f2 cd 68 	rMAC = Null + 333005;
84202312:	21 f0 21 8e 	M[r0 + 132] = rMAC;
#ifdef INSTALL_EXTERNAL_MEM
    splitter->cbuffer.sram_packed_space = ext_buffer_amount_space;
84202316:	01 f0 37 68 	rMAC = Null + 5175;
8420231a:	21 f0 22 8e 	M[r0 + 136] = rMAC;
    splitter->cbuffer.sram_pack = ext_buffer_circ_write;
8420231e:	01 f0 bd 6a 	rMAC = Null + 5821;
84202322:	21 f0 23 8e 	M[r0 + 140] = rMAC;
    splitter->cbuffer.sram_unpack = ext_buffer_circ_read;
84202326:	01 f0 45 69 	rMAC = Null + 5445;
8420232a:	21 f0 24 8e 	M[r0 + 144] = rMAC;
    splitter->cbuffer.sram_discard = ext_buffer_discard_data;
8420232e:	01 f0 61 6b 	rMAC = Null + 5985;
84202332:	21 f0 25 8e 	M[r0 + 148] = rMAC;
#endif
    splitter->cbuffer.data_size = 1;
84202336:	41 20       	rMAC = Null + 1;
84202338:	21 f0 26 8e 	M[r0 + 152] = rMAC;

8420233c <Lc_set_cbuffer_functions_8>:
8420233c:	d8 4c       	rts;

8420233e <$_create_channel>:

/**
 * Helper function which creates a channel.
 */
SPLITTER_CHANNEL_STRUC *create_channel(SPLITTER_OP_DATA *splitter, unsigned channel_id)
{
8420233e:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84202340:	16 00       	r4 = r0 + Null;
84202342:	19 09       	r7 = r1 + Null;

    SPLITTER_MSG("Splitter: Creating internal buffer.");

    patch_fn_shared(splitter);

    if(splitter->buffer_size == 0)
84202344:	b0 88       	Null = M[r4 + 8];
84202346:	0d 62       	if NE jump (m) Lc_create_channel_5;

84202348 <Lc_create_channel_2>:
    {
        SPLITTER_ERRORMSG("Splitter: Internal buffer size not set cannot connect!" );
84202348:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420234c:	08 24       	Null = rMAC - 0;
8420234e:	07 6c       	if LE jump (m) Lc_create_channel_4;

84202350 <Lc_create_channel_3>:
84202350:	55 f1 02 f0 	r0 = Null + 357569324;
84202354:	2c 63 
84202356:	ef fd f6 ff 	call (m) 0x10b0;
8420235a:	3b ea 

8420235c <Lc_create_channel_4>:
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
            /* Free up the channel structure.*/
            pdelete(channel);
            return NULL;
8420235c:	02 00       	r0 = Null + Null;
8420235e:	61 6e       	jump (m) Lc_create_channel_27;

84202360 <Lc_create_channel_5>:
        return NULL;
    }


    /* Allocate the channel buffer structure. */
    channel = xzpnew(SPLITTER_CHANNEL_STRUC);
84202360:	c3 20       	r1 = Null + 3;
84202362:	02 30       	r0 = Null + 32;
84202364:	ff fd 26 f0 	call (m) 0x6f8e;
84202368:	2b e1 
8420236a:	10 09       	r6 = r0 + Null;
    if (channel == NULL)
8420236c:	0c 62       	if NE jump (m) Lc_create_channel_8;

8420236e <Lc_create_channel_6>:
    {
        SPLITTER_ERRORMSG("Splitter: Unable to allocate CHANNEL_STRUC!" );
8420236e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202372:	08 24       	Null = rMAC - 0;
84202374:	f4 6d       	if LE jump (m) Lc_create_channel_4;

84202376 <Lc_create_channel_7>:
84202376:	55 f1 02 f0 	r0 = Null + 357569379;
8420237a:	63 63 
8420237c:	ef fd f6 ff 	call (m) 0x10b0;
84202380:	35 e9 
84202382:	ed 6f       	jump (m) Lc_create_channel_4;

84202384 <Lc_create_channel_8>:
        return NULL;
    }
    /* No need to allocate internal buffer when in cloning mode. */
    if (splitter->working_mode == CLONE_BUFFER)
84202384:	31 81       	rMAC = MBS[r4 + 4];
84202386:	24 60       	if EQ jump (m) Lc__loop0;

84202388 <Lc_create_channel_9>:
        add_channel_to_op_channels(splitter, channel, channel_id);
        return channel;
    }

    /* If the data is packed we only need half of the buffer. */
    if (splitter->packing == PACKED)
84202388:	b1 81       	rMAC = MBS[r4 + 6];
8420238a:	48 24       	Null = rMAC - 1;
8420238c:	27 62       	if NE jump (m) Lc_create_channel_19;

8420238e <Lc_create_channel_10>:
    {
        buffer_size = splitter->buffer_size/2;
8420238e:	b2 88       	r0 = M[r4 + 8];
84202390:	17 50       	r5 = r0 LSHIFT -1;
84202392:	25 6e       	jump (m) Lc_create_channel_20;

84202394 <Lc_create_channel_11>:
            pdelete(channel);
            return NULL;
        }
    }
    /* Set the channel's internal buffer. */
    channel->internal.buffer = internal_buff;
84202394:	31 d8       	rMAC = M[FP + 24];
84202396:	81 f0 05 8e 	M[r6 + 20] = rMAC;

    /* Transition to hold is instant. No need to have an output buffer. */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
8420239a:	b2 b2       	r0 = MBU[r4 + 26];
8420239c:	d2 50       	r0 = r0 LSHIFT -4;
8420239e:	91 c0       	rMAC = r0 AND 0x3;
842023a0:	17 60       	if EQ jump (m) Lc__loop0;

842023a2 <Lc_create_channel_12>:
842023a2:	84 20       	r2 = Null + 2;
    {
        unsigned i;
        for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842023a4:	01 00       	rMAC = Null + Null;
842023a6:	14 71       	r10 = Null + 2;
842023a8:	13 4c       	do (m) Lc__loop0;

842023aa <Lc_create_channel_13>:
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
842023aa:	0a 00       	r0 = rMAC + Null;
842023ac:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
    if (splitter->active_streams & channel_mask)
842023b0:	b3 b2       	r1 = MBU[r4 + 26];
842023b2:	9d 10       	r3 = r1 AND r0;
842023b4:	ad c0       	r3 = r3 AND 0x3;
842023b6:	0b 62       	if NE jump (m) Lc_create_channel_17;

842023b8 <Lc_create_channel_14>:
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
842023b8:	5d 50       	r3 = r1 LSHIFT -2;
842023ba:	ad 10       	r3 = r3 AND r0;
842023bc:	ad c0       	r3 = r3 AND 0x3;
842023be:	07 62       	if NE jump (m) Lc_create_channel_17;

842023c0 <Lc_create_channel_15>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
842023c0:	db 50       	r1 = r1 LSHIFT -4;
842023c2:	d2 10       	r0 = r0 AND r1;
842023c4:	92 c0       	r0 = r0 AND 0x3;
842023c6:	03 60       	if EQ jump (m) Lc_create_channel_17;

842023c8 <Lc_create_channel_16>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
842023c8:	32 2a       	r0 = r4 + 24;
842023ca:	54 ea       	MB[r0 + rMAC] = r2;

842023cc <Lc_create_channel_17>:
842023cc:	49 20       	rMAC = rMAC + 1;

842023ce <Lc__loop0>:
842023ce:	4c 08       	r2 = r7 + Null;
842023d0:	43 08       	r1 = r6 + Null;
842023d2:	32 00       	r0 = r4 + Null;
842023d4:	94 4e       	call (m) Lc_add_channel_to_op_channels_1;
    }
    /* No need to allocate internal buffer when in cloning mode. */
    if (splitter->working_mode == CLONE_BUFFER)
    {
        add_channel_to_op_channels(splitter, channel, channel_id);
        return channel;
842023d6:	42 08       	r0 = r6 + Null;
842023d8:	24 6e       	jump (m) Lc_create_channel_27;

842023da <Lc_create_channel_19>:
    {
        buffer_size = splitter->buffer_size/2;
    }
    else
    {
        buffer_size = splitter->buffer_size;
842023da:	b7 88       	r5 = M[r4 + 8];

842023dc <Lc_create_channel_20>:
    }

    /* Allocate the buffer. Metadata flag is set later. */
    if (create_internal_data_buffer(splitter, buffer_size, &internal_buff) == FALSE)
842023dc:	84 11       	r2 = FP + 24;
842023de:	3b 00       	r1 = r5 + Null;
842023e0:	32 00       	r0 = r4 + Null;
842023e2:	4c 4e       	call (m) Lc_create_internal_data_buffer_1;
842023e4:	10 04       	Null = r0 - Null;
842023e6:	10 62       	if NE jump (m) Lc_create_channel_24;

842023e8 <Lc_create_channel_21>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate internal buffer for the channel!" );
842023e8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842023ec:	08 24       	Null = rMAC - 0;
842023ee:	07 6c       	if LE jump (m) Lc_create_channel_23;

842023f0 <Lc_create_channel_22>:
842023f0:	55 f1 02 f0 	r0 = Null + 357569423;
842023f4:	8f 63 
842023f6:	ef fd f6 ff 	call (m) 0x10b0;
842023fa:	3b e5 

842023fc <Lc_create_channel_23>:
    {
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
            /* Free up the channel structure.*/
            pdelete(channel);
842023fc:	42 08       	r0 = r6 + Null;
842023fe:	ff fd 25 f0 	call (m) 0x6fbe;
84202402:	21 ee 
84202404:	ac 6f       	jump (m) Lc_create_channel_4;

84202406 <Lc_create_channel_24>:
        pdelete(channel);
        return NULL;
    }

    internal_metadata_buff = get_internal_metadata_buffer(splitter);
    if (internal_metadata_buff == NULL)
84202406:	71 a9       	rMAC = M[r4 + 84];
84202408:	c6 63       	if NE jump (m) Lc_create_channel_11;

8420240a <Lc_create_channel_25>:
    {
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
8420240a:	83 11       	r1 = FP + 24;
8420240c:	3c 00       	r2 = r5 + Null;
8420240e:	32 00       	r0 = r4 + Null;
84202410:	fc ff 29 e8 	call (m) $_create_internal_metadata;
84202414:	10 04       	Null = r0 - Null;
84202416:	bf 63       	if NE jump (m) Lc_create_channel_11;

84202418 <Lc_create_channel_26>:
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
84202418:	83 11       	r1 = FP + 24;
8420241a:	32 00       	r0 = r4 + Null;
8420241c:	62 4e       	call (m) Lc_destroy_internal_data_buffer_1;
8420241e:	ef 6f       	jump (m) Lc_create_channel_23;

84202420 <Lc_create_channel_27>:
        }
    }

    add_channel_to_op_channels(splitter, channel, channel_id);
    return channel;
}
84202420:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84202422:	d8 4c       	rts;

84202424 <$_get_channel_struct>:
/**
 * Returns the channel with the given ID. If the channel is not present it will create it.
 */
SPLITTER_CHANNEL_STRUC *get_channel_struct(SPLITTER_OP_DATA *splitter, unsigned channel_id)
{
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
84202424:	12 e8       	r0 = M[r0 + Null];
84202426:	02 6e       	jump (m) Lc_get_channel_struct_3;

84202428 <Lc_get_channel_struct_2>:
    {
        if (channel->id == channel_id)
        {
            return channel;
        }
        channel = channel->next;
84202428:	12 e8       	r0 = M[r0 + Null];

8420242a <Lc_get_channel_struct_3>:
SPLITTER_CHANNEL_STRUC *get_channel_struct(SPLITTER_OP_DATA *splitter, unsigned channel_id)
{
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;

    patch_fn_shared(splitter);
    while (channel != NULL)
8420242a:	10 04       	Null = r0 - Null;
8420242c:	05 60       	if EQ jump (m) Lc_get_channel_struct_6;

8420242e <Lc_get_channel_struct_4>:
    {
        if (channel->id == channel_id)
8420242e:	51 88       	rMAC = M[r0 + 4];
84202430:	c8 04       	Null = rMAC - r1;
84202432:	fb 63       	if NE jump (m) Lc_get_channel_struct_2;

84202434 <Lc_get_channel_struct_5>:
        {
            return channel;
84202434:	02 6e       	jump (m) Lc_get_channel_struct_7;

84202436 <Lc_get_channel_struct_6>:
        }
        channel = channel->next;
    }

    return NULL;
84202436:	02 00       	r0 = Null + Null;

84202438 <Lc_get_channel_struct_7>:
84202438:	d8 4c       	rts;

8420243a <$_delete_disconnected_channel>:

/**
 * Removes and deletes the disconnected channels.
 */
void delete_disconnected_channel(SPLITTER_OP_DATA *splitter)
{
8420243a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420243c:	16 00       	r4 = r0 + Null;
    SPLITTER_CHANNEL_STRUC **channel_ptr = &splitter->channel_list;
8420243e:	30 09       	r6 = r4 + Null;

84202440 <Lc_delete_disconnected_channel_2>:
    patch_fn_shared(splitter);

    while (*channel_ptr != NULL)
84202440:	87 f0 00 e8 	r5 = M[r6 + Null];
84202444:	19 60       	if EQ jump (m) Lc_delete_disconnected_channel_11;

84202446 <Lc_delete_disconnected_channel_3>:
    {
        bool channel_disconnected = TRUE;
        int i;

        /* Check if the channel has connection. */
        if ((*channel_ptr)->input_buffer != NULL)
84202446:	b9 88       	rMAC = M[r5 + 8];
84202448:	03 60       	if EQ jump (m) Lc_delete_disconnected_channel_5;

8420244a <Lc_delete_disconnected_channel_4>:
8420244a:	38 09       	r6 = r5 + Null;
8420244c:	fa 6f       	jump (m) Lc_delete_disconnected_channel_2;

8420244e <Lc_delete_disconnected_channel_5>:
8420244e:	3a 23       	r0 = r5 + 12;
        {
            channel_disconnected = FALSE;
        }
        else
        {
            for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84202450:	01 00       	rMAC = Null + Null;

84202452 <Lc_delete_disconnected_channel_6>:
            {
                if ((*channel_ptr)->output_buffer[i] != NULL)
84202452:	13 e8       	r1 = M[r0 + Null];
84202454:	fb 63       	if NE jump (m) Lc_delete_disconnected_channel_4;

84202456 <Lc_delete_disconnected_channel_7>:
        {
            channel_disconnected = FALSE;
        }
        else
        {
            for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84202456:	49 20       	rMAC = rMAC + 1;
84202458:	12 21       	r0 = r0 + 4;
8420245a:	88 24       	Null = rMAC - 2;
8420245c:	fb 69       	if LT jump (m) Lc_delete_disconnected_channel_6;

8420245e <Lc_delete_disconnected_channel_8>:
        if (channel_disconnected)
        {
            SPLITTER_CHANNEL_STRUC *temp = *channel_ptr;

            /* Remove it from the list, */
            *channel_ptr = temp->next;
8420245e:	39 e8       	rMAC = M[r5 + Null];
84202460:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            /* Delete the metadata if this is the last channel. */
            if (splitter->channel_list == NULL)
84202464:	31 e8       	rMAC = M[r4 + Null];
84202466:	04 62       	if NE jump (m) Lc_delete_disconnected_channel_10;

84202468 <Lc_delete_disconnected_channel_9>:
            {
                delete_internal_metadata(splitter);
84202468:	32 00       	r0 = r4 + Null;
8420246a:	fc ff 3d e9 	call (m) $_delete_internal_metadata;

8420246e <Lc_delete_disconnected_channel_10>:
            }
            /* Delete the channel. */
            delete_channel(splitter, temp);
8420246e:	3b 00       	r1 = r5 + Null;
84202470:	32 00       	r0 = r4 + Null;
84202472:	50 4e       	call (m) Lc_delete_channel_1;
84202474:	e6 6f       	jump (m) Lc_delete_disconnected_channel_2;

84202476 <Lc_delete_disconnected_channel_11>:
        else
        {
            channel_ptr = &((*channel_ptr)->next);
        }
    }
}
84202476:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202478:	d8 4c       	rts;

8420247a <Lc_create_internal_data_buffer_1>:

/**
 * Allocates the buffering buffer. The buffer can be internal or external (SRAM).
 */
static bool create_internal_data_buffer(SPLITTER_OP_DATA *splitter, unsigned buffer_size, data_buffer_t* internal_buff)
{
8420247a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420247c:	19 00       	rMAC = r1 + Null;
8420247e:	26 00       	r4 = r2 + Null;
    patch_fn_shared(splitter);

    if (splitter->location == INTERNAL && buffer_size > MAX_CIRCULAR_BUFFER_SIZE_WORDS)
84202480:	52 81       	r0 = MBS[r0 + 5];
84202482:	1b 62       	if NE jump (m) Lc_create_internal_data_buffer_8;

84202484 <Lc_create_internal_data_buffer_2>:
84202484:	03 f0 10 f3 	Null = rMAC - 65535;
84202488:	ff 3f 
8420248a:	09 f0 9d e0 	if LS jump (m) Lc_create_internal_data_buffer_6;

8420248e <Lc_create_internal_data_buffer_3>:
    {
        SPLITTER_ERRORMSG1("splitter: Cannot create a buffer bigger than 16383 words or 65535 octets in DM RAM."
                "\n  Current buffer size is %d. Note when packing the buffer size is halved!", buffer_size);
8420248e:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84202492:	10 24       	Null = r0 - 0;
84202494:	07 6c       	if LE jump (m) Lc_create_internal_data_buffer_5;

84202496 <Lc_create_internal_data_buffer_4>:
84202496:	55 f1 02 f0 	r0 = Null + 357569118;
8420249a:	5e 62 
8420249c:	ef fd f6 ff 	call (m) 0x10c2;
842024a0:	27 e1 

842024a2 <Lc_create_internal_data_buffer_5>:
        return FALSE;
842024a2:	02 00       	r0 = Null + Null;
842024a4:	1c 6e       	jump (m) Lc_create_internal_data_buffer_11;

842024a6 <Lc_create_internal_data_buffer_6>:
    }
    if (splitter->location == INTERNAL)
    {
        tCbuffer *buffer;
        buffer = cbuffer_create_with_malloc(buffer_size, BUF_DESC_SW_BUFFER);
842024a6:	03 00       	r1 = Null + Null;
842024a8:	0a 00       	r0 = rMAC + Null;
842024aa:	ff fd 8e f0 	call (m) 0x1421e;
842024ae:	35 eb 
        SPLITTER_MSG1("splitter: Internal cbuffer 0x%08x", buffer);
        internal_buff->dsp = buffer;
        if (buffer != NULL)
842024b0:	32 ee       	M[r4 + Null] = r0;
842024b2:	0a 60       	if EQ jump (m) Lc_create_internal_data_buffer_9;

842024b4 <Lc_create_internal_data_buffer_7>:
        {
            return TRUE;
842024b4:	42 20       	r0 = Null + 1;
842024b6:	13 6e       	jump (m) Lc_create_internal_data_buffer_11;

842024b8 <Lc_create_internal_data_buffer_8>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        EXT_BUFFER *buffer;
        buffer = ext_buffer_create(buffer_size, 0);
842024b8:	03 00       	r1 = Null + Null;
842024ba:	0a 00       	r0 = rMAC + Null;
842024bc:	ef fd f6 ff 	call (m) 0x125a;
842024c0:	3f ec 
        /* Allocate the memory on the external SRAM */
        SPLITTER_MSG1("splitter: Internal SRAM buffer 0x%08x", buffer);
        internal_buff->sram = buffer;
        if (buffer != NULL)
842024c2:	32 ee       	M[r4 + Null] = r0;
842024c4:	f8 63       	if NE jump (m) Lc_create_internal_data_buffer_7;

842024c6 <Lc_create_internal_data_buffer_9>:
        {
            return TRUE;
        }
#endif
    }
    SPLITTER_ERRORMSG("splitter: Could not create the internal buffer.");
842024c6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842024ca:	08 24       	Null = rMAC - 0;
842024cc:	eb 6d       	if LE jump (m) Lc_create_internal_data_buffer_5;

842024ce <Lc_create_internal_data_buffer_10>:
842024ce:	55 f1 02 f0 	r0 = Null + 357569276;
842024d2:	fc 62 
842024d4:	ef fd f5 ff 	call (m) 0x10b0;
842024d8:	3d ee 
842024da:	e4 6f       	jump (m) Lc_create_internal_data_buffer_5;

842024dc <Lc_create_internal_data_buffer_11>:
    return FALSE;
}
842024dc:	f1 48       	popm <FP, r4, rLink>;
842024de:	d8 4c       	rts;

842024e0 <Lc_destroy_internal_data_buffer_1>:

static void destroy_internal_data_buffer(SPLITTER_OP_DATA *splitter, data_buffer_t* internal_buff)
{
842024e0:	c8 1c       	pushm <FP(=SP), rLink>;

    patch_fn_shared(splitter);
    /* delete the internal metadata buffer allocated for the channel. */
    if (splitter->location == INTERNAL)
842024e2:	51 81       	rMAC = MBS[r0 + 5];
842024e4:	06 62       	if NE jump (m) Lc_destroy_internal_data_buffer_3;

842024e6 <Lc_destroy_internal_data_buffer_2>:
    {
        /* delete the internal buffer allocated for the channel. */
        cbuffer_destroy(internal_buff->dsp);
842024e6:	1a e8       	r0 = M[r1 + Null];
842024e8:	ff fd 8f f0 	call (m) 0x14302;
842024ec:	3b e0 
842024ee:	05 6e       	jump (m) Lc_destroy_internal_data_buffer_4;

842024f0 <Lc_destroy_internal_data_buffer_3>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        ext_buffer_destroy(internal_buff->sram);
842024f0:	1a e8       	r0 = M[r1 + Null];
842024f2:	ef fd f6 ff 	call (m) 0x12c4;
842024f6:	33 ee 

842024f8 <Lc_destroy_internal_data_buffer_4>:
#else
        PL_ASSERT(splitter->location == INTERNAL);
#endif
    }
}
842024f8:	c8 48       	popm <FP, rLink>;
842024fa:	d8 4c       	rts;

842024fc <Lc_add_channel_to_op_channels_1>:
 * Adds the given to the operators channels list.
 */
static void add_channel_to_op_channels(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned channel_id)
{
    /* Set the channel ID*/
    channel->id = channel_id;
842024fc:	5c 8e       	M[r1 + 4] = r2;

    /* Add the channel to the channel list. */
    if (splitter->channel_list == NULL)
842024fe:	11 e8       	rMAC = M[r0 + Null];
84202500:	03 62       	if NE jump (m) Lc_add_channel_to_op_channels_3;

84202502 <Lc_add_channel_to_op_channels_2>:
    {
        /* First Channel. */
        splitter->channel_list = channel;
84202502:	13 ee       	M[r0 + Null] = r1;
84202504:	06 6e       	jump (m) Lc_add_channel_to_op_channels_7;

84202506 <Lc_add_channel_to_op_channels_3>:
    }
    else
    {
        /* Add the channel to the end of the list. */
        SPLITTER_CHANNEL_STRUC *temp_channel = splitter->channel_list;
        while (temp_channel->next != NULL)
84202506:	0a e8       	r0 = M[rMAC + Null];
84202508:	03 60       	if EQ jump (m) Lc_add_channel_to_op_channels_6;

8420250a <Lc_add_channel_to_op_channels_5>:
        {
            temp_channel = temp_channel->next;
8420250a:	11 00       	rMAC = r0 + Null;
8420250c:	fd 6f       	jump (m) Lc_add_channel_to_op_channels_3;

8420250e <Lc_add_channel_to_op_channels_6>:
        }
        temp_channel->next = channel;
8420250e:	0b ee       	M[rMAC + Null] = r1;

84202510 <Lc_add_channel_to_op_channels_7>:
84202510:	d8 4c       	rts;

84202512 <Lc_delete_channel_1>:

/**
 * Deletes the channel.
 */
static void delete_channel(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel)
{
84202512:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202514:	1e 00       	r4 = r1 + Null;
    SPLITTER_MSG1("splitter: Deleting channel %d !", channel->id);
    patch_fn_shared(splitter);

    /* Select the correct interface */
    if (splitter->location == INTERNAL)
84202516:	51 81       	rMAC = MBS[r0 + 5];
84202518:	06 62       	if NE jump (m) Lc_delete_channel_3;

8420251a <Lc_delete_channel_2>:
    {
        SPLITTER_MSG1("Deleting internal buffer 0x%08x",channel->internal.buffer.dsp);
        cbuffer_destroy(channel->internal.buffer.dsp);
8420251a:	72 89       	r0 = M[r4 + 20];
8420251c:	ff fd 8e f0 	call (m) 0x14302;
84202520:	27 ef 
84202522:	05 6e       	jump (m) Lc_delete_channel_4;

84202524 <Lc_delete_channel_3>:
    }
    else
    {
#ifdef INSTALL_EXTERNAL_MEM
        SPLITTER_MSG1("Deleting internal sram buffer 0x%08x",channel->internal.buffer.sram);
        ext_buffer_destroy(channel->internal.buffer.sram);
84202524:	72 89       	r0 = M[r4 + 20];
84202526:	ef fd f6 ff 	call (m) 0x12c4;
8420252a:	3f ec 

8420252c <Lc_delete_channel_4>:
        PL_ASSERT(splitter->location == INTERNAL);
#endif
    }

    /* delete the channel structure */
    pdelete(channel);
8420252c:	32 00       	r0 = r4 + Null;
8420252e:	ff fd 25 f0 	call (m) 0x6fbe;
84202532:	31 e4 

84202534 <Lc_delete_channel_5>:
}
84202534:	f1 48       	popm <FP, r4, rLink>;
84202536:	d8 4c       	rts;

84202538 <$_un_pack_audio>:
84202538:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
    return num_octets>>1;
}


unsigned un_pack_audio(tCbuffer * dst, tCbuffer *src, unsigned num_samples)
{
8420253a:	10 09       	r6 = r0 + Null;
8420253c:	1f 00       	r5 = r1 + Null;
    unsigned num_octets, temp_data_space;


    num_octets = num_samples<<1;
8420253e:	26 54       	r4 = r2 LSHIFT 1;

    PL_ASSERT(cbuffer_get_usable_octets(src) == 4);
84202540:	3a 00       	r0 = r5 + Null;
84202542:	ff fd 8e f0 	call (m) 0x142ec;
84202546:	2b ed 
84202548:	10 25       	Null = r0 - 4;
8420254a:	07 60       	if EQ jump (m) Lc_un_pack_audio_3;

8420254c <Lc_un_pack_audio_2>:
8420254c:	43 39       	r1 = Null + 53;
8420254e:	02 f0 13 60 	r0 = Null + 4115;
84202552:	ff fd a3 f0 	call (m) 0x16bdc;
84202556:	2b e4 

84202558 <Lc_un_pack_audio_3>:
    temp_data_space = cbuffer_calc_amount_data_ex(src);
84202558:	3a 00       	r0 = r5 + Null;
8420255a:	ff fd 76 f2 	call (m) 0x512f8;
8420255e:	3f ec 
    if (temp_data_space < num_octets)
84202560:	90 05       	Null = r0 - r4;
84202562:	02 f0 87 e0 	if C jump (m) Lc_un_pack_audio_5;

84202566 <Lc_un_pack_audio_4>:
    {
        num_octets = temp_data_space;
84202566:	16 00       	r4 = r0 + Null;

84202568 <Lc_un_pack_audio_5>:
    }

    /* Convert from samples to octets. */
    temp_data_space = cbuffer_calc_amount_space_in_words(dst)<<1;
84202568:	42 08       	r0 = r6 + Null;
8420256a:	ff fd 5a f2 	call (m) 0x4db14;
8420256e:	2b ed 
84202570:	12 54       	r0 = r0 LSHIFT 1;
    if (temp_data_space < num_octets)
84202572:	90 05       	Null = r0 - r4;
84202574:	02 f0 87 e0 	if C jump (m) Lc_un_pack_audio_7;

84202578 <Lc_un_pack_audio_6>:
    {
        num_octets = temp_data_space;
84202578:	16 00       	r4 = r0 + Null;

8420257a <Lc_un_pack_audio_7>:
    }

    cbuffer_copy_packed_to_audio(dst, src, num_octets>>1);
8420257a:	34 50       	r2 = r4 LSHIFT -1;
8420257c:	3b 00       	r1 = r5 + Null;
8420257e:	42 08       	r0 = r6 + Null;
84202580:	ff fd 7d f2 	call (m) 0x51f9c;
84202584:	3d e0 

    /*we still need to return samples*/
    return num_octets>>1;
84202586:	32 50       	r0 = r4 LSHIFT -1;

84202588 <Lc_un_pack_audio_8>:
}
84202588:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420258a:	d8 4c       	rts;

8420258c <$_pack_audio>:

/****************************************************************************
Private Function Definitions
*/
unsigned pack_audio(tCbuffer * dst, tCbuffer *src, unsigned num_samples)
{
8420258c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420258e:	10 09       	r6 = r0 + Null;
84202590:	1f 00       	r5 = r1 + Null;
84202592:	26 00       	r4 = r2 + Null;
    unsigned num_octets, temp_data_space;

    temp_data_space = cbuffer_calc_amount_data_in_words(src);
84202594:	3a 00       	r0 = r5 + Null;
84202596:	ff fd 5a f2 	call (m) 0x4db5a;
8420259a:	25 ee 
    if (temp_data_space < num_samples)
8420259c:	90 05       	Null = r0 - r4;
8420259e:	02 f0 87 e0 	if C jump (m) Lc_pack_audio_3;

842025a2 <Lc_pack_audio_2>:
    {
        num_samples = temp_data_space;
842025a2:	16 00       	r4 = r0 + Null;

842025a4 <Lc_pack_audio_3>:
    }

    /* Because the audio is packed a sample only occupies 2 octets.*/
    num_octets = num_samples<<1;
842025a4:	36 54       	r4 = r4 LSHIFT 1;

    temp_data_space = cbuffer_calc_amount_space_ex(dst);
842025a6:	42 08       	r0 = r6 + Null;
842025a8:	ff fd 76 f2 	call (m) 0x51360;
842025ac:	39 ed 
    if (temp_data_space < num_octets)
842025ae:	90 05       	Null = r0 - r4;
842025b0:	02 f0 87 e0 	if C jump (m) Lc_pack_audio_5;

842025b4 <Lc_pack_audio_4>:
    {
        num_octets = temp_data_space;
842025b4:	16 00       	r4 = r0 + Null;

842025b6 <Lc_pack_audio_5>:
    }

    /* Call splitters packing function. */
    cbuffer_copy_audio_to_packed(dst, src, num_octets>>1);
842025b6:	34 50       	r2 = r4 LSHIFT -1;
842025b8:	3b 00       	r1 = r5 + Null;
842025ba:	42 08       	r0 = r6 + Null;
842025bc:	ff fd 7c f2 	call (m) 0x51ed0;
842025c0:	35 e8 

    /*we still need to return samples*/
    return num_octets>>1;
842025c2:	32 50       	r0 = r4 LSHIFT -1;

842025c4 <Lc_pack_audio_6>:
}
842025c4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842025c6:	d8 4c       	rts;

842025c8 <$_advance_packed>:
    /*we still need to return samples*/
    return num_octets>>1;
}

void advance_packed(tCbuffer *cbuffer, unsigned num_samples)
{
842025c8:	c8 1c       	pushm <FP(=SP), rLink>;

    unsigned num_octets;
    num_octets = num_samples<<1;
842025ca:	1b 54       	r1 = r1 LSHIFT 1;
    cbuffer_advance_read_ptr_ex(cbuffer, num_octets);
842025cc:	ff fd 77 f2 	call (m) 0x514cc;
842025d0:	21 e8 

842025d2 <Lc_advance_packed_2>:
}
842025d2:	c8 48       	popm <FP, rLink>;
842025d4:	d8 4c       	rts;

842025d6 <$_packed_space>:

/**
 * Function returns the number of samples which can be copied to the internal buffer.
 */
unsigned packed_space(tCbuffer *cbuffer)
{
842025d6:	c8 1c       	pushm <FP(=SP), rLink>;
    return cbuffer_calc_amount_space_ex(cbuffer) >>1;
842025d8:	ff fd 76 f2 	call (m) 0x51360;
842025dc:	29 ec 
842025de:	12 50       	r0 = r0 LSHIFT -1;

842025e0 <Lc_packed_space_2>:
}
842025e0:	c8 48       	popm <FP, rLink>;
842025e2:	d8 4c       	rts;

842025e4 <$_pack_ext_buffer_discard_data>:


#ifdef INSTALL_EXTERNAL_MEM
void pack_ext_buffer_discard_data(EXT_BUFFER * eb, unsigned int num_samples)
{
842025e4:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<1;
842025e6:	1b 54       	r1 = r1 LSHIFT 1;
    ext_buffer_discard_data(eb, num_octets);
842025e8:	ef fd f8 ff 	call (m) 0x1760;
842025ec:	39 eb 

842025ee <Lc_pack_ext_buffer_discard_data_2>:
}
842025ee:	c8 48       	popm <FP, rLink>;
842025f0:	d8 4c       	rts;

842025f2 <$_audio_ext_buffer_discard_data>:


void audio_ext_buffer_discard_data(EXT_BUFFER * eb, unsigned int num_samples)
{
842025f2:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
842025f4:	5b 54       	r1 = r1 LSHIFT 2;
    ext_buffer_discard_data(eb, num_octets);
842025f6:	ef fd f8 ff 	call (m) 0x1760;
842025fa:	2b eb 

842025fc <Lc_audio_ext_buffer_discard_data_2>:
}
842025fc:	c8 48       	popm <FP, rLink>;
842025fe:	d8 4c       	rts;

84202600 <$_pack_ext_buffer_amount_space>:

unsigned int pack_ext_buffer_amount_space(EXT_BUFFER * eb)
{
84202600:	c8 1c       	pushm <FP(=SP), rLink>;
    return ext_buffer_amount_space(eb)>>1;
84202602:	ef fd f7 ff 	call (m) 0x1436;
84202606:	35 e1 
84202608:	12 50       	r0 = r0 LSHIFT -1;

8420260a <Lc_pack_ext_buffer_amount_space_2>:

}
8420260a:	c8 48       	popm <FP, rLink>;
8420260c:	d8 4c       	rts;

8420260e <$_audio_ext_buffer_amount_space>:

unsigned int audio_ext_buffer_amount_space(EXT_BUFFER * eb)
{
8420260e:	c8 1c       	pushm <FP(=SP), rLink>;
    return ext_buffer_amount_space(eb)>>2;
84202610:	ef fd f7 ff 	call (m) 0x1436;
84202614:	27 e1 
84202616:	52 50       	r0 = r0 LSHIFT -2;

84202618 <Lc_audio_ext_buffer_amount_space_2>:

}
84202618:	c8 48       	popm <FP, rLink>;
8420261a:	d8 4c       	rts;

8420261c <$_audio_ext_buffer_circ_read>:


unsigned int audio_ext_buffer_circ_read(tCbuffer * dest, EXT_BUFFER * ext_src, unsigned int num_samples)
{
8420261c:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
8420261e:	64 54       	r2 = r2 LSHIFT 2;

    return ext_buffer_circ_read(dest, ext_src, num_octets)>>2;
84202620:	ef fd f7 ff 	call (m) 0x1544;
84202624:	25 e9 
84202626:	52 50       	r0 = r0 LSHIFT -2;

84202628 <Lc_audio_ext_buffer_circ_read_2>:
}
84202628:	c8 48       	popm <FP, rLink>;
8420262a:	d8 4c       	rts;

8420262c <$_audio_ext_buffer_circ_write>:

unsigned int audio_ext_buffer_circ_write(EXT_BUFFER * ext_dest, tCbuffer * src, unsigned int num_samples)
{
8420262c:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
8420262e:	64 54       	r2 = r2 LSHIFT 2;

    return ext_buffer_circ_write(ext_dest, src, num_octets)>>2;
84202630:	ef fd f8 ff 	call (m) 0x16bc;
84202634:	2d e4 
84202636:	52 50       	r0 = r0 LSHIFT -2;

84202638 <Lc_audio_ext_buffer_circ_write_2>:
}
84202638:	c8 48       	popm <FP, rLink>;
8420263a:	d8 4c       	rts;

8420263c <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_splitter_cap_data;
8420263c:	01 f0 02 f3 	r0 = Null + 1441792;
84202640:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84202642:	00 f0 4c 5a 	Null = Null + 3660;
