
/home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/tools/KCSMaker/out/14612/maor_rom_release/download/debugbin/download_va_graph_manager.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <Lc_vagm_create_1>:
 * response
 */

static bool vagm_create(OPERATOR_DATA *op_data, void *message_data,
                          unsigned *response_id, void **response_data)
{
84200000:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200002:	16 00       	r4 = r0 + Null;
84200004:	28 09       	r6 = r3 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200006:	ff fd 04 f0 	call (m) 0x8ea;
8420000a:	25 e7 
8420000c:	17 00       	r5 = r0 + Null;
                          unsigned *response_id, void **response_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create_lite(op_data, response_data))
8420000e:	43 08       	r1 = r6 + Null;
84200010:	32 00       	r0 = r4 + Null;
84200012:	ff fd 04 f0 	call (m) 0x850;
84200016:	3f e1 
84200018:	10 04       	Null = r0 - Null;
8420001a:	03 62       	if NE jump (m) Lc_vagm_create_3;

8420001c <Lc_vagm_create_2>:
    {
        return FALSE;
8420001c:	02 00       	r0 = Null + Null;
8420001e:	04 6e       	jump (m) Lc_vagm_create_4;

84200020 <Lc_vagm_create_3>:
    }
    /* (By default 32MHz is supported) */
    ext_data->graph_load = OPMSG_VA_GM_LOAD_LOW;
84200020:	c1 20       	rMAC = Null + 3;
84200022:	39 aa       	MB[r5 + 16] = rMAC;

    return TRUE;
84200024:	42 20       	r0 = Null + 1;

84200026 <Lc_vagm_create_4>:
}
84200026:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200028:	d8 4c       	rts;

8420002a <Lc_vagm_init_1>:
 * \brief Initialize the capability specific data.
 *
 * \param op_data Pointer to the operator instance data.
 */
static void vagm_init(OPERATOR_DATA *op_data)
{
8420002a:	c8 1c       	pushm <FP(=SP), rLink>;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420002c:	ff fd 04 f0 	call (m) 0x8ea;
84200030:	3f e5 
 */
static void vagm_init(OPERATOR_DATA *op_data)
{
    VAGM_OP_DATA * ext_data = get_instance_data(op_data);

    ext_data->wait_for_qva = FALSE;
84200032:	90 8f       	M[r0 + 24] = Null;
    ext_data->wait_for_vad = FALSE;
84200034:	50 8f       	M[r0 + 20] = Null;
    ext_data->aov_operation = NO_OPERATION;
84200036:	20 f0 20 8a 	MB[r0 + 32] = Null;
    ext_data->splitter_deactivate_to_buffer = FALSE;
8420003a:	d0 8f       	M[r0 + 28] = Null;
    ext_data->voice_activity = FALSE;
8420003c:	50 9e       	M[r0 + 36] = Null;
    ext_data->lp_active = FALSE;
8420003e:	90 9e       	M[r0 + 40] = Null;
    ext_data->delegated = FALSE;
84200040:	10 ae       	M[r0 + 64] = Null;
#ifdef GM_SENDS_COMMANDS
    ext_data->issued_cmd = COMMAND_NONE;
#endif
    if (ext_data->is_configured)
84200042:	10 99       	Null = M[r0 + 48];
84200044:	04 60       	if EQ jump (m) Lc_vagm_init_3;

84200046 <Lc_vagm_init_2>:
    {
        ext_data->buffer_time_offset_ms = ext_data->buffer_time_offset_ms_initval;
84200046:	51 99       	rMAC = M[r0 + 52];
84200048:	d1 9e       	M[r0 + 44] = rMAC;
8420004a:	04 6e       	jump (m) Lc_vagm_init_4;

8420004c <Lc_vagm_init_3>:
    }
    else
    {
        ext_data->buffer_time_offset_ms = BUFFER_TIME_OFFSET_MS;
8420004c:	01 f0 f4 41 	rMAC = Null + 500;
84200050:	d1 9e       	M[r0 + 44] = rMAC;

84200052 <Lc_vagm_init_4>:
    }
    L3_DBG_MSG1("VA_GM: vagm_init: buffer_time_offset_ms %d", ext_data->buffer_time_offset_ms);
84200052:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200056:	c8 24       	Null = rMAC - 3;
84200058:	08 68       	if LT jump (m) Lc_vagm_init_6;

8420005a <Lc_vagm_init_5>:
8420005a:	d3 98       	r1 = M[r0 + 44];
8420005c:	55 f1 02 f0 	r0 = Null + 357564416;
84200060:	00 40 
84200062:	ff fd 08 f0 	call (m) 0x10c2;
84200066:	21 e3 

84200068 <Lc_vagm_init_6>:
}
84200068:	c8 48       	popm <FP, rLink>;
8420006a:	d8 4c       	rts;

8420006c <Lc_vagm_process_data_1>:
8420006c:	d8 4c       	rts;

8420006e <Lc_vagm_connect_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420006e:	c8 1c       	pushm <FP(=SP), rLink>;
84200070:	2c 00       	r2 = r3 + Null;
    return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200072:	03 f0 00 60 	r1 = Null + 4096;
84200076:	ff fd 04 f0 	call (m) 0x8c0;
8420007a:	2b e2 

8420007c <Lc_vagm_connect_2>:
}
8420007c:	c8 48       	popm <FP, rLink>;
8420007e:	d8 4c       	rts;

84200080 <Lc_vagm_disconnect_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200080:	c8 1c       	pushm <FP(=SP), rLink>;
84200082:	2c 00       	r2 = r3 + Null;
    return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200084:	03 f0 00 60 	r1 = Null + 4096;
84200088:	ff fd 04 f0 	call (m) 0x8c0;
8420008c:	39 e1 

8420008e <Lc_vagm_disconnect_2>:
}
8420008e:	c8 48       	popm <FP, rLink>;
84200090:	d8 4c       	rts;

84200092 <Lc_vagm_buffer_details_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200092:	c8 1c       	pushm <FP(=SP), rLink>;
84200094:	2b 00       	r1 = r3 + Null;
    bool result = base_op_buffer_details_lite(op_data, response_data);
84200096:	ff fd 03 f0 	call (m) 0x842;
8420009a:	2d ed 

8420009c <Lc_vagm_buffer_details_2>:

    return result;
8420009c:	c8 48       	popm <FP, rLink>;
8420009e:	d8 4c       	rts;

842000a0 <Lc_vagm_get_data_format_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000a0:	c8 1c       	pushm <FP(=SP), rLink>;
842000a2:	2c 00       	r2 = r3 + Null;
    return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000a4:	03 f0 00 60 	r1 = Null + 4096;
842000a8:	ff fd 04 f0 	call (m) 0x8c0;
842000ac:	39 e0 

842000ae <Lc_vagm_get_data_format_2>:
}
842000ae:	c8 48       	popm <FP, rLink>;
842000b0:	d8 4c       	rts;

842000b2 <Lc_vagm_set_trigger_mode_clock_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_set_trigger_mode_clock(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842000b2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842000b4:	16 00       	r4 = r0 + Null;
842000b6:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842000b8:	ff fd 04 f0 	call (m) 0x8ea;
842000bc:	33 e1 
 */
static bool vagm_set_trigger_mode_clock(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    unsigned value = OPMSG_FIELD_GET(message_data, OPMSG_VA_GM_SET_TRIGGER_MODE_CLOCK, ACTIVE_MODE_CLOCK);
842000be:	f9 88       	rMAC = M[r5 + 12];
    if (value < AOV_IF_CPU_CLK_EXT_LP_CLOCK || value > AOV_IF_CPU_CLK_TURBO_PLUS)
842000c0:	89 c6       	rMAC = rMAC AND 0xffff;
842000c2:	04 60       	if EQ jump (m) Lc_vagm_set_trigger_mode_clock_3;

842000c4 <Lc_vagm_set_trigger_mode_clock_2>:
842000c4:	08 26       	Null = rMAC - 8;
842000c6:	09 f0 89 e0 	if LS jump (m) Lc_vagm_set_trigger_mode_clock_4;

842000ca <Lc_vagm_set_trigger_mode_clock_3>:
    {
        return FALSE;
842000ca:	02 00       	r0 = Null + Null;
842000cc:	14 6e       	jump (m) Lc_vagm_set_trigger_mode_clock_11;

842000ce <Lc_vagm_set_trigger_mode_clock_4>:
    }
    ext_data->active_mode_clk_val = value;
842000ce:	91 9f       	M[r0 + 56] = rMAC;

    value = OPMSG_FIELD_GET(message_data, OPMSG_VA_GM_SET_TRIGGER_MODE_CLOCK, TRIGGER_MODE_CLOCK);
842000d0:	39 89       	rMAC = M[r5 + 16];
    if (value < AOV_IF_CPU_CLK_EXT_LP_CLOCK || value > AOV_IF_CPU_CLK_TURBO_PLUS)
842000d2:	89 c6       	rMAC = rMAC AND 0xffff;
842000d4:	fb 61       	if EQ jump (m) Lc_vagm_set_trigger_mode_clock_3;

842000d6 <Lc_vagm_set_trigger_mode_clock_5>:
842000d6:	08 26       	Null = rMAC - 8;
842000d8:	f8 ff f3 ef 	if HI jump (m) Lc_vagm_set_trigger_mode_clock_3;

842000dc <Lc_vagm_set_trigger_mode_clock_6>:
    {
        return FALSE;
    }
    ext_data->trigger_mode_clk_val = value;
842000dc:	d1 9f       	M[r0 + 60] = rMAC;
    /* Graph manager should change clock when we are in active mode(not in low power) and
     * operators are delegated to itself. We need to change clock on reception of message
     * as there may be scenario when VA GM has been delegated and prompt is played. To play
     * prompt apps may boost clock for chain creation and message may be sent to VA GM.
     */
    if(!ext_data->voice_activity && ext_data->delegated && !ext_data->lp_active)
842000de:	50 98       	Null = M[r0 + 36];
842000e0:	09 62       	if NE jump (m) Lc_vagm_set_trigger_mode_clock_10;

842000e2 <Lc_vagm_set_trigger_mode_clock_7>:
842000e2:	10 a8       	Null = M[r0 + 64];
842000e4:	07 60       	if EQ jump (m) Lc_vagm_set_trigger_mode_clock_10;

842000e6 <Lc_vagm_set_trigger_mode_clock_8>:
842000e6:	90 98       	Null = M[r0 + 40];
842000e8:	05 62       	if NE jump (m) Lc_vagm_set_trigger_mode_clock_10;

842000ea <Lc_vagm_set_trigger_mode_clock_9>:
    {
        manage_am_clock(op_data, FALSE);
842000ea:	03 00       	r1 = Null + Null;
842000ec:	32 00       	r0 = r4 + Null;
842000ee:	03 f0 23 e3 	call (m) Lc_manage_am_clock_1;

842000f2 <Lc_vagm_set_trigger_mode_clock_10>:
    }
    return TRUE;
842000f2:	42 20       	r0 = Null + 1;

842000f4 <Lc_vagm_set_trigger_mode_clock_11>:
}
842000f4:	f2 48       	popm <FP, r4, r5, rLink>;
842000f6:	d8 4c       	rts;

842000f8 <Lc_vagm_message_response_handler_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_message_response_handler(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842000f8:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842000fa:	10 09       	r6 = r0 + Null;
842000fc:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842000fe:	ff fd 03 f0 	call (m) 0x8ea;
84200102:	2d ef 
84200104:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_message_response_handler(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    OPERATOR_ID src_op_id = OPMSG_FIELD_GET(message_data, OPMSG_OP_CLIENT_MESSAGE_RESPONSE, SOURCE_OP_ID);
84200106:	f9 88       	rMAC = M[r5 + 12];
84200108:	8b c6       	r1 = rMAC AND 0xffff;
    STATUS_KYMERA status = (STATUS_KYMERA) OPMSG_FIELD_GET(message_data, OPMSG_OP_CLIENT_MESSAGE_RESPONSE, STATUS);
8420010a:	39 89       	rMAC = M[r5 + 16];

    if (status == STATUS_OK && src_op_id != 0)
8420010c:	09 0c       	rMAC = SE16 rMAC;
8420010e:	4a 62       	if NE jump (m) Lc_vagm_message_response_handler_20;

84200110 <Lc_vagm_message_response_handler_2>:
84200110:	18 04       	Null = r1 - Null;
84200112:	48 60       	if EQ jump (m) Lc_vagm_message_response_handler_20;

84200114 <Lc_vagm_message_response_handler_3>:
    {
        if (src_op_id == ext_data->vad_op_id)
84200114:	6f f3 80 c2 	Null = r1 - M[r4];
84200118:	0d 62       	if NE jump (m) Lc_vagm_message_response_handler_7;

8420011a <Lc_vagm_message_response_handler_4>:
        {
            L3_DBG_MSG("VA_GM: response from VAD");
8420011a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420011e:	c8 24       	Null = rMAC - 3;
84200120:	07 68       	if LT jump (m) Lc_vagm_message_response_handler_6;

84200122 <Lc_vagm_message_response_handler_5>:
84200122:	55 f1 02 f0 	r0 = Null + 357564769;
84200126:	61 41 
84200128:	ff fd 07 f0 	call (m) 0x10b0;
8420012c:	29 ec 

8420012e <Lc_vagm_message_response_handler_6>:
            ext_data->wait_for_vad = FALSE;
8420012e:	70 8f       	M[r4 + 20] = Null;
84200130:	3e 6e       	jump (m) Lc_vagm_message_response_handler_21;

84200132 <Lc_vagm_message_response_handler_7>:
        }
        else if (src_op_id == ext_data->qva_op_id)
84200132:	71 88       	rMAC = M[r4 + 4];
84200134:	58 04       	Null = r1 - rMAC;
84200136:	0d 62       	if NE jump (m) Lc_vagm_message_response_handler_11;

84200138 <Lc_vagm_message_response_handler_8>:
        {
            L3_DBG_MSG("VA_GM: response from QVA");
84200138:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420013c:	c8 24       	Null = rMAC - 3;
8420013e:	07 68       	if LT jump (m) Lc_vagm_message_response_handler_10;

84200140 <Lc_vagm_message_response_handler_9>:
84200140:	55 f1 02 f0 	r0 = Null + 357564794;
84200144:	7a 41 
84200146:	ff fd 07 f0 	call (m) 0x10b0;
8420014a:	2b eb 

8420014c <Lc_vagm_message_response_handler_10>:
            ext_data->wait_for_qva = FALSE;
8420014c:	b0 8f       	M[r4 + 24] = Null;
8420014e:	2f 6e       	jump (m) Lc_vagm_message_response_handler_21;

84200150 <Lc_vagm_message_response_handler_11>:
        }
        else if (src_op_id == ext_data->cvc_op_id)
84200150:	b1 88       	rMAC = M[r4 + 8];
84200152:	58 04       	Null = r1 - rMAC;
84200154:	0c 62       	if NE jump (m) Lc_vagm_message_response_handler_14;

84200156 <Lc_vagm_message_response_handler_12>:
        {
            L3_DBG_MSG("VA_GM: response from CVC");
84200156:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420015a:	c8 24       	Null = rMAC - 3;
8420015c:	28 68       	if LT jump (m) Lc_vagm_message_response_handler_21;

8420015e <Lc_vagm_message_response_handler_13>:
8420015e:	55 f1 02 f0 	r0 = Null + 357564819;
84200162:	93 41 
84200164:	ff fd 07 f0 	call (m) 0x10b0;
84200168:	2d ea 
8420016a:	21 6e       	jump (m) Lc_vagm_message_response_handler_21;

8420016c <Lc_vagm_message_response_handler_14>:
            /* We don't need to wait for CVC response. */
        }
        else if (src_op_id == ext_data->splitter_op_id)
8420016c:	f1 88       	rMAC = M[r4 + 12];
8420016e:	58 04       	Null = r1 - rMAC;
84200170:	13 62       	if NE jump (m) Lc_vagm_message_response_handler_19;

84200172 <Lc_vagm_message_response_handler_15>:
        {
            L3_DBG_MSG("VA_GM: response from Splitter");
84200172:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200176:	c8 24       	Null = rMAC - 3;
84200178:	07 68       	if LT jump (m) Lc_vagm_message_response_handler_17;

8420017a <Lc_vagm_message_response_handler_16>:
8420017a:	55 f1 02 f0 	r0 = Null + 357564844;
8420017e:	ac 41 
84200180:	ff fd 07 f0 	call (m) 0x10b0;
84200184:	31 e9 

84200186 <Lc_vagm_message_response_handler_17>:
            if (ext_data->splitter_deactivate_to_buffer)
84200186:	f0 89       	Null = M[r4 + 28];
84200188:	12 60       	if EQ jump (m) Lc_vagm_message_response_handler_21;

8420018a <Lc_vagm_message_response_handler_18>:
            {
                configure_splitter(op_data, OPMSG_SPLITTER_ID_BUFFER_STREAMS);
8420018a:	43 21       	r1 = Null + 5;
8420018c:	42 08       	r0 = r6 + Null;
8420018e:	03 f0 31 ea 	call (m) Lc_configure_splitter_1;
                ext_data->splitter_deactivate_to_buffer = FALSE;
84200192:	f0 8f       	M[r4 + 28] = Null;
84200194:	0c 6e       	jump (m) Lc_vagm_message_response_handler_21;

84200196 <Lc_vagm_message_response_handler_19>:
            }
        }
        else
        {
            /* Operator id is unrecognized */
            fault_diatribe(FAULT_AUDIO_VAGM_UNRECOGNIZED_OPERATOR, src_op_id);
84200196:	02 f0 65 40 	r0 = Null + 101;
8420019a:	ff fd b3 f0 	call (m) 0x16870;
8420019e:	37 e6 
842001a0:	06 6e       	jump (m) Lc_vagm_message_response_handler_21;

842001a2 <Lc_vagm_message_response_handler_20>:
        }
    }
    else
    {
        /* Operation configuration went wrong */
        fault_diatribe(FAULT_AUDIO_VAGM_ERROR_MESSAGE, src_op_id);
842001a2:	02 f0 66 40 	r0 = Null + 102;
842001a6:	ff fd b3 f0 	call (m) 0x16870;
842001aa:	2b e6 

842001ac <Lc_vagm_message_response_handler_21>:
    }
    return TRUE;
842001ac:	42 20       	r0 = Null + 1;

842001ae <Lc_vagm_message_response_handler_22>:
}
842001ae:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842001b0:	d8 4c       	rts;

842001b2 <Lc_vagm_delegated_ops_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_delegated_ops(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842001b2:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842001b4:	10 09       	r6 = r0 + Null;
842001b6:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842001b8:	ff fd 03 f0 	call (m) 0x8ea;
842001bc:	33 e9 
842001be:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_delegated_ops(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg_len = OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data);
842001c0:	79 f0 01 88 	r7 = M[r5 + 4];
    /* If message with no payload is received then it must be sent due
     * to delegation being cancelled */
    if (msg_len == OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET && ext_data->delegated)
842001c4:	90 f0 01 24 	Null = r7 - 1;
842001c8:	05 62       	if NE jump (m) Lc_vagm_delegated_ops_4;

842001ca <Lc_vagm_delegated_ops_2>:
842001ca:	30 a8       	Null = M[r4 + 64];
842001cc:	07 60       	if EQ jump (m) Lc_vagm_delegated_ops_5;

842001ce <Lc_vagm_delegated_ops_3>:
    {
        ext_data->delegated = FALSE;
842001ce:	30 ae       	M[r4 + 64] = Null;
842001d0:	4a 6e       	jump (m) Lc_vagm_delegated_ops_18;

842001d2 <Lc_vagm_delegated_ops_4>:
        return TRUE;
    }

    if (msg_len < OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MIN_DELEGATED_OPERATORS)
842001d2:	90 f0 02 24 	Null = r7 - 2;
842001d6:	02 f0 89 e0 	if C jump (m) Lc_vagm_delegated_ops_6;

842001da <Lc_vagm_delegated_ops_5>:
    {
        return FALSE;
842001da:	02 00       	r0 = Null + Null;
842001dc:	45 6e       	jump (m) Lc_vagm_delegated_ops_19;

842001de <Lc_vagm_delegated_ops_6>:
    }
    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MAX_DELEGATED_OPERATORS)
842001de:	90 f0 05 24 	Null = r7 - 5;
842001e2:	f8 ff f9 ef 	if HI jump (m) Lc_vagm_delegated_ops_5;

842001e6 <Lc_vagm_delegated_ops_7>:
    {
        return FALSE;
    }

    vagm_init(op_data);
842001e6:	42 08       	r0 = r6 + Null;
842001e8:	21 4f       	call (m) Lc_vagm_init_1;

    L3_DBG_MSG("VA_GM: delegated operators");
842001ea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842001ee:	c8 24       	Null = rMAC - 3;
842001f0:	07 68       	if LT jump (m) Lc_vagm_delegated_ops_9;

842001f2 <Lc_vagm_delegated_ops_8>:
842001f2:	55 f1 02 f0 	r0 = Null + 357564576;
842001f6:	a0 40 
842001f8:	ff fd 07 f0 	call (m) 0x10b0;
842001fc:	39 e5 

842001fe <Lc_vagm_delegated_ops_9>:

    /* Application client will send the VAD operator in the first position. */
    ext_data->vad_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 0);
842001fe:	f9 88       	rMAC = M[r5 + 12];
84200200:	89 c6       	rMAC = rMAC AND 0xffff;
84200202:	31 ee       	M[r4 + Null] = rMAC;
    /* Application client will send the VAD operator in the second position. */
    ext_data->qva_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 1);
84200204:	39 89       	rMAC = M[r5 + 16];
84200206:	89 c6       	rMAC = rMAC AND 0xffff;
84200208:	71 8e       	M[r4 + 4] = rMAC;

    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MIN_DELEGATED_OPERATORS)
8420020a:	90 f0 02 24 	Null = r7 - 2;
8420020e:	09 f0 99 e0 	if LS jump (m) Lc_vagm_delegated_ops_12;

84200212 <Lc_vagm_delegated_ops_10>:
    {
        /* Application client will send the CVC operator in the third position. */
        ext_data->cvc_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 2);
84200212:	79 89       	rMAC = M[r5 + 20];
84200214:	89 c6       	rMAC = rMAC AND 0xffff;
84200216:	b1 8e       	M[r4 + 8] = rMAC;
    }
    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MIN_DELEGATED_OPERATORS + 1)
84200218:	90 f0 03 24 	Null = r7 - 3;
8420021c:	09 f0 8b e0 	if LS jump (m) Lc_vagm_delegated_ops_12;

84200220 <Lc_vagm_delegated_ops_11>:
    {
        /* Application client will send the Splitter operator in the fourth position. */
        ext_data->splitter_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 3);
84200220:	b9 89       	rMAC = M[r5 + 24];
84200222:	89 c6       	rMAC = rMAC AND 0xffff;
84200224:	f1 8e       	M[r4 + 12] = rMAC;

84200226 <Lc_vagm_delegated_ops_12>:
    }

    configure_vad(op_data, OPMSG_VAD_MODE_FULL_PROC);
84200226:	43 20       	r1 = Null + 1;
84200228:	42 08       	r0 = r6 + Null;
8420022a:	02 f0 37 ef 	call (m) Lc_configure_vad_1;

    if (ext_data->splitter_op_id != 0)
8420022e:	f0 88       	Null = M[r4 + 12];
84200230:	0c 60       	if EQ jump (m) Lc_vagm_delegated_ops_14;

84200232 <Lc_vagm_delegated_ops_13>:
    {
        configure_qva(op_data, OPMSG_QVA_MODE_FULL_PROC);
84200232:	43 20       	r1 = Null + 1;
84200234:	42 08       	r0 = r6 + Null;
84200236:	03 f0 27 e1 	call (m) Lc_configure_qva_1;
        configure_splitter(op_data, OPMSG_SPLITTER_ID_DEACTIVATE_STREAMS);
8420023a:	03 21       	r1 = Null + 4;
8420023c:	42 08       	r0 = r6 + Null;
8420023e:	03 f0 21 e5 	call (m) Lc_configure_splitter_1;
        ext_data->splitter_deactivate_to_buffer = TRUE;
84200242:	41 20       	rMAC = Null + 1;
84200244:	f1 8f       	M[r4 + 28] = rMAC;
84200246:	05 6e       	jump (m) Lc_vagm_delegated_ops_15;

84200248 <Lc_vagm_delegated_ops_14>:
    }
    else
    {
        configure_qva(op_data, OPMSG_QVA_MODE_PASS_THRU);
84200248:	83 20       	r1 = Null + 2;
8420024a:	42 08       	r0 = r6 + Null;
8420024c:	03 f0 31 e0 	call (m) Lc_configure_qva_1;

84200250 <Lc_vagm_delegated_ops_15>:
    }
    ext_data->delegated = TRUE;
84200250:	41 20       	rMAC = Null + 1;
84200252:	31 ae       	M[r4 + 64] = rMAC;
    /* Set active mode clock to the requested value in message
     * OPMSG_VA_GM_ID_SET_TRIGGER_MODE_CLOCK once GM has been
     * delegated and is not in low power mode.
     */
    if(ext_data->active_mode_clk_val !=0 && !ext_data->lp_active)
84200254:	b0 99       	Null = M[r4 + 56];
84200256:	07 60       	if EQ jump (m) Lc_vagm_delegated_ops_18;

84200258 <Lc_vagm_delegated_ops_16>:
84200258:	b0 98       	Null = M[r4 + 40];
8420025a:	05 62       	if NE jump (m) Lc_vagm_delegated_ops_18;

8420025c <Lc_vagm_delegated_ops_17>:
    {
        manage_am_clock(op_data, FALSE);
8420025c:	03 00       	r1 = Null + Null;
8420025e:	42 08       	r0 = r6 + Null;
84200260:	02 f0 31 e7 	call (m) Lc_manage_am_clock_1;

84200264 <Lc_vagm_delegated_ops_18>:
    /* If message with no payload is received then it must be sent due
     * to delegation being cancelled */
    if (msg_len == OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET && ext_data->delegated)
    {
        ext_data->delegated = FALSE;
        return TRUE;
84200264:	42 20       	r0 = Null + 1;

84200266 <Lc_vagm_delegated_ops_19>:
    {
        manage_am_clock(op_data, FALSE);
    }

    return TRUE;
}
84200266:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200268:	d8 4c       	rts;

8420026a <Lc_vagm_delegated_ops_trimmed_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_delegated_ops_trimmed(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420026a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420026c:	10 09       	r6 = r0 + Null;
8420026e:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200270:	ff fd 03 f0 	call (m) 0x8ea;
84200274:	3b e3 
84200276:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_delegated_ops_trimmed(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg_len = OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data);
84200278:	79 f0 01 88 	r7 = M[r5 + 4];

    if (msg_len < OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
    
                  + VAGM_MIN_DELEGATED_OPERATORS ) 
8420027c:	90 f0 02 24 	Null = r7 - 2;
84200280:	02 f0 89 e0 	if C jump (m) Lc_vagm_delegated_ops_trimmed_3;

84200284 <Lc_vagm_delegated_ops_trimmed_2>:
    {
        return FALSE;
84200284:	02 00       	r0 = Null + Null;
84200286:	45 6e       	jump (m) Lc_vagm_delegated_ops_trimmed_17;

84200288 <Lc_vagm_delegated_ops_trimmed_3>:
    }
    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MAX_DELEGATED_OPERATORS)
84200288:	90 f0 05 24 	Null = r7 - 5;
8420028c:	f8 ff f9 ef 	if HI jump (m) Lc_vagm_delegated_ops_trimmed_2;

84200290 <Lc_vagm_delegated_ops_trimmed_4>:
    {
        return FALSE;
    }

    vagm_init(op_data);
84200290:	42 08       	r0 = r6 + Null;
84200292:	fe ff 39 ec 	call (m) Lc_vagm_init_1;

    L2_DBG_MSG("VA_GM: vagm_delegated_ops_trimmed");
84200296:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420029a:	88 24       	Null = rMAC - 2;
8420029c:	07 68       	if LT jump (m) Lc_vagm_delegated_ops_trimmed_6;

8420029e <Lc_vagm_delegated_ops_trimmed_5>:
8420029e:	55 f1 02 f0 	r0 = Null + 357564603;
842002a2:	bb 40 
842002a4:	ff fd 07 f0 	call (m) 0x10b0;
842002a8:	2d e0 

842002aa <Lc_vagm_delegated_ops_trimmed_6>:

    /* Application client will send the QVA operator in the first position. */
    ext_data->qva_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 0);
842002aa:	f9 88       	rMAC = M[r5 + 12];
842002ac:	89 c6       	rMAC = rMAC AND 0xffff;
842002ae:	71 8e       	M[r4 + 4] = rMAC;

    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MIN_DELEGATED_OPERATORS)
842002b0:	90 f0 02 24 	Null = r7 - 2;
842002b4:	09 f0 99 e0 	if LS jump (m) Lc_vagm_delegated_ops_trimmed_9;

842002b8 <Lc_vagm_delegated_ops_trimmed_7>:
    {
        /* Application client will send the CVC operator in the second position. */
        ext_data->cvc_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 1);
842002b8:	39 89       	rMAC = M[r5 + 16];
842002ba:	89 c6       	rMAC = rMAC AND 0xffff;
842002bc:	b1 8e       	M[r4 + 8] = rMAC;
    }
    if (msg_len > OPMSG_OP_CLIENT_DELEGATED_OPERATORS_OPERATORS_WORD_OFFSET
                  + VAGM_MIN_DELEGATED_OPERATORS + 1)
842002be:	90 f0 03 24 	Null = r7 - 3;
842002c2:	09 f0 8b e0 	if LS jump (m) Lc_vagm_delegated_ops_trimmed_9;

842002c6 <Lc_vagm_delegated_ops_trimmed_8>:
    {
        /* Application client will send the Splitter operator in the third position. */
        ext_data->splitter_op_id = OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_OP_CLIENT_DELEGATED_OPERATORS, OPERATORS, 2);
842002c6:	79 89       	rMAC = M[r5 + 20];
842002c8:	89 c6       	rMAC = rMAC AND 0xffff;
842002ca:	f1 8e       	M[r4 + 12] = rMAC;

842002cc <Lc_vagm_delegated_ops_trimmed_9>:
    }

    if(ext_data->lp_active)
842002cc:	b0 98       	Null = M[r4 + 40];
842002ce:	0d 60       	if EQ jump (m) Lc_vagm_delegated_ops_trimmed_12;

842002d0 <Lc_vagm_delegated_ops_trimmed_10>:
    {
        if (!manage_clock(op_data, TRUE))
842002d0:	43 20       	r1 = Null + 1;
842002d2:	42 08       	r0 = r6 + Null;
842002d4:	02 f0 39 e4 	call (m) Lc_manage_clock_1;
842002d8:	10 04       	Null = r0 - Null;
842002da:	07 62       	if NE jump (m) Lc_vagm_delegated_ops_trimmed_12;

842002dc <Lc_vagm_delegated_ops_trimmed_11>:
        {
            /* AOV client is not present. Cannot change clock. */
            fault_diatribe(FAULT_AUDIO_VAGM_AOV_NOT_PRESENT, ext_data->qva_op_id);
842002dc:	73 88       	r1 = M[r4 + 4];
842002de:	02 f0 67 40 	r0 = Null + 103;
842002e2:	ff fd b2 f0 	call (m) 0x16870;
842002e6:	2f ec 

842002e8 <Lc_vagm_delegated_ops_trimmed_12>:
        }
    }

    ext_data->voice_activity = TRUE; 
842002e8:	41 20       	rMAC = Null + 1;
842002ea:	71 9e       	M[r4 + 36] = rMAC;

    if (ext_data->splitter_op_id != 0)
842002ec:	f0 88       	Null = M[r4 + 12];
842002ee:	08 60       	if EQ jump (m) Lc_vagm_delegated_ops_trimmed_14;

842002f0 <Lc_vagm_delegated_ops_trimmed_13>:
    {
        reinit_wwe(op_data);
842002f0:	42 08       	r0 = r6 + Null;
842002f2:	02 f0 37 e7 	call (m) Lc_reinit_wwe_1;
        configure_splitter(op_data, OPMSG_SPLITTER_ID_ACTIVATE_STREAMS_AFTER_TIMESTAMP);
842002f6:	c3 20       	r1 = Null + 3;
842002f8:	42 08       	r0 = r6 + Null;
842002fa:	02 f0 25 ef 	call (m) Lc_configure_splitter_1;

842002fe <Lc_vagm_delegated_ops_trimmed_14>:
    }
    if (ext_data->qva_op_id != 0)
842002fe:	70 88       	Null = M[r4 + 4];
84200300:	07 60       	if EQ jump (m) Lc_vagm_delegated_ops_trimmed_16;

84200302 <Lc_vagm_delegated_ops_trimmed_15>:
    {
        configure_qva(op_data, OPMSG_QVA_MODE_FULL_PROC);
84200302:	43 20       	r1 = Null + 1;
84200304:	42 08       	r0 = r6 + Null;
84200306:	02 f0 37 ea 	call (m) Lc_configure_qva_1;
        ext_data->wait_for_qva = TRUE;
8420030a:	41 20       	rMAC = Null + 1;
8420030c:	b1 8f       	M[r4 + 24] = rMAC;

8420030e <Lc_vagm_delegated_ops_trimmed_16>:
    }

    return TRUE;
8420030e:	42 20       	r0 = Null + 1;

84200310 <Lc_vagm_delegated_ops_trimmed_17>:
}
84200310:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200312:	d8 4c       	rts;

84200314 <Lc_vagm_delegated_ops_main_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_delegated_ops_main(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200314:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200316:	17 00       	r5 = r0 + Null;
84200318:	18 09       	r6 = r1 + Null;
8420031a:	26 00       	r4 = r2 + Null;
8420031c:	29 09       	r7 = r3 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420031e:	ff fd 02 f0 	call (m) 0x8ea;
84200322:	2d ee 
 */
static bool vagm_delegated_ops_main(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    if(ext_data->vad_op_id == 0xFFFF)
84200324:	11 e8       	rMAC = M[r0 + Null];
84200326:	03 f0 10 f3 	Null = rMAC - 65535;
8420032a:	ff 3f 
8420032c:	0a 62       	if NE jump (m) Lc_vagm_delegated_ops_main_4;

8420032e <Lc_vagm_delegated_ops_main_2>:
    {
        if( !vagm_delegated_ops_trimmed(op_data, message_data, resp_length, resp_data) )
8420032e:	4d 08       	r3 = r7 + Null;
84200330:	34 00       	r2 = r4 + Null;
84200332:	43 08       	r1 = r6 + Null;
84200334:	3a 00       	r0 = r5 + Null;
84200336:	9a 4f       	call (m) Lc_vagm_delegated_ops_trimmed_1;
84200338:	10 04       	Null = r0 - Null;
8420033a:	0a 62       	if NE jump (m) Lc_vagm_delegated_ops_main_5;

8420033c <Lc_vagm_delegated_ops_main_3>:
        {
            return FALSE;
8420033c:	02 00       	r0 = Null + Null;
8420033e:	09 6e       	jump (m) Lc_vagm_delegated_ops_main_6;

84200340 <Lc_vagm_delegated_ops_main_4>:
        }
    }
    else
    {
       if(!vagm_delegated_ops(op_data, message_data, resp_length, resp_data))
84200340:	4d 08       	r3 = r7 + Null;
84200342:	34 00       	r2 = r4 + Null;
84200344:	43 08       	r1 = r6 + Null;
84200346:	3a 00       	r0 = r5 + Null;
84200348:	35 4f       	call (m) Lc_vagm_delegated_ops_1;
8420034a:	10 04       	Null = r0 - Null;
8420034c:	f8 61       	if EQ jump (m) Lc_vagm_delegated_ops_main_3;

8420034e <Lc_vagm_delegated_ops_main_5>:
       {
           return FALSE;
       }
    }
       
    return TRUE;
8420034e:	42 20       	r0 = Null + 1;

84200350 <Lc_vagm_delegated_ops_main_6>:
}
84200350:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200352:	d8 4c       	rts;

84200354 <Lc_vagm_trigger_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_trigger(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200354:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200356:	17 00       	r5 = r0 + Null;
84200358:	18 09       	r6 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420035a:	ff fd 02 f0 	call (m) 0x8ea;
8420035e:	31 ec 
84200360:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_trigger(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    OPERATOR_ID src_op_id = OPMSG_FIELD_GET(message_data, OPMSG_OP_CLIENT_UNSOLICITED_MESSAGE, SOURCE_OP_ID);
84200362:	81 f0 03 88 	rMAC = M[r6 + 12];
84200366:	1a f7 ff 1f 	r8 = rMAC AND 0xffff;
 */
static inline bool waiting_for_any_response(VAGM_OP_DATA *ext_data)
{
    return (ext_data->wait_for_vad ||
            ext_data->wait_for_qva ||
            ext_data->aov_operation != NO_OPERATION);
8420036a:	70 89       	Null = M[r4 + 20];
8420036c:	21 62       	if NE jump (m) Lc_vagm_trigger_10;

8420036e <Lc_vagm_trigger_2>:
8420036e:	b0 89       	Null = M[r4 + 24];
84200370:	1f 62       	if NE jump (m) Lc_vagm_trigger_10;

84200372 <Lc_vagm_trigger_3>:
84200372:	61 f0 20 80 	rMAC = MBS[r4 + 32];
84200376:	1c 62       	if NE jump (m) Lc_vagm_trigger_10;

84200378 <Lc_vagm_trigger_4>:
         * This task should run at priority 0, so that the messages
         * are handled sequentially. If this happens, we can ignore it. */
        return TRUE;
    }

    if (src_op_id == ext_data->vad_op_id)
84200378:	6f fa 80 c2 	Null = r8 - M[r4];
8420037c:	34 62       	if NE jump (m) Lc_vagm_trigger_16;

8420037e <Lc_vagm_trigger_5>:
    {
        L3_DBG_MSG("VA_GM: positive trigger from VAD");
8420037e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200382:	c8 24       	Null = rMAC - 3;
84200384:	07 68       	if LT jump (m) Lc_vagm_trigger_7;

84200386 <Lc_vagm_trigger_6>:
84200386:	55 f1 02 f0 	r0 = Null + 357564637;
8420038a:	dd 40 
8420038c:	ff fd 06 f0 	call (m) 0x10b0;
84200390:	25 e9 

84200392 <Lc_vagm_trigger_7>:

        if (ext_data->lp_active)
84200392:	b0 98       	Null = M[r4 + 40];
84200394:	0f 60       	if EQ jump (m) Lc_vagm_trigger_11;

84200396 <Lc_vagm_trigger_8>:
        {
            /**
             * In low power mode, the MIPS budged is not enough to run QVA.
             * We send a request to the framework to switch to a higher clock.
             */
            if (!manage_clock(op_data, TRUE))
84200396:	43 20       	r1 = Null + 1;
84200398:	3a 00       	r0 = r5 + Null;
8420039a:	01 f0 33 ee 	call (m) Lc_manage_clock_1;
8420039e:	10 04       	Null = r0 - Null;
842003a0:	07 62       	if NE jump (m) Lc_vagm_trigger_10;

842003a2 <Lc_vagm_trigger_9>:
            {
                /* AOV client is not present. Cannot change clock. */
                fault_diatribe(FAULT_AUDIO_VAGM_AOV_NOT_PRESENT, src_op_id);
842003a2:	02 f0 67 40 	r0 = Null + 103;
842003a6:	53 08       	r1 = r8 + Null;
842003a8:	ff fd b2 f0 	call (m) 0x16870;
842003ac:	29 e6 

842003ae <Lc_vagm_trigger_10>:
    if (waiting_for_any_response(ext_data))
    {
        /* A trigger came while waiting for response by operators or aov.
         * This task should run at priority 0, so that the messages
         * are handled sequentially. If this happens, we can ignore it. */
        return TRUE;
842003ae:	42 20       	r0 = Null + 1;
842003b0:	58 6e       	jump (m) Lc_vagm_trigger_26;

842003b2 <Lc_vagm_trigger_11>:
        else
        {
            /* Once trigger is received we expect graph manager to switch
             * clock to trigger clock value.
             */
            ext_data->voice_activity = TRUE;
842003b2:	41 20       	rMAC = Null + 1;
842003b4:	71 9e       	M[r4 + 36] = rMAC;
            if(ext_data->trigger_mode_clk_val != 0)
842003b6:	f0 99       	Null = M[r4 + 60];
842003b8:	05 60       	if EQ jump (m) Lc_vagm_trigger_13;

842003ba <Lc_vagm_trigger_12>:
            {
                manage_am_clock(op_data, TRUE);
842003ba:	0b 00       	r1 = rMAC + Null;
842003bc:	3a 00       	r0 = r5 + Null;
842003be:	01 f0 33 ec 	call (m) Lc_manage_am_clock_1;

842003c2 <Lc_vagm_trigger_13>:
            }
            if (ext_data->splitter_op_id != 0)
842003c2:	f0 88       	Null = M[r4 + 12];
842003c4:	09 60       	if EQ jump (m) Lc_vagm_trigger_15;

842003c6 <Lc_vagm_trigger_14>:
            {
                reinit_wwe(op_data);
842003c6:	3a 00       	r0 = r5 + Null;
842003c8:	02 f0 21 e1 	call (m) Lc_reinit_wwe_1;
                configure_splitter(op_data, OPMSG_SPLITTER_ID_ACTIVATE_STREAMS_AFTER_TIMESTAMP);
842003cc:	c3 20       	r1 = Null + 3;
842003ce:	3a 00       	r0 = r5 + Null;
842003d0:	02 f0 2f e8 	call (m) Lc_configure_splitter_1;
842003d4:	ed 6f       	jump (m) Lc_vagm_trigger_10;

842003d6 <Lc_vagm_trigger_15>:
            }
            else
            {
                configure_qva(op_data, OPMSG_QVA_MODE_FULL_PROC);
842003d6:	43 20       	r1 = Null + 1;
842003d8:	3a 00       	r0 = r5 + Null;
842003da:	02 f0 23 e4 	call (m) Lc_configure_qva_1;
                ext_data->wait_for_qva = TRUE;
842003de:	41 20       	rMAC = Null + 1;
842003e0:	b1 8f       	M[r4 + 24] = rMAC;
842003e2:	e6 6f       	jump (m) Lc_vagm_trigger_10;

842003e4 <Lc_vagm_trigger_16>:
            }
        }
    }
    else if (src_op_id == ext_data->qva_op_id)
842003e4:	71 88       	rMAC = M[r4 + 4];
842003e6:	1f fa 00 c2 	Null = r8 - rMAC;
842003ea:	34 62       	if NE jump (m) Lc_vagm_trigger_25;

842003ec <Lc_vagm_trigger_17>:
    {
        L3_DBG_MSG("VA_GM: positive trigger from QVA");
842003ec:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842003f0:	c8 24       	Null = rMAC - 3;
842003f2:	07 68       	if LT jump (m) Lc_vagm_trigger_19;

842003f4 <Lc_vagm_trigger_18>:
842003f4:	55 f1 02 f0 	r0 = Null + 357564670;
842003f8:	fe 40 
842003fa:	ff fd 06 f0 	call (m) 0x10b0;
842003fe:	37 e5 

84200400 <Lc_vagm_trigger_19>:
        unsigned *payload = OPMSG_FIELD_POINTER_GET(message_data, OPMSG_OP_CLIENT_UNSOLICITED_MESSAGE, PAYLOAD);
84200400:	89 f0 10 20 	r7 = r6 + 16;
        unsigned length = OPMGR_GET_OPCMD_MESSAGE_LENGTH((OPMSG_HEADER*)message_data);
84200404:	88 f0 01 88 	r6 = M[r6 + 4];
        
        if (0xFFFF != ext_data->vad_op_id)
84200408:	31 e8       	rMAC = M[r4 + Null];
8420040a:	03 f0 10 f3 	Null = rMAC - 65535;
8420040e:	ff 3f 
84200410:	05 60       	if EQ jump (m) Lc_vagm_trigger_21;

84200412 <Lc_vagm_trigger_20>:
        {
            configure_vad(op_data, OPMSG_VAD_MODE_PASS_THRU);                       
84200412:	83 20       	r1 = Null + 2;
84200414:	3a 00       	r0 = r5 + Null;
84200416:	02 f0 2b e0 	call (m) Lc_configure_vad_1;

8420041a <Lc_vagm_trigger_21>:
        }  
        configure_qva(op_data, OPMSG_QVA_MODE_PASS_THRU);         
8420041a:	83 20       	r1 = Null + 2;
8420041c:	3a 00       	r0 = r5 + Null;
8420041e:	02 f0 3f e1 	call (m) Lc_configure_qva_1;

        if (ext_data->lp_active)
84200422:	b0 98       	Null = M[r4 + 40];
84200424:	0e 60       	if EQ jump (m) Lc_vagm_trigger_24;

84200426 <Lc_vagm_trigger_22>:
             * notification to the application client, as the link used by
             * othe application is down.
             */
            if (aov_request_notify_trigger(op_data,
                                           length - CLIENT_UNSOLICITED_MESSAGE_SIZE_EXTRA,
                                           payload))
84200426:	83 f0 02 24 	r1 = r6 - 2;
8420042a:	4c 08       	r2 = r7 + Null;
8420042c:	3a 00       	r0 = r5 + Null;
8420042e:	ff fd 9d f2 	call (m) 0x53fd2;
84200432:	25 ed 
84200434:	10 04       	Null = r0 - Null;
84200436:	b6 61       	if EQ jump (m) Lc_vagm_trigger_9;

84200438 <Lc_vagm_trigger_23>:
            {
                ext_data->aov_operation = FWD_TRIGGER;
84200438:	c1 20       	rMAC = Null + 3;
8420043a:	61 f0 20 8a 	MB[r4 + 32] = rMAC;
8420043e:	b8 6f       	jump (m) Lc_vagm_trigger_10;

84200440 <Lc_vagm_trigger_24>:
             * Forward trigger notification and details to the application
             * client through the standard link used by the application.
             */
            common_send_unsolicited_message(op_data, OPMSG_REPLY_ID_VA_TRIGGER,
                                            length - CLIENT_UNSOLICITED_MESSAGE_SIZE_EXTRA,
                                            payload);
84200440:	84 f0 02 24 	r2 = r6 - 2;
84200444:	83 20       	r1 = Null + 2;
84200446:	4d 08       	r3 = r7 + Null;
84200448:	3a 00       	r0 = r5 + Null;
8420044a:	ff fd 02 f0 	call (m) 0x970;
8420044e:	27 e9 
84200450:	af 6f       	jump (m) Lc_vagm_trigger_10;

84200452 <Lc_vagm_trigger_25>:
        }
    }
    else
    {
        /* Operator id is unrecognized */
        fault_diatribe(FAULT_AUDIO_VAGM_UNRECOGNIZED_OPERATOR, src_op_id);
84200452:	02 f0 65 40 	r0 = Null + 101;
84200456:	53 08       	r1 = r8 + Null;
84200458:	ff fd b2 f0 	call (m) 0x16870;
8420045c:	39 e0 
8420045e:	a8 6f       	jump (m) Lc_vagm_trigger_10;

84200460 <Lc_vagm_trigger_26>:
    }
    return TRUE;
}
84200460:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200462:	d8 4c       	rts;

84200464 <Lc_vagm_negative_trigger_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_negative_trigger(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200464:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200466:	17 00       	r5 = r0 + Null;
84200468:	18 09       	r6 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420046a:	ff fd 02 f0 	call (m) 0x8ea;
8420046e:	21 e4 
84200470:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_negative_trigger(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    OPERATOR_ID src_op_id = OPMSG_FIELD_GET(message_data, OPMSG_OP_CLIENT_UNSOLICITED_MESSAGE, SOURCE_OP_ID);
84200472:	81 f0 03 88 	rMAC = M[r6 + 12];
84200476:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;
 */
static inline bool waiting_for_any_response(VAGM_OP_DATA *ext_data)
{
    return (ext_data->wait_for_vad ||
            ext_data->wait_for_qva ||
            ext_data->aov_operation != NO_OPERATION);
8420047a:	70 89       	Null = M[r4 + 20];
8420047c:	14 62       	if NE jump (m) Lc_vagm_negative_trigger_7;

8420047e <Lc_vagm_negative_trigger_2>:
8420047e:	b0 89       	Null = M[r4 + 24];
84200480:	12 62       	if NE jump (m) Lc_vagm_negative_trigger_7;

84200482 <Lc_vagm_negative_trigger_3>:
84200482:	61 f0 20 80 	rMAC = MBS[r4 + 32];
84200486:	0f 62       	if NE jump (m) Lc_vagm_negative_trigger_7;

84200488 <Lc_vagm_negative_trigger_4>:
         * This task should run at priority 0, so that the messages
         * are handled sequentially. If this happens, we can ignore it. */
        return TRUE;
    }

    if (src_op_id == ext_data->qva_op_id)
84200488:	71 88       	rMAC = M[r4 + 4];
8420048a:	1f f8 00 c2 	Null = r6 - rMAC;
8420048e:	0d 62       	if NE jump (m) Lc_vagm_negative_trigger_8;

84200490 <Lc_vagm_negative_trigger_5>:
    {
        L3_DBG_MSG("VA_GM: negative trigger from QVA");
84200490:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200494:	c8 24       	Null = rMAC - 3;
84200496:	07 68       	if LT jump (m) Lc_vagm_negative_trigger_7;

84200498 <Lc_vagm_negative_trigger_6>:
84200498:	55 f1 02 f0 	r0 = Null + 357564703;
8420049c:	1f 41 
8420049e:	ff fd 06 f0 	call (m) 0x10b0;
842004a2:	33 e0 

842004a4 <Lc_vagm_negative_trigger_7>:
    if (waiting_for_any_response(ext_data))
    {
        /* A trigger came while waiting for response by operators or aov.
         * This task should run at priority 0, so that the messages
         * are handled sequentially. If this happens, we can ignore it. */
        return TRUE;
842004a4:	42 20       	r0 = Null + 1;
842004a6:	3f 6e       	jump (m) Lc_vagm_negative_trigger_23;

842004a8 <Lc_vagm_negative_trigger_8>:
    if (src_op_id == ext_data->qva_op_id)
    {
        L3_DBG_MSG("VA_GM: negative trigger from QVA");
        /* We will ignore this and use the negative trigger from VAD.*/
    }
    else if (src_op_id == ext_data->vad_op_id)
842004a8:	6f f8 80 c2 	Null = r6 - M[r4];
842004ac:	35 62       	if NE jump (m) Lc_vagm_negative_trigger_22;

842004ae <Lc_vagm_negative_trigger_9>:
    {
        L3_DBG_MSG("VA_GM: negative trigger from VAD");
842004ae:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842004b2:	c8 24       	Null = rMAC - 3;
842004b4:	07 68       	if LT jump (m) Lc_vagm_negative_trigger_11;

842004b6 <Lc_vagm_negative_trigger_10>:
842004b6:	55 f1 02 f0 	r0 = Null + 357564736;
842004ba:	40 41 
842004bc:	ff fd 05 f0 	call (m) 0x10b0;
842004c0:	35 ef 

842004c2 <Lc_vagm_negative_trigger_11>:

        if (ext_data->splitter_op_id != 0)
842004c2:	f0 88       	Null = M[r4 + 12];
842004c4:	08 60       	if EQ jump (m) Lc_vagm_negative_trigger_13;

842004c6 <Lc_vagm_negative_trigger_12>:
        {
            configure_splitter(op_data, OPMSG_SPLITTER_ID_DEACTIVATE_STREAMS);
842004c6:	03 21       	r1 = Null + 4;
842004c8:	3a 00       	r0 = r5 + Null;
842004ca:	02 f0 35 e0 	call (m) Lc_configure_splitter_1;
            ext_data->splitter_deactivate_to_buffer = TRUE;
842004ce:	41 20       	rMAC = Null + 1;
842004d0:	f1 8f       	M[r4 + 28] = rMAC;
842004d2:	07 6e       	jump (m) Lc_vagm_negative_trigger_14;

842004d4 <Lc_vagm_negative_trigger_13>:
        }
        else
        {
            configure_qva(op_data, OPMSG_QVA_MODE_PASS_THRU);
842004d4:	83 20       	r1 = Null + 2;
842004d6:	3a 00       	r0 = r5 + Null;
842004d8:	01 f0 25 ec 	call (m) Lc_configure_qva_1;
            ext_data->wait_for_qva = TRUE;
842004dc:	41 20       	rMAC = Null + 1;
842004de:	b1 8f       	M[r4 + 24] = rMAC;

842004e0 <Lc_vagm_negative_trigger_14>:
        }

        /* This ensures that we don't change the clock if it was already scaled
         *  back in a previous negative trigger from the VAD */
        if (ext_data->lp_active && ext_data->voice_activity)
842004e0:	b1 98       	rMAC = M[r4 + 40];
842004e2:	10 60       	if EQ jump (m) Lc_vagm_negative_trigger_18;

842004e4 <Lc_vagm_negative_trigger_15>:
842004e4:	70 98       	Null = M[r4 + 36];
842004e6:	0e 60       	if EQ jump (m) Lc_vagm_negative_trigger_18;

842004e8 <Lc_vagm_negative_trigger_16>:
        {
            /**
             * Since we will wait for another VAD trigger, get back to the
             * default low power clock.
             */
            if (!manage_clock(op_data, FALSE))
842004e8:	03 00       	r1 = Null + Null;
842004ea:	3a 00       	r0 = r5 + Null;
842004ec:	01 f0 21 e4 	call (m) Lc_manage_clock_1;
842004f0:	10 04       	Null = r0 - Null;
842004f2:	10 62       	if NE jump (m) Lc_vagm_negative_trigger_21;

842004f4 <Lc_vagm_negative_trigger_17>:
            {
                /* AOV client is not present. Cannot change clock. */
                fault_diatribe(FAULT_AUDIO_VAGM_AOV_NOT_PRESENT, src_op_id);
842004f4:	02 f0 67 40 	r0 = Null + 103;
842004f8:	43 08       	r1 = r6 + Null;
842004fa:	ff fd b1 f0 	call (m) 0x16870;
842004fe:	37 eb 
84200500:	09 6e       	jump (m) Lc_vagm_negative_trigger_21;

84200502 <Lc_vagm_negative_trigger_18>:
            }
        }
        /* Once negative trigger is received we expect graph manager to switch
         * back to active mode clock value.
         */
        else if(ext_data->active_mode_clk_val !=0 && !ext_data->lp_active)
84200502:	b0 99       	Null = M[r4 + 56];
84200504:	07 60       	if EQ jump (m) Lc_vagm_negative_trigger_21;

84200506 <Lc_vagm_negative_trigger_19>:
84200506:	08 04       	Null = rMAC - Null;
84200508:	05 62       	if NE jump (m) Lc_vagm_negative_trigger_21;

8420050a <Lc_vagm_negative_trigger_20>:
        {
            manage_am_clock(op_data, FALSE);
8420050a:	03 00       	r1 = Null + Null;
8420050c:	3a 00       	r0 = r5 + Null;
8420050e:	01 f0 23 e2 	call (m) Lc_manage_am_clock_1;

84200512 <Lc_vagm_negative_trigger_21>:
        }

        ext_data->voice_activity = FALSE;
84200512:	70 9e       	M[r4 + 36] = Null;
84200514:	c8 6f       	jump (m) Lc_vagm_negative_trigger_7;

84200516 <Lc_vagm_negative_trigger_22>:
    }
    else
    {
        /* Operator id is unrecognized */
        fault_diatribe(FAULT_AUDIO_VAGM_UNRECOGNIZED_OPERATOR, src_op_id);
84200516:	02 f0 65 40 	r0 = Null + 101;
8420051a:	43 08       	r1 = r6 + Null;
8420051c:	ff fd b1 f0 	call (m) 0x16870;
84200520:	35 ea 
84200522:	c1 6f       	jump (m) Lc_vagm_negative_trigger_7;

84200524 <Lc_vagm_negative_trigger_23>:
    }
    return TRUE;
}
84200524:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200526:	d8 4c       	rts;

84200528 <Lc_vagm_lp_notification_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_lp_notification(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200528:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420052a:	16 00       	r4 = r0 + Null;
8420052c:	18 09       	r6 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420052e:	ff fd 01 f0 	call (m) 0x8ea;
84200532:	3d ed 
84200534:	17 00       	r5 = r0 + Null;
 * response
 */
static bool vagm_lp_notification(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    L3_DBG_MSG("VA_GM: Low power notification");
84200536:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420053a:	c8 24       	Null = rMAC - 3;
8420053c:	07 68       	if LT jump (m) Lc_vagm_lp_notification_3;

8420053e <Lc_vagm_lp_notification_2>:
8420053e:	55 f1 02 f0 	r0 = Null + 357564874;
84200542:	ca 41 
84200544:	ff fd 05 f0 	call (m) 0x10b0;
84200548:	2d eb 

8420054a <Lc_vagm_lp_notification_3>:
    bool lp_activated = (bool) OPMSG_FIELD_GET(message_data, OPMSG_OP_CLIENT_AOV_LP, ACTIVE);
8420054a:	81 f0 03 88 	rMAC = M[r6 + 12];

    if (lp_activated)
8420054e:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;
84200552:	16 60       	if EQ jump (m) Lc_vagm_lp_notification_9;

84200554 <Lc_vagm_lp_notification_4>:
    {
        /* We are entering low power. */
        if (ext_data->cvc_op_id != 0)
84200554:	b8 88       	Null = M[r5 + 8];
84200556:	05 60       	if EQ jump (m) Lc_vagm_lp_notification_6;

84200558 <Lc_vagm_lp_notification_5>:
        {
            /* In low power, we cannot afford to run cvc.*/
            configure_cvc(op_data, OPMSG_CVC_SEND_MODE_PASS_THRU_LEFT);
84200558:	03 21       	r1 = Null + 4;
8420055a:	32 00       	r0 = r4 + Null;
8420055c:	01 f0 3d e9 	call (m) Lc_configure_cvc_1;

84200560 <Lc_vagm_lp_notification_6>:
        }
        if( ext_data->voice_activity)
84200560:	78 98       	Null = M[r5 + 36];
84200562:	23 60       	if EQ jump (m) Lc_vagm_lp_notification_17;

84200564 <Lc_vagm_lp_notification_7>:
        {
            /**
             * In low power mode, the MIPS budged is not enough to run QVA.
             * We send a request to the framework to switch to a higher clock.
             */
            if (!manage_clock(op_data, TRUE))
84200564:	43 20       	r1 = Null + 1;
84200566:	32 00       	r0 = r4 + Null;
84200568:	01 f0 25 e0 	call (m) Lc_manage_clock_1;
8420056c:	10 04       	Null = r0 - Null;
8420056e:	1d 62       	if NE jump (m) Lc_vagm_lp_notification_17;

84200570 <Lc_vagm_lp_notification_8>:
            {
                /* AOV client is not present. Cannot change clock. */
                fault_diatribe(FAULT_AUDIO_VAGM_AOV_NOT_PRESENT, 0);
84200570:	02 f0 67 40 	r0 = Null + 103;
84200574:	03 00       	r1 = Null + Null;
84200576:	ff fd b1 f0 	call (m) 0x16870;
8420057a:	3b e7 
8420057c:	16 6e       	jump (m) Lc_vagm_lp_notification_17;

8420057e <Lc_vagm_lp_notification_9>:
            }
        }
    }
    else
    {
        if(ext_data->lp_active)
8420057e:	b8 98       	Null = M[r5 + 40];
84200580:	14 60       	if EQ jump (m) Lc_vagm_lp_notification_17;

84200582 <Lc_vagm_lp_notification_10>:
        {
            /* We are switching from low power to active mode */
            if (ext_data->cvc_op_id != 0)
84200582:	b8 88       	Null = M[r5 + 8];
84200584:	05 60       	if EQ jump (m) Lc_vagm_lp_notification_12;

84200586 <Lc_vagm_lp_notification_11>:
            {
                /* We are exiting low power. */
                configure_cvc(op_data, OPMSG_CVC_SEND_MODE_FULL_PROC);
84200586:	83 20       	r1 = Null + 2;
84200588:	32 00       	r0 = r4 + Null;
8420058a:	01 f0 2f e8 	call (m) Lc_configure_cvc_1;

8420058e <Lc_vagm_lp_notification_12>:
            }
            /* Change clock value when exiting low power to enter active mode
             * when no voice activity has been detected 
             */
            if(!ext_data->voice_activity && ext_data->active_mode_clk_val !=0)
8420058e:	78 98       	Null = M[r5 + 36];
84200590:	07 62       	if NE jump (m) Lc_vagm_lp_notification_15;

84200592 <Lc_vagm_lp_notification_13>:
84200592:	b8 99       	Null = M[r5 + 56];
84200594:	0a 60       	if EQ jump (m) Lc_vagm_lp_notification_17;

84200596 <Lc_vagm_lp_notification_14>:
            {
                manage_am_clock(op_data, FALSE);
84200596:	03 00       	r1 = Null + Null;
84200598:	32 00       	r0 = r4 + Null;
8420059a:	db 4e       	call (m) Lc_manage_am_clock_1;
8420059c:	06 6e       	jump (m) Lc_vagm_lp_notification_17;

8420059e <Lc_vagm_lp_notification_15>:
            }
            /* Change clock value when exiting low power to enter active mode
             * but voice activity has been detected and trigger mode clock needs
             * to be set.
             */
            else if(ext_data->voice_activity && ext_data->trigger_mode_clk_val !=0)
8420059e:	f8 99       	Null = M[r5 + 60];
842005a0:	04 60       	if EQ jump (m) Lc_vagm_lp_notification_17;

842005a2 <Lc_vagm_lp_notification_16>:
            {
                manage_am_clock(op_data, TRUE);
842005a2:	43 20       	r1 = Null + 1;
842005a4:	32 00       	r0 = r4 + Null;
842005a6:	d5 4e       	call (m) Lc_manage_am_clock_1;

842005a8 <Lc_vagm_lp_notification_17>:
        {
           /* We are still in active mode. */
        }
    }

    ext_data->lp_active = lp_activated;
842005a8:	78 f0 0a 8e 	M[r5 + 40] = r6;

    return TRUE;
842005ac:	42 20       	r0 = Null + 1;

842005ae <Lc_vagm_lp_notification_18>:

}
842005ae:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842005b0:	d8 4c       	rts;

842005b2 <Lc_vagm_aov_response_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_aov_response(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005b2:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842005b4:	17 00       	r5 = r0 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842005b6:	ff fd 01 f0 	call (m) 0x8ea;
842005ba:	35 e9 
842005bc:	16 00       	r4 = r0 + Null;
 */
static bool vagm_aov_response(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    L3_DBG_MSG("VA_GM: Response from AOV");
842005be:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842005c2:	c8 24       	Null = rMAC - 3;
842005c4:	07 68       	if LT jump (m) Lc_vagm_aov_response_3;

842005c6 <Lc_vagm_aov_response_2>:
842005c6:	55 f1 02 f0 	r0 = Null + 357564904;
842005ca:	e8 41 
842005cc:	ff fd 05 f0 	call (m) 0x10b0;
842005d0:	25 e7 

842005d2 <Lc_vagm_aov_response_3>:
    switch(ext_data->aov_operation)
842005d2:	61 f0 20 80 	rMAC = MBS[r4 + 32];
842005d6:	48 24       	Null = rMAC - 1;
842005d8:	0d 60       	if EQ jump (m) Lc_vagm_aov_response_8;

842005da <Lc_vagm_aov_response_4>:
842005da:	c8 24       	Null = rMAC - 3;
842005dc:	07 62       	if NE jump (m) Lc_vagm_aov_response_7;

842005de <Lc_vagm_aov_response_5>:
        }
        break;
    }
    case FWD_TRIGGER:
    {
        if (ext_data->cvc_op_id != 0)
842005de:	b0 88       	Null = M[r4 + 8];
842005e0:	05 60       	if EQ jump (m) Lc_vagm_aov_response_7;

842005e2 <Lc_vagm_aov_response_6>:
        {
            /* We will now be exiting from low power. */
            configure_cvc(op_data, OPMSG_CVC_SEND_MODE_FULL_PROC);
842005e2:	83 20       	r1 = Null + 2;
842005e4:	3a 00       	r0 = r5 + Null;
842005e6:	01 f0 33 e5 	call (m) Lc_configure_cvc_1;

842005ea <Lc_vagm_aov_response_7>:
    {
        /* Do nothing... */
        break;
    }
    }
    ext_data->aov_operation = NO_OPERATION;
842005ea:	60 f0 20 8a 	MB[r4 + 32] = Null;

    return TRUE;
842005ee:	42 20       	r0 = Null + 1;
842005f0:	16 6e       	jump (m) Lc_vagm_aov_response_12;

842005f2 <Lc_vagm_aov_response_8>:
    L3_DBG_MSG("VA_GM: Response from AOV");
    switch(ext_data->aov_operation)
    {
    case SCALE_CUSTOM:
    {
        if (!ext_data->voice_activity)
842005f2:	70 98       	Null = M[r4 + 36];
842005f4:	fb 63       	if NE jump (m) Lc_vagm_aov_response_7;

842005f6 <Lc_vagm_aov_response_9>:
        {
            ext_data->voice_activity = TRUE;
842005f6:	08 71       	r6 = Null + 1;
842005f8:	68 f0 09 8e 	M[r4 + 36] = r6;

            if (ext_data->splitter_op_id != 0)
842005fc:	f0 88       	Null = M[r4 + 12];
842005fe:	08 60       	if EQ jump (m) Lc_vagm_aov_response_11;

84200600 <Lc_vagm_aov_response_10>:
            {
                reinit_wwe(op_data);
84200600:	3a 00       	r0 = r5 + Null;
84200602:	f3 4e       	call (m) Lc_reinit_wwe_1;
                configure_splitter(op_data, OPMSG_SPLITTER_ID_ACTIVATE_STREAMS_AFTER_TIMESTAMP);
84200604:	c3 20       	r1 = Null + 3;
84200606:	3a 00       	r0 = r5 + Null;
84200608:	01 f0 37 e6 	call (m) Lc_configure_splitter_1;
8420060c:	ef 6f       	jump (m) Lc_vagm_aov_response_7;

8420060e <Lc_vagm_aov_response_11>:
            }
            else
            {
                configure_qva(op_data, OPMSG_QVA_MODE_FULL_PROC);
8420060e:	43 08       	r1 = r6 + Null;
84200610:	3a 00       	r0 = r5 + Null;
84200612:	01 f0 2b e2 	call (m) Lc_configure_qva_1;
                ext_data->wait_for_qva = TRUE;
84200616:	68 f0 06 8e 	M[r4 + 24] = r6;
8420061a:	e8 6f       	jump (m) Lc_vagm_aov_response_7;

8420061c <Lc_vagm_aov_response_12>:
    }
    }
    ext_data->aov_operation = NO_OPERATION;

    return TRUE;
}
8420061c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420061e:	d8 4c       	rts;

84200620 <Lc_vagm_set_graph_load_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_set_graph_load(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200620:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200622:	1e 00       	r4 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200624:	ff fd 01 f0 	call (m) 0x8ea;
84200628:	27 e6 
8420062a:	17 00       	r5 = r0 + Null;
 */
static bool vagm_set_graph_load(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    L3_DBG_MSG("VA_GM: Graph Load");
8420062c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200630:	c8 24       	Null = rMAC - 3;
84200632:	07 68       	if LT jump (m) Lc_vagm_set_graph_load_3;

84200634 <Lc_vagm_set_graph_load_2>:
84200634:	55 f1 02 f0 	r0 = Null + 357564929;
84200638:	01 42 
8420063a:	ff fd 05 f0 	call (m) 0x10b0;
8420063e:	37 e3 

84200640 <Lc_vagm_set_graph_load_3>:
    ext_data->graph_load = (OPMSG_VA_GM_LOAD) OPMSG_FIELD_GET(message_data, OPMSG_VA_GM_SET_GRAPH_LOAD, LOAD);
84200640:	f1 88       	rMAC = M[r4 + 12];
84200642:	39 aa       	MB[r5 + 16] = rMAC;

    return TRUE;
84200644:	42 20       	r0 = Null + 1;

84200646 <Lc_vagm_set_graph_load_4>:
}
84200646:	f2 48       	popm <FP, r4, r5, rLink>;
84200648:	d8 4c       	rts;

8420064a <Lc_vagm_set_splitter_offset_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_set_splitter_offset(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420064a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420064c:	1e 00       	r4 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420064e:	ff fd 01 f0 	call (m) 0x8ea;
84200652:	3d e4 
 * response
 */
static bool vagm_set_splitter_offset(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned value = OPMSG_FIELD_GET(message_data, OPMSG_VA_GM_SET_SPLITTER_OFFSET, OFFSET);
84200654:	f1 88       	rMAC = M[r4 + 12];
84200656:	8b c6       	r1 = rMAC AND 0xffff;
    ext_data->buffer_time_offset_ms_initval = value;
84200658:	53 9f       	M[r0 + 52] = r1;
    ext_data->buffer_time_offset_ms = ext_data->buffer_time_offset_ms_initval;
8420065a:	d3 9e       	M[r0 + 44] = r1;
    ext_data->is_configured = TRUE;
8420065c:	41 20       	rMAC = Null + 1;
8420065e:	11 9f       	M[r0 + 48] = rMAC;

    L3_DBG_MSG1("VA_GM: vagm_set_splitter_offset %d", value);
84200660:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200664:	c8 24       	Null = rMAC - 3;
84200666:	07 68       	if LT jump (m) Lc_vagm_set_splitter_offset_3;

84200668 <Lc_vagm_set_splitter_offset_2>:
84200668:	55 f1 02 f0 	r0 = Null + 357564947;
8420066c:	13 42 
8420066e:	ff fd 05 f0 	call (m) 0x10c2;
84200672:	35 e2 

84200674 <Lc_vagm_set_splitter_offset_3>:

    return TRUE;
84200674:	42 20       	r0 = Null + 1;

84200676 <Lc_vagm_set_splitter_offset_4>:
}
84200676:	f1 48       	popm <FP, r4, rLink>;
84200678:	d8 4c       	rts;

8420067a <Lc_vagm_set_graph_mode_1>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
static bool vagm_set_graph_mode(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420067a:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420067c:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420067e:	ff fd 01 f0 	call (m) 0x8ea;
84200682:	2d e3 
84200684:	16 00       	r4 = r0 + Null;
 * response
 */
static bool vagm_set_graph_mode(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned set_mode = OPMSG_FIELD_GET(message_data, OPMSG_VA_GM_SET_GRAPH_MODE, MODE_BITMASK);
84200686:	f9 88       	rMAC = M[r5 + 12];
84200688:	8f c6       	r5 = rMAC AND 0xffff;
    unsigned value_op_id[MAX_OPERATORS_DISABLED] = {0};
8420068a:	01 f0 03 f3 	r1 = Null + 1441968;
8420068e:	b0 40 
84200690:	02 11       	r0 = FP + 16;
84200692:	04 21       	r2 = Null + 4;
84200694:	ff fd cd f0 	call (m) 0x1a094;
84200698:	21 e0 
    unsigned i;
    L2_DBG_MSG1("VA_GM: vagm_set_graph_manager_mode: mode_bitmask: %d", set_mode);
8420069a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420069e:	88 24       	Null = rMAC - 2;
842006a0:	08 68       	if LT jump (m) Lc_vagm_set_graph_mode_3;

842006a2 <Lc_vagm_set_graph_mode_2>:
842006a2:	55 f1 02 f0 	r0 = Null + 357564982;
842006a6:	36 42 
842006a8:	3b 00       	r1 = r5 + Null;
842006aa:	ff fd 05 f0 	call (m) 0x10c2;
842006ae:	39 e0 

842006b0 <Lc_vagm_set_graph_mode_3>:
    if(set_mode)
842006b0:	38 04       	Null = r5 - Null;
842006b2:	1d 60       	if EQ jump (m) Lc_vagm_set_graph_mode_11;

842006b4 <Lc_vagm_set_graph_mode_4>:
842006b4:	43 20       	r1 = Null + 1;
    {
        for( i = 0 ; i < MAX_OPERATORS_DISABLED; i ++ )
842006b6:	01 00       	rMAC = Null + Null;
842006b8:	02 11       	r0 = FP + 16;
842006ba:	24 71       	r10 = Null + 4;
842006bc:	09 4c       	do (m) Lc__loop0;

842006be <Lc_vagm_set_graph_mode_5>:
        {
            if (set_mode & (0x1 << i))
842006be:	0c 00       	r2 = rMAC + Null;
842006c0:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
842006c4:	e4 11       	r2 = r2 AND r5;
842006c6:	02 60       	if EQ jump (m) Lc_vagm_set_graph_mode_7;

842006c8 <Lc_vagm_set_graph_mode_6>:
            {
                value_op_id[i] = 1;
842006c8:	13 ee       	M[r0 + Null] = r1;

842006ca <Lc_vagm_set_graph_mode_7>:
    unsigned value_op_id[MAX_OPERATORS_DISABLED] = {0};
    unsigned i;
    L2_DBG_MSG1("VA_GM: vagm_set_graph_manager_mode: mode_bitmask: %d", set_mode);
    if(set_mode)
    {
        for( i = 0 ; i < MAX_OPERATORS_DISABLED; i ++ )
842006ca:	49 20       	rMAC = rMAC + 1;
842006cc:	12 21       	r0 = r0 + 4;

842006ce <Lc__loop0>:
842006ce:	20 d8       	Null = M[FP + 16];
842006d0:	0e 60       	if EQ jump (m) Lc_vagm_set_graph_mode_11;

842006d2 <Lc_vagm_set_graph_mode_9>:
        }
    }

    if(value_op_id[0])
    {
        ext_data->vad_op_id = 0xFFFF;
842006d2:	71 f0 ff 7b 	rMAC = Null + 65535;
842006d6:	31 ee       	M[r4 + Null] = rMAC;
        L2_DBG_MSG("VA_GM: vagm_set_manager_mode: VAD is not present in graph");
842006d8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842006dc:	88 24       	Null = rMAC - 2;
842006de:	07 68       	if LT jump (m) Lc_vagm_set_graph_mode_11;

842006e0 <Lc_vagm_set_graph_mode_10>:
842006e0:	55 f1 02 f0 	r0 = Null + 357565035;
842006e4:	6b 42 
842006e6:	ff fd 04 f0 	call (m) 0x10b0;
842006ea:	2b ee 

842006ec <Lc_vagm_set_graph_mode_11>:
    }
    if(value_op_id[1])
842006ec:	28 d8       	Null = M[FP + 20];
842006ee:	10 60       	if EQ jump (m) Lc_vagm_set_graph_mode_15;

842006f0 <Lc_vagm_set_graph_mode_12>:
    {
        ext_data->qva_op_id = 0xFFFF;
842006f0:	71 f0 ff 7b 	rMAC = Null + 65535;
842006f4:	71 8e       	M[r4 + 4] = rMAC;
        L2_DBG_MSG("VA_GM: vagm_set_manager_mode: QVA is not present in graph. Not supported yet. Returning");
842006f6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842006fa:	88 24       	Null = rMAC - 2;
842006fc:	07 68       	if LT jump (m) Lc_vagm_set_graph_mode_14;

842006fe <Lc_vagm_set_graph_mode_13>:
842006fe:	55 f1 02 f0 	r0 = Null + 357565093;
84200702:	a5 42 
84200704:	ff fd 04 f0 	call (m) 0x10b0;
84200708:	2d ed 

8420070a <Lc_vagm_set_graph_mode_14>:
        return FALSE;
8420070a:	02 00       	r0 = Null + Null;
8420070c:	20 6e       	jump (m) Lc_vagm_set_graph_mode_22;

8420070e <Lc_vagm_set_graph_mode_15>:
    }
    if(value_op_id[2])
8420070e:	30 d8       	Null = M[FP + 24];
84200710:	0e 60       	if EQ jump (m) Lc_vagm_set_graph_mode_18;

84200712 <Lc_vagm_set_graph_mode_16>:
    {
        ext_data->cvc_op_id = 0xFFFF;
84200712:	71 f0 ff 7b 	rMAC = Null + 65535;
84200716:	b1 8e       	M[r4 + 8] = rMAC;
        L2_DBG_MSG("VA_GM: vagm_set_manager_mode: CVC is not present in graph.");
84200718:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420071c:	88 24       	Null = rMAC - 2;
8420071e:	07 68       	if LT jump (m) Lc_vagm_set_graph_mode_18;

84200720 <Lc_vagm_set_graph_mode_17>:
84200720:	55 f1 02 f0 	r0 = Null + 357565181;
84200724:	fd 42 
84200726:	ff fd 04 f0 	call (m) 0x10b0;
8420072a:	2b ec 

8420072c <Lc_vagm_set_graph_mode_18>:
    }
    if(value_op_id[3])
8420072c:	38 d8       	Null = M[FP + 28];
8420072e:	0e 60       	if EQ jump (m) Lc_vagm_set_graph_mode_21;

84200730 <Lc_vagm_set_graph_mode_19>:
    {
        ext_data->splitter_op_id = 0xFFFF;
84200730:	71 f0 ff 7b 	rMAC = Null + 65535;
84200734:	f1 8e       	M[r4 + 12] = rMAC;
        L2_DBG_MSG("VA_GM: vagm_set_manager_mode: Splitter is not present in graph");
84200736:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420073a:	88 24       	Null = rMAC - 2;
8420073c:	07 68       	if LT jump (m) Lc_vagm_set_graph_mode_21;

8420073e <Lc_vagm_set_graph_mode_20>:
8420073e:	55 f1 02 f0 	r0 = Null + 357565240;
84200742:	38 43 
84200744:	ff fd 04 f0 	call (m) 0x10b0;
84200748:	2d eb 

8420074a <Lc_vagm_set_graph_mode_21>:
    }

    return TRUE;
8420074a:	42 20       	r0 = Null + 1;

8420074c <Lc_vagm_set_graph_mode_22>:
}
8420074c:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420074e:	d8 4c       	rts;

84200750 <Lc_manage_am_clock_1>:
 * \param trigger_clk checks if trigger clock needs to be set or active mode
 *
 * \return True if success (clock change request is successful)
 */
static void manage_am_clock(OPERATOR_DATA *op_data, bool trigger_clk)
{
84200750:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200752:	1e 00       	r4 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200754:	ff fd 00 f0 	call (m) 0x8ea;
84200758:	37 ec 
     * kalsim builds
     */
#ifndef RUNNING_ON_KALSIM
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned clk_mode;
    if (trigger_clk)
8420075a:	30 04       	Null = r4 - Null;
8420075c:	03 60       	if EQ jump (m) Lc_manage_am_clock_3;

8420075e <Lc_manage_am_clock_2>:
    {   
        clk_mode = ext_data->trigger_mode_clk_val;
8420075e:	d2 99       	r0 = M[r0 + 60];
84200760:	02 6e       	jump (m) Lc_manage_am_clock_4;

84200762 <Lc_manage_am_clock_3>:
    }
    else
    {
        clk_mode = ext_data->active_mode_clk_val;
84200762:	92 99       	r0 = M[r0 + 56];

84200764 <Lc_manage_am_clock_4>:
    }
    vagm_clk_change_req(clk_mode);
84200764:	01 f0 3b e0 	call (m) $_vagm_clk_change_req;

84200768 <Lc_manage_am_clock_5>:
#endif
}
84200768:	f1 48       	popm <FP, r4, rLink>;
8420076a:	d8 4c       	rts;

8420076c <Lc_manage_clock_1>:
 * \param custom_clock Whether we are setting a custom clock (or the default)
 *
 * \return True if success (request successfully sent or no change needed)
 */
static bool manage_clock(OPERATOR_DATA *op_data, bool custom_clock)
{
8420076c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420076e:	17 00       	r5 = r0 + Null;
84200770:	18 09       	r6 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200772:	ff fd 00 f0 	call (m) 0x8ea;
84200776:	39 eb 
84200778:	16 00       	r4 = r0 + Null;
static bool manage_clock(OPERATOR_DATA *op_data, bool custom_clock)
{
    AOV_IF_CPU_CLK clk_val;
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    switch(ext_data->graph_load)
8420077a:	31 a2       	rMAC = MBU[r4 + 16];
8420077c:	48 24       	Null = rMAC - 1;
8420077e:	1e 60       	if EQ jump (m) Lc_manage_clock_11;

84200780 <Lc_manage_clock_2>:
84200780:	88 24       	Null = rMAC - 2;
84200782:	1e 60       	if EQ jump (m) Lc_manage_clock_12;

84200784 <Lc_manage_clock_3>:
84200784:	c8 24       	Null = rMAC - 3;
84200786:	1e 60       	if EQ jump (m) Lc_manage_clock_13;

84200788 <Lc_manage_clock_4>:
84200788:	08 25       	Null = rMAC - 4;
8420078a:	21 62       	if NE jump (m) Lc_manage_clock_15;

8420078c <Lc_manage_clock_5>:
    {
    case OPMSG_VA_GM_LOAD_MAX:
        clk_val = AOV_IF_CPU_CLK_TURBO_PLUS;
8420078c:	41 71       	r7 = Null + 8;

8420078e <Lc_manage_clock_6>:
        break;
    default:
        return TRUE;
    }

    L3_DBG_MSG("VA_GM: request AOV");
8420078e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200792:	c8 24       	Null = rMAC - 3;
84200794:	07 68       	if LT jump (m) Lc_manage_clock_8;

84200796 <Lc_manage_clock_7>:
84200796:	55 f1 02 f0 	r0 = Null + 357565303;
8420079a:	77 43 
8420079c:	ff fd 04 f0 	call (m) 0x10b0;
842007a0:	35 e8 

842007a2 <Lc_manage_clock_8>:

    if (custom_clock)
842007a2:	0f f8 00 c2 	Null = r6 - Null;
842007a6:	15 60       	if EQ jump (m) Lc_manage_clock_16;

842007a8 <Lc_manage_clock_9>:
    {
        if (!aov_request_custom_clock(op_data, clk_val))
842007a8:	4b 08       	r1 = r7 + Null;
842007aa:	3a 00       	r0 = r5 + Null;
842007ac:	ff fd 9b f2 	call (m) 0x53f5c;
842007b0:	31 ed 
842007b2:	10 04       	Null = r0 - Null;
842007b4:	09 62       	if NE jump (m) Lc_manage_clock_14;

842007b6 <Lc_manage_clock_10>:
        {
            return FALSE;
842007b6:	02 00       	r0 = Null + Null;
842007b8:	16 6e       	jump (m) Lc_manage_clock_18;

842007ba <Lc_manage_clock_11>:
    {
    case OPMSG_VA_GM_LOAD_MAX:
        clk_val = AOV_IF_CPU_CLK_TURBO_PLUS;
        break;
    case OPMSG_VA_GM_LOAD_HIGH:
        clk_val = AOV_IF_CPU_CLK_TURBO;
842007ba:	39 71       	r7 = Null + 7;
        break;
842007bc:	e9 6f       	jump (m) Lc_manage_clock_6;

842007be <Lc_manage_clock_12>:
    case OPMSG_VA_GM_LOAD_MEDIUM:
        clk_val = AOV_IF_CPU_CLK_BASE_CLOCK;
842007be:	31 71       	r7 = Null + 6;
        break;
842007c0:	e7 6f       	jump (m) Lc_manage_clock_6;

842007c2 <Lc_manage_clock_13>:
    case OPMSG_VA_GM_LOAD_LOW:
        clk_val = AOV_IF_CPU_CLK_SLOW_CLOCK;
842007c2:	29 71       	r7 = Null + 5;
        break;
842007c4:	e5 6f       	jump (m) Lc_manage_clock_6;

842007c6 <Lc_manage_clock_14>:
    {
        if (!aov_request_custom_clock(op_data, clk_val))
        {
            return FALSE;
        }
        ext_data->aov_operation = SCALE_CUSTOM;
842007c6:	41 20       	rMAC = Null + 1;
842007c8:	61 f0 20 8a 	MB[r4 + 32] = rMAC;

842007cc <Lc_manage_clock_15>:
        break;
    case OPMSG_VA_GM_LOAD_LOW:
        clk_val = AOV_IF_CPU_CLK_SLOW_CLOCK;
        break;
    default:
        return TRUE;
842007cc:	42 20       	r0 = Null + 1;
842007ce:	0b 6e       	jump (m) Lc_manage_clock_18;

842007d0 <Lc_manage_clock_16>:
        }
        ext_data->aov_operation = SCALE_CUSTOM;
    }
    else
    {
        if (!aov_request_default_clock(op_data))
842007d0:	3a 00       	r0 = r5 + Null;
842007d2:	ff fd 9b f2 	call (m) 0x53fa6;
842007d6:	35 ee 
842007d8:	10 04       	Null = r0 - Null;
842007da:	ee 61       	if EQ jump (m) Lc_manage_clock_10;

842007dc <Lc_manage_clock_17>:
        {
            return FALSE;
        }
        ext_data->aov_operation = SCALE_BACK;
842007dc:	81 20       	rMAC = Null + 2;
842007de:	61 f0 20 8a 	MB[r4 + 32] = rMAC;
842007e2:	f5 6f       	jump (m) Lc_manage_clock_15;

842007e4 <Lc_manage_clock_18>:
    }

    return TRUE;
}
842007e4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842007e6:	d8 4c       	rts;

842007e8 <Lc_reinit_wwe_1>:
 *
 *
 * \param op_data Pointer to the operator instance data.
 */
static void reinit_wwe(OPERATOR_DATA *op_data)
{
842007e8:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
842007ea:	16 00       	r4 = r0 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842007ec:	ff fd 00 f0 	call (m) 0x8ea;
842007f0:	3f e7 
842007f2:	17 00       	r5 = r0 + Null;
static void reinit_wwe(OPERATOR_DATA *op_data)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg[OPMSG_COMMON_MSG_REINIT_ALGORITHM_WORD_SIZE];

    L3_DBG_MSG("VA_GM: Reseting WWE");
842007f4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842007f8:	c8 24       	Null = rMAC - 3;
842007fa:	07 68       	if LT jump (m) Lc_reinit_wwe_3;

842007fc <Lc_reinit_wwe_2>:
842007fc:	55 f1 02 f0 	r0 = Null + 357564505;
84200800:	59 40 
84200802:	ff fd 04 f0 	call (m) 0x10b0;
84200806:	2f e5 

84200808 <Lc_reinit_wwe_3>:

    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_MSG_REINIT_ALGORITHM, MESSAGE_ID, OPMSG_COMMON_REINIT_ALGORITHM);
84200808:	11 f0 1d 40 	rMAC = Null + 8221;
8420080c:	21 de       	M[FP + 16] = rMAC;

    opmgr_op_client_send_message(op_data, ext_data->qva_op_id,
                                 OPMSG_COMMON_MSG_REINIT_ALGORITHM_WORD_SIZE,
                                 (unsigned *) &msg);
8420080e:	05 11       	r3 = FP + 16;
84200810:	44 20       	r2 = Null + 1;
84200812:	7b 88       	r1 = M[r5 + 4];
84200814:	32 00       	r0 = r4 + Null;
84200816:	ff fd 2b f0 	call (m) 0x5f62;
8420081a:	2d ea 

8420081c <Lc_reinit_wwe_4>:
}
8420081c:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420081e:	d8 4c       	rts;

84200820 <Lc_configure_vad_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param mode Operation mode to set VAD.
 */
static void configure_vad(OPERATOR_DATA *op_data, OPMSG_VAD_MODE mode)
{
84200820:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200822:	16 00       	r4 = r0 + Null;
84200824:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200826:	ff fd 00 f0 	call (m) 0x8ea;
8420082a:	25 e6 
8420082c:	10 09       	r6 = r0 + Null;
static void configure_vad(OPERATOR_DATA *op_data, OPMSG_VAD_MODE mode)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg[OPMSG_VAD_MODE_CHANGE_WORD_SIZE];

    L3_DBG_MSG("VA_GM: Configuring VAD");
8420082e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200832:	c8 24       	Null = rMAC - 3;
84200834:	07 68       	if LT jump (m) Lc_configure_vad_3;

84200836 <Lc_configure_vad_2>:
84200836:	55 f1 02 f0 	r0 = Null + 357564459;
8420083a:	2b 40 
8420083c:	ff fd 04 f0 	call (m) 0x10b0;
84200840:	35 e3 

84200842 <Lc_configure_vad_3>:

    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_VAD_MODE_CHANGE, MESSAGE_ID, OPMSG_VAD_ID_MODE_CHANGE);
84200842:	41 20       	rMAC = Null + 1;
84200844:	29 de       	M[FP + 20] = rMAC;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_VAD_MODE_CHANGE, WORKING_MODE, mode);
84200846:	37 de       	M[FP + 24] = r5;

    opmgr_op_client_send_message(op_data, ext_data->vad_op_id,
                                 OPMSG_VAD_MODE_CHANGE_WORD_SIZE,
                                 (unsigned *) &msg);
84200848:	45 11       	r3 = FP + 20;
8420084a:	84 20       	r2 = Null + 2;
8420084c:	83 f0 00 e8 	r1 = M[r6 + Null];
84200850:	32 00       	r0 = r4 + Null;
84200852:	ff fd 2b f0 	call (m) 0x5f62;
84200856:	31 e8 

84200858 <Lc_configure_vad_4>:
}
84200858:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420085a:	d8 4c       	rts;

8420085c <Lc_configure_qva_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param mode Operation mode to set QVA.
 */
static void configure_qva(OPERATOR_DATA *op_data, OPMSG_QVA_MODE mode)
{
8420085c:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
8420085e:	16 00       	r4 = r0 + Null;
84200860:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
84200862:	ff fd 00 f0 	call (m) 0x8ea;
84200866:	29 e4 
84200868:	10 09       	r6 = r0 + Null;
static void configure_qva(OPERATOR_DATA *op_data, OPMSG_QVA_MODE mode)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg[OPMSG_QVA_MODE_CHANGE_WORD_SIZE];

    L3_DBG_MSG("VA_GM: Configuring QVA");
8420086a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420086e:	c8 24       	Null = rMAC - 3;
84200870:	07 68       	if LT jump (m) Lc_configure_qva_3;

84200872 <Lc_configure_qva_2>:
84200872:	55 f1 02 f0 	r0 = Null + 357564482;
84200876:	42 40 
84200878:	ff fd 04 f0 	call (m) 0x10b0;
8420087c:	39 e1 

8420087e <Lc_configure_qva_3>:

    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_QVA_MODE_CHANGE, MESSAGE_ID, OPMSG_QVA_ID_MODE_CHANGE);
8420087e:	41 20       	rMAC = Null + 1;
84200880:	29 de       	M[FP + 20] = rMAC;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_QVA_MODE_CHANGE, WORKING_MODE, mode);
84200882:	37 de       	M[FP + 24] = r5;

    opmgr_op_client_send_message(op_data, ext_data->qva_op_id,
                                 OPMSG_QVA_MODE_CHANGE_WORD_SIZE,
                                 (unsigned *) &msg);
84200884:	45 11       	r3 = FP + 20;
84200886:	84 20       	r2 = Null + 2;
84200888:	83 f0 01 88 	r1 = M[r6 + 4];
8420088c:	32 00       	r0 = r4 + Null;
8420088e:	ff fd 2b f0 	call (m) 0x5f62;
84200892:	35 e6 

84200894 <Lc_configure_qva_4>:
}
84200894:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200896:	d8 4c       	rts;

84200898 <Lc_configure_cvc_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param mode Operation mode to set CVC.
 */
static void configure_cvc(OPERATOR_DATA *op_data, OPMSG_CVC_SEND_MODE mode)
{
84200898:	f3 1e       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x20;
8420089a:	16 00       	r4 = r0 + Null;
8420089c:	1f 00       	r5 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
8420089e:	ff fd 00 f0 	call (m) 0x8ea;
842008a2:	2d e2 
842008a4:	10 09       	r6 = r0 + Null;
static void configure_cvc(OPERATOR_DATA *op_data, OPMSG_CVC_SEND_MODE mode)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);
    unsigned msg[OPMSG_COMMON_SET_CONTROL_WORD_SIZE];

    L3_DBG_MSG("VA_GM: Configuring CVC");
842008a6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842008aa:	c8 24       	Null = rMAC - 3;
842008ac:	07 68       	if LT jump (m) Lc_configure_cvc_3;

842008ae <Lc_configure_cvc_2>:
842008ae:	55 f1 02 f0 	r0 = Null + 357564525;
842008b2:	6d 40 
842008b4:	ff fd 03 f0 	call (m) 0x10b0;
842008b8:	3d ef 

842008ba <Lc_configure_cvc_3>:

    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_SET_CONTROL, MESSAGE_ID, OPMSG_COMMON_ID_SET_CONTROL);
842008ba:	11 f0 02 40 	rMAC = Null + 8194;
842008be:	29 de       	M[FP + 20] = rMAC;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_SET_CONTROL, NUM_BLOCKS, 1);
842008c0:	41 20       	rMAC = Null + 1;
842008c2:	31 de       	M[FP + 24] = rMAC;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_SET_CONTROL, CONTROL_ID, OPMSG_CONTROL_MODE_ID);
842008c4:	39 de       	M[FP + 28] = rMAC;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_SET_CONTROL, VALUE_MSW, 0);
842008c6:	40 de       	M[FP + 32] = Null;
    OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_COMMON_SET_CONTROL, VALUE_LSW, mode);
842008c8:	4f de       	M[FP + 36] = r5;

    opmgr_op_client_send_message(op_data, ext_data->cvc_op_id,
                                 OPMSG_COMMON_SET_CONTROL_WORD_SIZE,
                                 (unsigned *) &msg);
842008ca:	45 11       	r3 = FP + 20;
842008cc:	44 21       	r2 = Null + 5;
842008ce:	83 f0 02 88 	r1 = M[r6 + 8];
842008d2:	32 00       	r0 = r4 + Null;
842008d4:	ff fd 2b f0 	call (m) 0x5f62;
842008d8:	2f e4 

842008da <Lc_configure_cvc_4>:
}
842008da:	f3 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, rLink>;
842008dc:	d8 4c       	rts;

842008de <Lc_configure_splitter_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param mode Operation mode to set Splitter.
 */
static void configure_splitter(OPERATOR_DATA *op_data, OPMSG_SPLITTER_ID mode)
{
842008de:	f3 1e       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x20;
842008e0:	17 00       	r5 = r0 + Null;
842008e2:	18 09       	r6 = r1 + Null;
MAP_INSTANCE_DATA(CAP_ID_DOWNLOAD_VA_GRAPH_MANAGER, VAGM_OP_DATA)
#endif /* CAPABILITY_DOWNLOAD_BUILD */

static inline VAGM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VAGM_OP_DATA *) base_op_get_instance_data(op_data);
842008e4:	ff fd 00 f0 	call (m) 0x8ea;
842008e8:	27 e0 
842008ea:	16 00       	r4 = r0 + Null;
 */
static void configure_splitter(OPERATOR_DATA *op_data, OPMSG_SPLITTER_ID mode)
{
    VAGM_OP_DATA *ext_data = get_instance_data(op_data);

    L3_DBG_MSG("VA_GM: Configuring Splitter");
842008ec:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842008f0:	c8 24       	Null = rMAC - 3;
842008f2:	07 68       	if LT jump (m) Lc_configure_splitter_3;

842008f4 <Lc_configure_splitter_2>:
842008f4:	55 f1 02 f0 	r0 = Null + 357564548;
842008f8:	84 40 
842008fa:	ff fd 03 f0 	call (m) 0x10b0;
842008fe:	37 ed 

84200900 <Lc_configure_splitter_3>:

    switch(mode)
84200900:	80 f0 03 24 	Null = r6 - 3;
84200904:	1f 60       	if EQ jump (m) Lc_configure_splitter_8;

84200906 <Lc_configure_splitter_4>:
84200906:	80 f0 04 24 	Null = r6 - 4;
8420090a:	10 60       	if EQ jump (m) Lc_configure_splitter_7;

8420090c <Lc_configure_splitter_5>:
8420090c:	80 f0 05 24 	Null = r6 - 5;
84200910:	30 62       	if NE jump (m) Lc_configure_splitter_9;

84200912 <Lc_configure_splitter_6>:
        break;
    }
    case OPMSG_SPLITTER_ID_BUFFER_STREAMS:
    {
        unsigned msg[OPMSG_SPLITTER_BUFFER_STREAMS_WORD_SIZE];
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_BUFFER_STREAMS, MESSAGE_ID, OPMSG_SPLITTER_ID_BUFFER_STREAMS);
84200912:	41 21       	rMAC = Null + 5;
84200914:	59 de       	M[FP + 44] = rMAC;
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_BUFFER_STREAMS, STREAMS, SPLITTER_STREAMS_BIT);
84200916:	41 20       	rMAC = Null + 1;
84200918:	61 de       	M[FP + 48] = rMAC;

        opmgr_op_client_send_message(op_data, ext_data->splitter_op_id,
                                     OPMSG_SPLITTER_DEACTIVATE_STREAMS_WORD_SIZE,
                                     msg);
8420091a:	c5 12       	r3 = FP + 44;
8420091c:	84 20       	r2 = Null + 2;
8420091e:	f3 88       	r1 = M[r4 + 12];
84200920:	3a 00       	r0 = r5 + Null;
84200922:	ff fd 2b f0 	call (m) 0x5f62;
84200926:	21 e2 
        break;
84200928:	24 6e       	jump (m) Lc_configure_splitter_9;

8420092a <Lc_configure_splitter_7>:
    switch(mode)
    {
    case OPMSG_SPLITTER_ID_DEACTIVATE_STREAMS:
    {
        unsigned msg[OPMSG_SPLITTER_DEACTIVATE_STREAMS_WORD_SIZE];
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_DEACTIVATE_STREAMS, MESSAGE_ID, OPMSG_SPLITTER_ID_DEACTIVATE_STREAMS);
8420092a:	01 21       	rMAC = Null + 4;
8420092c:	29 de       	M[FP + 20] = rMAC;
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_DEACTIVATE_STREAMS, STREAMS, SPLITTER_STREAMS_BIT);
8420092e:	41 20       	rMAC = Null + 1;
84200930:	31 de       	M[FP + 24] = rMAC;

        opmgr_op_client_send_message(op_data, ext_data->splitter_op_id,
                                     OPMSG_SPLITTER_DEACTIVATE_STREAMS_WORD_SIZE,
                                     msg);
84200932:	45 11       	r3 = FP + 20;
84200934:	84 20       	r2 = Null + 2;
84200936:	f3 88       	r1 = M[r4 + 12];
84200938:	3a 00       	r0 = r5 + Null;
8420093a:	ff fd 2b f0 	call (m) 0x5f62;
8420093e:	29 e1 
        break;
84200940:	18 6e       	jump (m) Lc_configure_splitter_9;

84200942 <Lc_configure_splitter_8>:
        /* Get the current time and calculate the time offset to send to the
         * splitter. The splitter will forward audio samples to QVA from
         * roughly that time onwards.
         * NOTE: This timing is approximate and is only used to provide QVA
         * with a few more frames prior to the one on which VAD triggered. */
        TIME start_time = time_get_time();
84200942:	ff fd 2f f0 	call (m) 0x679c;
84200946:	3b e2 
        start_time = time_sub(start_time, ext_data->buffer_time_offset_ms*1000);
84200948:	f1 98       	rMAC = M[r4 + 44];
8420094a:	03 f0 e8 f1 	rMAC = rMAC * 1000 (int);
8420094e:	91 d9 
84200950:	52 04       	r0 = r0 - rMAC;

        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, MESSAGE_ID, OPMSG_SPLITTER_ID_ACTIVATE_STREAMS_AFTER_TIMESTAMP);
84200952:	c1 20       	rMAC = Null + 3;
84200954:	39 de       	M[FP + 28] = rMAC;
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, STREAMS, SPLITTER_STREAMS_BIT);
84200956:	41 20       	rMAC = Null + 1;
84200958:	41 de       	M[FP + 32] = rMAC;
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_MS, TIME_GET_MS(start_time));
8420095a:	93 52       	r1 = r0 LSHIFT -16;
8420095c:	4b de       	M[FP + 36] = r1;
        OP_CLIENT_MSG_FIELD_SET(msg, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_LS, TIME_GET_LS(start_time));
8420095e:	91 c6       	rMAC = r0 AND 0xffff;
84200960:	51 de       	M[FP + 40] = rMAC;

        opmgr_op_client_send_message(op_data, ext_data->splitter_op_id,
                                     OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP_WORD_SIZE,
                                     msg);
84200962:	c5 11       	r3 = FP + 28;
84200964:	04 21       	r2 = Null + 4;
84200966:	f3 88       	r1 = M[r4 + 12];
84200968:	3a 00       	r0 = r5 + Null;
8420096a:	ff fd 2a f0 	call (m) 0x5f62;
8420096e:	39 ef 

84200970 <Lc_configure_splitter_9>:
        break;
84200970:	f3 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, rLink>;
84200972:	d8 4c       	rts;

84200974 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_va_graph_manager_cap_data;
84200974:	01 f0 02 f3 	r0 = Null + 1441792;
84200978:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
8420097a:	00 f0 4c 5a 	Null = Null + 3660;

8420097e <$_vagm_clk_change_req>:
8420097e:	01 f1 03 88 	rMAC = M[Null + 0x200c];
.CODESEGMENT PM;
.MINIM;
$_vagm_clk_change_req:
#ifdef ENTRY_POINT_VAGM_MANAGE_CLK
    rMAC = M[$_patched_fw_version];
    Null = rMAC - PATCH_BUILD_ID;
84200982:	01 f0 10 f3 	Null = rMAC - 32094;
84200986:	5e 3d 
    if NZ rts;
84200988:	01 fd c0 cd 	if NE rts;
    // patch is compatible, so enable/disable the feature.
    jump ENTRY_POINT_VAGM_MANAGE_CLK;
8420098c:	fc ff ff f1 	jump (m) 0x40102d4;
84200990:	c9 e2 
