
/home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/tools/KCSMaker/out/14612/maor_rom_release/download/debugbin/download_aanc_external.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

842005c0 <$_aanc_create>:
Capability API Handlers
*/

bool aanc_create(OPERATOR_DATA *op_data, void *message_data,
                 unsigned *response_id, void **resp_data)
{
842005c0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842005c2:	17 00       	r5 = r0 + Null;
842005c4:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
842005c6:	ff fd 01 f0 	call (m) 0x8ea;
842005ca:	25 e9 
842005cc:	16 00       	r4 = r0 + Null;

    /* NB: create is passed a zero-initialized structure so any fields not
     * explicitly initialized are 0.
     */

    L5_DBG_MSG1("AANC Create: p_ext_data at %p", p_ext_data);
842005ce:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842005d2:	48 25       	Null = rMAC - 5;
842005d4:	08 68       	if LT jump (m) Lc_aanc_create_3;

842005d6 <Lc_aanc_create_2>:
842005d6:	55 f1 02 f0 	r0 = Null + 357564899;
842005da:	e3 41 
842005dc:	33 00       	r1 = r4 + Null;
842005de:	ff fd 05 f0 	call (m) 0x10c2;
842005e2:	25 e7 

842005e4 <Lc_aanc_create_3>:

    if (!base_op_create_lite(op_data, resp_data))
842005e4:	43 08       	r1 = r6 + Null;
842005e6:	3a 00       	r0 = r5 + Null;
842005e8:	ff fd 01 f0 	call (m) 0x850;
842005ec:	29 e3 
842005ee:	10 04       	Null = r0 - Null;
842005f0:	03 62       	if NE jump (m) Lc_aanc_create_5;

842005f2 <Lc_aanc_create_4>:
    {
        return FALSE;
842005f2:	02 00       	r0 = Null + Null;
842005f4:	7e 6e       	jump (m) Lc_aanc_create_18;

842005f6 <Lc_aanc_create_5>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842005f6:	01 f0 00 60 	rMAC = Null + 4096;
842005fa:	82 f0 00 e8 	r0 = M[r6 + Null];
842005fe:	51 8e       	M[r0 + 4] = rMAC;
84200600:	31 00       	rMAC = r4 + Null;
     * termination point in create then change it to STATUS_OK.
     */
    base_op_change_response_status(resp_data, STATUS_CMD_FAILED);

    /* Initialize buffers */
    for (i = 0; i < AANC_MAX_SINKS; i++)
84200602:	24 71       	r10 = Null + 4;
84200604:	03 4c       	do (m) Lc__loop0;

84200606 <Lc_aanc_create_6>:
    {
        p_ext_data->inputs[i] = NULL;
84200606:	08 ee       	M[rMAC + Null] = Null;
84200608:	09 21       	rMAC = rMAC + 4;

8420060a <Lc__loop0>:
     * termination point in create then change it to STATUS_OK.
     */
    base_op_change_response_status(resp_data, STATUS_CMD_FAILED);

    /* Initialize buffers */
    for (i = 0; i < AANC_MAX_SINKS; i++)
8420060a:	31 28       	rMAC = r4 + 16;
    {
        p_ext_data->inputs[i] = NULL;
    }
    for (i = 0; i < AANC_MAX_SOURCES; i++)
8420060c:	24 71       	r10 = Null + 4;
8420060e:	03 4c       	do (m) Lc__loop1;

84200610 <Lc_aanc_create_8>:
    {
        p_ext_data->outputs[i] = NULL;
84200610:	08 ee       	M[rMAC + Null] = Null;
84200612:	09 21       	rMAC = rMAC + 4;

84200614 <Lc__loop1>:
    /* Initialize buffers */
    for (i = 0; i < AANC_MAX_SINKS; i++)
    {
        p_ext_data->inputs[i] = NULL;
    }
    for (i = 0; i < AANC_MAX_SOURCES; i++)
84200614:	31 30       	rMAC = r4 + 32;
    {
        p_ext_data->outputs[i] = NULL;
    }

    for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
84200616:	14 71       	r10 = Null + 2;
84200618:	04 4c       	do (m) Lc__loop2;

8420061a <Lc_aanc_create_10>:
    {
        p_ext_data->metadata_ip[i] = NULL;
8420061a:	08 ee       	M[rMAC + Null] = Null;
        p_ext_data->metadata_op[i] = NULL;
8420061c:	88 8e       	M[rMAC + 8] = Null;
8420061e:	09 21       	rMAC = rMAC + 4;

84200620 <Lc__loop2>:
    for (i = 0; i < AANC_MAX_SOURCES; i++)
    {
        p_ext_data->outputs[i] = NULL;
    }

    for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
84200620:	21 f0 9f 40 	rMAC = Null + 16543;
84200624:	b1 9f       	M[r4 + 56] = rMAC;
        p_ext_data->metadata_op[i] = NULL;
    }

    /* Initialize capid and sample rate fields */
    p_ext_data->cap_id = AANC_MONO_16K_CAP_ID;
    p_ext_data->sample_rate = 16000;
84200626:	11 f0 80 7a 	rMAC = Null + 16000;
8420062a:	71 9f       	M[r4 + 52] = rMAC;

    /* Initialize parameters */
    p_default_params = (unsigned*) AANC_GetDefaults(p_ext_data->cap_id);
8420062c:	22 f0 9f 40 	r0 = Null + 16543;
84200630:	0c f0 3b ee 	call (m) $_AANC_GetDefaults;
84200634:	13 00       	r1 = r0 + Null;
    p_cap_params = (unsigned*) &p_ext_data->aanc_cap_params;
84200636:	34 3b       	r2 = r4 + 60;
    if(!cpsInitParameters(&p_ext_data->params_def, p_default_params,
                          p_cap_params, sizeof(AANC_PARAMETERS)))
84200638:	05 f0 5c 41 	r3 = Null + 348;
8420063c:	42 f0 d4 21 	r0 = r2 + 468;
84200640:	ff fd 02 f0 	call (m) 0xb2a;
84200644:	2b e7 
84200646:	10 04       	Null = r0 - Null;
84200648:	20 60       	if EQ jump (m) Lc_aanc_create_15;

8420064a <Lc_aanc_create_12>:
    {
       return TRUE;
    }

    /* Initialize system mode */
    p_ext_data->cur_mode = AANC_SYSMODE_FULL;
8420064a:	81 20       	rMAC = Null + 2;
8420064c:	61 f0 66 8e 	M[r4 + 408] = rMAC;
    p_ext_data->host_mode = AANC_SYSMODE_FULL;
84200650:	61 f0 67 8e 	M[r4 + 412] = rMAC;
    p_ext_data->qact_mode = AANC_SYSMODE_FULL;
84200654:	61 f0 68 8e 	M[r4 + 416] = rMAC;

    /* Trigger re-initialization at start */
    p_ext_data->re_init_flag = TRUE;
84200658:	41 20       	rMAC = Null + 1;
8420065a:	61 f0 02 9a 	MB[r4 + 514] = rMAC;
    p_ext_data->re_init_hard = TRUE;
8420065e:	61 f0 03 9a 	MB[r4 + 515] = rMAC;
    
    /* Initialize connect flag */
    p_ext_data->connect_flag = FALSE;
84200662:	60 f0 82 8e 	M[r4 + 520] = Null;

    if (!aanc_proc_create(&p_ext_data->ag, p_ext_data->sample_rate))
84200666:	73 99       	r1 = M[r4 + 52];
84200668:	62 f0 bc 21 	r0 = r4 + 444;
8420066c:	0c f0 39 ed 	call (m) $_aanc_proc_create;
84200670:	10 04       	Null = r0 - Null;
84200672:	0d 62       	if NE jump (m) Lc_aanc_create_16;

84200674 <Lc_aanc_create_13>:
    {
        L4_DBG_MSG("Failed to create AG data");
84200674:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200678:	08 25       	Null = rMAC - 4;
8420067a:	07 68       	if LT jump (m) Lc_aanc_create_15;

8420067c <Lc_aanc_create_14>:
8420067c:	55 f1 02 f0 	r0 = Null + 357564929;
84200680:	01 42 
84200682:	ff fd 05 f0 	call (m) 0x10b0;
84200686:	2f e1 

84200688 <Lc_aanc_create_15>:
    p_default_params = (unsigned*) AANC_GetDefaults(p_ext_data->cap_id);
    p_cap_params = (unsigned*) &p_ext_data->aanc_cap_params;
    if(!cpsInitParameters(&p_ext_data->params_def, p_default_params,
                          p_cap_params, sizeof(AANC_PARAMETERS)))
    {
       return TRUE;
84200688:	42 20       	r0 = Null + 1;
8420068a:	33 6e       	jump (m) Lc_aanc_create_18;

8420068c <Lc_aanc_create_16>:
    {
        L4_DBG_MSG("Failed to create AG data");
        return TRUE;
    }

    p_ext_data->filter_config = AANC_FILTER_CONFIG_SINGLE;
8420068c:	60 f0 dc 8c 	MH[r4 + 440] = Null;
    p_ext_data->anc_channel = AANC_ANC_INSTANCE_ANC0_ID;
84200690:	41 20       	rMAC = Null + 1;
84200692:	61 f0 fc 8b 	MB[r4 + 508] = rMAC;
    p_ext_data->anc_mask = AANC_ANC_INSTANCE_ANC0_ID;
84200696:	61 f0 fd 8b 	MB[r4 + 509] = rMAC;
    /* Default to hybrid: ff path is FFB, fb path is FFA */
    p_ext_data->anc_ff_path = AANC_ANC_PATH_FFB_ID;
8420069a:	82 20       	r0 = Null + 2;
8420069c:	62 f0 fe 8b 	MB[r4 + 510] = r0;
    p_ext_data->anc_fb_path = AANC_ANC_PATH_FFA_ID;
842006a0:	61 f0 ff 8b 	MB[r4 + 511] = rMAC;
    p_ext_data->anc_clock_check_value = AANC_HYBRID_ENABLE;
842006a4:	c1 23       	rMAC = Null + 15;
842006a6:	61 f0 00 8d 	MH[r4 + 512] = rMAC;

#ifdef USE_AANC_LICENSING
    p_ext_data->license_status = AANC_LICENSE_STATUS_LICENSING_BUILD_STATUS;
842006aa:	00 f1 01 f0 	rMAC = Null + 268435456;
842006ae:	00 40 
842006b0:	61 f0 83 8e 	M[r4 + 524] = rMAC;
#endif

    p_ext_data->ff_ramp.p_gain = &p_ext_data->ff_gain.fine;
842006b4:	61 f0 c2 21 	rMAC = r4 + 450;
842006b8:	61 f0 a8 8e 	M[r4 + 672] = rMAC;
    p_ext_data->ff_ramp.p_static = &p_ext_data->ff_static_gain.fine;
842006bc:	0a 32       	r0 = rMAC + 40;
842006be:	62 f0 a9 8e 	M[r4 + 676] = r0;
    p_ext_data->fb_ramp.p_gain = &p_ext_data->fb_gain.fine;
842006c2:	0a 21       	r0 = rMAC + 4;
842006c4:	62 f0 af 8e 	M[r4 + 700] = r0;
    p_ext_data->fb_ramp.p_static = &p_ext_data->fb_static_gain.fine;
842006c8:	09 33       	rMAC = rMAC + 44;
842006ca:	61 f0 b0 8e 	M[r4 + 704] = rMAC;

    aanc_initialize_prev_gain(p_ext_data);
842006ce:	32 00       	r0 = r4 + Null;
842006d0:	09 f0 33 e9 	call (m) Lc_aanc_initialize_prev_gain_1;
842006d4:	81 f0 00 e8 	rMAC = M[r6 + Null];
842006d8:	48 8e       	M[rMAC + 4] = Null;

    /* Operator creation was succesful, change respone to STATUS_OK*/
    base_op_change_response_status(resp_data, STATUS_OK);

    L4_DBG_MSG("AANC: Created");
842006da:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842006de:	08 25       	Null = rMAC - 4;
842006e0:	d4 69       	if LT jump (m) Lc_aanc_create_15;

842006e2 <Lc_aanc_create_17>:
842006e2:	55 f1 02 f0 	r0 = Null + 357564954;
842006e6:	1a 42 
842006e8:	ff fd 04 f0 	call (m) 0x10b0;
842006ec:	29 ee 
842006ee:	cd 6f       	jump (m) Lc_aanc_create_15;

842006f0 <Lc_aanc_create_18>:
    return TRUE;
}
842006f0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842006f2:	d8 4c       	rts;

842006f4 <$_aanc_destroy>:

bool aanc_destroy(OPERATOR_DATA *op_data, void *message_data,
                  unsigned *response_id, void **resp_data)
{
842006f4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842006f6:	16 00       	r4 = r0 + Null;
842006f8:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
842006fa:	ff fd 00 f0 	call (m) 0x8ea;
842006fe:	31 ef 
84200700:	17 00       	r5 = r0 + Null;
                  unsigned *response_id, void **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);

    /* call base_op destroy that creates and fills response message, too */
    if (!base_op_destroy_lite(op_data, resp_data))
84200702:	43 08       	r1 = r6 + Null;
84200704:	32 00       	r0 = r4 + Null;
84200706:	ff fd 00 f0 	call (m) 0x834;
8420070a:	2f e9 
8420070c:	10 04       	Null = r0 - Null;
8420070e:	03 62       	if NE jump (m) Lc_aanc_destroy_3;

84200710 <Lc_aanc_destroy_2>:
    {
        return FALSE;
84200710:	02 00       	r0 = Null + Null;
84200712:	1c 6e       	jump (m) Lc_aanc_destroy_9;

84200714 <Lc_aanc_destroy_3>:
    }

    /* patch_fn_shared(aanc_capability); TODO: patch functions */

    if (p_ext_data != NULL)
84200714:	38 04       	Null = r5 - Null;
84200716:	0f 60       	if EQ jump (m) Lc_aanc_destroy_6;

84200718 <Lc_aanc_destroy_4>:
    {
        aanc_proc_destroy(&p_ext_data->ag);
84200718:	72 f0 bc 21 	r0 = r5 + 444;
8420071c:	0e f0 3b e1 	call (m) $_aanc_proc_destroy;

        L4_DBG_MSG("AANC: Cleanup complete.");
84200720:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200724:	08 25       	Null = rMAC - 4;
84200726:	11 68       	if LT jump (m) Lc_aanc_destroy_8;

84200728 <Lc_aanc_destroy_5>:
84200728:	55 f1 02 f0 	r0 = Null + 357564968;
8420072c:	28 42 
8420072e:	ff fd 04 f0 	call (m) 0x10b0;
84200732:	23 ec 

84200734 <Lc_aanc_destroy_6>:
    }

    L4_DBG_MSG("AANC: Destroyed");
84200734:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200738:	08 25       	Null = rMAC - 4;
8420073a:	07 68       	if LT jump (m) Lc_aanc_destroy_8;

8420073c <Lc_aanc_destroy_7>:
8420073c:	55 f1 02 f0 	r0 = Null + 357564992;
84200740:	40 42 
84200742:	ff fd 04 f0 	call (m) 0x10b0;
84200746:	2f eb 

84200748 <Lc_aanc_destroy_8>:
    return TRUE;
84200748:	42 20       	r0 = Null + 1;

8420074a <Lc_aanc_destroy_9>:
}
8420074a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420074c:	d8 4c       	rts;

8420074e <$_aanc_start>:

bool aanc_start(OPERATOR_DATA *op_data, void *message_data,
                unsigned *response_id, void **resp_data)
{
8420074e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200750:	11 09       	r7 = r0 + Null;
84200752:	2a 09       	r8 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200754:	ff fd 00 f0 	call (m) 0x8ea;
84200758:	37 ec 
8420075a:	16 00       	r4 = r0 + Null;
    /* FF, FB fine gain ramp variables: duration, delay, target */
    unsigned ff_dur, fb_dur, fb_dly;
    uint16 ff_tgt, fb_tgt;

    /* Start with the assumption that we fail and change later if we succeed */
    if (!base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, resp_data))
8420075c:	03 f0 00 60 	r1 = Null + 4096;
84200760:	54 08       	r2 = r8 + Null;
84200762:	4a 08       	r0 = r7 + Null;
84200764:	ff fd 00 f0 	call (m) 0x8c0;
84200768:	3d ea 
8420076a:	10 04       	Null = r0 - Null;
8420076c:	03 62       	if NE jump (m) Lc_aanc_start_3;

8420076e <Lc_aanc_start_2>:
    {
        return FALSE;
8420076e:	02 00       	r0 = Null + Null;
84200770:	61 6e       	jump (m) Lc_aanc_start_14;

84200772 <Lc_aanc_start_3>:
    }

    /* Initialize coarse gains to static values */
    p_ext_data->ec_gain.coarse = p_ext_data->ec_static_gain.coarse;
84200772:	61 f0 f8 86 	rMAC = MHU[r4 + 496];
84200776:	61 f0 e4 8c 	MH[r4 + 456] = rMAC;
    p_ext_data->fb_gain.coarse = p_ext_data->fb_static_gain.coarse;
8420077a:	61 f0 f6 86 	rMAC = MHU[r4 + 492];
8420077e:	61 f0 e2 8c 	MH[r4 + 452] = rMAC;
    p_ext_data->ff_gain.coarse = p_ext_data->ff_static_gain.coarse;
84200782:	61 f0 f4 86 	rMAC = MHU[r4 + 488];
84200786:	61 f0 e0 8c 	MH[r4 + 448] = rMAC;

    /* EC fine gain is not mode depedent */
    p_ext_data->ec_gain.fine = p_ext_data->ec_static_gain.fine;
8420078a:	61 f0 f9 86 	rMAC = MHU[r4 + 498];
8420078e:	61 f0 e5 8c 	MH[r4 + 458] = rMAC;

#ifdef AANC_MAOR_V20
    /* Rx FFA/FFB mix gains are not mode dependent */
    p_ext_data->rx_ffa_mix_gain = p_ext_data->rx_ffa_mix_static_gain;
84200792:	61 f0 fa 86 	rMAC = MHU[r4 + 500];
84200796:	62 f0 fb 86 	r0 = MHU[r4 + 502];
8420079a:	61 f0 e6 8c 	MH[r4 + 460] = rMAC;
8420079e:	62 f0 e7 8c 	MH[r4 + 462] = r0;
    p_ext_data->rx_ffb_mix_gain = p_ext_data->rx_ffb_mix_static_gain;
842007a2:	61 f0 fc 86 	rMAC = MHU[r4 + 504];
842007a6:	62 f0 fd 86 	r0 = MHU[r4 + 506];
842007aa:	61 f0 e8 8c 	MH[r4 + 464] = rMAC;
842007ae:	62 f0 e9 8c 	MH[r4 + 466] = r0;
#endif

    /* FF and FB fine gains are updated in the first process frame */
    p_ext_data->fb_gain.fine = 0;
842007b2:	60 f0 e3 8c 	MH[r4 + 454] = Null;
    p_ext_data->ff_gain.fine = 0;
842007b6:	60 f0 e1 8c 	MH[r4 + 450] = Null;

    ff_dur = p_ext_data->aanc_cap_params.OFFSET_FF_FINE_RAMP_UP_TIMER;
842007ba:	64 f0 63 88 	r2 = M[r4 + 396];
    fb_dur = p_ext_data->aanc_cap_params.OFFSET_FB_FINE_RAMP_UP_TIMER;
842007be:	68 f0 64 88 	r6 = M[r4 + 400];
    fb_dly = p_ext_data->aanc_cap_params.OFFSET_FB_FINE_RAMP_DELAY_TIMER;
842007c2:	67 f0 65 88 	r5 = M[r4 + 404];

    switch (p_ext_data->cur_mode)
842007c6:	61 f0 66 88 	rMAC = M[r4 + 408];
842007ca:	88 24       	Null = rMAC - 2;
842007cc:	0c 60       	if EQ jump (m) Lc_aanc_start_8;

842007ce <Lc_aanc_start_4>:
842007ce:	c8 24       	Null = rMAC - 3;
842007d0:	07 60       	if EQ jump (m) Lc_aanc_start_7;

842007d2 <Lc_aanc_start_5>:
842007d2:	88 25       	Null = rMAC - 6;
842007d4:	18 62       	if NE jump (m) Lc_aanc_start_11;

842007d6 <Lc_aanc_start_6>:
            fb_tgt = p_ext_data->fb_static_gain.fine;
            aanc_initialize_ramp(&p_ext_data->fb_ramp, fb_tgt, fb_dur, fb_dly);
            break;
        /* Quiet ramps FB fine gain to static/2 */
        case AANC_SYSMODE_QUIET:
            fb_tgt = (uint16)(p_ext_data->fb_static_gain.fine >> 1);
842007d6:	62 f0 f7 86 	r0 = MHU[r4 + 494];
842007da:	13 58       	r1 = r0 ASHIFT -1;
842007dc:	0e 6e       	jump (m) Lc_aanc_start_10;

842007de <Lc_aanc_start_7>:

    switch (p_ext_data->cur_mode)
    {
        /* Static ramps FF and FB fine gains */
        case AANC_SYSMODE_STATIC:
            ff_tgt = p_ext_data->ff_static_gain.fine;
842007de:	63 f0 f5 86 	r1 = MHU[r4 + 490];
842007e2:	04 6e       	jump (m) Lc_aanc_start_9;

842007e4 <Lc_aanc_start_8>:
            fb_tgt = p_ext_data->fb_static_gain.fine;
            aanc_initialize_ramp(&p_ext_data->fb_ramp, fb_tgt, fb_dur, fb_dly);
            break;
        /* Full ramps FF and FB fine gains */
        case AANC_SYSMODE_FULL:
            ff_tgt = (uint16)p_ext_data->aanc_cap_params.OFFSET_FXLMS_INITIAL_VALUE;
842007e4:	61 f0 55 88 	rMAC = M[r4 + 340];
842007e8:	8b c6       	r1 = rMAC AND 0xffff;

842007ea <Lc_aanc_start_9>:
    switch (p_ext_data->cur_mode)
    {
        /* Static ramps FF and FB fine gains */
        case AANC_SYSMODE_STATIC:
            ff_tgt = p_ext_data->ff_static_gain.fine;
            aanc_initialize_ramp(&p_ext_data->ff_ramp, ff_tgt, ff_dur, 0);
842007ea:	62 f0 90 22 	r0 = r4 + 656;
842007ee:	05 00       	r3 = Null + Null;
842007f0:	0b f0 23 ec 	call (m) Lc_aanc_initialize_ramp_1;

            fb_tgt = p_ext_data->fb_static_gain.fine;
842007f4:	63 f0 f7 86 	r1 = MHU[r4 + 494];

842007f8 <Lc_aanc_start_10>:
            aanc_initialize_ramp(&p_ext_data->fb_ramp, fb_tgt, fb_dur, fb_dly);
842007f8:	62 f0 ac 22 	r0 = r4 + 684;
842007fc:	3d 00       	r3 = r5 + Null;
842007fe:	44 08       	r2 = r6 + Null;
84200800:	0b f0 33 eb 	call (m) Lc_aanc_initialize_ramp_1;

84200804 <Lc_aanc_start_11>:
            break;
        default:
            break;
    }

    aanc_update_gain(op_data, p_ext_data);
84200804:	33 00       	r1 = r4 + Null;
84200806:	4a 08       	r0 = r7 + Null;
84200808:	08 f0 39 e5 	call (m) Lc_aanc_update_gain_1;

    /* Set reinitialization flags to ensure first run behavior */
    p_ext_data->re_init_flag = TRUE;
8420080c:	41 20       	rMAC = Null + 1;
8420080e:	61 f0 02 9a 	MB[r4 + 514] = rMAC;
    p_ext_data->re_init_hard = TRUE;
84200812:	61 f0 03 9a 	MB[r4 + 515] = rMAC;
84200816:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420081a:	48 8e       	M[rMAC + 4] = Null;

    /* All good */
    base_op_change_response_status(resp_data, STATUS_OK);

    L4_DBG_MSG("AANC Started");
8420081c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200820:	08 25       	Null = rMAC - 4;
84200822:	07 68       	if LT jump (m) Lc_aanc_start_13;

84200824 <Lc_aanc_start_12>:
84200824:	55 f1 02 f0 	r0 = Null + 357565008;
84200828:	50 42 
8420082a:	ff fd 04 f0 	call (m) 0x10b0;
8420082e:	27 e4 

84200830 <Lc_aanc_start_13>:
    return TRUE;
84200830:	42 20       	r0 = Null + 1;

84200832 <Lc_aanc_start_14>:
}
84200832:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200834:	d8 4c       	rts;

84200836 <$_aanc_reset>:

bool aanc_reset(OPERATOR_DATA *op_data, void *message_data,
                unsigned *response_id, void **resp_data)
{
84200836:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200838:	10 09       	r6 = r0 + Null;
8420083a:	1a 09       	r8 = r1 + Null;
8420083c:	27 00       	r5 = r2 + Null;
8420083e:	29 09       	r7 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200840:	ff fd 00 f0 	call (m) 0x8ea;
84200844:	2b e5 
84200846:	16 00       	r4 = r0 + Null;
bool aanc_reset(OPERATOR_DATA *op_data, void *message_data,
                unsigned *response_id, void **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (!base_op_reset(op_data, message_data, response_id, resp_data))
84200848:	4d 08       	r3 = r7 + Null;
8420084a:	3c 00       	r2 = r5 + Null;
8420084c:	53 08       	r1 = r8 + Null;
8420084e:	42 08       	r0 = r6 + Null;
84200850:	ef fd ff ff 	call (m) 0x724;
84200854:	35 e6 
84200856:	10 04       	Null = r0 - Null;
84200858:	03 62       	if NE jump (m) Lc_aanc_reset_3;

8420085a <Lc_aanc_reset_2>:
    {
        return FALSE;
8420085a:	02 00       	r0 = Null + Null;
8420085c:	11 6e       	jump (m) Lc_aanc_reset_6;

8420085e <Lc_aanc_reset_3>:
    }

    p_ext_data->re_init_flag = TRUE;
8420085e:	41 20       	rMAC = Null + 1;
84200860:	61 f0 02 9a 	MB[r4 + 514] = rMAC;
    p_ext_data->re_init_hard = TRUE;
84200864:	61 f0 03 9a 	MB[r4 + 515] = rMAC;

    L4_DBG_MSG("AANC: Reset");
84200868:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420086c:	08 25       	Null = rMAC - 4;
8420086e:	07 68       	if LT jump (m) Lc_aanc_reset_5;

84200870 <Lc_aanc_reset_4>:
84200870:	55 f1 02 f0 	r0 = Null + 357565021;
84200874:	5d 42 
84200876:	ff fd 04 f0 	call (m) 0x10b0;
8420087a:	3b e1 

8420087c <Lc_aanc_reset_5>:
    return TRUE;
8420087c:	42 20       	r0 = Null + 1;

8420087e <Lc_aanc_reset_6>:
}
8420087e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200880:	d8 4c       	rts;

84200882 <$_aanc_connect>:

bool aanc_connect(OPERATOR_DATA *op_data, void *message_data,
                  unsigned *response_id, void **resp_data)
{
84200882:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200884:	17 00       	r5 = r0 + Null;
84200886:	19 09       	r7 = r1 + Null;
84200888:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
8420088a:	ff fd 00 f0 	call (m) 0x8ea;
8420088e:	21 e3 
84200890:	16 00       	r4 = r0 + Null;
    tCbuffer** selected_buffer;
    tCbuffer** selected_metadata;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, resp_data))
84200892:	03 00       	r1 = Null + Null;
84200894:	44 08       	r2 = r6 + Null;
84200896:	3a 00       	r0 = r5 + Null;
84200898:	ff fd 00 f0 	call (m) 0x8c0;
8420089c:	29 e1 
8420089e:	10 04       	Null = r0 - Null;
842008a0:	03 62       	if NE jump (m) Lc_aanc_connect_3;

842008a2 <Lc_aanc_connect_2>:
    {
        return FALSE;
842008a2:	02 00       	r0 = Null + Null;
842008a4:	6a 6e       	jump (m) Lc_aanc_connect_29;

842008a6 <Lc_aanc_connect_3>:
    }

    /* can't connect while running if adaptive gain is not disabled */
    if (opmgr_op_is_running(op_data))
842008a6:	3a 00       	r0 = r5 + Null;
842008a8:	ff fd 29 f0 	call (m) 0x5ca4;
842008ac:	3d ef 
842008ae:	10 04       	Null = r0 - Null;
842008b0:	03 60       	if EQ jump (m) Lc_aanc_connect_5;

842008b2 <Lc_aanc_connect_4>:
    {
        if (p_ext_data->aanc_cap_params.OFFSET_DISABLE_AG_CALC == 0)
842008b2:	30 a8       	Null = M[r4 + 64];
842008b4:	26 60       	if EQ jump (m) Lc_aanc_connect_12;

842008b6 <Lc_aanc_connect_5>:
            return TRUE;
        }
    }

    /* Determine whether sink or source terminal being connected */
    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
842008b6:	91 f0 00 e8 	rMAC = M[r7 + Null];
    terminal_num = terminal_id & TERMINAL_NUM_MASK;
842008ba:	8f c2       	r5 = rMAC AND 0x3f;

    if (terminal_id & TERMINAL_SINK_MASK)
842008bc:	40 f0 11 f0 	rMAC = rMAC AND 0x800000;
842008c0:	00 00 
842008c2:	25 60       	if EQ jump (m) Lc_aanc_connect_13;

842008c4 <Lc_aanc_connect_6>:
    {
        L4_DBG_MSG1("AANC connect: sink terminal %u", terminal_num);
842008c4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842008c8:	08 25       	Null = rMAC - 4;
842008ca:	08 68       	if LT jump (m) Lc_aanc_connect_8;

842008cc <Lc_aanc_connect_7>:
842008cc:	55 f1 02 f0 	r0 = Null + 357565033;
842008d0:	69 42 
842008d2:	3b 00       	r1 = r5 + Null;
842008d4:	ff fd 03 f0 	call (m) 0x10c2;
842008d8:	2f ef 

842008da <Lc_aanc_connect_8>:
        max_value = AANC_MAX_SINKS;
        selected_buffer = p_ext_data->inputs;
842008da:	31 00       	rMAC = r4 + Null;
842008dc:	0b 00       	r1 = rMAC + Null;
        selected_metadata = p_ext_data->metadata_ip;
842008de:	32 30       	r0 = r4 + 32;
842008e0:	24 6e       	jump (m) Lc_aanc_connect_16;

842008e2 <Lc_aanc_connect_9>:
        base_op_change_response_status(resp_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* Can't connect if already connected */
    if (selected_buffer[terminal_num] != NULL)
842008e2:	7c 54       	r2 = r5 LSHIFT 2;
842008e4:	e3 00       	r1 = r2 + r1;
842008e6:	19 e8       	rMAC = M[r1 + Null];
842008e8:	34 60       	if EQ jump (m) Lc_aanc_connect_21;

842008ea <Lc_aanc_connect_10>:
    {
        L4_DBG_MSG1("AANC connect failed: terminal %u already connected",
                    terminal_num);
842008ea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842008ee:	08 25       	Null = rMAC - 4;
842008f0:	08 68       	if LT jump (m) Lc_aanc_connect_12;

842008f2 <Lc_aanc_connect_11>:
842008f2:	55 f1 02 f0 	r0 = Null + 357565138;
842008f6:	d2 42 
842008f8:	3b 00       	r1 = r5 + Null;
842008fa:	ff fd 03 f0 	call (m) 0x10c2;
842008fe:	29 ee 

84200900 <Lc_aanc_connect_12>:
84200900:	01 f0 00 60 	rMAC = Null + 4096;
84200904:	82 f0 00 e8 	r0 = M[r6 + Null];
84200908:	51 8e       	M[r0 + 4] = rMAC;
8420090a:	21 6e       	jump (m) Lc_aanc_connect_20;

8420090c <Lc_aanc_connect_13>:
        selected_buffer = p_ext_data->inputs;
        selected_metadata = p_ext_data->metadata_ip;
    }
    else
    {
        L4_DBG_MSG1("AANC connect: source terminal %u", terminal_num);
8420090c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200910:	08 25       	Null = rMAC - 4;
84200912:	08 68       	if LT jump (m) Lc_aanc_connect_15;

84200914 <Lc_aanc_connect_14>:
84200914:	55 f1 02 f0 	r0 = Null + 357565064;
84200918:	88 42 
8420091a:	3b 00       	r1 = r5 + Null;
8420091c:	ff fd 03 f0 	call (m) 0x10c2;
84200920:	27 ed 

84200922 <Lc_aanc_connect_15>:
        max_value = AANC_MAX_SOURCES;
        selected_buffer = p_ext_data->outputs;
84200922:	31 28       	rMAC = r4 + 16;
84200924:	0b 00       	r1 = rMAC + Null;
        selected_metadata = p_ext_data->metadata_op;
84200926:	0a 2a       	r0 = rMAC + 24;

84200928 <Lc_aanc_connect_16>:
    }

    /* Can't use invalid ID */
    if (terminal_num >= max_value)
84200928:	38 25       	Null = r5 - 4;
8420092a:	dc 65       	if NC jump (m) Lc_aanc_connect_9;

8420092c <Lc_aanc_connect_17>:
    {
        /* invalid terminal id */
        L4_DBG_MSG1("AANC connect failed: invalid terminal %u", terminal_num);
8420092c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200930:	08 25       	Null = rMAC - 4;
84200932:	08 68       	if LT jump (m) Lc_aanc_connect_19;

84200934 <Lc_aanc_connect_18>:
84200934:	55 f1 02 f0 	r0 = Null + 357565097;
84200938:	a9 42 
8420093a:	3b 00       	r1 = r5 + Null;
8420093c:	ff fd 03 f0 	call (m) 0x10c2;
84200940:	27 ec 

84200942 <Lc_aanc_connect_19>:
84200942:	01 f0 03 60 	rMAC = Null + 4099;
84200946:	82 f0 00 e8 	r0 = M[r6 + Null];
8420094a:	51 8e       	M[r0 + 4] = rMAC;

8420094c <Lc_aanc_connect_20>:
    if (opmgr_op_is_running(op_data))
    {
        if (p_ext_data->aanc_cap_params.OFFSET_DISABLE_AG_CALC == 0)
        {
            base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
            return TRUE;
8420094c:	42 20       	r0 = Null + 1;
8420094e:	15 6e       	jump (m) Lc_aanc_connect_29;

84200950 <Lc_aanc_connect_21>:
                    terminal_num);
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200950:	91 f0 01 88 	rMAC = M[r7 + 4];
    selected_buffer[terminal_num] = pterminal_buf;
84200954:	19 ee       	M[r1 + Null] = rMAC;

    if (terminal_num == AANC_PLAYBACK_TERMINAL_ID)
84200956:	38 04       	Null = r5 - Null;
84200958:	0a 62       	if NE jump (m) Lc_aanc_connect_26;

8420095a <Lc_aanc_connect_22>:
    {
        /* playback metadata has its own metadata channel */
        if (selected_metadata[AANC_METADATA_PLAYBACK_ID] == NULL &&
            buff_has_metadata(pterminal_buf))
8420095a:	13 e8       	r1 = M[r0 + Null];
8420095c:	04 62       	if NE jump (m) Lc_aanc_connect_25;

8420095e <Lc_aanc_connect_23>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(const tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420095e:	8b 89       	r1 = M[rMAC + 24];
84200960:	02 60       	if EQ jump (m) Lc_aanc_connect_25;

84200962 <Lc_aanc_connect_24>:
        {
            selected_metadata[AANC_METADATA_PLAYBACK_ID] = pterminal_buf;
84200962:	11 ee       	M[r0 + Null] = rMAC;

84200964 <Lc_aanc_connect_25>:
        {
            selected_metadata[AANC_METADATA_MIC_ID] = pterminal_buf;
        }
    }

    update_touched_sink_sources(p_ext_data);
84200964:	32 00       	r0 = r4 + Null;
84200966:	08 f0 31 e6 	call (m) Lc_update_touched_sink_sources_1;
8420096a:	f1 6f       	jump (m) Lc_aanc_connect_20;

8420096c <Lc_aanc_connect_26>:
    {
        /* mic int/ext and fb mon metadata all muxed onto the same metadata
         * channel
         */
        if (selected_metadata[AANC_METADATA_MIC_ID] == NULL &&
            buff_has_metadata(pterminal_buf))
8420096c:	53 88       	r1 = M[r0 + 4];
8420096e:	fb 63       	if NE jump (m) Lc_aanc_connect_25;

84200970 <Lc_aanc_connect_27>:
84200970:	8b 89       	r1 = M[rMAC + 24];
84200972:	f9 61       	if EQ jump (m) Lc_aanc_connect_25;

84200974 <Lc_aanc_connect_28>:
        {
            selected_metadata[AANC_METADATA_MIC_ID] = pterminal_buf;
84200974:	51 8e       	M[r0 + 4] = rMAC;
84200976:	f7 6f       	jump (m) Lc_aanc_connect_25;

84200978 <Lc_aanc_connect_29>:
    }

    update_touched_sink_sources(p_ext_data);

    return TRUE;
}
84200978:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420097a:	d8 4c       	rts;

8420097c <$_aanc_disconnect>:

bool aanc_disconnect(OPERATOR_DATA *op_data, void *message_data,
                     unsigned *response_id, void **resp_data)
{
8420097c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420097e:	17 00       	r5 = r0 + Null;
84200980:	19 09       	r7 = r1 + Null;
84200982:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200984:	ef fd ff ff 	call (m) 0x8ea;
84200988:	27 eb 
8420098a:	16 00       	r4 = r0 + Null;
    unsigned i;
    bool found_alternative;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, resp_data))
8420098c:	03 00       	r1 = Null + Null;
8420098e:	44 08       	r2 = r6 + Null;
84200990:	3a 00       	r0 = r5 + Null;
84200992:	ef fd ff ff 	call (m) 0x8c0;
84200996:	2f e9 
84200998:	10 04       	Null = r0 - Null;
8420099a:	03 62       	if NE jump (m) Lc_aanc_disconnect_3;

8420099c <Lc_aanc_disconnect_2>:
    {
        return FALSE;
8420099c:	02 00       	r0 = Null + Null;
8420099e:	78 6e       	jump (m) Lc_aanc_disconnect_33;

842009a0 <Lc_aanc_disconnect_3>:
    }

    /* can't disconnect while running if adaptive gain is not disabled */
    if (opmgr_op_is_running(op_data))
842009a0:	3a 00       	r0 = r5 + Null;
842009a2:	ff fd 29 f0 	call (m) 0x5ca4;
842009a6:	23 e8 
842009a8:	10 04       	Null = r0 - Null;
842009aa:	03 60       	if EQ jump (m) Lc_aanc_disconnect_5;

842009ac <Lc_aanc_disconnect_4>:
    {
        if (p_ext_data->aanc_cap_params.OFFSET_DISABLE_AG_CALC == 0)
842009ac:	30 a8       	Null = M[r4 + 64];
842009ae:	27 60       	if EQ jump (m) Lc_aanc_disconnect_12;

842009b0 <Lc_aanc_disconnect_5>:
            return TRUE;
        }
    }

    /* Determine whether sink or source terminal being disconnected */
    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
842009b0:	91 f0 00 e8 	rMAC = M[r7 + Null];
    terminal_num = terminal_id & TERMINAL_NUM_MASK;
842009b4:	8f c2       	r5 = rMAC AND 0x3f;

    if (terminal_id & TERMINAL_SINK_MASK)
842009b6:	40 f0 11 f0 	rMAC = rMAC AND 0x800000;
842009ba:	00 00 
842009bc:	26 60       	if EQ jump (m) Lc_aanc_disconnect_13;

842009be <Lc_aanc_disconnect_6>:
    {
        L4_DBG_MSG1("AANC disconnect: sink terminal %u", terminal_num);
842009be:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842009c2:	08 25       	Null = rMAC - 4;
842009c4:	08 68       	if LT jump (m) Lc_aanc_disconnect_8;

842009c6 <Lc_aanc_disconnect_7>:
842009c6:	55 f1 02 f0 	r0 = Null + 357565189;
842009ca:	05 43 
842009cc:	3b 00       	r1 = r5 + Null;
842009ce:	ff fd 03 f0 	call (m) 0x10c2;
842009d2:	35 e7 

842009d4 <Lc_aanc_disconnect_8>:
        max_value = AANC_MAX_SINKS;
        selected_buffer = p_ext_data->inputs;
842009d4:	31 00       	rMAC = r4 + Null;
        selected_metadata = p_ext_data->metadata_ip;
842009d6:	32 30       	r0 = r4 + 32;
842009d8:	26 6e       	jump (m) Lc_aanc_disconnect_16;

842009da <Lc_aanc_disconnect_9>:
        return TRUE;
    }

    found_alternative = FALSE;
    /* Can't disconnect if not connected */
    if (selected_buffer[terminal_num] == NULL)
842009da:	7c 54       	r2 = r5 LSHIFT 2;
842009dc:	0b 00       	r1 = rMAC + Null;
842009de:	e3 00       	r1 = r2 + r1;
842009e0:	1d 00       	r3 = r1 + Null;
842009e2:	2b e8       	r1 = M[r3 + Null];
842009e4:	34 62       	if NE jump (m) Lc_aanc_disconnect_21;

842009e6 <Lc_aanc_disconnect_10>:
    {
        L4_DBG_MSG1("AANC disconnect failed: terminal %u not connected",
                    terminal_num);
842009e6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842009ea:	08 25       	Null = rMAC - 4;
842009ec:	08 68       	if LT jump (m) Lc_aanc_disconnect_12;

842009ee <Lc_aanc_disconnect_11>:
842009ee:	55 f1 02 f0 	r0 = Null + 357565303;
842009f2:	77 43 
842009f4:	3b 00       	r1 = r5 + Null;
842009f6:	ff fd 03 f0 	call (m) 0x10c2;
842009fa:	2d e6 

842009fc <Lc_aanc_disconnect_12>:
842009fc:	01 f0 00 60 	rMAC = Null + 4096;
84200a00:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a04:	51 8e       	M[r0 + 4] = rMAC;
84200a06:	21 6e       	jump (m) Lc_aanc_disconnect_20;

84200a08 <Lc_aanc_disconnect_13>:
        selected_buffer = p_ext_data->inputs;
        selected_metadata = p_ext_data->metadata_ip;
    }
    else
    {
        L4_DBG_MSG1("AANC disconnect: source terminal %u", terminal_num);
84200a08:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a0c:	08 25       	Null = rMAC - 4;
84200a0e:	08 68       	if LT jump (m) Lc_aanc_disconnect_15;

84200a10 <Lc_aanc_disconnect_14>:
84200a10:	55 f1 02 f0 	r0 = Null + 357565223;
84200a14:	27 43 
84200a16:	3b 00       	r1 = r5 + Null;
84200a18:	ff fd 03 f0 	call (m) 0x10c2;
84200a1c:	2b e5 

84200a1e <Lc_aanc_disconnect_15>:
        max_value = AANC_MAX_SOURCES;
        selected_buffer = p_ext_data->outputs;
84200a1e:	32 28       	r0 = r4 + 16;
84200a20:	11 00       	rMAC = r0 + Null;
        selected_metadata = p_ext_data->metadata_op;
84200a22:	12 2a       	r0 = r0 + 24;

84200a24 <Lc_aanc_disconnect_16>:
    }

    /* Can't use invalid ID */
    if (terminal_num >= max_value)
84200a24:	38 25       	Null = r5 - 4;
84200a26:	da 65       	if NC jump (m) Lc_aanc_disconnect_9;

84200a28 <Lc_aanc_disconnect_17>:
    {
        /* invalid terminal id */
        L4_DBG_MSG1("AANC disconnect failed: invalid terminal %u",
                    terminal_num);
84200a28:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200a2c:	08 25       	Null = rMAC - 4;
84200a2e:	08 68       	if LT jump (m) Lc_aanc_disconnect_19;

84200a30 <Lc_aanc_disconnect_18>:
84200a30:	55 f1 02 f0 	r0 = Null + 357565259;
84200a34:	4b 43 
84200a36:	3b 00       	r1 = r5 + Null;
84200a38:	ff fd 03 f0 	call (m) 0x10c2;
84200a3c:	2b e4 

84200a3e <Lc_aanc_disconnect_19>:
84200a3e:	01 f0 03 60 	rMAC = Null + 4099;
84200a42:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a46:	51 8e       	M[r0 + 4] = rMAC;

84200a48 <Lc_aanc_disconnect_20>:
    if (opmgr_op_is_running(op_data))
    {
        if (p_ext_data->aanc_cap_params.OFFSET_DISABLE_AG_CALC == 0)
        {
            base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
            return TRUE;
84200a48:	42 20       	r0 = Null + 1;
84200a4a:	22 6e       	jump (m) Lc_aanc_disconnect_33;

84200a4c <Lc_aanc_disconnect_21>:
                    terminal_num);
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (terminal_num == AANC_PLAYBACK_TERMINAL_ID)
84200a4c:	38 04       	Null = r5 - Null;
84200a4e:	05 62       	if NE jump (m) Lc_aanc_disconnect_24;

84200a50 <Lc_aanc_disconnect_22>:
    {
        /* playback metadata has its own metadata channel */
        if (selected_metadata[AANC_METADATA_PLAYBACK_ID] != NULL)
84200a50:	11 e8       	rMAC = M[r0 + Null];
84200a52:	15 60       	if EQ jump (m) Lc_aanc_disconnect_31;

84200a54 <Lc_aanc_disconnect_23>:
        {
            selected_metadata[AANC_METADATA_PLAYBACK_ID] = NULL;
84200a54:	10 ee       	M[r0 + Null] = Null;
84200a56:	13 6e       	jump (m) Lc_aanc_disconnect_31;

84200a58 <Lc_aanc_disconnect_24>:
    {
        /* Mic int/ext and fb mon metadata all muxed onto the same metadata
         * channel. Try to find an alternative channel to set the metadata to if
         * we're disconnecting the existing metadata channel. */
        if (selected_metadata[AANC_METADATA_MIC_ID] ==
            selected_buffer[terminal_num])
84200a58:	54 88       	r2 = M[r0 + 4];
84200a5a:	e0 04       	Null = r2 - r1;
84200a5c:	10 62       	if NE jump (m) Lc_aanc_disconnect_31;

84200a5e <Lc_aanc_disconnect_25>:
        {
            for (i = 1; i < max_value; i++)
84200a5e:	43 20       	r1 = Null + 1;
84200a60:	0c 21       	r2 = rMAC + 4;

84200a62 <Lc_aanc_disconnect_26>:
            {
                if (i == terminal_num)
84200a62:	d8 05       	Null = r1 - r5;
84200a64:	07 60       	if EQ jump (m) Lc_aanc_disconnect_29;

84200a66 <Lc_aanc_disconnect_27>:
                {
                    continue;
                }
                if (selected_buffer[i] != NULL &&
                    buff_has_metadata(selected_buffer[i]))
84200a66:	48 f0 00 e8 	r6 = M[r2 + Null];
84200a6a:	04 60       	if EQ jump (m) Lc_aanc_disconnect_29;

84200a6c <Lc_aanc_disconnect_28>:
84200a6c:	88 f0 06 88 	r6 = M[r6 + 24];
84200a70:	0b 62       	if NE jump (m) Lc_aanc_disconnect_32;

84200a72 <Lc_aanc_disconnect_29>:
         * channel. Try to find an alternative channel to set the metadata to if
         * we're disconnecting the existing metadata channel. */
        if (selected_metadata[AANC_METADATA_MIC_ID] ==
            selected_buffer[terminal_num])
        {
            for (i = 1; i < max_value; i++)
84200a72:	5b 20       	r1 = r1 + 1;
84200a74:	24 21       	r2 = r2 + 4;
84200a76:	18 25       	Null = r1 - 4;
84200a78:	f5 65       	if NC jump (m) Lc_aanc_disconnect_26;

84200a7a <Lc_aanc_disconnect_30>:
                    break;
                }
            }
            if (!found_alternative)
            {
                selected_metadata[AANC_METADATA_MIC_ID] = NULL;
84200a7a:	50 8e       	M[r0 + 4] = Null;

84200a7c <Lc_aanc_disconnect_31>:
            }
        }
    }

    selected_buffer[terminal_num] = NULL;
84200a7c:	28 ee       	M[r3 + Null] = Null;

    update_touched_sink_sources(p_ext_data);
84200a7e:	32 00       	r0 = r4 + Null;
84200a80:	07 f0 37 ed 	call (m) Lc_update_touched_sink_sources_1;
84200a84:	e2 6f       	jump (m) Lc_aanc_disconnect_20;

84200a86 <Lc_aanc_disconnect_32>:
                    continue;
                }
                if (selected_buffer[i] != NULL &&
                    buff_has_metadata(selected_buffer[i]))
                {
                    selected_metadata[AANC_METADATA_MIC_ID] = selected_buffer[i];
84200a86:	5b 54       	r1 = r1 LSHIFT 2;
84200a88:	c9 e8       	rMAC = M[rMAC + r1];
84200a8a:	51 8e       	M[r0 + 4] = rMAC;
                    found_alternative = TRUE;
                    break;
84200a8c:	f8 6f       	jump (m) Lc_aanc_disconnect_31;

84200a8e <Lc_aanc_disconnect_33>:
    selected_buffer[terminal_num] = NULL;

    update_touched_sink_sources(p_ext_data);

    return TRUE;
}
84200a8e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200a90:	d8 4c       	rts;

84200a92 <$_aanc_buffer_details>:

bool aanc_buffer_details(OPERATOR_DATA *op_data, void *message_data,
                         unsigned *response_id, void **resp_data)
{
84200a92:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200a94:	16 00       	r4 = r0 + Null;
84200a96:	18 09       	r6 = r1 + Null;
84200a98:	2a 09       	r8 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200a9a:	ef fd ff ff 	call (m) 0x8ea;
84200a9e:	31 e2 
84200aa0:	11 09       	r7 = r0 + Null;
    /* Variables used for distinguishing source/sink */
    unsigned max_value;
    tCbuffer** opposite_buffer;
    tCbuffer** selected_metadata;

    if (!base_op_buffer_details_lite(op_data, resp_data))
84200aa2:	53 08       	r1 = r8 + Null;
84200aa4:	32 00       	r0 = r4 + Null;
84200aa6:	ef fd fe ff 	call (m) 0x842;
84200aaa:	3d ec 
84200aac:	10 04       	Null = r0 - Null;
84200aae:	03 62       	if NE jump (m) Lc_aanc_buffer_details_3;

84200ab0 <Lc_aanc_buffer_details_2>:
    {
        return FALSE;
84200ab0:	02 00       	r0 = Null + Null;
84200ab2:	60 6e       	jump (m) Lc_aanc_buffer_details_20;

84200ab4 <Lc_aanc_buffer_details_3>:
    }

    /* Response pointer */
    OP_BUF_DETAILS_RSP *p_resp = (OP_BUF_DETAILS_RSP*) *resp_data;
84200ab4:	a7 f0 00 e8 	r5 = M[r8 + Null];
    p_resp->runs_in_place = FALSE;
    p_resp->b.buffer_size = AANC_DEFAULT_BUFFER_SIZE;
#else

    /* Determine whether sink or source terminal being disconnected */
    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84200ab8:	88 f0 00 e8 	r6 = M[r6 + Null];
    terminal_num = terminal_id & TERMINAL_NUM_MASK;
84200abc:	86 f0 3f 00 	r4 = r6 AND 0x3f;

    if (terminal_id & TERMINAL_SINK_MASK)
84200ac0:	40 f0 81 f0 	rMAC = r6 AND 0x800000;
84200ac4:	00 00 
84200ac6:	12 60       	if EQ jump (m) Lc_aanc_buffer_details_7;

84200ac8 <Lc_aanc_buffer_details_4>:
    {
        L4_DBG_MSG1("AANC buffer details: sink buffer %u", terminal_num);
84200ac8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200acc:	08 25       	Null = rMAC - 4;
84200ace:	08 68       	if LT jump (m) Lc_aanc_buffer_details_6;

84200ad0 <Lc_aanc_buffer_details_5>:
84200ad0:	55 f1 02 f0 	r0 = Null + 357565353;
84200ad4:	a9 43 
84200ad6:	33 00       	r1 = r4 + Null;
84200ad8:	ff fd 02 f0 	call (m) 0x10c2;
84200adc:	2b ef 

84200ade <Lc_aanc_buffer_details_6>:
        max_value = AANC_MAX_SINKS;
        opposite_buffer = p_ext_data->outputs;
84200ade:	92 f0 10 20 	r0 = r7 + 16;
84200ae2:	11 00       	rMAC = r0 + Null;
        selected_metadata = p_ext_data->metadata_ip;
84200ae4:	29 f0 10 20 	r7 = r0 + 16;
84200ae8:	0f 6e       	jump (m) Lc_aanc_buffer_details_10;

84200aea <Lc_aanc_buffer_details_7>:
    }
    else
    {
        L4_DBG_MSG1("AANC buffer details: source buffer %u", terminal_num);
84200aea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200aee:	08 25       	Null = rMAC - 4;
84200af0:	08 68       	if LT jump (m) Lc_aanc_buffer_details_9;

84200af2 <Lc_aanc_buffer_details_8>:
84200af2:	55 f1 02 f0 	r0 = Null + 357565389;
84200af6:	cd 43 
84200af8:	33 00       	r1 = r4 + Null;
84200afa:	ff fd 02 f0 	call (m) 0x10c2;
84200afe:	29 ee 

84200b00 <Lc_aanc_buffer_details_9>:
        max_value = AANC_MAX_SOURCES;
        opposite_buffer = p_ext_data->inputs;
84200b00:	49 08       	rMAC = r7 + Null;
        selected_metadata = p_ext_data->metadata_op;
84200b02:	09 f0 28 44 	r7 = r7 + 40;

84200b06 <Lc_aanc_buffer_details_10>:
    }

    /* Can't use invalid ID */
    if (terminal_num >= max_value)
84200b06:	30 25       	Null = r4 - 4;
84200b08:	12 64       	if NC jump (m) Lc_aanc_buffer_details_14;

84200b0a <Lc_aanc_buffer_details_11>:
    {
        /* invalid terminal id */
        L4_DBG_MSG1("AANC buffer details failed: invalid terminal %u",
                    terminal_num);
84200b0a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200b0e:	08 25       	Null = rMAC - 4;
84200b10:	08 68       	if LT jump (m) Lc_aanc_buffer_details_13;

84200b12 <Lc_aanc_buffer_details_12>:
84200b12:	55 f1 02 f0 	r0 = Null + 357565427;
84200b16:	f3 43 
84200b18:	33 00       	r1 = r4 + Null;
84200b1a:	ff fd 02 f0 	call (m) 0x10c2;
84200b1e:	29 ed 

84200b20 <Lc_aanc_buffer_details_13>:
84200b20:	01 f0 03 60 	rMAC = Null + 4099;
84200b24:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200b28:	51 8e       	M[r0 + 4] = rMAC;
84200b2a:	23 6e       	jump (m) Lc_aanc_buffer_details_19;

84200b2c <Lc_aanc_buffer_details_14>:
        base_op_change_response_status(resp_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    p_resp->runs_in_place = TRUE;
84200b2c:	42 20       	r0 = Null + 1;
84200b2e:	fa 9a       	MB[r5 + 11] = r0;
    p_resp->b.in_place_buff_params.in_place_terminal = \
        terminal_id ^ TERMINAL_SINK_MASK;
84200b30:	08 f0 00 f0 	r1 = r6 XOR 0x800000;
84200b34:	00 f8 93 c8 
84200b38:	7b 8f       	M[r5 + 20] = r1;
    p_resp->b.in_place_buff_params.size = AANC_DEFAULT_BUFFER_SIZE;
84200b3a:	02 f0 80 40 	r0 = Null + 128;
84200b3e:	ba 8f       	M[r5 + 24] = r0;
    p_resp->b.in_place_buff_params.buffer = opposite_buffer[terminal_num];
84200b40:	72 54       	r0 = r4 LSHIFT 2;
84200b42:	89 e8       	rMAC = M[rMAC + r0];
84200b44:	f9 8f       	M[r5 + 28] = rMAC;
    L4_DBG_MSG1("aanc_playback_buffer_details: %u",
                p_resp->b.buffer_size);
84200b46:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200b4a:	08 25       	Null = rMAC - 4;
84200b4c:	07 68       	if LT jump (m) Lc_aanc_buffer_details_16;

84200b4e <Lc_aanc_buffer_details_15>:
84200b4e:	55 f1 02 f0 	r0 = Null + 357565475;
84200b52:	23 48 
84200b54:	ff fd 02 f0 	call (m) 0x10c2;
84200b58:	2f eb 

84200b5a <Lc_aanc_buffer_details_16>:

    p_resp->supports_metadata = TRUE;
84200b5a:	41 20       	rMAC = Null + 1;
84200b5c:	39 9b       	MB[r5 + 12] = rMAC;

    if (terminal_num == AANC_PLAYBACK_TERMINAL_ID)
84200b5e:	30 04       	Null = r4 - Null;
84200b60:	05 62       	if NE jump (m) Lc_aanc_buffer_details_18;

84200b62 <Lc_aanc_buffer_details_17>:
    {
        p_resp->metadata_buffer = selected_metadata[AANC_METADATA_PLAYBACK_ID];
84200b62:	91 f0 00 e8 	rMAC = M[r7 + Null];
84200b66:	39 8f       	M[r5 + 16] = rMAC;
84200b68:	04 6e       	jump (m) Lc_aanc_buffer_details_19;

84200b6a <Lc_aanc_buffer_details_18>:
    }
    else
    {
        p_resp->metadata_buffer = selected_metadata[AANC_METADATA_MIC_ID];
84200b6a:	91 f0 01 88 	rMAC = M[r7 + 4];
84200b6e:	39 8f       	M[r5 + 16] = rMAC;

84200b70 <Lc_aanc_buffer_details_19>:
    }

#endif /* DISABLE_IN_PLACE */
    return TRUE;
84200b70:	42 20       	r0 = Null + 1;

84200b72 <Lc_aanc_buffer_details_20>:
}
84200b72:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200b74:	d8 4c       	rts;

84200b76 <$_aanc_get_sched_info>:

bool aanc_get_sched_info(OPERATOR_DATA *op_data, void *message_data,
                         unsigned *response_id, void **resp_data)
{
84200b76:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200b78:	17 00       	r5 = r0 + Null;
84200b7a:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200b7c:	ef fd fe ff 	call (m) 0x7f6;
84200b80:	3b e3 
    if (resp == NULL)
84200b82:	10 04       	Null = r0 - Null;
84200b84:	09 62       	if NE jump (m) Lc_aanc_get_sched_info_3;

84200b86 <Lc_aanc_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED,
                                             resp_data);
84200b86:	03 f0 00 60 	r1 = Null + 4096;
84200b8a:	34 00       	r2 = r4 + Null;
84200b8c:	3a 00       	r0 = r5 + Null;
84200b8e:	ef fd fe ff 	call (m) 0x8c0;
84200b92:	33 e9 
84200b94:	05 6e       	jump (m) Lc_aanc_get_sched_info_4;

84200b96 <Lc_aanc_get_sched_info_3>:
    }

    *resp_data = resp;
84200b96:	32 ee       	M[r4 + Null] = r0;
    resp->block_size = AANC_DEFAULT_BLOCK_SIZE;
84200b98:	01 30       	rMAC = Null + 32;
84200b9a:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200b9c:	42 20       	r0 = Null + 1;

84200b9e <Lc_aanc_get_sched_info_4>:
}
84200b9e:	f2 48       	popm <FP, r4, r5, rLink>;
84200ba0:	d8 4c       	rts;

84200ba2 <$_aanc_opmsg_set_control>:
Opmsg handlers
*/
bool aanc_opmsg_set_control(OPERATOR_DATA *op_data, void *message_data,
                            unsigned *resp_length,
                            OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ba2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200ba4:	4e 4c       	SP = SP + 56;
84200ba6:	42 de       	M[FP + 32] = r0;
84200ba8:	4b de       	M[FP + 36] = r1;
84200baa:	27 00       	r5 = r2 + Null;
84200bac:	55 de       	M[FP + 40] = r3;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200bae:	ef fd fe ff 	call (m) 0x8ea;
84200bb2:	3d e9 
84200bb4:	16 00       	r4 = r0 + Null;
    /* FF, FB fine gain ramp: duration, delay, target, ramp pointers */
    unsigned mt_dur, fb_dur, ff_dur, fb_dly;
    uint16 ff_tgt, fb_tgt;
    AANC_RAMP *p_ff_ramp, *p_fb_ramp;

    if(!cps_control_setup(message_data, resp_length, resp_data, &num_controls))
84200bb6:	85 14       	r3 = FP + 72;
84200bb8:	3b 00       	r1 = r5 + Null;
84200bba:	54 d8       	r2 = M[FP + 40];
84200bbc:	4a d8       	r0 = M[FP + 36];
84200bbe:	ff fd 01 f0 	call (m) 0xe9e;
84200bc2:	21 e7 
84200bc4:	10 04       	Null = r0 - Null;
84200bc6:	04 62       	if NE jump (m) Lc_aanc_opmsg_set_control_3;

84200bc8 <Lc_aanc_opmsg_set_control_2>:
    {
       return FALSE;
84200bc8:	02 00       	r0 = Null + Null;
84200bca:	0f f0 91 e6 	jump (m) Lc_aanc_opmsg_set_control_64;

84200bce <Lc_aanc_opmsg_set_control_3>:
    }

    /* Iterate through the control messages looking for mode and gain override
     * messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
84200bce:	58 de       	M[FP + 44] = Null;
84200bd0:	81 20       	rMAC = Null + 2;
84200bd2:	61 de       	M[FP + 48] = rMAC;
84200bd4:	c1 23       	rMAC = Null + 15;
84200bd6:	69 de       	M[FP + 52] = rMAC;
84200bd8:	41 20       	rMAC = Null + 1;
84200bda:	71 de       	M[FP + 56] = rMAC;
84200bdc:	41 22       	rMAC = Null + 9;
84200bde:	79 de       	M[FP + 60] = rMAC;
84200be0:	41 20       	rMAC = Null + 1;
84200be2:	81 de       	M[FP + 64] = rMAC;
84200be4:	c1 20       	rMAC = Null + 3;
84200be6:	89 de       	M[FP + 68] = rMAC;
    for (i=0; i<num_controls; i++)
84200be8:	03 09       	r9 = Null + Null;
84200bea:	04 6e       	jump (m) Lc_aanc_opmsg_set_control_6;

84200bec <Lc_aanc_opmsg_set_control_4>:

            /* No override flags indicated for channel */
            continue;
        }

        result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
84200bec:	01 21       	rMAC = Null + 4;
84200bee:	59 de       	M[FP + 44] = rMAC;

84200bf0 <Lc_aanc_opmsg_set_control_5>:
    }

    /* Iterate through the control messages looking for mode and gain override
     * messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
    for (i=0; i<num_controls; i++)
84200bf0:	0b 75       	r9 = r9 + 1;

84200bf2 <Lc_aanc_opmsg_set_control_6>:
84200bf2:	91 d8       	rMAC = M[FP + 72];
84200bf4:	1f fb 00 c2 	Null = r9 - rMAC;
84200bf8:	02 f0 a7 e0 	if C jump (m) Lc_aanc_opmsg_set_control_10;

84200bfc <Lc_aanc_opmsg_set_control_7>:
    {
        CPS_CONTROL_SOURCE ctrl_src;
        unsigned ctrl_value, ctrl_id;

        ctrl_id = cps_control_get(message_data, i, &ctrl_value, &ctrl_src);
84200bfc:	c5 14       	r3 = FP + 76;
84200bfe:	04 15       	r2 = FP + 80;
84200c00:	5b 08       	r1 = r9 + Null;
84200c02:	4a d8       	r0 = M[FP + 36];
84200c04:	ff fd 01 f0 	call (m) 0xee2;
84200c08:	3f e6 
84200c0a:	17 00       	r5 = r0 + Null;

        /* Mode override */
        if (ctrl_id == OPMSG_CONTROL_MODE_ID)
84200c0c:	78 24       	Null = r5 - 1;
84200c0e:	ac 62       	if NE jump (m) Lc_aanc_opmsg_set_control_31;

84200c10 <Lc_aanc_opmsg_set_control_8>:
        {

            /* Check for valid mode */
            ctrl_value &= AANC_SYSMODE_MASK;
84200c10:	a1 d8       	rMAC = M[FP + 80];
84200c12:	09 c1       	rMAC = rMAC AND 0x7;
84200c14:	a1 de       	M[FP + 80] = rMAC;
            if (ctrl_value >= AANC_SYSMODE_MAX_MODES)
84200c16:	c8 25       	Null = rMAC - 7;
84200c18:	0f 64       	if NC jump (m) Lc_aanc_opmsg_set_control_12;

84200c1a <Lc_aanc_opmsg_set_control_9>:
            {
                result = OPMSG_RESULT_STATES_INVALID_CONTROL_VALUE;
84200c1a:	41 21       	rMAC = Null + 5;
84200c1c:	59 de       	M[FP + 44] = rMAC;

84200c1e <Lc_aanc_opmsg_set_control_10>:
    }

    /* Set current operating mode based on override */
    /* NB: double AND removes gain override bits from comparison */
    if ((p_ext_data->ovr_control & AANC_CONTROL_MODE_OVERRIDE)
        & AANC_CONTROL_MODE_OVERRIDE)
84200c1e:	61 f0 69 88 	rMAC = M[r4 + 420];
84200c22:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
84200c26:	00 f0 a1 e5 	if EQ jump (m) Lc_aanc_opmsg_set_control_62;

84200c2a <Lc_aanc_opmsg_set_control_11>:
    {
        p_ext_data->cur_mode = p_ext_data->qact_mode;
84200c2a:	61 f0 68 88 	rMAC = M[r4 + 416];
84200c2e:	61 f0 66 8e 	M[r4 + 408] = rMAC;
84200c32:	0f f0 9d e5 	jump (m) Lc_aanc_opmsg_set_control_63;

84200c36 <Lc_aanc_opmsg_set_control_12>:
                break;
            }

            /* Re-initialize event states if not in quiet mode */
            if (ctrl_value != AANC_SYSMODE_QUIET &&
                ctrl_value != AANC_SYSMODE_GENTLE_MUTE)
84200c36:	88 25       	Null = rMAC - 6;
84200c38:	07 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_15;

84200c3a <Lc_aanc_opmsg_set_control_13>:
84200c3a:	48 25       	Null = rMAC - 5;
84200c3c:	05 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_15;

84200c3e <Lc_aanc_opmsg_set_control_14>:
            {
                aanc_initialize_events(op_data, p_ext_data);
84200c3e:	33 00       	r1 = r4 + Null;
84200c40:	42 d8       	r0 = M[FP + 32];
84200c42:	07 f0 39 e8 	call (m) Lc_aanc_initialize_events_1;

84200c46 <Lc_aanc_opmsg_set_control_15>:
            }

            /* Initialize previous gains */
            aanc_initialize_prev_gain(p_ext_data);
84200c46:	32 00       	r0 = r4 + Null;
84200c48:	06 f0 3b ed 	call (m) Lc_aanc_initialize_prev_gain_1;

            /* Gain update logic */
            mt_dur = p_ext_data->aanc_cap_params.OFFSET_GENTLE_MUTE_TIMER;
84200c4c:	f7 a8       	r5 = M[r4 + 76];
            fb_dur = p_ext_data->aanc_cap_params.OFFSET_FB_FINE_RAMP_UP_TIMER;
84200c4e:	69 f0 64 88 	r7 = M[r4 + 400];
            ff_dur = p_ext_data->aanc_cap_params.OFFSET_FF_FINE_RAMP_UP_TIMER;
84200c52:	64 f0 63 88 	r2 = M[r4 + 396];
            fb_dly = p_ext_data->aanc_cap_params.OFFSET_FB_FINE_RAMP_DELAY_TIMER;
84200c56:	68 f0 65 88 	r6 = M[r4 + 404];

            p_ff_ramp = &p_ext_data->ff_ramp;
84200c5a:	62 f0 90 22 	r0 = r4 + 656;
            p_fb_ramp = &p_ext_data->fb_ramp;
84200c5e:	2a f0 1c 20 	r8 = r0 + 28;

            switch (ctrl_value)
84200c62:	a1 d8       	rMAC = M[FP + 80];
84200c64:	48 24       	Null = rMAC - 1;
84200c66:	28 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_24;

84200c68 <Lc_aanc_opmsg_set_control_16>:
84200c68:	88 24       	Null = rMAC - 2;
84200c6a:	3a 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_26;

84200c6c <Lc_aanc_opmsg_set_control_17>:
84200c6c:	c8 24       	Null = rMAC - 3;
84200c6e:	29 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_25;

84200c70 <Lc_aanc_opmsg_set_control_18>:
84200c70:	48 25       	Null = rMAC - 5;
84200c72:	16 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_23;

84200c74 <Lc_aanc_opmsg_set_control_19>:
84200c74:	88 25       	Null = rMAC - 6;
84200c76:	0d 62       	if NE jump (m) Lc_aanc_opmsg_set_control_21;

84200c78 <Lc_aanc_opmsg_set_control_20>:
                     * gains at their current value. Initializing the ramps
                     * ensures the gains will be ramped down to the target
                     * value.
                     */
                    ff_tgt = 0;
                    aanc_initialize_ramp(p_ff_ramp, ff_tgt, ff_dur, 0);
84200c78:	05 00       	r3 = Null + Null;
84200c7a:	03 00       	r1 = Null + Null;
84200c7c:	09 f0 37 e7 	call (m) Lc_aanc_initialize_ramp_1;
                    fb_tgt = (uint16)(p_ext_data->fb_static_gain.fine >> 1);
84200c80:	62 f0 f7 86 	r0 = MHU[r4 + 494];
84200c84:	13 58       	r1 = r0 ASHIFT -1;
                    aanc_initialize_ramp(p_fb_ramp, fb_tgt, fb_dur, 0);
84200c86:	05 00       	r3 = Null + Null;
84200c88:	4c 08       	r2 = r7 + Null;
84200c8a:	52 08       	r0 = r8 + Null;
84200c8c:	09 f0 27 e7 	call (m) Lc_aanc_initialize_ramp_1;

84200c90 <Lc_aanc_opmsg_set_control_21>:
                    /* Handled by early exit above */
                    break;
            }

            /* Determine control mode source and set override flags for mode */
            if (ctrl_src == CPS_SOURCE_HOST)
84200c90:	e1 f0 4c 80 	rMAC = MBS[FP + 76];
84200c94:	53 62       	if NE jump (m) Lc_aanc_opmsg_set_control_28;

84200c96 <Lc_aanc_opmsg_set_control_22>:
            {
                p_ext_data->host_mode = ctrl_value;
84200c96:	a1 d8       	rMAC = M[FP + 80];
84200c98:	61 f0 67 8e 	M[r4 + 412] = rMAC;
84200c9c:	aa 6f       	jump (m) Lc_aanc_opmsg_set_control_5;

84200c9e <Lc_aanc_opmsg_set_control_23>:
                    break;
                case AANC_SYSMODE_GENTLE_MUTE:
                    /* Gentle mute will ramp the FF and FB fine gains down to
                     * 0.
                     */
                    aanc_initialize_ramp(p_ff_ramp, 0, mt_dur, 0);
84200c9e:	05 00       	r3 = Null + Null;
84200ca0:	03 00       	r1 = Null + Null;
84200ca2:	3c 00       	r2 = r5 + Null;
84200ca4:	09 f0 2f e6 	call (m) Lc_aanc_initialize_ramp_1;
                    aanc_initialize_ramp(p_fb_ramp, 0, mt_dur, 0);
84200ca8:	05 00       	r3 = Null + Null;
84200caa:	03 00       	r1 = Null + Null;
84200cac:	3c 00       	r2 = r5 + Null;
84200cae:	52 08       	r0 = r8 + Null;
84200cb0:	09 f0 23 e6 	call (m) Lc_aanc_initialize_ramp_1;
                    break;
84200cb4:	ee 6f       	jump (m) Lc_aanc_opmsg_set_control_21;

84200cb6 <Lc_aanc_opmsg_set_control_24>:
                case AANC_SYSMODE_MUTE_ANC:
                    /* Mute FF and FB gains */
                    p_ext_data->ff_gain.fine = 0;
84200cb6:	60 f0 e1 8c 	MH[r4 + 450] = Null;
                    p_ext_data->fb_gain.fine = 0;
84200cba:	60 f0 e3 8c 	MH[r4 + 454] = Null;
                    break;
84200cbe:	e9 6f       	jump (m) Lc_aanc_opmsg_set_control_21;

84200cc0 <Lc_aanc_opmsg_set_control_25>:
                case AANC_SYSMODE_STATIC:
                    /* Set all gains to static values. FF and FB gains will
                     * be ramped from 0 to the static value.
                     */
                    p_ext_data->ec_gain = p_ext_data->ec_static_gain;
84200cc0:	61 f0 f8 86 	rMAC = MHU[r4 + 496];
84200cc4:	63 f0 f9 86 	r1 = MHU[r4 + 498];
84200cc8:	61 f0 e4 8c 	MH[r4 + 456] = rMAC;
84200ccc:	63 f0 e5 8c 	MH[r4 + 458] = r1;

                    p_ext_data->ff_gain.coarse = p_ext_data->ff_static_gain.coarse;
84200cd0:	61 f0 f4 86 	rMAC = MHU[r4 + 488];
84200cd4:	61 f0 e0 8c 	MH[r4 + 448] = rMAC;
                    ff_tgt = p_ext_data->ff_static_gain.fine;
84200cd8:	63 f0 f5 86 	r1 = MHU[r4 + 490];
84200cdc:	10 6e       	jump (m) Lc_aanc_opmsg_set_control_27;

84200cde <Lc_aanc_opmsg_set_control_26>:
                case AANC_SYSMODE_FULL:
                    /* Set gains to static. FB fine gain will be ramped from 0
                     * from 0 to its static value, FF fine gain ramped to its
                     * initial value.
                     */
                    p_ext_data->ec_gain = p_ext_data->ec_static_gain;
84200cde:	61 f0 f8 86 	rMAC = MHU[r4 + 496];
84200ce2:	63 f0 f9 86 	r1 = MHU[r4 + 498];
84200ce6:	61 f0 e4 8c 	MH[r4 + 456] = rMAC;
84200cea:	63 f0 e5 8c 	MH[r4 + 458] = r1;

                    p_ext_data->ff_gain.coarse = p_ext_data->ff_static_gain.coarse;
84200cee:	61 f0 f4 86 	rMAC = MHU[r4 + 488];
84200cf2:	61 f0 e0 8c 	MH[r4 + 448] = rMAC;
                    ff_tgt = (uint16)p_ext_data->aanc_cap_params.OFFSET_FXLMS_INITIAL_VALUE;
84200cf6:	61 f0 55 88 	rMAC = M[r4 + 340];
84200cfa:	8b c6       	r1 = rMAC AND 0xffff;

84200cfc <Lc_aanc_opmsg_set_control_27>:
                     */
                    p_ext_data->ec_gain = p_ext_data->ec_static_gain;

                    p_ext_data->ff_gain.coarse = p_ext_data->ff_static_gain.coarse;
                    ff_tgt = p_ext_data->ff_static_gain.fine;
                    aanc_initialize_ramp(p_ff_ramp, ff_tgt, ff_dur, 0);
84200cfc:	05 00       	r3 = Null + Null;
84200cfe:	09 f0 35 e3 	call (m) Lc_aanc_initialize_ramp_1;

                    p_ext_data->fb_gain.coarse = p_ext_data->fb_static_gain.coarse;
84200d02:	61 f0 f6 86 	rMAC = MHU[r4 + 492];
84200d06:	61 f0 e2 8c 	MH[r4 + 452] = rMAC;
                    fb_tgt = p_ext_data->fb_static_gain.fine;
84200d0a:	63 f0 f7 86 	r1 = MHU[r4 + 494];
                    aanc_initialize_ramp(p_fb_ramp, fb_tgt, fb_dur, fb_dly);
84200d0e:	45 08       	r3 = r6 + Null;
84200d10:	4c 08       	r2 = r7 + Null;
84200d12:	52 08       	r0 = r8 + Null;
84200d14:	09 f0 3f e2 	call (m) Lc_aanc_initialize_ramp_1;
#ifdef AANC_MAOR_V20
                    p_ext_data->rx_ffa_mix_gain = p_ext_data->rx_ffa_mix_static_gain;
84200d18:	61 f0 fa 86 	rMAC = MHU[r4 + 500];
84200d1c:	62 f0 fb 86 	r0 = MHU[r4 + 502];
84200d20:	61 f0 e6 8c 	MH[r4 + 460] = rMAC;
84200d24:	62 f0 e7 8c 	MH[r4 + 462] = r0;
                    p_ext_data->rx_ffb_mix_gain = p_ext_data->rx_ffb_mix_static_gain;
84200d28:	61 f0 fc 86 	rMAC = MHU[r4 + 504];
84200d2c:	62 f0 fd 86 	r0 = MHU[r4 + 506];
84200d30:	61 f0 e8 8c 	MH[r4 + 464] = rMAC;
84200d34:	62 f0 e9 8c 	MH[r4 + 466] = r0;
#endif
                    break;
84200d38:	ac 6f       	jump (m) Lc_aanc_opmsg_set_control_21;

84200d3a <Lc_aanc_opmsg_set_control_28>:
            {
                p_ext_data->host_mode = ctrl_value;
            }
            else
            {
                p_ext_data->qact_mode = ctrl_value;
84200d3a:	a1 d8       	rMAC = M[FP + 80];
84200d3c:	61 f0 68 8e 	M[r4 + 416] = rMAC;
                /* Set or clear the QACT override flag.
                * &= is used to preserve the state of the gain bits in the
                * override word.
                */
                if (ctrl_src == CPS_SOURCE_OBPM_ENABLE)
84200d40:	e1 f0 4c 80 	rMAC = MBS[FP + 76];
84200d44:	88 24       	Null = rMAC - 2;
84200d46:	09 62       	if NE jump (m) Lc_aanc_opmsg_set_control_30;

84200d48 <Lc_aanc_opmsg_set_control_29>:
                {
                    p_ext_data->ovr_control |= AANC_CONTROL_MODE_OVERRIDE;
84200d48:	61 f0 69 88 	rMAC = M[r4 + 420];
84200d4c:	20 f0 00 f1 	rMAC = rMAC OR 0x2000;
84200d50:	51 d8 
84200d52:	61 f0 69 8e 	M[r4 + 420] = rMAC;
84200d56:	4d 6f       	jump (m) Lc_aanc_opmsg_set_control_5;

84200d58 <Lc_aanc_opmsg_set_control_30>:
                }
                else
                {
                    p_ext_data->ovr_control &= AANC_OVERRIDE_MODE_MASK;
84200d58:	61 f0 69 88 	rMAC = M[r4 + 420];
84200d5c:	11 f6 ff 1f 	rMAC = rMAC AND 0xdfff;
84200d60:	61 f0 69 8e 	M[r4 + 420] = rMAC;
84200d64:	46 6f       	jump (m) Lc_aanc_opmsg_set_control_5;

84200d66 <Lc_aanc_opmsg_set_control_31>:

            continue;
        }

        /* In/Out of Ear control */
        else if (ctrl_id == AANC_CONSTANT_IN_OUT_EAR_CTRL)
84200d66:	f8 24       	Null = r5 - 3;
84200d68:	07 62       	if NE jump (m) Lc_aanc_opmsg_set_control_33;

84200d6a <Lc_aanc_opmsg_set_control_32>:
        {
            ctrl_value &= 0x01;
84200d6a:	a1 d8       	rMAC = M[FP + 80];
84200d6c:	09 c0       	rMAC = rMAC AND 0x1;
84200d6e:	a1 de       	M[FP + 80] = rMAC;
            p_ext_data->in_out_status = ctrl_value;
84200d70:	61 f0 04 9a 	MB[r4 + 516] = rMAC;

            /* No override flags indicated for in/out of ear */
            continue;
84200d74:	3e 6f       	jump (m) Lc_aanc_opmsg_set_control_5;

84200d76 <Lc_aanc_opmsg_set_control_33>:
        }

        /* Channel control */
        else if (ctrl_id == AANC_CONSTANT_CHANNEL_CTRL)
84200d76:	78 25       	Null = r5 - 5;
84200d78:	21 62       	if NE jump (m) Lc_aanc_opmsg_set_control_41;

84200d7a <Lc_aanc_opmsg_set_control_34>:
        {
            ctrl_value &= 0x1;
84200d7a:	a1 d8       	rMAC = M[FP + 80];
84200d7c:	09 c0       	rMAC = rMAC AND 0x1;
            if (ctrl_value == 0)
84200d7e:	a1 de       	M[FP + 80] = rMAC;
84200d80:	05 62       	if NE jump (m) Lc_aanc_opmsg_set_control_36;

84200d82 <Lc_aanc_opmsg_set_control_35>:
            {
                p_ext_data->anc_channel = AANC_ANC_INSTANCE_ANC0_ID;
84200d82:	71 d8       	rMAC = M[FP + 56];
84200d84:	61 f0 fc 8b 	MB[r4 + 508] = rMAC;
84200d88:	04 6e       	jump (m) Lc_aanc_opmsg_set_control_37;

84200d8a <Lc_aanc_opmsg_set_control_36>:
            }
            else
            {
                p_ext_data->anc_channel = AANC_ANC_INSTANCE_ANC1_ID;
84200d8a:	61 d8       	rMAC = M[FP + 48];
84200d8c:	61 f0 fc 8b 	MB[r4 + 508] = rMAC;

84200d90 <Lc_aanc_opmsg_set_control_37>:
            }

            /* Update ANC mask if in single filter mode */
            if (p_ext_data->filter_config != AANC_FILTER_CONFIG_PARALLEL)
84200d90:	61 f0 dc 86 	rMAC = MHU[r4 + 440];
84200d94:	48 24       	Null = rMAC - 1;
84200d96:	05 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_39;

84200d98 <Lc_aanc_opmsg_set_control_38>:
            {
                p_ext_data->anc_mask = p_ext_data->anc_channel;
84200d98:	61 f0 fc 81 	rMAC = MBS[r4 + 508];
84200d9c:	61 f0 fd 8b 	MB[r4 + 509] = rMAC;

84200da0 <Lc_aanc_opmsg_set_control_39>:
            }

            L4_DBG_MSG1("AANC channel override: %d",
                        p_ext_data->anc_channel);
84200da0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200da4:	08 25       	Null = rMAC - 4;
84200da6:	25 69       	if LT jump (m) Lc_aanc_opmsg_set_control_5;

84200da8 <Lc_aanc_opmsg_set_control_40>:
84200da8:	63 f0 fc 81 	r1 = MBS[r4 + 508];
84200dac:	55 f1 02 f0 	r0 = Null + 357565508;
84200db0:	44 48 
84200db2:	ff fd 01 f0 	call (m) 0x10c2;
84200db6:	31 e8 
84200db8:	1c 6f       	jump (m) Lc_aanc_opmsg_set_control_5;

84200dba <Lc_aanc_opmsg_set_control_41>:
            /* No override flags indicated for channel */
            continue;
        }

        /* Feedforward control */
        else if (ctrl_id == AANC_CONSTANT_FEEDFORWARD_CTRL)
84200dba:	b8 25       	Null = r5 - 6;
84200dbc:	27 62       	if NE jump (m) Lc_aanc_opmsg_set_control_47;

84200dbe <Lc_aanc_opmsg_set_control_42>:
        {
            ctrl_value &= 0x1;
84200dbe:	a1 d8       	rMAC = M[FP + 80];
84200dc0:	09 c0       	rMAC = rMAC AND 0x1;
            if (ctrl_value == 0)
84200dc2:	a1 de       	M[FP + 80] = rMAC;
84200dc4:	0b 62       	if NE jump (m) Lc_aanc_opmsg_set_control_44;

84200dc6 <Lc_aanc_opmsg_set_control_43>:
            {
                /* hybrid */
                p_ext_data->anc_ff_path = AANC_ANC_PATH_FFB_ID;
84200dc6:	61 d8       	rMAC = M[FP + 48];
84200dc8:	61 f0 fe 8b 	MB[r4 + 510] = rMAC;
                p_ext_data->anc_fb_path = AANC_ANC_PATH_FFA_ID;
84200dcc:	71 d8       	rMAC = M[FP + 56];
84200dce:	61 f0 ff 8b 	MB[r4 + 511] = rMAC;
                p_ext_data->anc_clock_check_value = AANC_HYBRID_ENABLE;
84200dd2:	69 d8       	rMAC = M[FP + 52];
84200dd4:	61 f0 00 8d 	MH[r4 + 512] = rMAC;
84200dd8:	09 6e       	jump (m) Lc_aanc_opmsg_set_control_45;

84200dda <Lc_aanc_opmsg_set_control_44>:
            }
            else
            {
                /* feedforward only */
                p_ext_data->anc_ff_path = AANC_ANC_PATH_FFA_ID;
84200dda:	71 d8       	rMAC = M[FP + 56];
84200ddc:	61 f0 fe 8b 	MB[r4 + 510] = rMAC;
                p_ext_data->anc_fb_path = AANC_ANC_PATH_NONE_ID;
84200de0:	60 f0 ff 8b 	MB[r4 + 511] = Null;
                p_ext_data->anc_clock_check_value = AANC_FEEDFORWARD_ENABLE;
84200de4:	79 d8       	rMAC = M[FP + 60];
84200de6:	61 f0 00 8d 	MH[r4 + 512] = rMAC;

84200dea <Lc_aanc_opmsg_set_control_45>:
            }
            L4_DBG_MSG2("AANC feedforward override: %d - %d",
                        p_ext_data->anc_ff_path, p_ext_data->anc_fb_path);
84200dea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200dee:	08 25       	Null = rMAC - 4;
84200df0:	00 69       	if LT jump (m) Lc_aanc_opmsg_set_control_5;

84200df2 <Lc_aanc_opmsg_set_control_46>:
84200df2:	64 f0 ff 81 	r2 = MBS[r4 + 511];
84200df6:	63 f0 fe 81 	r1 = MBS[r4 + 510];
84200dfa:	55 f1 02 f0 	r0 = Null + 357565534;
84200dfe:	5e 48 
84200e00:	ff fd 01 f0 	call (m) 0x10d6;
84200e04:	37 e6 
84200e06:	ff ff eb eb 	jump (m) Lc_aanc_opmsg_set_control_5;

84200e0a <Lc_aanc_opmsg_set_control_47>:
            /* No override flags indicated for feedforward */
            continue;
        }

#ifdef AANC_MAOR_V20
        else if (ctrl_id == AANC_CONSTANT_SAMPLE_RATE_CTRL)
84200e0a:	78 2c       	Null = r5 - 17;
84200e0c:	0a 62       	if NE jump (m) Lc_aanc_opmsg_set_control_49;

84200e0e <Lc_aanc_opmsg_set_control_48>:
        {
            ctrl_value &= 0x3;
84200e0e:	a1 d8       	rMAC = M[FP + 80];
84200e10:	89 c0       	rMAC = rMAC AND 0x3;
84200e12:	a1 de       	M[FP + 80] = rMAC;
            p_ext_data->ag->p_fxlms->sample_rate_config = ctrl_value;
84200e14:	62 f0 6f 88 	r0 = M[r4 + 444];
84200e18:	92 99       	r0 = M[r0 + 56];
84200e1a:	d1 9f       	M[r0 + 60] = rMAC;

            continue;
84200e1c:	ff ff d5 eb 	jump (m) Lc_aanc_opmsg_set_control_5;

84200e20 <Lc_aanc_opmsg_set_control_49>:

        else if (ctrl_id == AANC_CONSTANT_FF_FINE_GAIN_CTRL ||
                 (ctrl_id >= AANC_CONSTANT_FF_COARSE_GAIN_CTRL &&
                  ctrl_id <= AANC_CONSTANT_EC_COARSE_GAIN_CTRL) ||
                 (ctrl_id >= AANC_CONSTANT_RX_FFA_MIX_FINE_GAIN_CTRL &&
                  ctrl_id <= AANC_CONSTANT_RX_FFB_MIX_COARSE_GAIN_CTRL))
84200e20:	38 25       	Null = r5 - 4;
84200e22:	0c 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_54;

84200e24 <Lc_aanc_opmsg_set_control_50>:
84200e24:	f8 25       	Null = r5 - 7;
84200e26:	f3 ff c7 eb 	if NC jump (m) Lc_aanc_opmsg_set_control_4;

84200e2a <Lc_aanc_opmsg_set_control_51>:
84200e2a:	f8 26       	Null = r5 - 11;
84200e2c:	09 f0 8f e0 	if LS jump (m) Lc_aanc_opmsg_set_control_54;

84200e30 <Lc_aanc_opmsg_set_control_52>:
84200e30:	78 27       	Null = r5 - 13;
84200e32:	21 64       	if NC jump (m) Lc_aanc_opmsg_set_control_57;

84200e34 <Lc_aanc_opmsg_set_control_53>:
84200e34:	38 2c       	Null = r5 - 16;
84200e36:	f8 ff b7 eb 	if HI jump (m) Lc_aanc_opmsg_set_control_4;

84200e3a <Lc_aanc_opmsg_set_control_54>:
        else if (ctrl_id == AANC_CONSTANT_FF_FINE_GAIN_CTRL ||
                 (ctrl_id >= AANC_CONSTANT_FF_COARSE_GAIN_CTRL &&
                  ctrl_id <= AANC_CONSTANT_EC_COARSE_GAIN_CTRL))
#endif
        {
            aanc_initialize_prev_gain(p_ext_data);
84200e3a:	32 00       	r0 = r4 + Null;
84200e3c:	05 f0 27 ee 	call (m) Lc_aanc_initialize_prev_gain_1;
            sel_override = gain_override_table[ctrl_id];
84200e40:	7a 54       	r0 = r5 LSHIFT 2;
84200e42:	58 f0 21 f0 	rMAC = r0 + 1441968;
84200e46:	b0 20 
84200e48:	0a 88       	r0 = M[rMAC + 0];
84200e4a:	aa de       	M[FP + 84] = r0;

            if (override_gain(p_ext_data,
                              (uint16)ctrl_value,
                              sel_override.coarse,
                              sel_override.offset))
84200e4c:	55 d7       	r3 = MHU[FP + 84];
84200e4e:	e4 f0 56 82 	r2 = MBU[FP + 86];
84200e52:	a1 d8       	rMAC = M[FP + 80];
84200e54:	8b c6       	r1 = rMAC AND 0xffff;
84200e56:	32 00       	r0 = r4 + Null;
84200e58:	06 f0 29 e1 	call (m) Lc_override_gain_1;
84200e5c:	10 04       	Null = r0 - Null;
84200e5e:	07 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_56;

84200e60 <Lc_aanc_opmsg_set_control_55>:
            {
                aanc_update_gain(op_data, p_ext_data);
84200e60:	33 00       	r1 = r4 + Null;
84200e62:	42 d8       	r0 = M[FP + 32];
84200e64:	05 f0 3d e2 	call (m) Lc_aanc_update_gain_1;
84200e68:	ff ff 89 eb 	jump (m) Lc_aanc_opmsg_set_control_5;

84200e6c <Lc_aanc_opmsg_set_control_56>:
            }
            else
            {
                result = OPMSG_RESULT_STATES_PARAMETER_STATE_NOT_READY;
84200e6c:	81 20       	rMAC = Null + 2;
84200e6e:	59 de       	M[FP + 44] = rMAC;
84200e70:	ff ff 81 eb 	jump (m) Lc_aanc_opmsg_set_control_5;

84200e74 <Lc_aanc_opmsg_set_control_57>:
        }

        /* Filter config control */
        else if (ctrl_id == AANC_CONSTANT_FILTER_CONFIG_CTRL)
        {
            ctrl_value &= 0x1;
84200e74:	a1 d8       	rMAC = M[FP + 80];
84200e76:	0b c0       	r1 = rMAC AND 0x1;
84200e78:	a3 de       	M[FP + 80] = r1;
            /* Set ANC channel */
            FXLMS100_DMX *p_fxlms = p_ext_data->ag->p_fxlms;
84200e7a:	61 f0 6f 88 	rMAC = M[r4 + 444];
84200e7e:	89 99       	rMAC = M[rMAC + 56];
            unsigned existing_configuration = \
                p_fxlms->configuration & FXLMS100_CONFIG_LAYOUT_MASK_INV;
84200e80:	8a 99       	r0 = M[rMAC + 56];
84200e82:	22 f7 f0 1f 	r0 = r0 AND 0xfff0;
            switch (ctrl_value)
84200e86:	58 24       	Null = r1 - 1;
84200e88:	0a 62       	if NE jump (m) Lc_aanc_opmsg_set_control_59;

84200e8a <Lc_aanc_opmsg_set_control_58>:
            {
                case AANC_FILTER_CONFIG_PARALLEL:
                    p_fxlms->configuration = \
                        existing_configuration | FXLMS100_CONFIG_PARALLEL;
84200e8a:	12 c8       	r0 = r0 OR 0x1;
84200e8c:	8a 9f       	M[rMAC + 56] = r0;
                    p_ext_data->filter_config = AANC_FILTER_CONFIG_PARALLEL;
84200e8e:	82 d8       	r0 = M[FP + 64];
84200e90:	62 f0 dc 8c 	MH[r4 + 440] = r0;
                    p_ext_data->anc_mask = AANC_ANC_INSTANCE_BOTH_ID;
84200e94:	8a d8       	r0 = M[FP + 68];
84200e96:	62 f0 fd 8b 	MB[r4 + 509] = r0;
                    break;
84200e9a:	08 6e       	jump (m) Lc_aanc_opmsg_set_control_60;

84200e9c <Lc_aanc_opmsg_set_control_59>:
                case AANC_FILTER_CONFIG_SINGLE:
                default:
                    p_fxlms->configuration = \
                        existing_configuration | FXLMS100_CONFIG_SINGLE;
84200e9c:	8a 9f       	M[rMAC + 56] = r0;
                    p_ext_data->filter_config = AANC_FILTER_CONFIG_SINGLE;
84200e9e:	60 f0 dc 8c 	MH[r4 + 440] = Null;
                    p_ext_data->anc_mask = p_ext_data->anc_channel;
84200ea2:	62 f0 fc 81 	r0 = MBS[r4 + 508];
84200ea6:	62 f0 fd 8b 	MB[r4 + 509] = r0;

84200eaa <Lc_aanc_opmsg_set_control_60>:
                    break;
            }
            L4_DBG_MSG1("AANC filter configuration override: %u",
                        p_fxlms->configuration);
84200eaa:	02 f0 34 91 	r0 = MBS[Null + 0x334];
84200eae:	10 25       	Null = r0 - 4;
84200eb0:	fb ff c1 ea 	if LT jump (m) Lc_aanc_opmsg_set_control_5;

84200eb4 <Lc_aanc_opmsg_set_control_61>:
84200eb4:	8b 99       	r1 = M[rMAC + 56];
84200eb6:	55 f1 02 f0 	r0 = Null + 357565569;
84200eba:	81 48 
84200ebc:	ff fd 01 f0 	call (m) 0x10c2;
84200ec0:	27 e0 
84200ec2:	ff ff af ea 	jump (m) Lc_aanc_opmsg_set_control_5;

84200ec6 <Lc_aanc_opmsg_set_control_62>:
    {
        p_ext_data->cur_mode = p_ext_data->qact_mode;
    }
    else
    {
        p_ext_data->cur_mode = p_ext_data->host_mode;
84200ec6:	61 f0 67 88 	rMAC = M[r4 + 412];
84200eca:	61 f0 66 8e 	M[r4 + 408] = rMAC;

84200ece <Lc_aanc_opmsg_set_control_63>:
    }

    cps_response_set_result(resp_data, result);
84200ece:	5b d8       	r1 = M[FP + 44];
84200ed0:	52 d8       	r0 = M[FP + 40];
84200ed2:	ff fd 00 f0 	call (m) 0xf30;
84200ed6:	3f e2 

    return TRUE;
84200ed8:	42 20       	r0 = Null + 1;

84200eda <Lc_aanc_opmsg_set_control_64>:
}
84200eda:	72 4c       	SP = SP + -56;
84200edc:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200ede:	d8 4c       	rts;

84200ee0 <$_aanc_opmsg_get_params>:

bool aanc_opmsg_get_params(OPERATOR_DATA *op_data, void *message_data,
                           unsigned *resp_length,
                           OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ee0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200ee2:	1f 00       	r5 = r1 + Null;
84200ee4:	26 00       	r4 = r2 + Null;
84200ee6:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200ee8:	ef fd fd ff 	call (m) 0x8ea;
84200eec:	23 e0 
                           unsigned *resp_length,
                           OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);
    return cpsGetParameterMsgHandler(&p_ext_data->params_def, message_data,
                                     resp_length, resp_data);
84200eee:	02 f0 10 46 	r0 = r0 + 528;
84200ef2:	45 08       	r3 = r6 + Null;
84200ef4:	34 00       	r2 = r4 + Null;
84200ef6:	3b 00       	r1 = r5 + Null;
84200ef8:	ef fd fe ff 	call (m) 0xb7c;
84200efc:	25 e4 

84200efe <Lc_aanc_opmsg_get_params_2>:
}
84200efe:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200f00:	d8 4c       	rts;

84200f02 <$_aanc_opmsg_get_defaults>:

bool aanc_opmsg_get_defaults(OPERATOR_DATA *op_data, void *message_data,
                             unsigned *resp_length,
                             OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f02:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200f04:	1f 00       	r5 = r1 + Null;
84200f06:	26 00       	r4 = r2 + Null;
84200f08:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200f0a:	ef fd fc ff 	call (m) 0x8ea;
84200f0e:	21 ef 
                             unsigned *resp_length,
                             OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);
    return cpsGetDefaultsMsgHandler(&p_ext_data->params_def, message_data,
                                    resp_length, resp_data);
84200f10:	02 f0 10 46 	r0 = r0 + 528;
84200f14:	45 08       	r3 = r6 + Null;
84200f16:	34 00       	r2 = r4 + Null;
84200f18:	3b 00       	r1 = r5 + Null;
84200f1a:	ef fd fe ff 	call (m) 0xc2c;
84200f1e:	33 e8 

84200f20 <Lc_aanc_opmsg_get_defaults_2>:
}
84200f20:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200f22:	d8 4c       	rts;

84200f24 <$_aanc_opmsg_set_params>:

bool aanc_opmsg_set_params(OPERATOR_DATA *op_data, void *message_data,
                           unsigned *resp_length,
                           OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f24:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200f26:	1b 09       	r9 = r1 + Null;
84200f28:	22 09       	r8 = r2 + Null;
84200f2a:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200f2c:	ef fd fc ff 	call (m) 0x8ea;
84200f30:	3f ed 
84200f32:	17 00       	r5 = r0 + Null;
bool aanc_opmsg_set_params(OPERATOR_DATA *op_data, void *message_data,
                           unsigned *resp_length,
                           OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);
    AANC_PARAMETERS *p_params = &p_ext_data->aanc_cap_params;
84200f34:	3e 3b       	r4 = r5 + 60;
    bool success;
    unsigned disable_agc_calc_saved;
    disable_agc_calc_saved = p_params->OFFSET_DISABLE_AG_CALC;
84200f36:	69 f0 01 88 	r7 = M[r4 + 4];
    /* patch_fn(aanc_opmsg_set_params); */

    success = cpsSetParameterMsgHandler(&p_ext_data->params_def, message_data,
                                       resp_length, resp_data);
84200f3a:	62 f0 d4 21 	r0 = r4 + 468;
84200f3e:	45 08       	r3 = r6 + Null;
84200f40:	54 08       	r2 = r8 + Null;
84200f42:	5b 08       	r1 = r9 + Null;
84200f44:	ef fd fe ff 	call (m) 0xd00;
84200f48:	3d ed 
84200f4a:	10 09       	r6 = r0 + Null;

    if (success)
84200f4c:	09 60       	if EQ jump (m) Lc_aanc_opmsg_set_params_4;

84200f4e <Lc_aanc_opmsg_set_params_2>:
    {
       if(disable_agc_calc_saved == p_params->OFFSET_DISABLE_AG_CALC)
84200f4e:	71 88       	rMAC = M[r4 + 4];
84200f50:	1f f9 00 c2 	Null = r7 - rMAC;
84200f54:	0f 62       	if NE jump (m) Lc_aanc_opmsg_set_params_6;

84200f56 <Lc_aanc_opmsg_set_params_3>:
       {
           /* Set re-initialization flag for capability */
           p_ext_data->re_init_flag = TRUE;
84200f56:	41 20       	rMAC = Null + 1;
84200f58:	71 f0 02 9a 	MB[r5 + 514] = rMAC;
84200f5c:	0b 6e       	jump (m) Lc_aanc_opmsg_set_params_6;

84200f5e <Lc_aanc_opmsg_set_params_4>:
       }
    }
    else
    {
        L2_DBG_MSG("AANC Set Parameters Failed");
84200f5e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200f62:	88 24       	Null = rMAC - 2;
84200f64:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_params_6;

84200f66 <Lc_aanc_opmsg_set_params_5>:
84200f66:	55 f1 02 f0 	r0 = Null + 357565608;
84200f6a:	a8 48 
84200f6c:	ff fd 00 f0 	call (m) 0x10b0;
84200f70:	25 ea 

84200f72 <Lc_aanc_opmsg_set_params_6>:
    }

    return success;
84200f72:	42 08       	r0 = r6 + Null;

84200f74 <Lc_aanc_opmsg_set_params_7>:
}
84200f74:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200f76:	d8 4c       	rts;

84200f78 <$_aanc_opmsg_get_status>:

bool aanc_opmsg_get_status(OPERATOR_DATA *op_data, void *message_data,
                           unsigned *resp_length,
                           OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f78:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200f7a:	59 4c       	SP = SP + 100;
84200f7c:	19 09       	r7 = r1 + Null;
84200f7e:	27 00       	r5 = r2 + Null;
84200f80:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84200f82:	ef fd fc ff 	call (m) 0x8ea;
84200f86:	29 eb 
84200f88:	16 00       	r4 = r0 + Null;
    ParamType *pparam;
    ADAPTIVE_GAIN *p_ag;

    /* Build the response */
    if(!common_obpm_status_helper(message_data, resp_length, resp_data,
                                  sizeof(AANC_STATISTICS), &resp))
84200f8a:	81 11       	rMAC = FP + 24;
84200f8c:	09 1c       	pushm <rMAC>;
84200f8e:	05 f0 60 40 	r3 = Null + 96;
84200f92:	44 08       	r2 = r6 + Null;
84200f94:	3b 00       	r1 = r5 + Null;
84200f96:	4a 08       	r0 = r7 + Null;
84200f98:	ef fd ff ff 	call (m) 0xf46;
84200f9c:	2f ed 
84200f9e:	7f 4c       	SP = SP + -4;
84200fa0:	10 04       	Null = r0 - Null;
84200fa2:	03 62       	if NE jump (m) Lc_aanc_opmsg_get_status_3;

84200fa4 <Lc_aanc_opmsg_get_status_2>:
    {
         return FALSE;
84200fa4:	02 00       	r0 = Null + Null;
84200fa6:	8b 6e       	jump (m) Lc_aanc_opmsg_get_status_13;

84200fa8 <Lc_aanc_opmsg_get_status_3>:
    }

    if (resp != NULL)
84200fa8:	31 d8       	rMAC = M[FP + 24];
84200faa:	88 60       	if EQ jump (m) Lc_aanc_opmsg_get_status_12;

84200fac <Lc_aanc_opmsg_get_status_4>:
    {
        p_fxlms = p_ext_data->ag->p_fxlms;
84200fac:	62 f0 6f 88 	r0 = M[r4 + 444];
84200fb0:	91 99       	rMAC = M[r0 + 56];
        p_ed_ext = p_ext_data->ag->p_ed_ext;
84200fb2:	57 98       	r5 = M[r0 + 36];
        p_ed_int = p_ext_data->ag->p_ed_int;
84200fb4:	28 f0 05 88 	r6 = M[r0 + 20];
        p_ed_pb = p_ext_data->ag->p_ed_pb;
84200fb8:	29 f0 0c 88 	r7 = M[r0 + 48];

#ifdef USE_AANC_LICENSING
        p_ext_data->license_status = AANC_LICENSE_STATUS_LICENSING_BUILD_STATUS;
84200fbc:	00 f1 02 f0 	r0 = Null + 268435456;
84200fc0:	00 40 
84200fc2:	62 f0 83 8e 	M[r4 + 524] = r0;
        if (p_fxlms->licensed)
84200fc6:	c8 a8       	Null = M[rMAC + 76];
84200fc8:	06 60       	if EQ jump (m) Lc_aanc_opmsg_get_status_6;

84200fca <Lc_aanc_opmsg_get_status_5>:
        {
            p_ext_data->license_status |= AANC_LICENSE_STATUS_FxLMS;
84200fca:	00 f1 02 f0 	r0 = Null + 268435458;
84200fce:	02 40 
84200fd0:	62 f0 83 8e 	M[r4 + 524] = r0;

84200fd4 <Lc_aanc_opmsg_get_status_6>:
        }
        /* NB: License status won't be set if the block is disabled.
         * Given that all EDs use the same license check, OR a comparison
         * between them.
         */
        if (p_ed_ext->licensed || p_ed_int->licensed || p_ed_pb->licensed)
84200fd4:	78 a9       	Null = M[r5 + 84];
84200fd6:	07 62       	if NE jump (m) Lc_aanc_opmsg_get_status_9;

84200fd8 <Lc_aanc_opmsg_get_status_7>:
84200fd8:	80 f0 15 88 	Null = M[r6 + 84];
84200fdc:	04 62       	if NE jump (m) Lc_aanc_opmsg_get_status_9;

84200fde <Lc_aanc_opmsg_get_status_8>:
84200fde:	90 f0 15 88 	Null = M[r7 + 84];
84200fe2:	06 60       	if EQ jump (m) Lc_aanc_opmsg_get_status_10;

84200fe4 <Lc_aanc_opmsg_get_status_9>:
        {
            p_ext_data->license_status |= AANC_LICENSE_STATUS_ED;
84200fe4:	62 f0 83 88 	r0 = M[r4 + 524];
84200fe8:	12 c8       	r0 = r0 OR 0x1;
84200fea:	62 f0 83 8e 	M[r4 + 524] = r0;

84200fee <Lc_aanc_opmsg_get_status_10>:
        }
#endif /* USE_AANC_LICENSING */

        stats.OFFSET_CUR_MODE = p_ext_data->cur_mode;
84200fee:	62 f0 66 88 	r0 = M[r4 + 408];
84200ff2:	3a de       	M[FP + 28] = r0;
        stats.OFFSET_OVR_CONTROL = p_ext_data->ovr_control;
84200ff4:	62 f0 69 88 	r0 = M[r4 + 420];
84200ff8:	42 de       	M[FP + 32] = r0;
        stats.OFFSET_IN_OUT_EAR_CTRL = p_ext_data->in_out_status;
84200ffa:	62 f0 04 92 	r0 = MBU[r4 + 516];
84200ffe:	4a de       	M[FP + 36] = r0;
        stats.OFFSET_CHANNEL = p_ext_data->anc_channel;
84201000:	62 f0 fc 81 	r0 = MBS[r4 + 508];
84201004:	52 de       	M[FP + 40] = r0;
        stats.OFFSET_FILTER_CONFIG = p_fxlms->configuration;
84201006:	8a 99       	r0 = M[rMAC + 56];
84201008:	5a de       	M[FP + 44] = r0;
        stats.OFFSET_FEEDFORWARD_PATH = p_ext_data->anc_ff_path;
8420100a:	62 f0 fe 81 	r0 = MBS[r4 + 510];
8420100e:	62 de       	M[FP + 48] = r0;
        stats.OFFSET_LICENSE_STATUS = p_ext_data->license_status;
84201010:	62 f0 83 88 	r0 = M[r4 + 524];
84201014:	6a de       	M[FP + 52] = r0;
        stats.OFFSET_FLAGS = p_ext_data->flags;
84201016:	62 f0 6b 88 	r0 = M[r4 + 428];
8420101a:	72 de       	M[FP + 56] = r0;
        stats.OFFSET_AG_CALC = p_fxlms->adaptive_gain;
8420101c:	49 a8       	rMAC = M[rMAC + 68];
8420101e:	79 de       	M[FP + 60] = rMAC;
        /* Send previous gain values as stats because these are only updated
         * when the value is actually written to HW.
         */
        stats.OFFSET_FF_FINE_GAIN_CTRL = p_ext_data->ff_gain_prev.fine;
84201020:	61 f0 eb 86 	rMAC = MHU[r4 + 470];
84201024:	81 de       	M[FP + 64] = rMAC;
        stats.OFFSET_FF_COARSE_GAIN_CTRL = \
        p_ext_data->ff_gain_prev.coarse & AANC_COARSE_GAIN_MASK;
84201026:	61 f0 ea 86 	rMAC = MHU[r4 + 468];
8420102a:	89 c1       	rMAC = rMAC AND 0xf;
8420102c:	89 de       	M[FP + 68] = rMAC;
        stats.OFFSET_FF_GAIN_DB = aanc_proc_calc_gain_db(
            p_ext_data->ff_gain_prev.fine,
            (int16)p_ext_data->ff_gain_prev.coarse);
8420102e:	61 f0 ea 86 	rMAC = MHU[r4 + 468];
84201032:	0b 0c       	r1 = SE16 rMAC;
84201034:	62 f0 eb 86 	r0 = MHU[r4 + 470];
84201038:	0d f0 37 ec 	call (m) $_aanc_proc_calc_gain_db;
8420103c:	92 de       	M[FP + 72] = r0;
        stats.OFFSET_FB_FINE_GAIN_CTRL = p_ext_data->fb_gain_prev.fine;
8420103e:	61 f0 ed 86 	rMAC = MHU[r4 + 474];
84201042:	99 de       	M[FP + 76] = rMAC;
        stats.OFFSET_FB_COARSE_GAIN_CTRL = \
            p_ext_data->fb_gain_prev.coarse & AANC_COARSE_GAIN_MASK;
84201044:	61 f0 ec 86 	rMAC = MHU[r4 + 472];
84201048:	89 c1       	rMAC = rMAC AND 0xf;
8420104a:	a1 de       	M[FP + 80] = rMAC;
        stats.OFFSET_FB_GAIN_DB = aanc_proc_calc_gain_db(
            p_ext_data->fb_gain_prev.fine,
            (int16)p_ext_data->fb_gain_prev.coarse);
8420104c:	61 f0 ec 86 	rMAC = MHU[r4 + 472];
84201050:	0b 0c       	r1 = SE16 rMAC;
84201052:	62 f0 ed 86 	r0 = MHU[r4 + 474];
84201056:	0d f0 39 eb 	call (m) $_aanc_proc_calc_gain_db;
8420105a:	aa de       	M[FP + 84] = r0;
        stats.OFFSET_EC_FINE_GAIN_CTRL = p_ext_data->ec_gain_prev.fine;
8420105c:	61 f0 ef 86 	rMAC = MHU[r4 + 478];
84201060:	b1 de       	M[FP + 88] = rMAC;
        stats.OFFSET_EC_COARSE_GAIN_CTRL = \
            p_ext_data->ec_gain_prev.coarse & AANC_COARSE_GAIN_MASK;
84201062:	61 f0 ee 86 	rMAC = MHU[r4 + 476];
84201066:	89 c1       	rMAC = rMAC AND 0xf;
84201068:	b9 de       	M[FP + 92] = rMAC;
        stats.OFFSET_EC_GAIN_DB = aanc_proc_calc_gain_db(
            p_ext_data->ec_gain_prev.fine,
            (int16)p_ext_data->ec_gain_prev.coarse);
8420106a:	61 f0 ee 86 	rMAC = MHU[r4 + 476];
8420106e:	0b 0c       	r1 = SE16 rMAC;
84201070:	62 f0 ef 86 	r0 = MHU[r4 + 478];
84201074:	0d f0 3b ea 	call (m) $_aanc_proc_calc_gain_db;
84201078:	c2 de       	M[FP + 96] = r0;
        stats.OFFSET_SPL_EXT = p_ed_ext->spl;
8420107a:	79 a8       	rMAC = M[r5 + 68];
8420107c:	c9 de       	M[FP + 100] = rMAC;
        stats.OFFSET_SPL_INT = p_ed_int->spl;
8420107e:	81 f0 11 88 	rMAC = M[r6 + 68];
84201082:	d1 de       	M[FP + 104] = rMAC;
        stats.OFFSET_SPL_PB = p_ed_pb->spl;
84201084:	91 f0 11 88 	rMAC = M[r7 + 68];
84201088:	d9 de       	M[FP + 108] = rMAC;
        /* Read and reset peak meters */
        p_ag = p_ext_data->ag;
8420108a:	61 f0 6f 88 	rMAC = M[r4 + 444];
        stats.OFFSET_PEAK_EXT = p_ag->clip_ext.peak_value;
8420108e:	4a a8       	r0 = M[rMAC + 68];
84201090:	e2 de       	M[FP + 112] = r0;
        p_ag->clip_ext.peak_value = 0;
84201092:	48 ae       	M[rMAC + 68] = Null;
        stats.OFFSET_PEAK_INT = p_ag->clip_int.peak_value;
84201094:	0a a9       	r0 = M[rMAC + 80];
84201096:	ea de       	M[FP + 116] = r0;
        p_ag->clip_int.peak_value = 0;
84201098:	08 af       	M[rMAC + 80] = Null;
        stats.OFFSET_PEAK_PB = p_ag->clip_pb.peak_value;
8420109a:	ca a9       	r0 = M[rMAC + 92];
8420109c:	f2 de       	M[FP + 120] = r0;
        p_ag->clip_pb.peak_value = 0;
8420109e:	c8 af       	M[rMAC + 92] = Null;

        pparam = (ParamType*)(&stats);
        for (i=0; i<AANC_N_STAT/2; i++)
842010a0:	06 00       	r4 = Null + Null;
842010a2:	c7 11       	r5 = FP + 28;

842010a4 <Lc_aanc_opmsg_get_status_11>:
        {
            resp = cpsPack2Words(pparam[2*i], pparam[2*i+1], resp);
842010a4:	34 d8       	r2 = M[FP + 24];
842010a6:	7b 88       	r1 = M[r5 + 4];
842010a8:	3a e8       	r0 = M[r5 + Null];
842010aa:	ff fd 64 f2 	call (m) 0x4da2c;
842010ae:	23 ec 
842010b0:	32 de       	M[FP + 24] = r0;
        p_ag->clip_int.peak_value = 0;
        stats.OFFSET_PEAK_PB = p_ag->clip_pb.peak_value;
        p_ag->clip_pb.peak_value = 0;

        pparam = (ParamType*)(&stats);
        for (i=0; i<AANC_N_STAT/2; i++)
842010b2:	76 20       	r4 = r4 + 1;
842010b4:	3f 22       	r5 = r5 + 8;
842010b6:	30 27       	Null = r4 - 12;
842010b8:	f6 69       	if LT jump (m) Lc_aanc_opmsg_get_status_11;

842010ba <Lc_aanc_opmsg_get_status_12>:
        {
            cpsPack1Word(pparam[AANC_N_STAT-1], resp);
        }
    }

    return TRUE;
842010ba:	42 20       	r0 = Null + 1;

842010bc <Lc_aanc_opmsg_get_status_13>:
}
842010bc:	67 4c       	SP = SP + -100;
842010be:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842010c0:	d8 4c       	rts;

842010c2 <$_aanc_opmsg_set_ucid>:
}

bool aanc_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data,
                         unsigned *resp_length,
                         OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010c2:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842010c4:	12 09       	r8 = r0 + Null;
842010c6:	19 09       	r7 = r1 + Null;
842010c8:	27 00       	r5 = r2 + Null;
842010ca:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
842010cc:	ef fd fc ff 	call (m) 0x8ea;
842010d0:	3f e0 
842010d2:	16 00       	r4 = r0 + Null;
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool success;

    success = cpsSetUcidMsgHandler(&p_ext_data->params_def, message_data,
                                  resp_length, resp_data);
842010d4:	62 f0 10 22 	r0 = r4 + 528;
842010d8:	45 08       	r3 = r6 + Null;
842010da:	3c 00       	r2 = r5 + Null;
842010dc:	4b 08       	r1 = r7 + Null;
842010de:	ef fd fe ff 	call (m) 0xd92;
842010e2:	35 e5 
842010e4:	17 00       	r5 = r0 + Null;
    L5_DBG_MSG1("AANC cpsSetUcidMsgHandler Return Value %u", success);
842010e6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842010ea:	48 25       	Null = rMAC - 5;
842010ec:	08 68       	if LT jump (m) Lc_aanc_opmsg_set_ucid_3;

842010ee <Lc_aanc_opmsg_set_ucid_2>:
842010ee:	55 f1 02 f0 	r0 = Null + 357565635;
842010f2:	c3 48 
842010f4:	3b 00       	r1 = r5 + Null;
842010f6:	ef fd ff ff 	call (m) 0x10c2;
842010fa:	2d ee 

842010fc <Lc_aanc_opmsg_set_ucid_3>:
    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(p_ext_data->cap_id,
                                         p_ext_data->params_def.ucid,
                                         OPMSG_P_STORE_PARAMETER_SUB_ID);
842010fc:	b1 99       	rMAC = M[r4 + 56];
842010fe:	8a c6       	r0 = rMAC AND 0xffff;
84201100:	92 55       	r0 = r0 LSHIFT 7;
84201102:	61 f0 88 88 	rMAC = M[r4 + 544];
84201106:	8b c2       	r1 = rMAC AND 0x3f;
84201108:	1b 54       	r1 = r1 LSHIFT 1;
8420110a:	9b 12       	r1 = r1 OR r0;

    ps_entry_read((void*)op_data, key, PERSIST_ANY, ups_params_aanc);
8420110c:	42 f0 05 f0 	r3 = Null + 69212121;
84201110:	d9 6b 
84201112:	04 00       	r2 = Null + Null;
84201114:	52 08       	r0 = r8 + Null;
84201116:	ff fd 39 f0 	call (m) 0x8370;
8420111a:	3b e2 

    L5_DBG_MSG1("AANC UCID Set to %u", p_ext_data->params_def.ucid);
8420111c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201120:	48 25       	Null = rMAC - 5;
84201122:	09 68       	if LT jump (m) Lc_aanc_opmsg_set_ucid_5;

84201124 <Lc_aanc_opmsg_set_ucid_4>:
84201124:	63 f0 88 88 	r1 = M[r4 + 544];
84201128:	55 f1 02 f0 	r0 = Null + 357565677;
8420112c:	ed 48 
8420112e:	ef fd ff ff 	call (m) 0x10c2;
84201132:	35 ec 

84201134 <Lc_aanc_opmsg_set_ucid_5>:

    p_ext_data->re_init_flag = TRUE;
84201134:	41 20       	rMAC = Null + 1;
84201136:	61 f0 02 9a 	MB[r4 + 514] = rMAC;

    return success;
8420113a:	3a 00       	r0 = r5 + Null;

8420113c <Lc_aanc_opmsg_set_ucid_6>:
}
8420113c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420113e:	d8 4c       	rts;

84201140 <$_aanc_opmsg_get_ps_id>:

bool aanc_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data,
                          unsigned *resp_length,
                          OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201140:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201142:	1f 00       	r5 = r1 + Null;
84201144:	26 00       	r4 = r2 + Null;
84201146:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84201148:	ef fd fb ff 	call (m) 0x8ea;
8420114c:	23 ed 
                          unsigned *resp_length,
                          OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);
    return cpsGetUcidMsgHandler(&p_ext_data->params_def, p_ext_data->cap_id,
                                message_data, resp_length, resp_data);
8420114e:	10 1c       	pushm <r6>;
84201150:	93 99       	r1 = M[r0 + 56];
84201152:	35 00       	r3 = r4 + Null;
84201154:	02 f0 10 46 	r0 = r0 + 528;
84201158:	3c 00       	r2 = r5 + Null;
8420115a:	ef fd fe ff 	call (m) 0xdb4;
8420115e:	3b e2 
84201160:	7f 4c       	SP = SP + -4;

84201162 <Lc_aanc_opmsg_get_ps_id_2>:
}
84201162:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201164:	d8 4c       	rts;

84201166 <$_aanc_opmsg_set_static_gain>:
Custom opmsg handlers
*/
bool aanc_opmsg_set_static_gain(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201166:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201168:	18 09       	r6 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
8420116a:	ef fd fb ff 	call (m) 0x8ea;
8420116e:	21 ec 
84201170:	16 00       	r4 = r0 + Null;

    uint16 coarse_gain, fine_gain;

    coarse_gain = OPMSG_FIELD_GET(message_data,
                                  OPMSG_SET_AANC_STATIC_GAIN,
                                  FF_COARSE_STATIC_GAIN);
84201172:	81 f0 03 88 	rMAC = M[r6 + 12];
84201176:	8f c6       	r5 = rMAC AND 0xffff;
    fine_gain = OPMSG_FIELD_GET(message_data,
                                OPMSG_SET_AANC_STATIC_GAIN,
                                FF_FINE_STATIC_GAIN);
84201178:	81 f0 04 88 	rMAC = M[r6 + 16];
8420117c:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;

    /* Add headroom for adaptive gain algorithm. If the fine gain is too
     * large, decrease it by 6dB and increment the coarse gain to compensate.
     */
    if (fine_gain > AANC_STATIC_GAIN_ADJUST_THRESHOLD)
84201180:	90 f0 80 24 	Null = r7 - 128;
84201184:	06 6c       	if LE jump (m) Lc_aanc_opmsg_set_static_gain_3;

84201186 <Lc_aanc_opmsg_set_static_gain_2>:
    {
        fine_gain = fine_gain >> 1;
84201186:	7f f9 19 d9 	r7 = r7 ASHIFT -1;
        coarse_gain++;
8420118a:	79 20       	rMAC = r5 + 1;
8420118c:	8f c6       	r5 = rMAC AND 0xffff;
8420118e:	0d 6e       	jump (m) Lc_aanc_opmsg_set_static_gain_5;

84201190 <Lc_aanc_opmsg_set_static_gain_3>:
    }
    else if (fine_gain < AANC_STATIC_GAIN_FAIL_THRESHOLD)
84201190:	90 f0 40 24 	Null = r7 - 64;
84201194:	0a 66       	if GE jump (m) Lc_aanc_opmsg_set_static_gain_5;

84201196 <Lc_aanc_opmsg_set_static_gain_4>:
    {
        L0_DBG_MSG2("AANC FF static fine gain too low: %hu (< %hu)",
                    fine_gain, AANC_STATIC_GAIN_FAIL_THRESHOLD);
84201196:	04 f0 40 40 	r2 = Null + 64;
8420119a:	55 f1 02 f0 	r0 = Null + 357565697;
8420119e:	01 49 
842011a0:	4b 08       	r1 = r7 + Null;
842011a2:	ef fd ff ff 	call (m) 0x10d6;
842011a6:	35 e9 

842011a8 <Lc_aanc_opmsg_set_static_gain_5>:
    }

    p_ext_data->ff_static_gain.coarse = coarse_gain;
842011a8:	67 f0 f4 8c 	MH[r4 + 488] = r5;
    p_ext_data->ff_static_gain.fine = fine_gain;
842011ac:	69 f0 f5 8c 	MH[r4 + 490] = r7;
    L4_DBG_MSG2("AANC Set FF Static Gain: Coarse = %hu, Fine = %hu",
        p_ext_data->ff_static_gain.coarse, p_ext_data->ff_static_gain.fine);
842011b0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842011b4:	08 25       	Null = rMAC - 4;
842011b6:	09 68       	if LT jump (m) Lc_aanc_opmsg_set_static_gain_7;

842011b8 <Lc_aanc_opmsg_set_static_gain_6>:
842011b8:	55 f1 02 f0 	r0 = Null + 357565743;
842011bc:	2f 49 
842011be:	4c 08       	r2 = r7 + Null;
842011c0:	3b 00       	r1 = r5 + Null;
842011c2:	ef fd ff ff 	call (m) 0x10d6;
842011c6:	35 e8 

842011c8 <Lc_aanc_opmsg_set_static_gain_7>:

    p_ext_data->fb_static_gain.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, FB_COARSE_STATIC_GAIN);
842011c8:	81 f0 05 88 	rMAC = M[r6 + 20];
842011cc:	8b c6       	r1 = rMAC AND 0xffff;
842011ce:	63 f0 f6 8c 	MH[r4 + 492] = r1;
    p_ext_data->fb_static_gain.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, FB_FINE_STATIC_GAIN);
842011d2:	81 f0 06 88 	rMAC = M[r6 + 24];
842011d6:	8c c6       	r2 = rMAC AND 0xffff;
842011d8:	64 f0 f7 8c 	MH[r4 + 494] = r2;
    L4_DBG_MSG2("AANC Set FB Static Gain: Coarse = %hu, Fine = %hu",
        p_ext_data->fb_static_gain.coarse, p_ext_data->fb_static_gain.fine);
842011dc:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842011e0:	08 25       	Null = rMAC - 4;
842011e2:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_static_gain_9;

842011e4 <Lc_aanc_opmsg_set_static_gain_8>:
842011e4:	55 f1 02 f0 	r0 = Null + 357565793;
842011e8:	61 49 
842011ea:	ef fd ff ff 	call (m) 0x10d6;
842011ee:	2d e7 

842011f0 <Lc_aanc_opmsg_set_static_gain_9>:

    p_ext_data->ec_static_gain.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, EC_COARSE_STATIC_GAIN);
842011f0:	81 f0 07 88 	rMAC = M[r6 + 28];
842011f4:	8b c6       	r1 = rMAC AND 0xffff;
842011f6:	63 f0 f8 8c 	MH[r4 + 496] = r1;
    p_ext_data->ec_static_gain.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, EC_FINE_STATIC_GAIN);
842011fa:	81 f0 08 88 	rMAC = M[r6 + 32];
842011fe:	8c c6       	r2 = rMAC AND 0xffff;
84201200:	64 f0 f9 8c 	MH[r4 + 498] = r2;
    L4_DBG_MSG2("AANC Set EC Static Gain: Coarse = %hu, Fine = %hu",
        p_ext_data->ec_static_gain.coarse, p_ext_data->ec_static_gain.fine);
84201204:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201208:	08 25       	Null = rMAC - 4;
8420120a:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_static_gain_11;

8420120c <Lc_aanc_opmsg_set_static_gain_10>:
8420120c:	55 f1 02 f0 	r0 = Null + 357565843;
84201210:	93 49 
84201212:	ef fd ff ff 	call (m) 0x10d6;
84201216:	25 e6 

84201218 <Lc_aanc_opmsg_set_static_gain_11>:

#ifdef AANC_MAOR_V20
    p_ext_data->rx_ffa_mix_static_gain.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, RX_FFA_MIX_COARSE_STATIC_GAIN);
84201218:	81 f0 09 88 	rMAC = M[r6 + 36];
8420121c:	8b c6       	r1 = rMAC AND 0xffff;
8420121e:	63 f0 fa 8c 	MH[r4 + 500] = r1;
    p_ext_data->rx_ffa_mix_static_gain.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, RX_FFA_MIX_FINE_STATIC_GAIN);
84201222:	81 f0 0a 88 	rMAC = M[r6 + 40];
84201226:	8c c6       	r2 = rMAC AND 0xffff;
84201228:	64 f0 fb 8c 	MH[r4 + 502] = r2;
    L4_DBG_MSG2("AANC Set Rx FFa Mix Static Gain: Coarse = %hu, Fine = %hu",
        p_ext_data->rx_ffa_mix_static_gain.coarse,
        p_ext_data->rx_ffa_mix_static_gain.fine);
8420122c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201230:	08 25       	Null = rMAC - 4;
84201232:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_static_gain_13;

84201234 <Lc_aanc_opmsg_set_static_gain_12>:
84201234:	55 f1 02 f0 	r0 = Null + 357565893;
84201238:	c5 49 
8420123a:	ef fd ff ff 	call (m) 0x10d6;
8420123e:	3d e4 

84201240 <Lc_aanc_opmsg_set_static_gain_13>:

    p_ext_data->rx_ffb_mix_static_gain.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, RX_FFB_MIX_COARSE_STATIC_GAIN);
84201240:	81 f0 0b 88 	rMAC = M[r6 + 44];
84201244:	8b c6       	r1 = rMAC AND 0xffff;
84201246:	63 f0 fc 8c 	MH[r4 + 504] = r1;
    p_ext_data->rx_ffb_mix_static_gain.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AANC_STATIC_GAIN, RX_FFB_MIX_FINE_STATIC_GAIN);
8420124a:	81 f0 0c 88 	rMAC = M[r6 + 48];
8420124e:	8c c6       	r2 = rMAC AND 0xffff;
84201250:	64 f0 fd 8c 	MH[r4 + 506] = r2;
    L4_DBG_MSG2("AANC Set Rx FFb Mix Static Gain: Coarse = %hu, Fine = %hu",
        p_ext_data->rx_ffb_mix_static_gain.coarse,
        p_ext_data->rx_ffb_mix_static_gain.fine);
84201254:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201258:	08 25       	Null = rMAC - 4;
8420125a:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_static_gain_15;

8420125c <Lc_aanc_opmsg_set_static_gain_14>:
8420125c:	55 f1 02 f0 	r0 = Null + 357565951;
84201260:	ff 49 
84201262:	ef fd ff ff 	call (m) 0x10d6;
84201266:	35 e3 

84201268 <Lc_aanc_opmsg_set_static_gain_15>:
#endif

    p_ext_data->flags |= AANC_FLAGS_STATIC_GAIN_LOADED;
84201268:	61 f0 6b 88 	rMAC = M[r4 + 428];
8420126c:	c9 ce       	rMAC = rMAC OR 0x10000;
8420126e:	61 f0 6b 8e 	M[r4 + 428] = rMAC;

    /* Allow a direct gain update if the sysmode is static without requiring
     * a follow-up gain override
     */
    if (p_ext_data->cur_mode == AANC_SYSMODE_STATIC)
84201272:	61 f0 66 88 	rMAC = M[r4 + 408];
84201276:	c8 24       	Null = rMAC - 3;
84201278:	29 62       	if NE jump (m) Lc_aanc_opmsg_set_static_gain_17;

8420127a <Lc_aanc_opmsg_set_static_gain_16>:
    {
        p_ext_data->ff_gain = p_ext_data->ff_static_gain;
8420127a:	61 f0 f4 86 	rMAC = MHU[r4 + 488];
8420127e:	62 f0 f5 86 	r0 = MHU[r4 + 490];
84201282:	61 f0 e0 8c 	MH[r4 + 448] = rMAC;
84201286:	62 f0 e1 8c 	MH[r4 + 450] = r0;
        p_ext_data->fb_gain = p_ext_data->fb_static_gain;
8420128a:	61 f0 f6 86 	rMAC = MHU[r4 + 492];
8420128e:	62 f0 f7 86 	r0 = MHU[r4 + 494];
84201292:	61 f0 e2 8c 	MH[r4 + 452] = rMAC;
84201296:	62 f0 e3 8c 	MH[r4 + 454] = r0;
        p_ext_data->ec_gain = p_ext_data->ec_static_gain;
8420129a:	61 f0 f8 86 	rMAC = MHU[r4 + 496];
8420129e:	62 f0 f9 86 	r0 = MHU[r4 + 498];
842012a2:	61 f0 e4 8c 	MH[r4 + 456] = rMAC;
842012a6:	62 f0 e5 8c 	MH[r4 + 458] = r0;
#ifdef AANC_MAOR_V20
        p_ext_data->rx_ffa_mix_gain = p_ext_data->rx_ffa_mix_static_gain;
842012aa:	61 f0 fa 86 	rMAC = MHU[r4 + 500];
842012ae:	62 f0 fb 86 	r0 = MHU[r4 + 502];
842012b2:	61 f0 e6 8c 	MH[r4 + 460] = rMAC;
842012b6:	62 f0 e7 8c 	MH[r4 + 462] = r0;
        p_ext_data->rx_ffb_mix_gain = p_ext_data->rx_ffb_mix_static_gain;
842012ba:	61 f0 fc 86 	rMAC = MHU[r4 + 504];
842012be:	62 f0 fd 86 	r0 = MHU[r4 + 506];
842012c2:	61 f0 e8 8c 	MH[r4 + 464] = rMAC;
842012c6:	62 f0 e9 8c 	MH[r4 + 466] = r0;

842012ca <Lc_aanc_opmsg_set_static_gain_17>:
#endif
    }

    return TRUE;
842012ca:	42 20       	r0 = Null + 1;

842012cc <Lc_aanc_opmsg_set_static_gain_18>:
}
842012cc:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842012ce:	d8 4c       	rts;

842012d0 <$_aanc_opmsg_set_plant_model>:

bool aanc_opmsg_set_plant_model(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012d0:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842012d2:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
842012d4:	ef fd fb ff 	call (m) 0x8ea;
842012d8:	37 e0 
842012da:	17 00       	r5 = r0 + Null;
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (!aanc_fxlms100_set_plant_model(p_ext_data->ag->p_fxlms, message_data))
842012dc:	71 f0 6f 88 	rMAC = M[r5 + 444];
842012e0:	8a 99       	r0 = M[rMAC + 56];
842012e2:	33 00       	r1 = r4 + Null;
842012e4:	0e f0 2d e9 	call (m) $_aanc_fxlms100_set_plant_model;
842012e8:	10 04       	Null = r0 - Null;
842012ea:	0d 62       	if NE jump (m) Lc_aanc_opmsg_set_plant_model_5;

842012ec <Lc_aanc_opmsg_set_plant_model_2>:
    {
        L4_DBG_MSG("AANC set plant coefficients failed");
842012ec:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842012f0:	08 25       	Null = rMAC - 4;
842012f2:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_plant_model_4;

842012f4 <Lc_aanc_opmsg_set_plant_model_3>:
842012f4:	55 f1 02 f0 	r0 = Null + 357566009;
842012f8:	39 4a 
842012fa:	ef fd fe ff 	call (m) 0x10b0;
842012fe:	37 ed 

84201300 <Lc_aanc_opmsg_set_plant_model_4>:
        return FALSE;
84201300:	02 00       	r0 = Null + Null;
84201302:	09 6e       	jump (m) Lc_aanc_opmsg_set_plant_model_6;

84201304 <Lc_aanc_opmsg_set_plant_model_5>:
    }

    p_ext_data->flags |= AANC_FLAGS_PLANT_MODEL_LOADED;
84201304:	71 f0 6b 88 	rMAC = M[r5 + 428];
84201308:	00 f2 00 f1 	rMAC = rMAC OR 0x20000;
8420130c:	51 d8 
8420130e:	71 f0 6b 8e 	M[r5 + 428] = rMAC;

    return TRUE;
84201312:	42 20       	r0 = Null + 1;

84201314 <Lc_aanc_opmsg_set_plant_model_6>:
}
84201314:	f2 48       	popm <FP, r4, r5, rLink>;
84201316:	d8 4c       	rts;

84201318 <$_aanc_opmsg_set_control_model>:

bool aanc_opmsg_set_control_model(OPERATOR_DATA *op_data,
                                  void *message_data,
                                  unsigned *resp_length,
                                  OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201318:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420131a:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
8420131c:	ef fd fa ff 	call (m) 0x8ea;
84201320:	2f ee 
84201322:	17 00       	r5 = r0 + Null;
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);

    int destination;

    if (!aanc_fxlms100_set_control_model(p_ext_data->ag->p_fxlms, message_data,
                                         &destination))
84201324:	04 11       	r2 = FP + 16;
84201326:	71 f0 6f 88 	rMAC = M[r5 + 444];
8420132a:	8a 99       	r0 = M[rMAC + 56];
8420132c:	33 00       	r1 = r4 + Null;
8420132e:	0e f0 3b ea 	call (m) $_aanc_fxlms100_set_control_model;
84201332:	10 04       	Null = r0 - Null;
84201334:	0d 62       	if NE jump (m) Lc_aanc_opmsg_set_control_model_5;

84201336 <Lc_aanc_opmsg_set_control_model_2>:
    {
        L4_DBG_MSG("AANC set control coefficients failed");
84201336:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420133a:	08 25       	Null = rMAC - 4;
8420133c:	07 68       	if LT jump (m) Lc_aanc_opmsg_set_control_model_4;

8420133e <Lc_aanc_opmsg_set_control_model_3>:
8420133e:	55 f1 02 f0 	r0 = Null + 357566044;
84201342:	5c 4a 
84201344:	ef fd fe ff 	call (m) 0x10b0;
84201348:	2d eb 

8420134a <Lc_aanc_opmsg_set_control_model_4>:
        return FALSE;
8420134a:	02 00       	r0 = Null + Null;
8420134c:	17 6e       	jump (m) Lc_aanc_opmsg_set_control_model_9;

8420134e <Lc_aanc_opmsg_set_control_model_5>:
    }

    if (destination)
8420134e:	20 d8       	Null = M[FP + 16];
84201350:	0a 60       	if EQ jump (m) Lc_aanc_opmsg_set_control_model_7;

84201352 <Lc_aanc_opmsg_set_control_model_6>:
    {
        p_ext_data->flags |= AANC_FLAGS_CONTROL_1_MODEL_LOADED;
84201352:	71 f0 6b 88 	rMAC = M[r5 + 428];
84201356:	00 f0 00 f8 	rMAC = rMAC OR 0x80000;
8420135a:	00 f1 51 c8 
8420135e:	71 f0 6b 8e 	M[r5 + 428] = rMAC;
84201362:	08 6e       	jump (m) Lc_aanc_opmsg_set_control_model_8;

84201364 <Lc_aanc_opmsg_set_control_model_7>:
    }
    else
    {
        p_ext_data->flags |= AANC_FLAGS_CONTROL_0_MODEL_LOADED;
84201364:	71 f0 6b 88 	rMAC = M[r5 + 428];
84201368:	00 f4 00 f1 	rMAC = rMAC OR 0x40000;
8420136c:	51 d8 
8420136e:	71 f0 6b 8e 	M[r5 + 428] = rMAC;

84201372 <Lc_aanc_opmsg_set_control_model_8>:
    }

    p_ext_data->re_init_flag = TRUE;
84201372:	41 20       	rMAC = Null + 1;
84201374:	71 f0 02 9a 	MB[r5 + 514] = rMAC;

    return TRUE;
84201378:	0a 00       	r0 = rMAC + Null;

8420137a <Lc_aanc_opmsg_set_control_model_9>:
}
8420137a:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420137c:	d8 4c       	rts;

8420137e <$_aanc_process_data>:

/****************************************************************************
Data processing function
*/
void aanc_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
8420137e:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84201380:	42 de       	M[FP + 32] = r0;
84201382:	4b de       	M[FP + 36] = r1;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
84201384:	ef fd fa ff 	call (m) 0x8ea;
84201388:	27 eb 
8420138a:	11 09       	r7 = r0 + Null;
    unsigned initial_value;

    /* Certain conditions require an "early exit" that will just discard any
     * data in the input buffers and not do any other processing
     */
    bool exit_early = FALSE;
8420138c:	50 de       	M[FP + 40] = Null;

    /* After data is processed flags are tested to determine the equivalent
     * operating state. This is an input to the gain update decision state
     * machine.
     */
    unsigned mode_after_flags = p_ext_data->cur_mode;
8420138e:	9b f0 66 88 	r9 = M[r7 + 408];

    /* Reference the calculated gain */
    unsigned *p_gain_calc = &p_ext_data->ag->p_fxlms->adaptive_gain;
84201392:	91 f0 6f 88 	rMAC = M[r7 + 444];
84201396:	89 99       	rMAC = M[rMAC + 56];
84201398:	01 f0 44 44 	rMAC = rMAC + 68;
8420139c:	59 de       	M[FP + 44] = rMAC;

    /* Reference the capability parameters */
    AANC_PARAMETERS *p_params = &p_ext_data->aanc_cap_params;
8420139e:	91 f0 3c 20 	rMAC = r7 + 60;
842013a2:	61 de       	M[FP + 48] = rMAC;

    bool calculate_gain = TRUE;
842013a4:	41 20       	rMAC = Null + 1;
842013a6:	69 de       	M[FP + 52] = rMAC;
static inline int aanc_calc_samples_to_process(AANC_OP_DATA *p_ext_data)
{
    int i, amt, min_data_space;

    /* Return if int and ext mic input terminals are not connected */
    if ((p_ext_data->touched_sinks & AANC_MIN_VALID_SINKS) != AANC_MIN_VALID_SINKS)
842013a8:	91 f0 d4 86 	rMAC = MHU[r7 + 424];
842013ac:	11 f0 0c 00 	rMAC = rMAC AND 0xc;
842013b0:	08 27       	Null = rMAC - 12;
842013b2:	0e 60       	if EQ jump (m) Lc_aanc_process_data_4;

842013b4 <Lc_aanc_process_data_2>:
    samples_to_process = aanc_calc_samples_to_process(p_ext_data);

    /* Return early if int and ext mic input terminals are not connected */
    if (samples_to_process == INT_MAX)
    {
        L5_DBG_MSG("Minimum number of ports (int and ext mic) not connected");
842013b4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842013b8:	48 25       	Null = rMAC - 5;
842013ba:	0b f0 9b e8 	if LT jump (m) Lc_aanc_process_data_105;

842013be <Lc_aanc_process_data_3>:
842013be:	55 f1 02 f0 	r0 = Null + 357566081;
842013c2:	81 4a 
842013c4:	ef fd fe ff 	call (m) 0x10b0;
842013c8:	2d e7 
842013ca:	0f f0 8b e8 	jump (m) Lc_aanc_process_data_105;

842013ce <Lc_aanc_process_data_4>:
    if ((p_ext_data->touched_sinks & AANC_MIN_VALID_SINKS) != AANC_MIN_VALID_SINKS)
    {
        return INT_MAX;
    }

    min_data_space = AANC_DEFAULT_FRAME_SIZE;
842013ce:	06 f0 40 40 	r4 = Null + 64;
    /* Calculate the amount of data available */
    for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
842013d2:	07 00       	r5 = Null + Null;
842013d4:	48 09       	r6 = r7 + Null;

842013d6 <Lc_aanc_process_data_5>:
    {
        if (p_ext_data->inputs[i] != NULL)
842013d6:	82 f0 00 e8 	r0 = M[r6 + Null];
842013da:	07 60       	if EQ jump (m) Lc_aanc_process_data_8;

842013dc <Lc_aanc_process_data_6>:
        {
            amt = cbuffer_calc_amount_data_in_words(p_ext_data->inputs[i]);
842013dc:	ff fd 63 f2 	call (m) 0x4db5a;
842013e0:	3f eb 
            if (amt < min_data_space)
842013e2:	90 05       	Null = r0 - r4;
842013e4:	02 66       	if GE jump (m) Lc_aanc_process_data_8;

842013e6 <Lc_aanc_process_data_7>:
            {
                min_data_space = amt;
842013e6:	16 00       	r4 = r0 + Null;

842013e8 <Lc_aanc_process_data_8>:
        return INT_MAX;
    }

    min_data_space = AANC_DEFAULT_FRAME_SIZE;
    /* Calculate the amount of data available */
    for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
842013e8:	7f 20       	r5 = r5 + 1;
842013ea:	20 75       	r6 = r6 + 4;
842013ec:	f8 24       	Null = r5 - 3;
842013ee:	f4 6d       	if LE jump (m) Lc_aanc_process_data_5;

842013f0 <Lc_aanc_process_data_9>:
            }
        }
    }

    /*  Calculate the available space */
    if (p_ext_data->touched_sources != 0)
842013f0:	91 f0 d5 86 	rMAC = MHU[r7 + 426];
842013f4:	11 60       	if EQ jump (m) Lc_aanc_process_data_15;

842013f6 <Lc_aanc_process_data_10>:
    {
        for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
842013f6:	07 00       	r5 = Null + Null;
842013f8:	98 f0 10 20 	r6 = r7 + 16;

842013fc <Lc_aanc_process_data_11>:
        {
            if (p_ext_data->outputs[i] != NULL)
842013fc:	82 f0 00 e8 	r0 = M[r6 + Null];
84201400:	07 60       	if EQ jump (m) Lc_aanc_process_data_14;

84201402 <Lc_aanc_process_data_12>:
            {
                amt = cbuffer_calc_amount_space_in_words(p_ext_data->outputs[i]);
84201402:	ff fd 63 f2 	call (m) 0x4db14;
84201406:	33 e8 
                if (amt < min_data_space)
84201408:	90 05       	Null = r0 - r4;
8420140a:	02 66       	if GE jump (m) Lc_aanc_process_data_14;

8420140c <Lc_aanc_process_data_13>:
                {
                    min_data_space = amt;
8420140c:	16 00       	r4 = r0 + Null;

8420140e <Lc_aanc_process_data_14>:
    }

    /*  Calculate the available space */
    if (p_ext_data->touched_sources != 0)
    {
        for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
8420140e:	7f 20       	r5 = r5 + 1;
84201410:	20 75       	r6 = r6 + 4;
84201412:	f8 24       	Null = r5 - 3;
84201414:	f4 6d       	if LE jump (m) Lc_aanc_process_data_11;

84201416 <Lc_aanc_process_data_15>:
            }
        }
    }
    /* Samples to process determined as minimum of data and space available */
    return min_data_space;
}
84201416:	37 00       	r5 = r4 + Null;
        L5_DBG_MSG("Minimum number of ports (int and ext mic) not connected");
        return;
    }

     /* Return early if no data or not enough space to process */
    if (samples_to_process < AANC_DEFAULT_FRAME_SIZE)
84201418:	60 f0 40 24 	Null = r4 - 64;
8420141c:	0f 66       	if GE jump (m) Lc_aanc_process_data_18;

8420141e <Lc_aanc_process_data_16>:
    {
        L5_DBG_MSG1("Not enough data/space to process (%d)", samples_to_process);
8420141e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201422:	48 25       	Null = rMAC - 5;
84201424:	0b f0 b1 e7 	if LT jump (m) Lc_aanc_process_data_105;

84201428 <Lc_aanc_process_data_17>:
84201428:	55 f1 02 f0 	r0 = Null + 357566137;
8420142c:	b9 4a 
8420142e:	33 00       	r1 = r4 + Null;
84201430:	ef fd fe ff 	call (m) 0x10c2;
84201434:	33 e4 
84201436:	0f f0 9f e7 	jump (m) Lc_aanc_process_data_105;

8420143a <Lc_aanc_process_data_18>:
    /* Other conditions that are invalid for running AANC need to discard
     * input data if it exists.
     */

    /* Don't do any processing in standby */
    if (p_ext_data->cur_mode == AANC_SYSMODE_STANDBY)
8420143a:	90 f0 66 88 	Null = M[r7 + 408];
8420143e:	03 62       	if NE jump (m) Lc_aanc_process_data_20;

84201440 <Lc_aanc_process_data_19>:
    {
        exit_early = TRUE;
84201440:	41 20       	rMAC = Null + 1;
84201442:	51 de       	M[FP + 40] = rMAC;

84201444 <Lc_aanc_process_data_20>:
    }

    /* Don't do any processing if out of ear */
    bool disable_ear_check = (p_params->OFFSET_AANC_DEBUG &
                              AANC_CONFIG_AANC_DEBUG_DISABLE_EAR_STATUS_CHECK);
84201444:	61 d8       	rMAC = M[FP + 48];
84201446:	49 89       	rMAC = M[rMAC + 20];
84201448:	49 c0       	rMAC = rMAC AND 0x2;
    if ((p_ext_data->in_out_status != AANC_IN_EAR) && !disable_ear_check)
8420144a:	92 f0 04 92 	r0 = MBU[r7 + 516];
8420144e:	50 24       	Null = r0 - 1;
84201450:	05 60       	if EQ jump (m) Lc_aanc_process_data_23;

84201452 <Lc_aanc_process_data_21>:
84201452:	08 04       	Null = rMAC - Null;
84201454:	03 62       	if NE jump (m) Lc_aanc_process_data_23;

84201456 <Lc_aanc_process_data_22>:
    {
        exit_early = TRUE;
84201456:	41 20       	rMAC = Null + 1;
84201458:	51 de       	M[FP + 40] = rMAC;

8420145a <Lc_aanc_process_data_23>:

    /* Don't do any processing if ANC HW clocks are invalid */
#ifndef RUNNING_ON_KALSIM
    uint16 anc0_enable;
    uint16 anc1_enable;
    uint16 *anc_selected = &anc0_enable;
8420145a:	86 13       	r4 = FP + 56;

    stream_get_anc_enable(&anc0_enable, &anc1_enable);
8420145c:	c3 13       	r1 = FP + 60;
8420145e:	82 13       	r0 = FP + 56;
84201460:	ff fd 5c f0 	call (m) 0xcdd6;
84201464:	37 eb 

    if (p_ext_data->anc_channel == AANC_ANC_INSTANCE_ANC1_ID)
84201466:	91 f0 fc 81 	rMAC = MBS[r7 + 508];
8420146a:	88 24       	Null = rMAC - 2;
8420146c:	02 62       	if NE jump (m) Lc_aanc_process_data_25;

8420146e <Lc_aanc_process_data_24>:
    {
        anc_selected = &anc1_enable;
8420146e:	c6 13       	r4 = FP + 60;

84201470 <Lc_aanc_process_data_25>:
    }

    bool anc_is_running = *anc_selected == p_ext_data->anc_clock_check_value;
84201470:	33 e6       	r1 = MHU[r4 + Null];
84201472:	92 f0 00 87 	r0 = MHU[r7 + 512];
84201476:	01 00       	rMAC = Null + Null;
84201478:	98 04       	Null = r1 - r0;
8420147a:	20 f0 41 ce 	if EQ rMAC = Null + 1;
    bool disable_clock_check = (p_params->OFFSET_AANC_DEBUG &
                                AANC_CONFIG_AANC_DEBUG_DISABLE_ANC_CLOCK_CHECK);
8420147e:	62 d8       	r0 = M[FP + 48];
84201480:	52 89       	r0 = M[r0 + 20];
84201482:	d2 c0       	r0 = r0 AND 0x4;
    /* Don't do any processing if HW clocks aren't running */
    if (!anc_is_running && !disable_clock_check)
84201484:	08 04       	Null = rMAC - Null;
84201486:	3b 62       	if NE jump (m) Lc_aanc_process_data_39;

84201488 <Lc_aanc_process_data_26>:
84201488:	10 04       	Null = r0 - Null;
8420148a:	39 62       	if NE jump (m) Lc_aanc_process_data_39;

8420148c <Lc_aanc_process_data_27>:
    {
        L2_DBG_MSG1("AANC invalid clocks detected: %hu", *anc_selected);
8420148c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201490:	88 24       	Null = rMAC - 2;
84201492:	07 68       	if LT jump (m) Lc_aanc_process_data_29;

84201494 <Lc_aanc_process_data_28>:
84201494:	55 f1 02 f0 	r0 = Null + 357566175;
84201498:	df 4a 
8420149a:	ef fd fe ff 	call (m) 0x10c2;
8420149e:	29 e1 

842014a0 <Lc_aanc_process_data_29>:
        exit_early = TRUE;
    }
#endif

    sample_count = 0;
842014a0:	02 09       	r8 = Null + Null;

842014a2 <Lc_aanc_process_data_30>:
    if (exit_early)
    {
        bool discard_data = TRUE;
842014a2:	08 71       	r6 = Null + 1;

842014a4 <Lc_aanc_process_data_31>:

        /* There is at least 1 frame to process */
        do {
            sample_count += AANC_DEFAULT_FRAME_SIZE;
842014a4:	0a f0 40 44 	r8 = r8 + 64;
            /* Iterate through all sinks */
            for (i = 0; i < AANC_MAX_SINKS; i++)
842014a8:	06 00       	r4 = Null + Null;
842014aa:	4f 08       	r5 = r7 + Null;

842014ac <Lc_aanc_process_data_32>:
            {
                if (p_ext_data->inputs[i] != NULL)
842014ac:	3a e8       	r0 = M[r5 + Null];
842014ae:	0e 60       	if EQ jump (m) Lc_aanc_process_data_35;

842014b0 <Lc_aanc_process_data_33>:
                {
                    /* Discard a frame of data */
                    cbuffer_discard_data(p_ext_data->inputs[i],
                                         AANC_DEFAULT_FRAME_SIZE);
842014b0:	03 f0 40 40 	r1 = Null + 64;
842014b4:	ff fd 63 f2 	call (m) 0x4dc8c;
842014b8:	39 ee 

                    /* If there isn't a frame worth of data left then don't
                     * iterate through the input terminals again.
                     */
                    samples_to_process = cbuffer_calc_amount_data_in_words(
                        p_ext_data->inputs[i]);
842014ba:	3a e8       	r0 = M[r5 + Null];
842014bc:	ff fd 63 f2 	call (m) 0x4db5a;
842014c0:	3f e4 

                    if (samples_to_process < AANC_DEFAULT_FRAME_SIZE)
842014c2:	20 f0 40 24 	Null = r0 - 64;
842014c6:	02 66       	if GE jump (m) Lc_aanc_process_data_35;

842014c8 <Lc_aanc_process_data_34>:
                    {
                        discard_data = FALSE;
842014c8:	00 09       	r6 = Null + Null;

842014ca <Lc_aanc_process_data_35>:

        /* There is at least 1 frame to process */
        do {
            sample_count += AANC_DEFAULT_FRAME_SIZE;
            /* Iterate through all sinks */
            for (i = 0; i < AANC_MAX_SINKS; i++)
842014ca:	76 20       	r4 = r4 + 1;
842014cc:	3f 21       	r5 = r5 + 4;
842014ce:	30 25       	Null = r4 - 4;
842014d0:	ee 69       	if LT jump (m) Lc_aanc_process_data_32;

842014d2 <Lc_aanc_process_data_36>:
842014d2:	0f f8 00 c2 	Null = r6 - Null;
842014d6:	e7 63       	if NE jump (m) Lc_aanc_process_data_31;

842014d8 <Lc_aanc_process_data_37>:
842014d8:	01 fa d7 c8 	r5 = r8 LSHIFT 2;
                        discard_data = FALSE;
                    }
                }
            }
        } while (discard_data);
        for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
842014dc:	06 00       	r4 = Null + Null;
842014de:	98 f0 20 20 	r6 = r7 + 32;

842014e2 <Lc_aanc_process_data_38>:
        {
            /* Input is discarded, so consume and delete incoming metadata tags
               This can be done by transporting input metadata to NULL ptr */
            metadata_strict_transport(p_ext_data->metadata_ip[i],
                                      NULL,
                                      sample_count * OCTETS_PER_SAMPLE);
842014e2:	82 f0 00 e8 	r0 = M[r6 + Null];
842014e6:	03 00       	r1 = Null + Null;
842014e8:	3c 00       	r2 = r5 + Null;
842014ea:	ff fd 9b f0 	call (m) 0x14af0;
842014ee:	27 e0 
                        discard_data = FALSE;
                    }
                }
            }
        } while (discard_data);
        for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
842014f0:	76 20       	r4 = r4 + 1;
842014f2:	20 75       	r6 = r6 + 4;
842014f4:	b0 24       	Null = r4 - 2;
842014f6:	f6 69       	if LT jump (m) Lc_aanc_process_data_38;

842014f8 <Lc__ite_57>:
842014f8:	0f f0 dd e5 	jump (m) Lc_aanc_process_data_105;

842014fc <Lc_aanc_process_data_39>:
        L2_DBG_MSG1("AANC invalid clocks detected: %hu", *anc_selected);
        exit_early = TRUE;
    }
#endif

    sample_count = 0;
842014fc:	02 09       	r8 = Null + Null;
    if (exit_early)
842014fe:	51 d8       	rMAC = M[FP + 40];
84201500:	d1 63       	if NE jump (m) Lc_aanc_process_data_30;

84201502 <Lc_aanc_process_data_40>:

    /***************************
     * Adaptive gain processing
     ***************************/
    
    ADAPTIVE_GAIN *p_ag = p_ext_data->ag;
84201502:	96 f0 6f 88 	r4 = M[r7 + 444];
    if (p_ext_data->connect_flag == TRUE)
84201506:	91 f0 82 88 	rMAC = M[r7 + 520];
8420150a:	48 24       	Null = rMAC - 1;
8420150c:	2d 62       	if NE jump (m) Lc_aanc_process_data_42;

8420150e <Lc_aanc_process_data_41>:
    {
        p_ext_data->connect_flag = FALSE;
8420150e:	90 f0 82 8e 	M[r7 + 520] = Null;

        /* Copy terminal buffer pointers */
        p_ag->p_playback_ip = p_ext_data->inputs[AANC_PLAYBACK_TERMINAL_ID];
84201512:	91 f0 00 e8 	rMAC = M[r7 + Null];
84201516:	61 f0 21 8e 	M[r4 + 132] = rMAC;
        p_ag->p_fbmon_ip = p_ext_data->inputs[AANC_FB_MON_TERMINAL_ID];
8420151a:	91 f0 01 88 	rMAC = M[r7 + 4];
8420151e:	b1 bf       	M[r4 + 120] = rMAC;
        p_ag->p_mic_int_ip = p_ext_data->inputs[AANC_MIC_INT_TERMINAL_ID];
84201520:	91 f0 02 88 	rMAC = M[r7 + 8];
84201524:	f1 bf       	M[r4 + 124] = rMAC;
        p_ag->p_mic_ext_ip = p_ext_data->inputs[AANC_MIC_EXT_TERMINAL_ID];
84201526:	91 f0 03 88 	rMAC = M[r7 + 12];
8420152a:	61 f0 20 8e 	M[r4 + 128] = rMAC;

        p_ag->p_playback_op = p_ext_data->outputs[AANC_PLAYBACK_TERMINAL_ID];
8420152e:	91 f0 04 88 	rMAC = M[r7 + 16];
84201532:	71 bf       	M[r4 + 116] = rMAC;
        p_ag->p_fbmon_op = p_ext_data->outputs[AANC_FB_MON_TERMINAL_ID];
84201534:	91 f0 05 88 	rMAC = M[r7 + 20];
84201538:	61 f0 22 8e 	M[r4 + 136] = rMAC;
        p_ag->p_mic_int_op = p_ext_data->outputs[AANC_MIC_INT_TERMINAL_ID];
8420153c:	91 f0 06 88 	rMAC = M[r7 + 24];
84201540:	61 f0 23 8e 	M[r4 + 140] = rMAC;
        p_ag->p_mic_ext_op = p_ext_data->outputs[AANC_MIC_EXT_TERMINAL_ID];
84201544:	91 f0 07 88 	rMAC = M[r7 + 28];
84201548:	61 f0 24 8e 	M[r4 + 144] = rMAC;
        
        aanc_proc_initialize(p_params, p_ag, p_params->OFFSET_FXLMS_INITIAL_VALUE,
                             &p_ext_data->flags, p_ext_data->re_init_hard);
8420154c:	91 f0 03 92 	rMAC = MBU[r7 + 515];
84201550:	09 1c       	pushm <rMAC>;
84201552:	95 f0 ac 21 	r3 = r7 + 428;
84201556:	61 d8       	rMAC = M[FP + 48];
84201558:	0a 00       	r0 = rMAC + Null;
8420155a:	14 f0 46 88 	r2 = M[rMAC + 280];
8420155e:	33 00       	r1 = r4 + Null;
84201560:	07 f0 2f e3 	call (m) $_aanc_proc_initialize;
84201564:	7f 4c       	SP = SP + -4;

84201566 <Lc_aanc_process_data_42>:
    }
    
    if (p_ext_data->re_init_flag == TRUE)
84201566:	91 f0 02 92 	rMAC = MBU[r7 + 514];
8420156a:	48 24       	Null = rMAC - 1;
8420156c:	1b 62       	if NE jump (m) Lc_aanc_process_data_44;

8420156e <Lc_aanc_process_data_43>:
    {
    
        p_ext_data->re_init_flag = FALSE;
8420156e:	90 f0 02 9a 	MB[r7 + 514] = Null;
        aanc_initialize_events(op_data, p_ext_data);
84201572:	4b 08       	r1 = r7 + Null;
84201574:	42 d8       	r0 = M[FP + 32];
84201576:	02 f0 25 ef 	call (m) Lc_aanc_initialize_events_1;
        /* Reinitialize flags but leave model flags untouched */
        p_ext_data->flags &= AANC_MODEL_MASK;
8420157a:	91 f0 6b 88 	rMAC = M[r7 + 428];
8420157e:	07 f0 11 f8 	rMAC = rMAC AND 0xf0000;
84201582:	00 00 
84201584:	91 f0 6b 8e 	M[r7 + 428] = rMAC;

        aanc_proc_initialize(p_params, p_ag, p_params->OFFSET_FXLMS_INITIAL_VALUE,
                             &p_ext_data->flags, p_ext_data->re_init_hard);
84201588:	91 f0 03 92 	rMAC = MBU[r7 + 515];
8420158c:	09 1c       	pushm <rMAC>;
8420158e:	95 f0 ac 21 	r3 = r7 + 428;
84201592:	61 d8       	rMAC = M[FP + 48];
84201594:	0a 00       	r0 = rMAC + Null;
84201596:	14 f0 46 88 	r2 = M[rMAC + 280];
8420159a:	33 00       	r1 = r4 + Null;
8420159c:	07 f0 33 e1 	call (m) $_aanc_proc_initialize;
842015a0:	7f 4c       	SP = SP + -4;

842015a2 <Lc_aanc_process_data_44>:
    }

    /* Identify whether to do the gain calculation step */
    if ((p_params->OFFSET_DISABLE_AG_CALC & 0x1) ||
        (p_ext_data->cur_mode != AANC_SYSMODE_FULL))
842015a2:	61 d8       	rMAC = M[FP + 48];
842015a4:	49 88       	rMAC = M[rMAC + 4];
842015a6:	09 c0       	rMAC = rMAC AND 0x1;
842015a8:	05 62       	if NE jump (m) Lc_aanc_process_data_46;

842015aa <Lc_aanc_process_data_45>:
842015aa:	91 f0 66 88 	rMAC = M[r7 + 408];
842015ae:	88 24       	Null = rMAC - 2;
842015b0:	02 60       	if EQ jump (m) Lc_aanc_process_data_47;

842015b2 <Lc_aanc_process_data_46>:
    {
        calculate_gain = FALSE;
842015b2:	68 de       	M[FP + 52] = Null;

842015b4 <Lc_aanc_process_data_47>:
    }

    sample_count = 0;
842015b4:	02 09       	r8 = Null + Null;
842015b6:	17 6e       	jump (m) Lc_aanc_process_data_52;

842015b8 <Lc_aanc_process_data_48>:
                aanc_process_ramp(&p_ext_data->fb_ramp);
                aanc_fxlms100_update_gain(p_ext_data->ag->p_fxlms,
                                          p_ext_data->ff_gain.fine, 0);
                break;
            default:
                L2_DBG_MSG1("AANC SYSMODE invalid: %u", p_ext_data->cur_mode);
842015b8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842015bc:	88 24       	Null = rMAC - 2;
842015be:	07 68       	if LT jump (m) Lc_aanc_process_data_50;

842015c0 <Lc_aanc_process_data_49>:
842015c0:	55 f1 02 f0 	r0 = Null + 357566384;
842015c4:	b0 4b 
842015c6:	ef fd fd ff 	call (m) 0x10c2;
842015ca:	3d e7 

842015cc <Lc_aanc_process_data_50>:
                break;
        }

        /* Evaluate event messaging criteria */
        if (!(p_params->OFFSET_AANC_DEBUG &
            AANC_CONFIG_AANC_DEBUG_DISABLE_EVENT_MESSAGING))
842015cc:	61 d8       	rMAC = M[FP + 48];
842015ce:	49 89       	rMAC = M[rMAC + 20];
842015d0:	49 c1       	rMAC = rMAC AND 0x8;
842015d2:	09 62       	if NE jump (m) Lc_aanc_process_data_52;

842015d4 <Lc_aanc_process_data_51>:
        {
            aanc_process_events(op_data, p_ext_data);
842015d4:	4b 08       	r1 = r7 + Null;
842015d6:	42 d8       	r0 = M[FP + 32];
842015d8:	03 f0 3b eb 	call (m) Lc_aanc_process_events_1;
            p_ext_data->prev_flags = p_ext_data->flags;
842015dc:	91 f0 6b 88 	rMAC = M[r7 + 428];
842015e0:	91 f0 6c 8e 	M[r7 + 432] = rMAC;

842015e4 <Lc_aanc_process_data_52>:

    sample_count = 0;
    /* Consume all the data in the input buffer, or until there isn't space
     * available.
     */
    while (samples_to_process >= AANC_DEFAULT_FRAME_SIZE)
842015e4:	70 f0 40 24 	Null = r5 - 64;
842015e8:	ce 68       	if LT jump (m) Lc_aanc_process_data_99;

842015ea <Lc_aanc_process_data_53>:
    {
        aanc_proc_process_data(p_ext_data->ag, calculate_gain);
842015ea:	92 f0 6f 88 	r0 = M[r7 + 444];
842015ee:	6b d8       	r1 = M[FP + 52];
842015f0:	08 f0 29 eb 	call (m) $_aanc_proc_process_data;
static inline int aanc_calc_samples_to_process(AANC_OP_DATA *p_ext_data)
{
    int i, amt, min_data_space;

    /* Return if int and ext mic input terminals are not connected */
    if ((p_ext_data->touched_sinks & AANC_MIN_VALID_SINKS) != AANC_MIN_VALID_SINKS)
842015f4:	91 f0 d4 86 	rMAC = MHU[r7 + 424];
842015f8:	11 f0 0c 00 	rMAC = rMAC AND 0xc;
842015fc:	08 27       	Null = rMAC - 12;
842015fe:	05 60       	if EQ jump (m) Lc_aanc_process_data_55;

84201600 <Lc_aanc_process_data_54>:
    {
        return INT_MAX;
84201600:	ff f7 f6 f7 	r4 = Null + 2147483647;
84201604:	ff 7b 
84201606:	25 6e       	jump (m) Lc_aanc_process_data_66;

84201608 <Lc_aanc_process_data_55>:
    }

    min_data_space = AANC_DEFAULT_FRAME_SIZE;
84201608:	06 f0 40 40 	r4 = Null + 64;
    /* Calculate the amount of data available */
    for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
8420160c:	07 00       	r5 = Null + Null;
8420160e:	48 09       	r6 = r7 + Null;

84201610 <Lc_aanc_process_data_56>:
    {
        if (p_ext_data->inputs[i] != NULL)
84201610:	82 f0 00 e8 	r0 = M[r6 + Null];
84201614:	07 60       	if EQ jump (m) Lc_aanc_process_data_59;

84201616 <Lc_aanc_process_data_57>:
        {
            amt = cbuffer_calc_amount_data_in_words(p_ext_data->inputs[i]);
84201616:	ff fd 62 f2 	call (m) 0x4db5a;
8420161a:	25 ea 
            if (amt < min_data_space)
8420161c:	90 05       	Null = r0 - r4;
8420161e:	02 66       	if GE jump (m) Lc_aanc_process_data_59;

84201620 <Lc_aanc_process_data_58>:
            {
                min_data_space = amt;
84201620:	16 00       	r4 = r0 + Null;

84201622 <Lc_aanc_process_data_59>:
        return INT_MAX;
    }

    min_data_space = AANC_DEFAULT_FRAME_SIZE;
    /* Calculate the amount of data available */
    for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
84201622:	7f 20       	r5 = r5 + 1;
84201624:	20 75       	r6 = r6 + 4;
84201626:	f8 24       	Null = r5 - 3;
84201628:	f4 6d       	if LE jump (m) Lc_aanc_process_data_56;

8420162a <Lc_aanc_process_data_60>:
            }
        }
    }

    /*  Calculate the available space */
    if (p_ext_data->touched_sources != 0)
8420162a:	91 f0 d5 86 	rMAC = MHU[r7 + 426];
8420162e:	11 60       	if EQ jump (m) Lc_aanc_process_data_66;

84201630 <Lc_aanc_process_data_61>:
    {
        for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
84201630:	07 00       	r5 = Null + Null;
84201632:	98 f0 10 20 	r6 = r7 + 16;

84201636 <Lc_aanc_process_data_62>:
        {
            if (p_ext_data->outputs[i] != NULL)
84201636:	82 f0 00 e8 	r0 = M[r6 + Null];
8420163a:	07 60       	if EQ jump (m) Lc_aanc_process_data_65;

8420163c <Lc_aanc_process_data_63>:
            {
                amt = cbuffer_calc_amount_space_in_words(p_ext_data->outputs[i]);
8420163c:	ff fd 62 f2 	call (m) 0x4db14;
84201640:	39 e6 
                if (amt < min_data_space)
84201642:	90 05       	Null = r0 - r4;
84201644:	02 66       	if GE jump (m) Lc_aanc_process_data_65;

84201646 <Lc_aanc_process_data_64>:
                {
                    min_data_space = amt;
84201646:	16 00       	r4 = r0 + Null;

84201648 <Lc_aanc_process_data_65>:
    }

    /*  Calculate the available space */
    if (p_ext_data->touched_sources != 0)
    {
        for (i = AANC_PLAYBACK_TERMINAL_ID; i <= AANC_MIC_EXT_TERMINAL_ID; i++)
84201648:	7f 20       	r5 = r5 + 1;
8420164a:	20 75       	r6 = r6 + 4;
8420164c:	f8 24       	Null = r5 - 3;
8420164e:	f4 6d       	if LE jump (m) Lc_aanc_process_data_62;

84201650 <Lc_aanc_process_data_66>:
            }
        }
    }
    /* Samples to process determined as minimum of data and space available */
    return min_data_space;
}
84201650:	37 00       	r5 = r4 + Null;
    {
        aanc_proc_process_data(p_ext_data->ag, calculate_gain);

        samples_to_process = aanc_calc_samples_to_process(p_ext_data);

        sample_count += AANC_DEFAULT_FRAME_SIZE;
84201652:	0a f0 40 44 	r8 = r8 + 64;
#endif /* RUNNING_ON_KALSIM */

        /*************************
         * Check processing flags
         *************************/
        if (p_ext_data->flags & AANC_ED_FLAG_MASK)
84201656:	91 f0 6b 88 	rMAC = M[r7 + 428];
8420165a:	13 f0 70 00 	r1 = rMAC AND 0x70;
8420165e:	0c 60       	if EQ jump (m) Lc_aanc_process_data_71;

84201660 <Lc_aanc_process_data_68>:
        {
            L5_DBG_MSG1("AANC ED detected: %u",
                        p_ext_data->flags & AANC_ED_FLAG_MASK);
84201660:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201664:	48 25       	Null = rMAC - 5;
84201666:	07 68       	if LT jump (m) Lc_aanc_process_data_70;

84201668 <Lc_aanc_process_data_69>:
84201668:	55 f1 02 f0 	r0 = Null + 357566209;
8420166c:	01 4b 
8420166e:	ef fd fd ff 	call (m) 0x10c2;
84201672:	35 e2 

84201674 <Lc_aanc_process_data_70>:
            mode_after_flags = AANC_SYSMODE_FREEZE;
84201674:	23 71       	r9 = Null + 4;

84201676 <Lc_aanc_process_data_71>:
        }

        if (p_ext_data->flags & AANC_CLIPPING_FLAG_MASK)
84201676:	91 f0 6b 88 	rMAC = M[r7 + 428];
8420167a:	13 f0 00 07 	r1 = rMAC AND 0x700;
8420167e:	0c 60       	if EQ jump (m) Lc_aanc_process_data_75;

84201680 <Lc_aanc_process_data_72>:
        {
            L5_DBG_MSG1("AANC Clipping detected: %u",
                        p_ext_data->flags & AANC_CLIPPING_FLAG_MASK);
84201680:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201684:	48 25       	Null = rMAC - 5;
84201686:	07 68       	if LT jump (m) Lc_aanc_process_data_74;

84201688 <Lc_aanc_process_data_73>:
84201688:	55 f1 02 f0 	r0 = Null + 357566230;
8420168c:	16 4b 
8420168e:	ef fd fd ff 	call (m) 0x10c2;
84201692:	35 e1 

84201694 <Lc_aanc_process_data_74>:
            mode_after_flags = AANC_SYSMODE_FREEZE;
84201694:	23 71       	r9 = Null + 4;

84201696 <Lc_aanc_process_data_75>:
        }

        if (p_ext_data->flags & AANC_SATURATION_FLAG_MASK)
84201696:	91 f0 6b 88 	rMAC = M[r7 + 428];
8420169a:	13 f7 00 10 	r1 = rMAC AND 0xf000;
8420169e:	0c 60       	if EQ jump (m) Lc_aanc_process_data_79;

842016a0 <Lc_aanc_process_data_76>:
        {
            L5_DBG_MSG1("AANC Saturation detected: %u",
                        p_ext_data->flags & AANC_SATURATION_FLAG_MASK);
842016a0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842016a4:	48 25       	Null = rMAC - 5;
842016a6:	07 68       	if LT jump (m) Lc_aanc_process_data_78;

842016a8 <Lc_aanc_process_data_77>:
842016a8:	55 f1 02 f0 	r0 = Null + 357566257;
842016ac:	31 4b 
842016ae:	ef fd fd ff 	call (m) 0x10c2;
842016b2:	35 e0 

842016b4 <Lc_aanc_process_data_78>:
            mode_after_flags = AANC_SYSMODE_FREEZE;
842016b4:	23 71       	r9 = Null + 4;

842016b6 <Lc_aanc_process_data_79>:

        /**************
         * Update gain
         **************/
        /* Check SYSMODE state as this is the primary control */
        switch (p_ext_data->cur_mode)
842016b6:	93 f0 66 88 	r1 = M[r7 + 408];
842016ba:	58 24       	Null = r1 - 1;
842016bc:	f9 ff 91 ee 	if LS jump (m) Lc_aanc_process_data_50;

842016c0 <Lc_aanc_process_data_80>:
842016c0:	98 24       	Null = r1 - 2;
842016c2:	19 60       	if EQ jump (m) Lc_aanc_process_data_85;

842016c4 <Lc_aanc_process_data_81>:
842016c4:	d8 24       	Null = r1 - 3;
842016c6:	5a 60       	if EQ jump (m) Lc_aanc_process_data_98;

842016c8 <Lc_aanc_process_data_82>:
842016c8:	18 25       	Null = r1 - 4;
842016ca:	81 61       	if EQ jump (m) Lc_aanc_process_data_50;

842016cc <Lc_aanc_process_data_83>:
842016cc:	98 25       	Null = r1 - 6;
842016ce:	f8 ff eb ed 	if HI jump (m) Lc_aanc_process_data_48;

842016d2 <Lc_aanc_process_data_84>:
                break;
            case AANC_SYSMODE_QUIET:
                /* Fall through as action is taken in gentle mute */
            case AANC_SYSMODE_GENTLE_MUTE:
                /* Gentle mute ramps gain down to 0 */
                aanc_process_ramp(&p_ext_data->ff_ramp);
842016d2:	92 f0 90 22 	r0 = r7 + 656;
842016d6:	04 f0 23 e7 	call (m) Lc_aanc_process_ramp_1;
                aanc_process_ramp(&p_ext_data->fb_ramp);
842016da:	92 f0 ac 22 	r0 = r7 + 684;
842016de:	04 f0 3b e6 	call (m) Lc_aanc_process_ramp_1;
                aanc_fxlms100_update_gain(p_ext_data->ag->p_fxlms,
                                          p_ext_data->ff_gain.fine, 0);
842016e2:	93 f0 e1 86 	r1 = MHU[r7 + 450];
842016e6:	91 f0 6f 88 	rMAC = M[r7 + 444];
842016ea:	8a 99       	r0 = M[rMAC + 56];
842016ec:	04 00       	r2 = Null + Null;
842016ee:	0c f0 21 e3 	call (m) $_aanc_fxlms100_update_gain;
                break;
842016f2:	6d 6f       	jump (m) Lc_aanc_process_data_50;

842016f4 <Lc_aanc_process_data_85>:
                /* Mute action is taken in SET_CONTROL */
            case AANC_SYSMODE_FREEZE:
                /* Freeze does nothing to change the gains */
                break;
            case AANC_SYSMODE_FULL:
                if (p_ext_data->ff_ramp.state == AANC_RAMP_FINISHED)
842016f4:	91 f0 9c 90 	rMAC = MBS[r7 + 668];
842016f8:	c8 24       	Null = rMAC - 3;
842016fa:	36 62       	if NE jump (m) Lc_aanc_process_data_97;

842016fc <Lc_aanc_process_data_86>:
                {
                    /* Not ramping FF fine gain, so fall through to state
                     * machine.
                     */
                    if (mode_after_flags == AANC_SYSMODE_FREEZE)
842016fc:	b0 f0 04 24 	Null = r9 - 4;
84201700:	12 62       	if NE jump (m) Lc_aanc_process_data_90;

84201702 <Lc_aanc_process_data_87>:
                    {
                        L4_DBG_MSG1("AANC FULL Mode, FREEZE: gain = %hu",
                                    p_ext_data->ff_gain.fine);
84201702:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201706:	08 25       	Null = rMAC - 4;
84201708:	09 68       	if LT jump (m) Lc_aanc_process_data_89;

8420170a <Lc_aanc_process_data_88>:
8420170a:	93 f0 e1 86 	r1 = MHU[r7 + 450];
8420170e:	55 f1 02 f0 	r0 = Null + 357566286;
84201712:	4e 4b 
84201714:	ef fd fc ff 	call (m) 0x10c2;
84201718:	2f ed 

8420171a <Lc_aanc_process_data_89>:
                    aanc_fxlms100_update_gain(p_ext_data->ag->p_fxlms,
                                                (uint16)initial_value, 0);
                    /* Process the FF fine gain ramp. */
                    aanc_process_ramp(&p_ext_data->ff_ramp);
                }
                aanc_process_ramp(&p_ext_data->fb_ramp);
8420171a:	92 f0 ac 22 	r0 = r7 + 684;
8420171e:	04 f0 3b e4 	call (m) Lc_aanc_process_ramp_1;
                break;
84201722:	55 6f       	jump (m) Lc_aanc_process_data_50;

84201724 <Lc_aanc_process_data_90>:
                    if (mode_after_flags == AANC_SYSMODE_FREEZE)
                    {
                        L4_DBG_MSG1("AANC FULL Mode, FREEZE: gain = %hu",
                                    p_ext_data->ff_gain.fine);
                    }
                    else if (mode_after_flags == AANC_SYSMODE_MUTE_ANC)
84201724:	b0 f0 01 24 	Null = r9 - 1;
84201728:	0e 62       	if NE jump (m) Lc_aanc_process_data_94;

8420172a <Lc_aanc_process_data_91>:
                    {
                        L4_DBG_MSG("AANC FULL Mode, MUTE: gain = 0");
8420172a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420172e:	08 25       	Null = rMAC - 4;
84201730:	07 68       	if LT jump (m) Lc_aanc_process_data_93;

84201732 <Lc_aanc_process_data_92>:
84201732:	55 f1 02 f0 	r0 = Null + 357566321;
84201736:	71 4b 
84201738:	ef fd fc ff 	call (m) 0x10b0;
8420173c:	39 eb 

8420173e <Lc_aanc_process_data_93>:
                        p_ext_data->ff_gain.fine = 0;
8420173e:	90 f0 e1 8c 	MH[r7 + 450] = Null;
84201742:	ec 6f       	jump (m) Lc_aanc_process_data_89;

84201744 <Lc_aanc_process_data_94>:
                    }
                    else
                    {
                        L4_DBG_MSG1("AANC FULL mode, FULL: gain = %u",
                                    *p_gain_calc);
84201744:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201748:	08 25       	Null = rMAC - 4;
8420174a:	09 68       	if LT jump (m) Lc_aanc_process_data_96;

8420174c <Lc_aanc_process_data_95>:
8420174c:	59 d8       	rMAC = M[FP + 44];
8420174e:	0b e8       	r1 = M[rMAC + Null];
84201750:	55 f1 02 f0 	r0 = Null + 357566352;
84201754:	90 4b 
84201756:	ef fd fc ff 	call (m) 0x10c2;
8420175a:	2d eb 

8420175c <Lc_aanc_process_data_96>:
                        p_ext_data->ff_gain.fine = (uint16) *p_gain_calc;
8420175c:	59 d8       	rMAC = M[FP + 44];
8420175e:	09 e8       	rMAC = M[rMAC + Null];
84201760:	91 f0 e1 8c 	MH[r7 + 450] = rMAC;
84201764:	db 6f       	jump (m) Lc_aanc_process_data_89;

84201766 <Lc_aanc_process_data_97>:
                else
                {
                    /* Initialize the FxLMS algorithm for when the ramp
                     * finishes.
                     */
                    initial_value = p_params->OFFSET_FXLMS_INITIAL_VALUE;
84201766:	61 d8       	rMAC = M[FP + 48];
84201768:	11 f0 46 88 	rMAC = M[rMAC + 280];
                    aanc_fxlms100_update_gain(p_ext_data->ag->p_fxlms,
                                                (uint16)initial_value, 0);
8420176c:	8b c6       	r1 = rMAC AND 0xffff;
8420176e:	91 f0 6f 88 	rMAC = M[r7 + 444];
84201772:	8a 99       	r0 = M[rMAC + 56];
84201774:	04 00       	r2 = Null + Null;
84201776:	0b f0 39 ee 	call (m) $_aanc_fxlms100_update_gain;

8420177a <Lc_aanc_process_data_98>:
                    /* Process the FF fine gain ramp. */
                    aanc_process_ramp(&p_ext_data->ff_ramp);
8420177a:	92 f0 90 22 	r0 = r7 + 656;
8420177e:	04 f0 3b e1 	call (m) Lc_aanc_process_ramp_1;
84201782:	cc 6f       	jump (m) Lc_aanc_process_data_89;

84201784 <Lc_aanc_process_data_99>:
    * set the FB fine gain to its static value.
    *
    * Clear "hard" reinitializion so that FB gain is not touched in
    * subsequent iterations.
    */
    if (p_ext_data->re_init_hard)
84201784:	91 f0 03 92 	rMAC = MBU[r7 + 515];
84201788:	03 60       	if EQ jump (m) Lc_aanc_process_data_101;

8420178a <Lc_aanc_process_data_100>:
    {
        p_ext_data->re_init_hard = FALSE;
8420178a:	90 f0 03 9a 	MB[r7 + 515] = Null;

8420178e <Lc_aanc_process_data_101>:
    }

    aanc_update_gain(op_data, p_ext_data);
8420178e:	4b 08       	r1 = r7 + Null;
84201790:	42 d8       	r0 = M[FP + 32];
84201792:	97 4e       	call (m) Lc_aanc_update_gain_1;
84201794:	01 fa d8 c8 	r6 = r8 LSHIFT 2;

    /****************
     * Pass Metadata
     ****************/
    for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
84201798:	06 00       	r4 = Null + Null;
8420179a:	97 f0 20 20 	r5 = r7 + 32;

8420179e <Lc_aanc_process_data_102>:
    {
        metadata_strict_transport(p_ext_data->metadata_ip[i],
                                  p_ext_data->metadata_op[i],
                                  sample_count * OCTETS_PER_SAMPLE);
8420179e:	bb 88       	r1 = M[r5 + 8];
842017a0:	3a e8       	r0 = M[r5 + Null];
842017a2:	44 08       	r2 = r6 + Null;
842017a4:	ff fd 99 f0 	call (m) 0x14af0;
842017a8:	2d ea 
    aanc_update_gain(op_data, p_ext_data);

    /****************
     * Pass Metadata
     ****************/
    for (i = 0; i < AANC_NUM_METADATA_CHANNELS; i++)
842017aa:	76 20       	r4 = r4 + 1;
842017ac:	3f 21       	r5 = r5 + 4;
842017ae:	b0 24       	Null = r4 - 2;
842017b0:	f7 69       	if LT jump (m) Lc_aanc_process_data_102;

842017b2 <Lc_aanc_process_data_103>:
    }

    /***************************
     * Update touched terminals
     ***************************/
    touched->sinks = (unsigned) p_ext_data->touched_sinks;
842017b2:	91 f0 d4 86 	rMAC = MHU[r7 + 424];
842017b6:	4a d8       	r0 = M[FP + 36];
842017b8:	51 8e       	M[r0 + 4] = rMAC;
    touched->sources = (unsigned) p_ext_data->touched_sources;
842017ba:	91 f0 d5 86 	rMAC = MHU[r7 + 426];
842017be:	11 ee       	M[r0 + Null] = rMAC;

    L5_DBG_MSG("AANC process channel data completed");
842017c0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842017c4:	48 25       	Null = rMAC - 5;
842017c6:	07 68       	if LT jump (m) Lc_aanc_process_data_105;

842017c8 <Lc_aanc_process_data_104>:
842017c8:	55 f1 02 f0 	r0 = Null + 357566409;
842017cc:	c9 4b 
842017ce:	ef fd fc ff 	call (m) 0x10b0;
842017d2:	23 e7 

842017d4 <Lc_aanc_process_data_105>:

    return;
}
842017d4:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842017d6:	d8 4c       	rts;

842017d8 <$_ups_params_aanc>:

bool ups_params_aanc(void* instance_data, PS_KEY_TYPE key,
                     PERSISTENCE_RANK rank, uint16 length,
                     unsigned* data, STATUS_KYMERA status,
                     uint16 extra_status_info)
{
842017d8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842017da:	2f 00       	r5 = r3 + Null;
 *
 * \return  Pointer to extra operator data AANC_OP_DATA.
 */
static inline AANC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AANC_OP_DATA *) base_op_get_instance_data(op_data);
842017dc:	ef fd f8 ff 	call (m) 0x8ea;
842017e0:	2f e8 
842017e2:	16 00       	r4 = r0 + Null;
                     uint16 extra_status_info)
{
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) instance_data;
    AANC_OP_DATA *p_ext_data = get_instance_data(op_data);

    cpsSetParameterFromPsStore(&p_ext_data->params_def, length, data, status);
842017e4:	e5 d5       	r3 = MHS[FP + -8];
842017e6:	fc d9       	r2 = M[FP + -4];
842017e8:	62 f0 10 22 	r0 = r4 + 528;
842017ec:	3b 00       	r1 = r5 + Null;
842017ee:	ef fd fb ff 	call (m) 0xdf6;
842017f2:	29 e0 

    /* Set the reinitialization flag after setting the parameters */
    p_ext_data->re_init_flag = TRUE;
842017f4:	41 20       	rMAC = Null + 1;
842017f6:	61 f0 02 9a 	MB[r4 + 514] = rMAC;

    return TRUE;
842017fa:	0a 00       	r0 = rMAC + Null;

842017fc <Lc_ups_params_aanc_2>:
}
842017fc:	f2 48       	popm <FP, r4, r5, rLink>;
842017fe:	d8 4c       	rts;

84201800 <Lc_aanc_update_fine_gain_1>:
 */
static void aanc_update_fine_gain(uint16 gain,
                                  AANC_ANC_PATH path,
                                  AANC_ANC_INSTANCE channel,
                                  bool filter_config)
{
84201800:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201802:	16 00       	r4 = r0 + Null;
84201804:	1f 00       	r5 = r1 + Null;
84201806:	22 00       	r0 = r2 + Null;
    if (filter_config == AANC_FILTER_CONFIG_PARALLEL)
84201808:	68 24       	Null = r3 - 1;
8420180a:	0d 62       	if NE jump (m) Lc_aanc_update_fine_gain_3;

8420180c <Lc_aanc_update_fine_gain_2>:
    {
        AANC_UPDATE_FINE_GAIN(AANC_ANC_INSTANCE_ANC0_ID, path, gain);
8420180c:	42 20       	r0 = Null + 1;
8420180e:	34 00       	r2 = r4 + Null;
84201810:	ff fd 5a f0 	call (m) 0xcdfe;
84201814:	2f ef 
        AANC_UPDATE_FINE_GAIN(AANC_ANC_INSTANCE_ANC1_ID, path, gain);
84201816:	82 20       	r0 = Null + 2;
84201818:	34 00       	r2 = r4 + Null;
8420181a:	3b 00       	r1 = r5 + Null;
8420181c:	ff fd 5a f0 	call (m) 0xcdfe;
84201820:	23 ef 
84201822:	05 6e       	jump (m) Lc_aanc_update_fine_gain_4;

84201824 <Lc_aanc_update_fine_gain_3>:
    }
    else
    {
        AANC_UPDATE_FINE_GAIN(channel, path, gain);
84201824:	34 00       	r2 = r4 + Null;
84201826:	ff fd 5a f0 	call (m) 0xcdfe;
8420182a:	39 ee 

8420182c <Lc_aanc_update_fine_gain_4>:
    }
}
8420182c:	f2 48       	popm <FP, r4, r5, rLink>;
8420182e:	d8 4c       	rts;

84201830 <Lc_aanc_update_coarse_gain_1>:
 */
static void aanc_update_coarse_gain(uint16 gain,
                                    AANC_ANC_PATH path,
                                    AANC_ANC_INSTANCE channel,
                                    bool filter_config)
{
84201830:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201832:	16 00       	r4 = r0 + Null;
84201834:	1f 00       	r5 = r1 + Null;
84201836:	22 00       	r0 = r2 + Null;
    if (filter_config == AANC_FILTER_CONFIG_PARALLEL)
84201838:	68 24       	Null = r3 - 1;
8420183a:	0d 62       	if NE jump (m) Lc_aanc_update_coarse_gain_3;

8420183c <Lc_aanc_update_coarse_gain_2>:
    {
        stream_anc_set_anc_coarse_gain(AANC_ANC_INSTANCE_ANC0_ID, path, gain);
8420183c:	42 20       	r0 = Null + 1;
8420183e:	34 00       	r2 = r4 + Null;
84201840:	ff fd 5a f0 	call (m) 0xce08;
84201844:	29 ee 
        stream_anc_set_anc_coarse_gain(AANC_ANC_INSTANCE_ANC1_ID, path, gain);
84201846:	82 20       	r0 = Null + 2;
84201848:	34 00       	r2 = r4 + Null;
8420184a:	3b 00       	r1 = r5 + Null;
8420184c:	ff fd 5a f0 	call (m) 0xce08;
84201850:	3d ed 
84201852:	05 6e       	jump (m) Lc_aanc_update_coarse_gain_4;

84201854 <Lc_aanc_update_coarse_gain_3>:
    }
    else
    {
        stream_anc_set_anc_coarse_gain(channel, path, gain);
84201854:	34 00       	r2 = r4 + Null;
84201856:	ff fd 5a f0 	call (m) 0xce08;
8420185a:	33 ed 

8420185c <Lc_aanc_update_coarse_gain_4>:
    }
}
8420185c:	f2 48       	popm <FP, r4, r5, rLink>;
8420185e:	d8 4c       	rts;

84201860 <Lc_aanc_update_fine_rx_mix_gain_1>:
 */
static void aanc_update_fine_rx_mix_gain(uint16 gain,
                                         AANC_ANC_PATH path,
                                         AANC_ANC_INSTANCE channel,
                                         bool filter_config)
{
84201860:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201862:	16 00       	r4 = r0 + Null;
84201864:	1f 00       	r5 = r1 + Null;
84201866:	22 00       	r0 = r2 + Null;
    if (filter_config == AANC_FILTER_CONFIG_PARALLEL)
84201868:	68 24       	Null = r3 - 1;
8420186a:	0d 62       	if NE jump (m) Lc_aanc_update_fine_rx_mix_gain_3;

8420186c <Lc_aanc_update_fine_rx_mix_gain_2>:
    {
        stream_anc_set_anc_rx_mix_foreground_fine_gain(
            AANC_ANC_INSTANCE_ANC0_ID, path, gain);
8420186c:	42 20       	r0 = Null + 1;
8420186e:	34 00       	r2 = r4 + Null;
84201870:	ff fd 5a f0 	call (m) 0xce12;
84201874:	23 ed 
        stream_anc_set_anc_rx_mix_foreground_fine_gain(
            AANC_ANC_INSTANCE_ANC1_ID, path, gain);
84201876:	82 20       	r0 = Null + 2;
84201878:	34 00       	r2 = r4 + Null;
8420187a:	3b 00       	r1 = r5 + Null;
8420187c:	ff fd 5a f0 	call (m) 0xce12;
84201880:	37 ec 
84201882:	05 6e       	jump (m) Lc_aanc_update_fine_rx_mix_gain_4;

84201884 <Lc_aanc_update_fine_rx_mix_gain_3>:
    }
    else
    {
        stream_anc_set_anc_rx_mix_foreground_fine_gain(channel, path, gain);
84201884:	34 00       	r2 = r4 + Null;
84201886:	ff fd 5a f0 	call (m) 0xce12;
8420188a:	2d ec 

8420188c <Lc_aanc_update_fine_rx_mix_gain_4>:
    }
}
8420188c:	f2 48       	popm <FP, r4, r5, rLink>;
8420188e:	d8 4c       	rts;

84201890 <Lc_aanc_update_coarse_rx_mix_gain_1>:
 */
static void aanc_update_coarse_rx_mix_gain(uint16 gain,
                                           AANC_ANC_PATH path,
                                           AANC_ANC_INSTANCE channel,
                                           bool filter_config)
{
84201890:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201892:	16 00       	r4 = r0 + Null;
84201894:	1f 00       	r5 = r1 + Null;
84201896:	22 00       	r0 = r2 + Null;
    if (filter_config == AANC_FILTER_CONFIG_PARALLEL)
84201898:	68 24       	Null = r3 - 1;
8420189a:	0d 62       	if NE jump (m) Lc_aanc_update_coarse_rx_mix_gain_3;

8420189c <Lc_aanc_update_coarse_rx_mix_gain_2>:
    {
        stream_anc_set_anc_rx_mix_coarse_gain(AANC_ANC_INSTANCE_ANC0_ID,
                                              path,
                                              gain);
8420189c:	42 20       	r0 = Null + 1;
8420189e:	34 00       	r2 = r4 + Null;
842018a0:	ff fd 5a f0 	call (m) 0xce46;
842018a4:	27 ed 
        stream_anc_set_anc_rx_mix_coarse_gain(AANC_ANC_INSTANCE_ANC1_ID,
                                              path,
                                              gain);
842018a6:	82 20       	r0 = Null + 2;
842018a8:	34 00       	r2 = r4 + Null;
842018aa:	3b 00       	r1 = r5 + Null;
842018ac:	ff fd 5a f0 	call (m) 0xce46;
842018b0:	3b ec 
842018b2:	05 6e       	jump (m) Lc_aanc_update_coarse_rx_mix_gain_4;

842018b4 <Lc_aanc_update_coarse_rx_mix_gain_3>:
    }
    else
    {
        stream_anc_set_anc_rx_mix_coarse_gain(channel, path, gain);
842018b4:	34 00       	r2 = r4 + Null;
842018b6:	ff fd 5a f0 	call (m) 0xce46;
842018ba:	31 ec 

842018bc <Lc_aanc_update_coarse_rx_mix_gain_4>:
    }
}
842018bc:	f2 48       	popm <FP, r4, r5, rLink>;
842018be:	d8 4c       	rts;

842018c0 <Lc_aanc_update_gain_1>:
 * Any changes in the gain value since the previous value was set is written
 * to the HW.
 *
 */
static bool aanc_update_gain(OPERATOR_DATA *op_data, AANC_OP_DATA *p_ext_data)
{
842018c0:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842018c2:	1e 00       	r4 = r1 + Null;
    AANC_ANC_PATH anc_path;
    bool filter_config = p_ext_data->filter_config;
842018c4:	68 f0 dc 86 	r6 = MHU[r4 + 440];
    AANC_ANC_INSTANCE anc_channel = p_ext_data->anc_channel;
842018c8:	69 f0 fc 81 	r7 = MBS[r4 + 508];

    /* Only update EC and FB gains if in hybrid mode */
    if (p_ext_data->anc_fb_path != AANC_ANC_PATH_NONE_ID)
842018cc:	61 f0 ff 81 	rMAC = MBS[r4 + 511];
842018d0:	3b 60       	if EQ jump (m) Lc_aanc_update_gain_10;

842018d2 <Lc_aanc_update_gain_2>:
    {
        /* Update EC gain */
        if (p_ext_data->ec_gain.fine != p_ext_data->ec_gain_prev.fine)
842018d2:	62 f0 e5 86 	r0 = MHU[r4 + 458];
842018d6:	61 f0 ef 86 	rMAC = MHU[r4 + 478];
842018da:	50 04       	Null = r0 - rMAC;
842018dc:	09 60       	if EQ jump (m) Lc_aanc_update_gain_4;

842018de <Lc_aanc_update_gain_3>:
        {
            aanc_update_fine_gain(p_ext_data->ec_gain.fine,
                                  AANC_ANC_PATH_FB_ID,
                                  anc_channel,
                                  filter_config);
842018de:	c3 20       	r1 = Null + 3;
842018e0:	45 08       	r3 = r6 + Null;
842018e2:	4c 08       	r2 = r7 + Null;
842018e4:	8e 4f       	call (m) Lc_aanc_update_fine_gain_1;
            p_ext_data->ec_gain_prev.fine = p_ext_data->ec_gain.fine;
842018e6:	61 f0 e5 86 	rMAC = MHU[r4 + 458];
842018ea:	61 f0 ef 8c 	MH[r4 + 478] = rMAC;

842018ee <Lc_aanc_update_gain_4>:
        }
        if (p_ext_data->ec_gain.coarse != p_ext_data->ec_gain_prev.coarse)
842018ee:	62 f0 e4 86 	r0 = MHU[r4 + 456];
842018f2:	61 f0 ee 86 	rMAC = MHU[r4 + 476];
842018f6:	50 04       	Null = r0 - rMAC;
842018f8:	09 60       	if EQ jump (m) Lc_aanc_update_gain_6;

842018fa <Lc_aanc_update_gain_5>:
        {
            aanc_update_coarse_gain(p_ext_data->ec_gain.coarse,
                                    AANC_ANC_PATH_FB_ID,
                                    anc_channel,
                                    filter_config);
842018fa:	c3 20       	r1 = Null + 3;
842018fc:	45 08       	r3 = r6 + Null;
842018fe:	4c 08       	r2 = r7 + Null;
84201900:	98 4f       	call (m) Lc_aanc_update_coarse_gain_1;
            p_ext_data->ec_gain_prev.coarse = p_ext_data->ec_gain.coarse;
84201902:	61 f0 e4 86 	rMAC = MHU[r4 + 456];
84201906:	61 f0 ee 8c 	MH[r4 + 476] = rMAC;

8420190a <Lc_aanc_update_gain_6>:
        }

        /* Update FB gain */
        anc_path = p_ext_data->anc_fb_path;
8420190a:	67 f0 ff 81 	r5 = MBS[r4 + 511];
        if (p_ext_data->fb_gain.fine != p_ext_data->fb_gain_prev.fine)
8420190e:	62 f0 e3 86 	r0 = MHU[r4 + 454];
84201912:	61 f0 ed 86 	rMAC = MHU[r4 + 474];
84201916:	50 04       	Null = r0 - rMAC;
84201918:	09 60       	if EQ jump (m) Lc_aanc_update_gain_8;

8420191a <Lc_aanc_update_gain_7>:
        {
            aanc_update_fine_gain(p_ext_data->fb_gain.fine,
                                  anc_path,
                                  anc_channel,
                                  filter_config);
8420191a:	45 08       	r3 = r6 + Null;
8420191c:	4c 08       	r2 = r7 + Null;
8420191e:	3b 00       	r1 = r5 + Null;
84201920:	70 4f       	call (m) Lc_aanc_update_fine_gain_1;
            p_ext_data->fb_gain_prev.fine = p_ext_data->fb_gain.fine;
84201922:	61 f0 e3 86 	rMAC = MHU[r4 + 454];
84201926:	61 f0 ed 8c 	MH[r4 + 474] = rMAC;

8420192a <Lc_aanc_update_gain_8>:
        }
        if (p_ext_data->fb_gain.coarse != p_ext_data->fb_gain_prev.coarse)
8420192a:	62 f0 e2 86 	r0 = MHU[r4 + 452];
8420192e:	61 f0 ec 86 	rMAC = MHU[r4 + 472];
84201932:	50 04       	Null = r0 - rMAC;
84201934:	09 60       	if EQ jump (m) Lc_aanc_update_gain_10;

84201936 <Lc_aanc_update_gain_9>:
        {
            aanc_update_coarse_gain(p_ext_data->fb_gain.coarse,
                                    anc_path,
                                    anc_channel,
                                    filter_config);
84201936:	45 08       	r3 = r6 + Null;
84201938:	4c 08       	r2 = r7 + Null;
8420193a:	3b 00       	r1 = r5 + Null;
8420193c:	7a 4f       	call (m) Lc_aanc_update_coarse_gain_1;
            p_ext_data->fb_gain_prev.coarse = p_ext_data->fb_gain.coarse;
8420193e:	61 f0 e2 86 	rMAC = MHU[r4 + 452];
84201942:	61 f0 ec 8c 	MH[r4 + 472] = rMAC;

84201946 <Lc_aanc_update_gain_10>:
        }
    }

    /* Update FF gain */
    anc_path = p_ext_data->anc_ff_path;
84201946:	67 f0 fe 81 	r5 = MBS[r4 + 510];
    if (p_ext_data->ff_gain.fine != p_ext_data->ff_gain_prev.fine)
8420194a:	62 f0 e1 86 	r0 = MHU[r4 + 450];
8420194e:	61 f0 eb 86 	rMAC = MHU[r4 + 470];
84201952:	50 04       	Null = r0 - rMAC;
84201954:	09 60       	if EQ jump (m) Lc_aanc_update_gain_12;

84201956 <Lc_aanc_update_gain_11>:
    {
        aanc_update_fine_gain(p_ext_data->ff_gain.fine,
                              anc_path,
                              anc_channel,
                              filter_config);
84201956:	45 08       	r3 = r6 + Null;
84201958:	4c 08       	r2 = r7 + Null;
8420195a:	3b 00       	r1 = r5 + Null;
8420195c:	52 4f       	call (m) Lc_aanc_update_fine_gain_1;
        p_ext_data->ff_gain_prev.fine = p_ext_data->ff_gain.fine;
8420195e:	61 f0 e1 86 	rMAC = MHU[r4 + 450];
84201962:	61 f0 eb 8c 	MH[r4 + 470] = rMAC;

84201966 <Lc_aanc_update_gain_12>:
    }
    if (p_ext_data->ff_gain.coarse != p_ext_data->ff_gain_prev.coarse)
84201966:	62 f0 e0 86 	r0 = MHU[r4 + 448];
8420196a:	61 f0 ea 86 	rMAC = MHU[r4 + 468];
8420196e:	50 04       	Null = r0 - rMAC;
84201970:	09 60       	if EQ jump (m) Lc_aanc_update_gain_14;

84201972 <Lc_aanc_update_gain_13>:
    {
        aanc_update_coarse_gain(p_ext_data->ff_gain.coarse,
                                anc_path,
                                anc_channel,
                                filter_config);
84201972:	45 08       	r3 = r6 + Null;
84201974:	4c 08       	r2 = r7 + Null;
84201976:	3b 00       	r1 = r5 + Null;
84201978:	5c 4f       	call (m) Lc_aanc_update_coarse_gain_1;
        p_ext_data->ff_gain_prev.coarse = p_ext_data->ff_gain.coarse;
8420197a:	61 f0 e0 86 	rMAC = MHU[r4 + 448];
8420197e:	61 f0 ea 8c 	MH[r4 + 468] = rMAC;

84201982 <Lc_aanc_update_gain_14>:
    }

#ifdef AANC_MAOR_V20
    if (p_ext_data->rx_ffa_mix_gain.fine != p_ext_data->rx_ffa_mix_gain_prev.fine)
84201982:	62 f0 e7 86 	r0 = MHU[r4 + 462];
84201986:	61 f0 f1 86 	rMAC = MHU[r4 + 482];
8420198a:	50 04       	Null = r0 - rMAC;
8420198c:	09 60       	if EQ jump (m) Lc_aanc_update_gain_16;

8420198e <Lc_aanc_update_gain_15>:
    {
        aanc_update_fine_rx_mix_gain(p_ext_data->rx_ffa_mix_gain.fine,
                                     AANC_ANC_PATH_FFA_ID,
                                     anc_channel,
                                     filter_config);
8420198e:	43 20       	r1 = Null + 1;
84201990:	45 08       	r3 = r6 + Null;
84201992:	4c 08       	r2 = r7 + Null;
84201994:	66 4f       	call (m) Lc_aanc_update_fine_rx_mix_gain_1;
        p_ext_data->rx_ffa_mix_gain_prev.fine = p_ext_data->rx_ffa_mix_gain.fine;
84201996:	61 f0 e7 86 	rMAC = MHU[r4 + 462];
8420199a:	61 f0 f1 8c 	MH[r4 + 482] = rMAC;

8420199e <Lc_aanc_update_gain_16>:
    }
    if (p_ext_data->rx_ffa_mix_gain.coarse != p_ext_data->rx_ffa_mix_gain_prev.coarse)
8420199e:	62 f0 e6 86 	r0 = MHU[r4 + 460];
842019a2:	61 f0 f0 86 	rMAC = MHU[r4 + 480];
842019a6:	50 04       	Null = r0 - rMAC;
842019a8:	09 60       	if EQ jump (m) Lc_aanc_update_gain_18;

842019aa <Lc_aanc_update_gain_17>:
    {
        aanc_update_coarse_rx_mix_gain(p_ext_data->rx_ffa_mix_gain.coarse,
                                       AANC_ANC_PATH_FFA_ID,
                                       anc_channel,
                                       filter_config);
842019aa:	43 20       	r1 = Null + 1;
842019ac:	45 08       	r3 = r6 + Null;
842019ae:	4c 08       	r2 = r7 + Null;
842019b0:	70 4f       	call (m) Lc_aanc_update_coarse_rx_mix_gain_1;
        p_ext_data->rx_ffa_mix_gain_prev.coarse = p_ext_data->rx_ffa_mix_gain.coarse;
842019b2:	61 f0 e6 86 	rMAC = MHU[r4 + 460];
842019b6:	61 f0 f0 8c 	MH[r4 + 480] = rMAC;

842019ba <Lc_aanc_update_gain_18>:
    }
    if (p_ext_data->rx_ffb_mix_gain.fine != p_ext_data->rx_ffb_mix_gain_prev.fine)
842019ba:	62 f0 e9 86 	r0 = MHU[r4 + 466];
842019be:	61 f0 f3 86 	rMAC = MHU[r4 + 486];
842019c2:	50 04       	Null = r0 - rMAC;
842019c4:	09 60       	if EQ jump (m) Lc_aanc_update_gain_20;

842019c6 <Lc_aanc_update_gain_19>:
    {
        aanc_update_fine_rx_mix_gain(p_ext_data->rx_ffb_mix_gain.fine,
                                     AANC_ANC_PATH_FFB_ID,
                                     anc_channel,
                                     filter_config);
842019c6:	83 20       	r1 = Null + 2;
842019c8:	45 08       	r3 = r6 + Null;
842019ca:	4c 08       	r2 = r7 + Null;
842019cc:	4a 4f       	call (m) Lc_aanc_update_fine_rx_mix_gain_1;
        p_ext_data->rx_ffb_mix_gain_prev.fine = p_ext_data->rx_ffb_mix_gain.fine;
842019ce:	61 f0 e9 86 	rMAC = MHU[r4 + 466];
842019d2:	61 f0 f3 8c 	MH[r4 + 486] = rMAC;

842019d6 <Lc_aanc_update_gain_20>:
    }
    if (p_ext_data->rx_ffb_mix_gain.coarse != p_ext_data->rx_ffb_mix_gain_prev.coarse)
842019d6:	62 f0 e8 86 	r0 = MHU[r4 + 464];
842019da:	61 f0 f2 86 	rMAC = MHU[r4 + 484];
842019de:	50 04       	Null = r0 - rMAC;
842019e0:	09 60       	if EQ jump (m) Lc_aanc_update_gain_22;

842019e2 <Lc_aanc_update_gain_21>:
    {
        aanc_update_coarse_rx_mix_gain(p_ext_data->rx_ffb_mix_gain.coarse,
                                       AANC_ANC_PATH_FFB_ID,
                                       anc_channel,
                                       filter_config);
842019e2:	83 20       	r1 = Null + 2;
842019e4:	45 08       	r3 = r6 + Null;
842019e6:	4c 08       	r2 = r7 + Null;
842019e8:	54 4f       	call (m) Lc_aanc_update_coarse_rx_mix_gain_1;
        p_ext_data->rx_ffb_mix_gain_prev.coarse = p_ext_data->rx_ffb_mix_gain.coarse;
842019ea:	61 f0 e8 86 	rMAC = MHU[r4 + 464];
842019ee:	61 f0 f2 8c 	MH[r4 + 484] = rMAC;

842019f2 <Lc_aanc_update_gain_22>:
    }
#endif

    AANC_UPDATE_BACKGROUND_GAINS(p_ext_data->anc_mask);
842019f2:	62 f0 fd 81 	r0 = MBS[r4 + 509];
842019f6:	ff fd 59 f0 	call (m) 0xcdbe;
842019fa:	29 ee 

    return TRUE;
842019fc:	42 20       	r0 = Null + 1;

842019fe <Lc_aanc_update_gain_23>:
}
842019fe:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201a00:	d8 4c       	rts;

84201a02 <Lc_aanc_initialize_prev_gain_1>:
 *
 * \return  boolean indicating success or failure.
 */
static bool aanc_initialize_prev_gain(AANC_OP_DATA *p_ext_data)
{
    p_ext_data->ff_gain_prev.coarse = AANC_INVALID_COARSE_GAIN;
84201a02:	01 f0 00 60 	rMAC = Null + 4096;
84201a06:	21 f0 ea 8c 	MH[r0 + 468] = rMAC;
    p_ext_data->ff_gain_prev.fine = AANC_INVALID_FINE_GAIN;
84201a0a:	73 f0 ff 7b 	r1 = Null + 65535;
84201a0e:	23 f0 eb 8c 	MH[r0 + 470] = r1;
    p_ext_data->fb_gain_prev.coarse = AANC_INVALID_COARSE_GAIN;
84201a12:	21 f0 ec 8c 	MH[r0 + 472] = rMAC;
    p_ext_data->fb_gain_prev.fine = AANC_INVALID_FINE_GAIN;
84201a16:	23 f0 ed 8c 	MH[r0 + 474] = r1;
    p_ext_data->ec_gain_prev.coarse = AANC_INVALID_COARSE_GAIN;
84201a1a:	21 f0 ee 8c 	MH[r0 + 476] = rMAC;
    p_ext_data->ec_gain_prev.fine = AANC_INVALID_FINE_GAIN;
84201a1e:	23 f0 ef 8c 	MH[r0 + 478] = r1;
#ifdef AANC_MAOR_V20
    p_ext_data->rx_ffa_mix_gain_prev.coarse = AANC_INVALID_COARSE_GAIN;
84201a22:	21 f0 f0 8c 	MH[r0 + 480] = rMAC;
    p_ext_data->rx_ffa_mix_gain_prev.fine = AANC_INVALID_FINE_GAIN;
84201a26:	23 f0 f1 8c 	MH[r0 + 482] = r1;
    p_ext_data->rx_ffb_mix_gain_prev.coarse = AANC_INVALID_COARSE_GAIN;
84201a2a:	21 f0 f2 8c 	MH[r0 + 484] = rMAC;
    p_ext_data->rx_ffb_mix_gain_prev.fine = AANC_INVALID_FINE_GAIN;
84201a2e:	23 f0 f3 8c 	MH[r0 + 486] = r1;
#endif /* AANC_MAOR_V20 */
    return TRUE;
84201a32:	42 20       	r0 = Null + 1;

84201a34 <Lc_aanc_initialize_prev_gain_2>:
84201a34:	d8 4c       	rts;

84201a36 <Lc_update_touched_sink_sources_1>:
 *
 * Because this is solely dependent on the terminal connections it can be
 * calculated in connect/disconnect rather than in every process_data loop.
 */
static bool update_touched_sink_sources(AANC_OP_DATA *p_ext_data)
{
84201a36:	71 1c       	pushm <FP(=SP), r4>;
    int i;
    unsigned touched_sinks = 0;
84201a38:	03 00       	r1 = Null + Null;
    unsigned touched_sources = 0;
84201a3a:	04 00       	r2 = Null + Null;

    /* Update touched sinks */
    for (i = 0; i < AANC_MAX_SINKS; i++)
84201a3c:	01 00       	rMAC = Null + Null;
84201a3e:	15 00       	r3 = r0 + Null;
84201a40:	24 71       	r10 = Null + 4;
84201a42:	09 4c       	do (m) Lc__loop3;

84201a44 <Lc_update_touched_sink_sources_2>:
    {
        if (p_ext_data->inputs[i] != NULL)
84201a44:	2e e8       	r4 = M[r3 + Null];
84201a46:	05 60       	if EQ jump (m) Lc_update_touched_sink_sources_4;

84201a48 <Lc_update_touched_sink_sources_3>:
        {
            touched_sinks |= (uint16)(1 << i);
84201a48:	0e 00       	r4 = rMAC + Null;
84201a4a:	00 f6 96 de 	r4 = 0x1 LSHIFT r4;
84201a4e:	9b 13       	r1 = r1 OR r4;

84201a50 <Lc_update_touched_sink_sources_4>:
    int i;
    unsigned touched_sinks = 0;
    unsigned touched_sources = 0;

    /* Update touched sinks */
    for (i = 0; i < AANC_MAX_SINKS; i++)
84201a50:	49 20       	rMAC = rMAC + 1;
84201a52:	2d 21       	r3 = r3 + 4;

84201a54 <Lc__loop3>:
84201a54:	01 00       	rMAC = Null + Null;
84201a56:	15 28       	r3 = r0 + 16;
            touched_sinks |= (uint16)(1 << i);
        }
    }

    /* Update touched sources */
    for (i = 0; i < AANC_MAX_SOURCES; i++)
84201a58:	24 71       	r10 = Null + 4;
84201a5a:	09 4c       	do (m) Lc__loop4;

84201a5c <Lc_update_touched_sink_sources_6>:
    {
        if (p_ext_data->outputs[i] != NULL)
84201a5c:	2e e8       	r4 = M[r3 + Null];
84201a5e:	05 60       	if EQ jump (m) Lc_update_touched_sink_sources_8;

84201a60 <Lc_update_touched_sink_sources_7>:
        {
            touched_sources |= (uint16)(1 << i);
84201a60:	0e 00       	r4 = rMAC + Null;
84201a62:	00 f6 96 de 	r4 = 0x1 LSHIFT r4;
84201a66:	a4 13       	r2 = r2 OR r4;

84201a68 <Lc_update_touched_sink_sources_8>:
            touched_sinks |= (uint16)(1 << i);
        }
    }

    /* Update touched sources */
    for (i = 0; i < AANC_MAX_SOURCES; i++)
84201a68:	49 20       	rMAC = rMAC + 1;
84201a6a:	2d 21       	r3 = r3 + 4;

84201a6c <Lc__loop4>:
84201a6c:	23 f0 d4 8c 	MH[r0 + 424] = r1;
            touched_sources |= (uint16)(1 << i);
        }
    }

    p_ext_data->touched_sinks = (uint16)touched_sinks;
    p_ext_data->touched_sources = (uint16)touched_sources;
84201a70:	24 f0 d5 8c 	MH[r0 + 426] = r2;

    /* Generate a reinitialization because terminals have changed */
    p_ext_data->connect_flag = TRUE;
84201a74:	41 20       	rMAC = Null + 1;
84201a76:	21 f0 82 8e 	M[r0 + 520] = rMAC;

    return TRUE;
84201a7a:	0a 00       	r0 = rMAC + Null;

84201a7c <Lc_update_touched_sink_sources_10>:
}
84201a7c:	71 48       	popm <FP, r4>;
84201a7e:	d8 4c       	rts;

84201a80 <Lc_override_gain_1>:
 *
 * \return  boolean indicating success or failure.
 */
static bool override_gain(AANC_OP_DATA *p_ext_data, uint16 ctrl_value,
                          bool coarse_value, uint16 gain_offset)
{
84201a80:	c8 1c       	pushm <FP(=SP), rLink>;
    void *p_target;

    if (!((p_ext_data->cur_mode == AANC_SYSMODE_FREEZE) ||
          (p_ext_data->cur_mode == AANC_SYSMODE_STATIC)))
84201a82:	21 f0 66 88 	rMAC = M[r0 + 408];
84201a86:	08 25       	Null = rMAC - 4;
84201a88:	05 60       	if EQ jump (m) Lc_override_gain_4;

84201a8a <Lc_override_gain_2>:
84201a8a:	c8 24       	Null = rMAC - 3;
84201a8c:	03 60       	if EQ jump (m) Lc_override_gain_4;

84201a8e <Lc_override_gain_3>:
    {
        return FALSE;
84201a8e:	02 00       	r0 = Null + Null;
84201a90:	1c 6e       	jump (m) Lc_override_gain_13;

84201a92 <Lc_override_gain_4>:
    }

    /* Mask for bottom 16 bits */
    ctrl_value &= 0xFFFF;
84201a92:	9b c6       	r1 = r1 AND 0xffff;

    if (coarse_value == TRUE)
84201a94:	60 24       	Null = r2 - 1;
84201a96:	08 62       	if NE jump (m) Lc_override_gain_8;

84201a98 <Lc_override_gain_5>:
    {
        /* B-308001: Backwards compatibility with uint4 from QACT.
         * QACT will send 15 = -1 .. 8 = -8 but these need to be in full
         * (u)int16.
         */
        if (ctrl_value > 7 && ctrl_value < 16)
84201a98:	d8 25       	Null = r1 - 7;
84201a9a:	0a 6c       	if LE jump (m) Lc_override_gain_10;

84201a9c <Lc_override_gain_6>:
84201a9c:	18 2c       	Null = r1 - 16;
84201a9e:	08 66       	if GE jump (m) Lc_override_gain_10;

84201aa0 <Lc_override_gain_7>:
        {
            ctrl_value = (uint16)((65536 - 16) + ctrl_value);
84201aa0:	73 f0 f0 7f 	r1 = r1 + 65520;
84201aa4:	05 6e       	jump (m) Lc_override_gain_10;

84201aa6 <Lc_override_gain_8>:
        }
    }

    /* Set the gain: fine gain needs an additional offset */
    if (coarse_value == FALSE)
84201aa6:	20 04       	Null = r2 - Null;
84201aa8:	03 62       	if NE jump (m) Lc_override_gain_10;

84201aaa <Lc_override_gain_9>:
    {
        gain_offset += offsetof(AANC_GAIN, fine);
84201aaa:	a9 20       	rMAC = r3 + 2;
84201aac:	8d c6       	r3 = rMAC AND 0xffff;

84201aae <Lc_override_gain_10>:
    }
    p_target = (void *)((uintptr_t)p_ext_data + (unsigned)gain_offset);
84201aae:	a9 00       	rMAC = r3 + r0;
    *((uint16 *)p_target) = ctrl_value;
84201ab0:	0b ec       	MH[rMAC + Null] = r1;
    L4_DBG_MSG1("AANC gain override: %hu", *(uint16 *)p_target);
84201ab2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201ab6:	08 25       	Null = rMAC - 4;
84201ab8:	07 68       	if LT jump (m) Lc_override_gain_12;

84201aba <Lc_override_gain_11>:
84201aba:	55 f1 02 f0 	r0 = Null + 357564416;
84201abe:	00 40 
84201ac0:	ef fd fb ff 	call (m) 0x10c2;
84201ac4:	23 e0 

84201ac6 <Lc_override_gain_12>:

    return TRUE;
84201ac6:	42 20       	r0 = Null + 1;

84201ac8 <Lc_override_gain_13>:
}
84201ac8:	c8 48       	popm <FP, rLink>;
84201aca:	d8 4c       	rts;

84201acc <Lc_aanc_send_event_trigger_1>:
 *
 * \return  bool indicating success
 */
static bool aanc_send_event_trigger(OPERATOR_DATA *op_data, bool detect,
                                    uint16 id, uint16 payload)
{
84201acc:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201ace:	12 09       	r8 = r0 + Null;
84201ad0:	27 00       	r5 = r2 + Null;
84201ad2:	28 09       	r6 = r3 + Null;
    unsigned msg_size;
    unsigned *trigger_message = NULL;
    OPMSG_REPLY_ID message_id = OPMSG_REPLY_ID_AANC_EVENT_TRIGGER;
84201ad4:	41 71       	r7 = Null + 8;
    if (!detect)
84201ad6:	18 04       	Null = r1 - Null;
84201ad8:	02 62       	if NE jump (m) Lc_aanc_send_event_trigger_3;

84201ada <Lc_aanc_send_event_trigger_2>:
    {
        message_id = OPMSG_REPLY_ID_AANC_EVENT_NEGATIVE_TRIGGER;
84201ada:	49 71       	r7 = Null + 9;

84201adc <Lc_aanc_send_event_trigger_3>:
    }

    msg_size = OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER_WORD_SIZE;
    trigger_message = xpnewn(msg_size, unsigned);
84201adc:	c3 20       	r1 = Null + 3;
84201ade:	02 28       	r0 = Null + 16;
84201ae0:	ff fd 29 f0 	call (m) 0x6e90;
84201ae4:	31 ed 
84201ae6:	16 00       	r4 = r0 + Null;
    if (trigger_message == NULL)
84201ae8:	0d 62       	if NE jump (m) Lc_aanc_send_event_trigger_7;

84201aea <Lc_aanc_send_event_trigger_4>:
    {
        L2_DBG_MSG("Failed to send AANC event message");
84201aea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201aee:	88 24       	Null = rMAC - 2;
84201af0:	07 68       	if LT jump (m) Lc_aanc_send_event_trigger_6;

84201af2 <Lc_aanc_send_event_trigger_5>:
84201af2:	55 f1 02 f0 	r0 = Null + 357564440;
84201af6:	18 40 
84201af8:	ef fd fa ff 	call (m) 0x10b0;
84201afc:	39 ed 

84201afe <Lc_aanc_send_event_trigger_6>:
        return FALSE;
84201afe:	02 00       	r0 = Null + Null;
84201b00:	1b 6e       	jump (m) Lc_aanc_send_event_trigger_10;

84201b02 <Lc_aanc_send_event_trigger_7>:
    }

    OPMSG_CREATION_FIELD_SET(trigger_message,
                             OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER,
                             ID,
                             id);
84201b02:	3b 00       	r1 = r5 + Null;
84201b04:	33 ee       	M[r4 + Null] = r1;
    OPMSG_CREATION_FIELD_SET(trigger_message,
                             OPMSG_UNSOLICITED_AANC_EVENT_TRIGGER,
                             PAYLOAD,
                             payload);
84201b06:	44 08       	r2 = r6 + Null;
84201b08:	74 8e       	M[r4 + 4] = r2;

    L4_DBG_MSG2("AANC Event Sent: [%u, %u]", trigger_message[0],
                trigger_message[1]);
84201b0a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201b0e:	08 25       	Null = rMAC - 4;
84201b10:	07 68       	if LT jump (m) Lc_aanc_send_event_trigger_9;

84201b12 <Lc_aanc_send_event_trigger_8>:
84201b12:	55 f1 02 f0 	r0 = Null + 357564474;
84201b16:	3a 40 
84201b18:	ef fd fa ff 	call (m) 0x10d6;
84201b1c:	3f ed 

84201b1e <Lc_aanc_send_event_trigger_9>:
    common_send_unsolicited_message(op_data, (unsigned)message_id, msg_size,
                                    trigger_message);
84201b1e:	04 21       	r2 = Null + 4;
84201b20:	35 00       	r3 = r4 + Null;
84201b22:	4b 08       	r1 = r7 + Null;
84201b24:	52 08       	r0 = r8 + Null;
84201b26:	ef fd f7 ff 	call (m) 0x970;
84201b2a:	2b e2 

    pdelete(trigger_message);
84201b2c:	32 00       	r0 = r4 + Null;
84201b2e:	ff fd 2a f0 	call (m) 0x6fbe;
84201b32:	31 e4 

    return TRUE;
84201b34:	42 20       	r0 = Null + 1;

84201b36 <Lc_aanc_send_event_trigger_10>:
}
84201b36:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201b38:	d8 4c       	rts;

84201b3a <Lc_aanc_process_event_clear_condition_1>:
 * \return  void.
 */
static void aanc_process_event_clear_condition(OPERATOR_DATA *op_data,
                                               AANC_EVENT *p_event,
                                               uint16 id, uint16 payload)
{
84201b3a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201b3c:	1e 00       	r4 = r1 + Null;
    switch (p_event->running)
84201b3e:	31 90       	rMAC = MBS[r4 + 8];
84201b40:	04 f0 97 e0 	if NEG jump (m) Lc_aanc_process_event_clear_condition_6;

84201b44 <Lc_aanc_process_event_clear_condition_2>:
84201b44:	48 24       	Null = rMAC - 1;
84201b46:	05 6c       	if LE jump (m) Lc_aanc_process_event_clear_condition_5;

84201b48 <Lc_aanc_process_event_clear_condition_3>:
84201b48:	88 24       	Null = rMAC - 2;
84201b4a:	06 62       	if NE jump (m) Lc_aanc_process_event_clear_condition_6;

84201b4c <Lc_aanc_process_event_clear_condition_4>:
            case AANC_EVENT_DETECTED:
                /* Have detected but not sent message so clear */
                aanc_clear_event(p_event);
                break;
            case AANC_EVENT_SENT:
                aanc_send_event_trigger(op_data, FALSE, id, payload);
84201b4c:	03 00       	r1 = Null + Null;
84201b4e:	bf 4f       	call (m) Lc_aanc_send_event_trigger_1;

84201b50 <Lc_aanc_process_event_clear_condition_5>:
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201b50:	71 88       	rMAC = M[r4 + 4];
84201b52:	31 ee       	M[r4 + Null] = rMAC;
       p_event->running = AANC_EVENT_CLEAR;
84201b54:	30 9a       	MB[r4 + 8] = Null;

84201b56 <Lc_aanc_process_event_clear_condition_6>:
                   is correct.
                */
            case AANC_EVENT_DETECTED:
                /* Have detected but not sent message so clear */
                aanc_clear_event(p_event);
                break;
84201b56:	f1 48       	popm <FP, r4, rLink>;
84201b58:	d8 4c       	rts;

84201b5a <Lc_aanc_initialize_events_1>:
 * \param  p_ext_data  Address of the AANC extra_op_data.
 *
 * \return  void.
 */
static void aanc_initialize_events(OPERATOR_DATA *op_data, AANC_OP_DATA *p_ext_data)
{
84201b5a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201b5c:	17 00       	r5 = r0 + Null;
84201b5e:	1e 00       	r4 = r1 + Null;
    AANC_PARAMETERS *p_params = &p_ext_data->aanc_cap_params;
84201b60:	68 f0 3c 20 	r6 = r4 + 60;
    unsigned set_frames;

    set_frames = (p_params->OFFSET_EVENT_GAIN_STUCK * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201b64:	81 f0 47 88 	rMAC = M[r6 + 284];
84201b68:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201b6c:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Gain Event Initialized at %u frames", set_frames);
84201b70:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201b74:	08 25       	Null = rMAC - 4;
84201b76:	08 68       	if LT jump (m) Lc_aanc_initialize_events_3;

84201b78 <Lc_aanc_initialize_events_2>:
84201b78:	55 f1 02 f0 	r0 = Null + 357564500;
84201b7c:	54 40 
84201b7e:	4b 08       	r1 = r7 + Null;
84201b80:	ef fd fa ff 	call (m) 0x10c2;
84201b84:	23 ea 

84201b86 <Lc_aanc_initialize_events_3>:
    p_ext_data->gain_event.set_frames = set_frames;
84201b86:	69 f0 8a 8e 	M[r4 + 552] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->gain_event,
                                       AANC_EVENT_ID_GAIN, 0);
84201b8a:	63 f0 24 22 	r1 = r4 + 548;
84201b8e:	05 00       	r3 = Null + Null;
84201b90:	04 00       	r2 = Null + Null;
84201b92:	3a 00       	r0 = r5 + Null;
84201b94:	d3 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_ED_STUCK * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201b96:	81 f0 48 88 	rMAC = M[r6 + 288];
84201b9a:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201b9e:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC ED Event Initialized at %u frames", set_frames);
84201ba2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201ba6:	08 25       	Null = rMAC - 4;
84201ba8:	08 68       	if LT jump (m) Lc_aanc_initialize_events_5;

84201baa <Lc_aanc_initialize_events_4>:
84201baa:	55 f1 02 f0 	r0 = Null + 357564541;
84201bae:	7d 40 
84201bb0:	4b 08       	r1 = r7 + Null;
84201bb2:	ef fd fa ff 	call (m) 0x10c2;
84201bb6:	31 e8 

84201bb8 <Lc_aanc_initialize_events_5>:
    p_ext_data->ed_event.set_frames = set_frames;
84201bb8:	69 f0 8d 8e 	M[r4 + 564] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->ed_event,
                                       AANC_EVENT_ID_ED, 0);
84201bbc:	44 20       	r2 = Null + 1;
84201bbe:	63 f0 30 22 	r1 = r4 + 560;
84201bc2:	05 00       	r3 = Null + Null;
84201bc4:	3a 00       	r0 = r5 + Null;
84201bc6:	ba 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_QUIET_DETECT * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201bc8:	81 f0 49 88 	rMAC = M[r6 + 292];
84201bcc:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201bd0:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Quiet Mode Detect Initialized at %u frames", set_frames);
84201bd4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201bd8:	08 25       	Null = rMAC - 4;
84201bda:	08 68       	if LT jump (m) Lc_aanc_initialize_events_7;

84201bdc <Lc_aanc_initialize_events_6>:
84201bdc:	55 f1 02 f0 	r0 = Null + 357564580;
84201be0:	a4 40 
84201be2:	4b 08       	r1 = r7 + Null;
84201be4:	ef fd fa ff 	call (m) 0x10c2;
84201be8:	3f e6 

84201bea <Lc_aanc_initialize_events_7>:
    p_ext_data->quiet_event_detect.set_frames = set_frames;
84201bea:	69 f0 90 8e 	M[r4 + 576] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->quiet_event_detect,
                                       AANC_EVENT_ID_QUIET, 0);
84201bee:	84 20       	r2 = Null + 2;
84201bf0:	63 f0 3c 22 	r1 = r4 + 572;
84201bf4:	05 00       	r3 = Null + Null;
84201bf6:	3a 00       	r0 = r5 + Null;
84201bf8:	a1 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_QUIET_CLEAR * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201bfa:	81 f0 4a 88 	rMAC = M[r6 + 296];
84201bfe:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201c02:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Quiet Mode Cleared Initialized at %u frames", set_frames);
84201c06:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201c0a:	08 25       	Null = rMAC - 4;
84201c0c:	08 68       	if LT jump (m) Lc_aanc_initialize_events_9;

84201c0e <Lc_aanc_initialize_events_8>:
84201c0e:	55 f1 02 f0 	r0 = Null + 357564628;
84201c12:	d4 40 
84201c14:	4b 08       	r1 = r7 + Null;
84201c16:	ef fd fa ff 	call (m) 0x10c2;
84201c1a:	2d e5 

84201c1c <Lc_aanc_initialize_events_9>:
    p_ext_data->quiet_event_clear.set_frames = set_frames;
84201c1c:	69 f0 93 8e 	M[r4 + 588] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->quiet_event_clear,
                                       AANC_EVENT_ID_QUIET, 0);
84201c20:	84 20       	r2 = Null + 2;
84201c22:	63 f0 48 22 	r1 = r4 + 584;
84201c26:	05 00       	r3 = Null + Null;
84201c28:	3a 00       	r0 = r5 + Null;
84201c2a:	88 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_CLIP_STUCK * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201c2c:	81 f0 4b 88 	rMAC = M[r6 + 300];
84201c30:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201c34:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Clip Event Initialized at %u frames", set_frames);
84201c38:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201c3c:	08 25       	Null = rMAC - 4;
84201c3e:	08 68       	if LT jump (m) Lc_aanc_initialize_events_11;

84201c40 <Lc_aanc_initialize_events_10>:
84201c40:	55 f1 02 f0 	r0 = Null + 357564677;
84201c44:	05 41 
84201c46:	4b 08       	r1 = r7 + Null;
84201c48:	ef fd fa ff 	call (m) 0x10c2;
84201c4c:	3b e3 

84201c4e <Lc_aanc_initialize_events_11>:
    p_ext_data->clip_event.set_frames = set_frames;
84201c4e:	69 f0 96 8e 	M[r4 + 600] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->clip_event,
                                       AANC_EVENT_ID_CLIP, 0);
84201c52:	c4 20       	r2 = Null + 3;
84201c54:	63 f0 54 22 	r1 = r4 + 596;
84201c58:	05 00       	r3 = Null + Null;
84201c5a:	3a 00       	r0 = r5 + Null;
84201c5c:	6f 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_SAT_STUCK * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201c5e:	81 f0 4c 88 	rMAC = M[r6 + 304];
84201c62:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201c66:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Saturation Event Initialized at %u frames", set_frames);
84201c6a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201c6e:	08 25       	Null = rMAC - 4;
84201c70:	08 68       	if LT jump (m) Lc_aanc_initialize_events_13;

84201c72 <Lc_aanc_initialize_events_12>:
84201c72:	55 f1 02 f0 	r0 = Null + 357564718;
84201c76:	2e 41 
84201c78:	4b 08       	r1 = r7 + Null;
84201c7a:	ef fd fa ff 	call (m) 0x10c2;
84201c7e:	29 e2 

84201c80 <Lc_aanc_initialize_events_13>:
    p_ext_data->sat_event.set_frames = set_frames;
84201c80:	69 f0 99 8e 	M[r4 + 612] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->sat_event,
                                       AANC_EVENT_ID_SAT, 0);
84201c84:	04 21       	r2 = Null + 4;
84201c86:	63 f0 60 22 	r1 = r4 + 608;
84201c8a:	05 00       	r3 = Null + Null;
84201c8c:	3a 00       	r0 = r5 + Null;
84201c8e:	56 4f       	call (m) Lc_aanc_process_event_clear_condition_1;

    set_frames = (p_params->OFFSET_EVENT_SELF_TALK * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201c90:	81 f0 4d 88 	rMAC = M[r6 + 308];
84201c94:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201c98:	76 f2 d9 c8 	r7 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC Self-Talk Event Initialized at %u frames", set_frames);
84201c9c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201ca0:	08 25       	Null = rMAC - 4;
84201ca2:	08 68       	if LT jump (m) Lc_aanc_initialize_events_15;

84201ca4 <Lc_aanc_initialize_events_14>:
84201ca4:	55 f1 02 f0 	r0 = Null + 357564765;
84201ca8:	5d 41 
84201caa:	4b 08       	r1 = r7 + Null;
84201cac:	ef fd fa ff 	call (m) 0x10c2;
84201cb0:	37 e0 

84201cb2 <Lc_aanc_initialize_events_15>:
    p_ext_data->self_talk_event.set_frames = set_frames;
84201cb2:	69 f0 9c 8e 	M[r4 + 624] = r7;
    aanc_process_event_clear_condition(op_data, &p_ext_data->self_talk_event,
                                       AANC_EVENT_ID_SELF_TALK, 0);
84201cb6:	44 21       	r2 = Null + 5;
84201cb8:	63 f0 6c 22 	r1 = r4 + 620;
84201cbc:	05 00       	r3 = Null + Null;
84201cbe:	3a 00       	r0 = r5 + Null;
84201cc0:	3d 4f       	call (m) Lc_aanc_process_event_clear_condition_1;
    set_frames = (p_params->OFFSET_EVENT_SPL * AANC_FRAME_RATE)
                                                         >> TIMER_PARAM_SHIFT;
84201cc2:	81 f0 52 88 	rMAC = M[r6 + 328];
84201cc6:	7d f1 92 c9 	r0 = rMAC * 250 (int);
84201cca:	76 f2 d8 c8 	r6 = r0 LSHIFT -20;
    L4_DBG_MSG1("AANC SPL Event Initialized at %u frames", set_frames);
84201cce:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201cd2:	08 25       	Null = rMAC - 4;
84201cd4:	08 68       	if LT jump (m) Lc_aanc_initialize_events_17;

84201cd6 <Lc_aanc_initialize_events_16>:
84201cd6:	55 f1 02 f0 	r0 = Null + 357564811;
84201cda:	8b 41 
84201cdc:	43 08       	r1 = r6 + Null;
84201cde:	ef fd f9 ff 	call (m) 0x10c2;
84201ce2:	25 ef 

84201ce4 <Lc_aanc_initialize_events_17>:
    p_ext_data->spl_event.set_frames = set_frames;
84201ce4:	68 f0 9f 8e 	M[r4 + 636] = r6;
    aanc_process_event_clear_condition(op_data, &p_ext_data->spl_event,
                                       AANC_EVENT_ID_SPL, 0);
84201ce8:	84 21       	r2 = Null + 6;
84201cea:	63 f0 78 22 	r1 = r4 + 632;
84201cee:	05 00       	r3 = Null + Null;
84201cf0:	3a 00       	r0 = r5 + Null;
84201cf2:	24 4f       	call (m) Lc_aanc_process_event_clear_condition_1;
    set_frames = 1;
    L4_DBG_MSG1("AANC Gentle Mute Event Initialized at %u frames", set_frames);
84201cf4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201cf8:	08 25       	Null = rMAC - 4;
84201cfa:	08 68       	if LT jump (m) Lc_aanc_initialize_events_19;

84201cfc <Lc_aanc_initialize_events_18>:
84201cfc:	43 20       	r1 = Null + 1;
84201cfe:	55 f1 02 f0 	r0 = Null + 357564851;
84201d02:	b3 41 
84201d04:	ef fd f9 ff 	call (m) 0x10c2;
84201d08:	3f ed 

84201d0a <Lc_aanc_initialize_events_19>:
    p_ext_data->gentle_mute_event.set_frames = set_frames;
84201d0a:	41 20       	rMAC = Null + 1;
84201d0c:	61 f0 a2 8e 	M[r4 + 648] = rMAC;
    aanc_clear_event(&p_ext_data->gentle_mute_event);
84201d10:	61 f0 84 22 	rMAC = r4 + 644;
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201d14:	4a 88       	r0 = M[rMAC + 4];
84201d16:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC_EVENT_CLEAR;
84201d18:	08 9a       	MB[rMAC + 8] = Null;
    set_frames = 1;
    L4_DBG_MSG1("AANC Gentle Mute Event Initialized at %u frames", set_frames);
    p_ext_data->gentle_mute_event.set_frames = set_frames;
    aanc_clear_event(&p_ext_data->gentle_mute_event);

    p_ext_data->prev_flags = 0;
84201d1a:	60 f0 6c 8e 	M[r4 + 432] = Null;

84201d1e <Lc_aanc_initialize_events_20>:
}
84201d1e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201d20:	d8 4c       	rts;

84201d22 <Lc_aanc_process_event_detect_condition_1>:
 * \return  void.
 */
static void aanc_process_event_detect_condition(OPERATOR_DATA *op_data,
                                                AANC_EVENT *p_event,
                                                uint16 id, uint16 payload)
{
84201d22:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201d24:	1e 00       	r4 = r1 + Null;
    switch (p_event->running)
84201d26:	31 90       	rMAC = MBS[r4 + 8];
84201d28:	08 60       	if EQ jump (m) Lc_aanc_process_event_detect_condition_5;

84201d2a <Lc_aanc_process_event_detect_condition_2>:
84201d2a:	48 24       	Null = rMAC - 1;
84201d2c:	11 62       	if NE jump (m) Lc_aanc_process_event_detect_condition_7;

84201d2e <Lc_aanc_process_event_detect_condition_3>:
        case AANC_EVENT_CLEAR:
            p_event->frame_counter -= 1;
            p_event->running = AANC_EVENT_DETECTED;
            break;
        case AANC_EVENT_DETECTED:
            if (p_event->frame_counter > 0)
84201d2e:	31 e8       	rMAC = M[r4 + Null];
84201d30:	0a 60       	if EQ jump (m) Lc_aanc_process_event_detect_condition_6;

84201d32 <Lc_aanc_process_event_detect_condition_4>:
            {
                p_event->frame_counter -= 1;
84201d32:	49 24       	rMAC = rMAC - 1;
84201d34:	31 ee       	M[r4 + Null] = rMAC;
84201d36:	0c 6e       	jump (m) Lc_aanc_process_event_detect_condition_7;

84201d38 <Lc_aanc_process_event_detect_condition_5>:
                                                uint16 id, uint16 payload)
{
    switch (p_event->running)
    {
        case AANC_EVENT_CLEAR:
            p_event->frame_counter -= 1;
84201d38:	ff f6 11 d1 	rMAC = M[r4] + -1;
84201d3c:	31 ee       	M[r4 + Null] = rMAC;
            p_event->running = AANC_EVENT_DETECTED;
84201d3e:	41 20       	rMAC = Null + 1;
84201d40:	31 9a       	MB[r4 + 8] = rMAC;
            break;
84201d42:	06 6e       	jump (m) Lc_aanc_process_event_detect_condition_7;

84201d44 <Lc_aanc_process_event_detect_condition_6>:
            {
                p_event->frame_counter -= 1;
            }
            else
            {
                aanc_send_event_trigger(op_data, TRUE, id, payload);
84201d44:	43 20       	r1 = Null + 1;
84201d46:	fe ff 27 ec 	call (m) Lc_aanc_send_event_trigger_1;
                p_event->running = AANC_EVENT_SENT;
84201d4a:	81 20       	rMAC = Null + 2;
84201d4c:	31 9a       	MB[r4 + 8] = rMAC;

84201d4e <Lc_aanc_process_event_detect_condition_7>:
            }
            break;
        case AANC_EVENT_SENT:
            break;
    }
}
84201d4e:	f1 48       	popm <FP, r4, rLink>;
84201d50:	d8 4c       	rts;

84201d52 <Lc_aanc_process_events_1>:
 *
 * \return  boolean indicating success or failure.
 */
static bool aanc_process_events(OPERATOR_DATA *op_data,
                                AANC_OP_DATA *p_ext_data)
{
84201d52:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201d54:	10 09       	r6 = r0 + Null;
84201d56:	1e 00       	r4 = r1 + Null;
    bool cur_clip, prev_clip;
    bool cur_sat, prev_sat;
    int cur_ext, cur_int, delta_ext;

    /* Adaptive gain event: reset if ED detected */
    if (p_ext_data->flags & AANC_ED_FLAG_MASK)
84201d58:	61 f0 6b 88 	rMAC = M[r4 + 428];
84201d5c:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84201d60:	10 60       	if EQ jump (m) Lc_aanc_process_events_5;

84201d62 <Lc_aanc_process_events_2>:
    {
        /* If we had previously sent a message then send the negative trigger */
        if (p_ext_data->gain_event.running == AANC_EVENT_SENT)
84201d62:	61 f0 2c 90 	rMAC = MBS[r4 + 556];
84201d66:	88 24       	Null = rMAC - 2;
84201d68:	06 62       	if NE jump (m) Lc_aanc_process_events_4;

84201d6a <Lc_aanc_process_events_3>:
        {
            aanc_send_event_trigger(op_data, FALSE, AANC_EVENT_ID_GAIN, 0);
84201d6a:	05 00       	r3 = Null + Null;
84201d6c:	04 00       	r2 = Null + Null;
84201d6e:	03 00       	r1 = Null + Null;
84201d70:	fe ff 3d ea 	call (m) Lc_aanc_send_event_trigger_1;

84201d74 <Lc_aanc_process_events_4>:
        }
        aanc_clear_event(&p_ext_data->gain_event);
84201d74:	61 f0 24 22 	rMAC = r4 + 548;
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201d78:	4a 88       	r0 = M[rMAC + 4];
84201d7a:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC_EVENT_CLEAR;
84201d7c:	08 9a       	MB[rMAC + 8] = Null;
84201d7e:	11 6e       	jump (m) Lc_aanc_process_events_8;

84201d80 <Lc_aanc_process_events_5>:
            aanc_send_event_trigger(op_data, FALSE, AANC_EVENT_ID_GAIN, 0);
        }
        aanc_clear_event(&p_ext_data->gain_event);
    }
    /* Condition holds */
    else if (p_ext_data->ff_gain.fine == p_ext_data->ff_gain_prev.fine)
84201d80:	65 f0 e1 86 	r3 = MHU[r4 + 450];
84201d84:	61 f0 eb 86 	rMAC = MHU[r4 + 470];
84201d88:	68 04       	Null = r3 - rMAC;
84201d8a:	06 62       	if NE jump (m) Lc_aanc_process_events_7;

84201d8c <Lc_aanc_process_events_6>:
    {
        aanc_process_event_detect_condition(op_data, &p_ext_data->gain_event,
                                            AANC_EVENT_ID_GAIN,
                                            p_ext_data->ff_gain.fine);
84201d8c:	63 f0 24 22 	r1 = r4 + 548;
84201d90:	04 00       	r2 = Null + Null;
84201d92:	c8 4f       	call (m) Lc_aanc_process_event_detect_condition_1;
84201d94:	06 6e       	jump (m) Lc_aanc_process_events_8;

84201d96 <Lc_aanc_process_events_7>:
    /* Condition cleared */
    else
    {
        aanc_process_event_clear_condition(op_data, &p_ext_data->gain_event,
                                           AANC_EVENT_ID_GAIN,
                                           p_ext_data->ff_gain.fine);
84201d96:	63 f0 24 22 	r1 = r4 + 548;
84201d9a:	04 00       	r2 = Null + Null;
84201d9c:	fe ff 3f ec 	call (m) Lc_aanc_process_event_clear_condition_1;

84201da0 <Lc_aanc_process_events_8>:
    }

    /* ED event */
    cur_ed = p_ext_data->flags & AANC_ED_FLAG_MASK;
84201da0:	61 f0 6b 88 	rMAC = M[r4 + 428];
84201da4:	15 f0 70 00 	r3 = rMAC AND 0x70;
    prev_ed = p_ext_data->prev_flags & AANC_ED_FLAG_MASK;
84201da8:	61 f0 6c 88 	rMAC = M[r4 + 432];
84201dac:	11 f0 70 00 	rMAC = rMAC AND 0x70;
    if (cur_ed)
84201db0:	28 04       	Null = r3 - Null;
84201db2:	09 60       	if EQ jump (m) Lc_aanc_process_events_11;

84201db4 <Lc_aanc_process_events_9>:
    {
        /* Non-zero flags and no change starts/continues event */
        if (cur_ed == prev_ed)
84201db4:	68 04       	Null = r3 - rMAC;
84201db6:	10 62       	if NE jump (m) Lc_aanc_process_events_13;

84201db8 <Lc_aanc_process_events_10>:
        {
            aanc_process_event_detect_condition(op_data, &p_ext_data->ed_event,
                                                AANC_EVENT_ID_ED,
                                                (uint16)cur_ed);
84201db8:	44 20       	r2 = Null + 1;
84201dba:	63 f0 30 22 	r1 = r4 + 560;
84201dbe:	42 08       	r0 = r6 + Null;
84201dc0:	b1 4f       	call (m) Lc_aanc_process_event_detect_condition_1;
84201dc2:	0a 6e       	jump (m) Lc_aanc_process_events_13;

84201dc4 <Lc_aanc_process_events_11>:
        }
    }
    else
    {
        /* Flags reset causes event to be reset */
        if (cur_ed != prev_ed)
84201dc4:	08 04       	Null = rMAC - Null;
84201dc6:	08 60       	if EQ jump (m) Lc_aanc_process_events_13;

84201dc8 <Lc_aanc_process_events_12>:
        {
            aanc_process_event_clear_condition(op_data, &p_ext_data->ed_event,
                                               AANC_EVENT_ID_ED,
                                               (uint16)cur_ed);
84201dc8:	44 20       	r2 = Null + 1;
84201dca:	63 f0 30 22 	r1 = r4 + 560;
84201dce:	05 00       	r3 = Null + Null;
84201dd0:	42 08       	r0 = r6 + Null;
84201dd2:	fe ff 29 eb 	call (m) Lc_aanc_process_event_clear_condition_1;

84201dd6 <Lc_aanc_process_events_13>:
        }
    }

    /* Quiet mode has positive and negative triggers */
    cur_qm = p_ext_data->flags & AANC_FLAGS_QUIET_MODE;
84201dd6:	61 f0 6b 88 	rMAC = M[r4 + 428];
    prev_qm = p_ext_data->prev_flags & AANC_FLAGS_QUIET_MODE;
84201dda:	62 f0 6c 88 	r0 = M[r4 + 432];
84201dde:	08 f0 22 f0 	r0 = r0 AND 0x100000;
84201de2:	00 00 

    if (cur_qm)
84201de4:	08 f0 11 f0 	rMAC = rMAC AND 0x100000;
84201de8:	00 00 
84201dea:	25 60       	if EQ jump (m) Lc_aanc_process_events_19;

84201dec <Lc_aanc_process_events_14>:
    {
        if (prev_qm) /* Steady state for quiet mode detect event */
84201dec:	10 04       	Null = r0 - Null;
84201dee:	15 60       	if EQ jump (m) Lc_aanc_process_events_18;

84201df0 <Lc_aanc_process_events_15>:
        {
            if (p_ext_data->quiet_event_detect.running == AANC_EVENT_DETECTED)
84201df0:	61 f0 44 90 	rMAC = MBS[r4 + 580];
84201df4:	48 24       	Null = rMAC - 1;
84201df6:	42 62       	if NE jump (m) Lc_aanc_process_events_24;

84201df8 <Lc_aanc_process_events_16>:
            {
                p_ext_data->quiet_event_detect.frame_counter -= 1;
84201df8:	61 f0 8f 88 	rMAC = M[r4 + 572];
84201dfc:	49 24       	rMAC = rMAC - 1;
                if (p_ext_data->quiet_event_detect.frame_counter <= 0)
84201dfe:	61 f0 8f 8e 	M[r4 + 572] = rMAC;
84201e02:	3c 62       	if NE jump (m) Lc_aanc_process_events_24;

84201e04 <Lc_aanc_process_events_17>:
                {
                    aanc_send_event_trigger(op_data, TRUE,
                                            AANC_EVENT_ID_QUIET, 0);
84201e04:	84 20       	r2 = Null + 2;
84201e06:	43 20       	r1 = Null + 1;
84201e08:	05 00       	r3 = Null + Null;
84201e0a:	42 08       	r0 = r6 + Null;
84201e0c:	fe ff 21 e6 	call (m) Lc_aanc_send_event_trigger_1;
                    p_ext_data->quiet_event_detect.running = AANC_EVENT_SENT;
84201e10:	81 20       	rMAC = Null + 2;
84201e12:	61 f0 44 9a 	MB[r4 + 580] = rMAC;
84201e16:	32 6e       	jump (m) Lc_aanc_process_events_24;

84201e18 <Lc_aanc_process_events_18>:
                }
            }
        }
        else /* Rising edge for quiet mode detect event */
        {
            p_ext_data->quiet_event_detect.frame_counter -= 1;
84201e18:	61 f0 8f 88 	rMAC = M[r4 + 572];
84201e1c:	49 24       	rMAC = rMAC - 1;
84201e1e:	61 f0 8f 8e 	M[r4 + 572] = rMAC;
            p_ext_data->quiet_event_detect.running = AANC_EVENT_DETECTED;
84201e22:	41 20       	rMAC = Null + 1;
84201e24:	61 f0 44 9a 	MB[r4 + 580] = rMAC;
            aanc_clear_event(&p_ext_data->quiet_event_clear);
84201e28:	61 f0 48 22 	rMAC = r4 + 584;
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201e2c:	4a 88       	r0 = M[rMAC + 4];
84201e2e:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC_EVENT_CLEAR;
84201e30:	08 9a       	MB[rMAC + 8] = Null;
84201e32:	24 6e       	jump (m) Lc_aanc_process_events_24;

84201e34 <Lc_aanc_process_events_19>:
            aanc_clear_event(&p_ext_data->quiet_event_clear);
        }
    }
    else
    {
        if (prev_qm) /* Falling edge for quiet mode clear event */
84201e34:	10 04       	Null = r0 - Null;
84201e36:	0f 60       	if EQ jump (m) Lc_aanc_process_events_21;

84201e38 <Lc_aanc_process_events_20>:
        {
            p_ext_data->quiet_event_clear.frame_counter -= 1;
84201e38:	61 f0 92 88 	rMAC = M[r4 + 584];
84201e3c:	49 24       	rMAC = rMAC - 1;
84201e3e:	61 f0 92 8e 	M[r4 + 584] = rMAC;
            p_ext_data->quiet_event_clear.running = AANC_EVENT_DETECTED;
84201e42:	41 20       	rMAC = Null + 1;
84201e44:	61 f0 50 9a 	MB[r4 + 592] = rMAC;
            aanc_clear_event(&p_ext_data->quiet_event_detect);
84201e48:	61 f0 3c 22 	rMAC = r4 + 572;
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201e4c:	4a 88       	r0 = M[rMAC + 4];
84201e4e:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC_EVENT_CLEAR;
84201e50:	08 9a       	MB[rMAC + 8] = Null;
84201e52:	14 6e       	jump (m) Lc_aanc_process_events_24;

84201e54 <Lc_aanc_process_events_21>:
            p_ext_data->quiet_event_clear.running = AANC_EVENT_DETECTED;
            aanc_clear_event(&p_ext_data->quiet_event_detect);
        }
        else /* Steady state for quite mode clear event */
        {
            if (p_ext_data->quiet_event_clear.running == AANC_EVENT_DETECTED)
84201e54:	61 f0 50 90 	rMAC = MBS[r4 + 592];
84201e58:	48 24       	Null = rMAC - 1;
84201e5a:	10 62       	if NE jump (m) Lc_aanc_process_events_24;

84201e5c <Lc_aanc_process_events_22>:
            {
                p_ext_data->quiet_event_clear.frame_counter -= 1;
84201e5c:	61 f0 92 88 	rMAC = M[r4 + 584];
84201e60:	49 24       	rMAC = rMAC - 1;
                if (p_ext_data->quiet_event_clear.frame_counter <= 0)
84201e62:	61 f0 92 8e 	M[r4 + 584] = rMAC;
84201e66:	0a 62       	if NE jump (m) Lc_aanc_process_events_24;

84201e68 <Lc_aanc_process_events_23>:
                {
                    aanc_send_event_trigger(op_data, FALSE,
                                            AANC_EVENT_ID_QUIET, 0);
84201e68:	84 20       	r2 = Null + 2;
84201e6a:	05 00       	r3 = Null + Null;
84201e6c:	03 00       	r1 = Null + Null;
84201e6e:	42 08       	r0 = r6 + Null;
84201e70:	fe ff 3d e2 	call (m) Lc_aanc_send_event_trigger_1;
                    p_ext_data->quiet_event_clear.running = AANC_EVENT_SENT;
84201e74:	81 20       	rMAC = Null + 2;
84201e76:	61 f0 50 9a 	MB[r4 + 592] = rMAC;

84201e7a <Lc_aanc_process_events_24>:
            }
        }
    }

    /* Clipping event */
    cur_clip = p_ext_data->flags & AANC_CLIPPING_FLAG_MASK;
84201e7a:	61 f0 6b 88 	rMAC = M[r4 + 428];
84201e7e:	15 f0 00 07 	r3 = rMAC AND 0x700;
    prev_clip = p_ext_data->prev_flags & AANC_CLIPPING_FLAG_MASK;
84201e82:	61 f0 6c 88 	rMAC = M[r4 + 432];
84201e86:	11 f0 00 07 	rMAC = rMAC AND 0x700;
    if (cur_clip)
84201e8a:	28 04       	Null = r3 - Null;
84201e8c:	09 60       	if EQ jump (m) Lc_aanc_process_events_27;

84201e8e <Lc_aanc_process_events_25>:
    {
        /* Non-zero flags and no change starts/continues event */
        if (cur_clip == prev_clip)
84201e8e:	68 04       	Null = r3 - rMAC;
84201e90:	10 62       	if NE jump (m) Lc_aanc_process_events_29;

84201e92 <Lc_aanc_process_events_26>:
        {
            aanc_process_event_detect_condition(op_data,
                                                &p_ext_data->clip_event,
                                                AANC_EVENT_ID_CLIP,
                                                (uint16)cur_clip);
84201e92:	c4 20       	r2 = Null + 3;
84201e94:	63 f0 54 22 	r1 = r4 + 596;
84201e98:	42 08       	r0 = r6 + Null;
84201e9a:	44 4f       	call (m) Lc_aanc_process_event_detect_condition_1;
84201e9c:	0a 6e       	jump (m) Lc_aanc_process_events_29;

84201e9e <Lc_aanc_process_events_27>:
        }
    }
    else
    {
        /* Flags reset causes event to be reset */
        if (cur_clip != prev_clip)
84201e9e:	08 04       	Null = rMAC - Null;
84201ea0:	08 60       	if EQ jump (m) Lc_aanc_process_events_29;

84201ea2 <Lc_aanc_process_events_28>:
        {
            aanc_process_event_clear_condition(op_data, &p_ext_data->clip_event,
                                               AANC_EVENT_ID_CLIP,
                                               (uint16)cur_clip);
84201ea2:	c4 20       	r2 = Null + 3;
84201ea4:	63 f0 54 22 	r1 = r4 + 596;
84201ea8:	05 00       	r3 = Null + Null;
84201eaa:	42 08       	r0 = r6 + Null;
84201eac:	fe ff 2f e4 	call (m) Lc_aanc_process_event_clear_condition_1;

84201eb0 <Lc_aanc_process_events_29>:
        }
    }

    /* Saturation event */
    cur_sat = p_ext_data->flags & AANC_SATURATION_FLAG_MASK;
84201eb0:	61 f0 6b 88 	rMAC = M[r4 + 428];
84201eb4:	15 f7 00 10 	r3 = rMAC AND 0xf000;
    prev_sat = p_ext_data->prev_flags & AANC_SATURATION_FLAG_MASK;
84201eb8:	61 f0 6c 88 	rMAC = M[r4 + 432];
84201ebc:	11 f7 00 10 	rMAC = rMAC AND 0xf000;
    if (cur_sat)
84201ec0:	28 04       	Null = r3 - Null;
84201ec2:	09 60       	if EQ jump (m) Lc_aanc_process_events_32;

84201ec4 <Lc_aanc_process_events_30>:
    {
        /* Non-zero flags and no change starts/continues event */
        if (cur_sat == prev_sat)
84201ec4:	68 04       	Null = r3 - rMAC;
84201ec6:	10 62       	if NE jump (m) Lc_aanc_process_events_34;

84201ec8 <Lc_aanc_process_events_31>:
        {
            aanc_process_event_detect_condition(op_data, &p_ext_data->sat_event,
                                                AANC_EVENT_ID_SAT,
                                                (uint16)cur_sat);
84201ec8:	04 21       	r2 = Null + 4;
84201eca:	63 f0 60 22 	r1 = r4 + 608;
84201ece:	42 08       	r0 = r6 + Null;
84201ed0:	29 4f       	call (m) Lc_aanc_process_event_detect_condition_1;
84201ed2:	0a 6e       	jump (m) Lc_aanc_process_events_34;

84201ed4 <Lc_aanc_process_events_32>:
        }
    }
    else
    {
        /* Flags reset causes event to be reset */
        if (cur_sat != prev_sat)
84201ed4:	08 04       	Null = rMAC - Null;
84201ed6:	08 60       	if EQ jump (m) Lc_aanc_process_events_34;

84201ed8 <Lc_aanc_process_events_33>:
        {
            aanc_process_event_clear_condition(op_data, &p_ext_data->sat_event,
                                               AANC_EVENT_ID_SAT,
                                               (uint16)cur_sat);
84201ed8:	04 21       	r2 = Null + 4;
84201eda:	63 f0 60 22 	r1 = r4 + 608;
84201ede:	05 00       	r3 = Null + Null;
84201ee0:	42 08       	r0 = r6 + Null;
84201ee2:	fe ff 39 e2 	call (m) Lc_aanc_process_event_clear_condition_1;

84201ee6 <Lc_aanc_process_events_34>:
        }
    }

    /* Self-talk event */
    cur_ext = p_ext_data->ag->p_ed_ext->spl;
84201ee6:	61 f0 6f 88 	rMAC = M[r4 + 444];
84201eea:	4a 98       	r0 = M[rMAC + 36];
84201eec:	57 a8       	r5 = M[r0 + 68];
    cur_int = p_ext_data->ag->p_ed_int->spl;
84201eee:	49 89       	rMAC = M[rMAC + 20];
84201ef0:	49 a8       	rMAC = M[rMAC + 68];
    delta_ext = cur_int - cur_ext;
84201ef2:	ca 05       	r0 = rMAC - r5;
    if (delta_ext > 0)
84201ef4:	10 24       	Null = r0 - 0;
84201ef6:	08 6c       	if LE jump (m) Lc_aanc_process_events_36;

84201ef8 <Lc_aanc_process_events_35>:
    {
        aanc_process_event_detect_condition(op_data,
                                            &p_ext_data->self_talk_event,
                                            AANC_EVENT_ID_SELF_TALK,
                                            (uint16)(delta_ext >> 16));
84201ef8:	95 5a       	r3 = r0 ASHIFT -16;
84201efa:	44 21       	r2 = Null + 5;
84201efc:	63 f0 6c 22 	r1 = r4 + 620;
84201f00:	42 08       	r0 = r6 + Null;
84201f02:	10 4f       	call (m) Lc_aanc_process_event_detect_condition_1;
84201f04:	09 6e       	jump (m) Lc_aanc_process_events_37;

84201f06 <Lc_aanc_process_events_36>:
    else
    {
        aanc_process_event_clear_condition(op_data,
                                           &p_ext_data->self_talk_event,
                                           AANC_EVENT_ID_SELF_TALK,
                                           (uint16)(delta_ext >> 16));
84201f06:	92 5a       	r0 = r0 ASHIFT -16;
84201f08:	44 21       	r2 = Null + 5;
84201f0a:	63 f0 6c 22 	r1 = r4 + 620;
84201f0e:	95 c6       	r3 = r0 AND 0xffff;
84201f10:	42 08       	r0 = r6 + Null;
84201f12:	fe ff 29 e1 	call (m) Lc_aanc_process_event_clear_condition_1;

84201f16 <Lc_aanc_process_events_37>:
    }

    /* SPL event */
    if (cur_ext > p_ext_data->aanc_cap_params.OFFSET_EVENT_SPL_THRESHOLD)
84201f16:	61 f0 62 88 	rMAC = M[r4 + 392];
84201f1a:	78 04       	Null = r5 - rMAC;
84201f1c:	09 f0 97 e0 	if LS jump (m) Lc_aanc_process_events_39;

84201f20 <Lc_aanc_process_events_38>:
    {
        aanc_process_event_detect_condition(op_data,
                                            &p_ext_data->spl_event,
                                            AANC_EVENT_ID_SPL,
                                            (uint16)(cur_ext >> 16));
84201f20:	ba 5a       	r0 = r5 ASHIFT -16;
84201f22:	84 21       	r2 = Null + 6;
84201f24:	63 f0 78 22 	r1 = r4 + 632;
84201f28:	95 c6       	r3 = r0 AND 0xffff;
84201f2a:	42 08       	r0 = r6 + Null;
84201f2c:	fe ff 37 ef 	call (m) Lc_aanc_process_event_detect_condition_1;
84201f30:	09 6e       	jump (m) Lc_aanc_process_events_40;

84201f32 <Lc_aanc_process_events_39>:
    else
    {
        aanc_process_event_clear_condition(op_data,
                                           &p_ext_data->spl_event,
                                           AANC_EVENT_ID_SPL,
                                           (uint16)(cur_ext >> 16));
84201f32:	ba 5a       	r0 = r5 ASHIFT -16;
84201f34:	84 21       	r2 = Null + 6;
84201f36:	63 f0 78 22 	r1 = r4 + 632;
84201f3a:	95 c6       	r3 = r0 AND 0xffff;
84201f3c:	42 08       	r0 = r6 + Null;
84201f3e:	fd ff 3d ef 	call (m) Lc_aanc_process_event_clear_condition_1;

84201f42 <Lc_aanc_process_events_40>:
    }

    /* Gentle mute event */
    if (p_ext_data->cur_mode == AANC_SYSMODE_GENTLE_MUTE ||
        p_ext_data->cur_mode == AANC_SYSMODE_QUIET)
84201f42:	61 f0 66 88 	rMAC = M[r4 + 408];
84201f46:	48 25       	Null = rMAC - 5;
84201f48:	03 60       	if EQ jump (m) Lc_aanc_process_events_42;

84201f4a <Lc_aanc_process_events_41>:
84201f4a:	88 25       	Null = rMAC - 6;
84201f4c:	10 62       	if NE jump (m) Lc_aanc_process_events_45;

84201f4e <Lc_aanc_process_events_42>:
    {
        if (p_ext_data->ff_gain.fine == 0)
84201f4e:	65 f0 e1 86 	r3 = MHU[r4 + 450];
84201f52:	08 62       	if NE jump (m) Lc_aanc_process_events_44;

84201f54 <Lc_aanc_process_events_43>:
        {
            aanc_process_event_detect_condition(op_data, &p_ext_data->gentle_mute_event,
                                                AANC_EVENT_ID_GENTLE_MUTE,
                                                p_ext_data->ff_gain.fine);
84201f54:	c4 21       	r2 = Null + 7;
84201f56:	63 f0 84 22 	r1 = r4 + 644;
84201f5a:	42 08       	r0 = r6 + Null;
84201f5c:	fe ff 27 ee 	call (m) Lc_aanc_process_event_detect_condition_1;
84201f60:	06 6e       	jump (m) Lc_aanc_process_events_45;

84201f62 <Lc_aanc_process_events_44>:
        }
        else
        {
            aanc_clear_event(&p_ext_data->gentle_mute_event);
84201f62:	61 f0 84 22 	rMAC = r4 + 644;
    return TRUE;
}

static inline void aanc_clear_event(AANC_EVENT *p_event)
{
       p_event->frame_counter =p_event->set_frames;
84201f66:	4a 88       	r0 = M[rMAC + 4];
84201f68:	0a ee       	M[rMAC + Null] = r0;
       p_event->running = AANC_EVENT_CLEAR;
84201f6a:	08 9a       	MB[rMAC + 8] = Null;

84201f6c <Lc_aanc_process_events_45>:
        {
            aanc_clear_event(&p_ext_data->gentle_mute_event);
        }
    }

    return TRUE;
84201f6c:	42 20       	r0 = Null + 1;

84201f6e <Lc_aanc_process_events_46>:
}
84201f6e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201f70:	d8 4c       	rts;

84201f72 <Lc_aanc_initialize_ramp_1>:
 */
static void aanc_initialize_ramp(AANC_RAMP *p_ramp,
                                 uint16 target,
                                 unsigned timer_param,
                                 unsigned delay_param)
{
84201f72:	71 1c       	pushm <FP(=SP), r4>;
    uint16 timer_duration, delay_duration;

    if (timer_param == 0 && delay_param == 0)
84201f74:	20 04       	Null = r2 - Null;
84201f76:	08 62       	if NE jump (m) Lc_aanc_initialize_ramp_4;

84201f78 <Lc_aanc_initialize_ramp_2>:
84201f78:	28 04       	Null = r3 - Null;
84201f7a:	06 62       	if NE jump (m) Lc_aanc_initialize_ramp_4;

84201f7c <Lc_aanc_initialize_ramp_3>:
    {
        *p_ramp->p_gain = target;
84201f7c:	11 89       	rMAC = M[r0 + 16];
84201f7e:	0b ec       	MH[rMAC + Null] = r1;
        p_ramp->state = AANC_RAMP_FINISHED;
84201f80:	c1 20       	rMAC = Null + 3;
84201f82:	11 9b       	MB[r0 + 12] = rMAC;
        return;
84201f84:	18 6e       	jump (m) Lc_aanc_initialize_ramp_5;

84201f86 <Lc_aanc_initialize_ramp_4>:
    }

    /* Calculate number of frames from timer parameter */
    timer_duration = (uint16) (
                        (timer_param * AANC_FRAME_RATE) >> 20);
84201f86:	7d f4 94 c9 	r2 = r2 * 250 (int);
84201f8a:	e4 52       	r2 = r2 LSHIFT -20;
    delay_duration = (uint16) (
                        (delay_param * AANC_FRAME_RATE) >> 20);
84201f8c:	7d f5 95 c9 	r3 = r3 * 250 (int);

    p_ramp->value = *p_ramp->p_gain << 16;
84201f90:	11 89       	rMAC = M[r0 + 16];
84201f92:	0e e6       	r4 = MHU[rMAC + Null];
84201f94:	b6 56       	r4 = r4 LSHIFT 16;
84201f96:	96 8e       	M[r0 + 8] = r4;
    p_ramp->target = target;
84201f98:	53 8c       	MH[r0 + 2] = r1;
    p_ramp->rate = ((target << 16) - p_ramp->value) / timer_duration;
84201f9a:	9b 56       	r1 = r1 LSHIFT 16;
84201f9c:	9b 05       	r1 = r1 - r4;
84201f9e:	a3 4c       	Div = r1 / r2;
84201fa0:	c1 4c       	rMAC = DivResult;
84201fa2:	51 8e       	M[r0 + 4] = rMAC;
    p_ramp->duration = timer_duration;
84201fa4:	14 ec       	MH[r0 + Null] = r2;
    if (delay_duration == 0)
    {
        p_ramp->state = AANC_RAMP_RUNNING;
84201fa6:	41 20       	rMAC = Null + 1;
84201fa8:	ed 52       	r3 = r3 LSHIFT -20;
84201faa:	a0 f0 41 ce 	if EQ rMAC = Null + 2;
84201fae:	11 9b       	MB[r0 + 12] = rMAC;
    }
    else
    {
        p_ramp->state = AANC_RAMP_WAITING;
    }
    p_ramp->frame_counter = (uint16)(p_ramp->duration + delay_duration);
84201fb0:	29 01       	rMAC = r3 + r2;
84201fb2:	11 9d       	MH[r0 + 24] = rMAC;

84201fb4 <Lc_aanc_initialize_ramp_5>:
}
84201fb4:	71 48       	popm <FP, r4>;
84201fb6:	d8 4c       	rts;

84201fb8 <Lc_aanc_process_ramp_1>:
 */
static void aanc_process_ramp(AANC_RAMP *p_ramp)
{
    unsigned rounded_gain;

    switch (p_ramp->state)
84201fb8:	11 91       	rMAC = MBS[r0 + 12];
84201fba:	11 60       	if EQ jump (m) Lc_aanc_process_ramp_6;

84201fbc <Lc_aanc_process_ramp_2>:
84201fbc:	48 24       	Null = rMAC - 1;
84201fbe:	11 60       	if EQ jump (m) Lc_aanc_process_ramp_7;

84201fc0 <Lc_aanc_process_ramp_3>:
84201fc0:	88 24       	Null = rMAC - 2;
84201fc2:	23 62       	if NE jump (m) Lc_aanc_process_ramp_10;

84201fc4 <Lc_aanc_process_ramp_4>:
            {
                p_ramp->state = AANC_RAMP_RUNNING;
            }
            break;
        case AANC_RAMP_RUNNING:
            p_ramp->frame_counter -= 1;
84201fc4:	11 95       	rMAC = MHS[r0 + 24];
84201fc6:	49 24       	rMAC = rMAC - 1;
84201fc8:	09 0c       	rMAC = SE16 rMAC;
84201fca:	11 9d       	MH[r0 + 24] = rMAC;
            if (p_ramp->frame_counter <= 0)
84201fcc:	08 24       	Null = rMAC - 0;
84201fce:	13 6a       	if GT jump (m) Lc_aanc_process_ramp_9;

84201fd0 <Lc_aanc_process_ramp_5>:
            {
                p_ramp->state = AANC_RAMP_FINISHED;
84201fd0:	c1 20       	rMAC = Null + 3;
84201fd2:	11 9b       	MB[r0 + 12] = rMAC;
                /* Make the ramp finishes */
                *p_ramp->p_gain = p_ramp->target;
84201fd4:	51 86       	rMAC = MHU[r0 + 2];
84201fd6:	12 89       	r0 = M[r0 + 16];
84201fd8:	11 ec       	MH[r0 + Null] = rMAC;
84201fda:	17 6e       	jump (m) Lc_aanc_process_ramp_10;

84201fdc <Lc_aanc_process_ramp_6>:
    unsigned rounded_gain;

    switch (p_ramp->state)
    {
        case AANC_RAMP_INITIALIZED:
            p_ramp->state = AANC_RAMP_WAITING;
84201fdc:	41 20       	rMAC = Null + 1;
84201fde:	11 9b       	MB[r0 + 12] = rMAC;

84201fe0 <Lc_aanc_process_ramp_7>:
        case AANC_RAMP_WAITING:
            p_ramp->frame_counter -= 1;
84201fe0:	11 95       	rMAC = MHS[r0 + 24];
84201fe2:	49 24       	rMAC = rMAC - 1;
84201fe4:	09 0c       	rMAC = SE16 rMAC;
84201fe6:	11 9d       	MH[r0 + 24] = rMAC;
            if (p_ramp->frame_counter <= p_ramp->duration)
84201fe8:	13 e6       	r1 = MHU[r0 + Null];
84201fea:	c8 04       	Null = rMAC - r1;
84201fec:	0e 6a       	if GT jump (m) Lc_aanc_process_ramp_10;

84201fee <Lc_aanc_process_ramp_8>:
            {
                p_ramp->state = AANC_RAMP_RUNNING;
84201fee:	81 20       	rMAC = Null + 2;
84201ff0:	11 9b       	MB[r0 + 12] = rMAC;
84201ff2:	0b 6e       	jump (m) Lc_aanc_process_ramp_10;

84201ff4 <Lc_aanc_process_ramp_9>:
                /* Make the ramp finishes */
                *p_ramp->p_gain = p_ramp->target;
            }
            else
            {
                p_ramp->value += p_ramp->rate;
84201ff4:	91 88       	rMAC = M[r0 + 8];
84201ff6:	53 88       	r1 = M[r0 + 4];
84201ff8:	59 00       	rMAC = r1 + rMAC;
84201ffa:	91 8e       	M[r0 + 8] = rMAC;
                rounded_gain = (p_ramp->value + (1 << 15)) >> 16;
84201ffc:	02 f0 13 f0 	r1 = rMAC + 32768;
84202000:	00 20 
84202002:	9b 5a       	r1 = r1 ASHIFT -16;
                *p_ramp->p_gain = (uint16)rounded_gain;
84202004:	11 89       	rMAC = M[r0 + 16];
84202006:	0b 8c       	MH[rMAC + 0] = r1;

84202008 <Lc_aanc_process_ramp_10>:
84202008:	d8 4c       	rts;

8420200a <$_AANC_GetDefaults>:
8420200a:	20 f0 c7 24 	Null = r0 - 199;
   0x0001999Au,			// FB_FINE_RAMP_UP_TIMER
   0x00000000u			// FB_FINE_RAMP_DELAY_TIMER
};

unsigned *AANC_GetDefaults(unsigned capid){
	switch(capid){
8420200e:	05 60       	if EQ jump (m) Lc_AANC_GetDefaults_3;

84202010 <Lc_AANC_GetDefaults_2>:
84202010:	01 f0 20 f0 	Null = r0 - 16543;
84202014:	9f 24 
84202016:	05 62       	if NE jump (m) Lc_AANC_GetDefaults_4;

84202018 <Lc_AANC_GetDefaults_3>:
		case 0x00C7: return defaults_aancAANC_MONO_16K;
84202018:	f1 ff 02 f3 	r0 = Null + -15335424;
8420201c:	00 40 
8420201e:	02 6e       	jump (m) Lc_AANC_GetDefaults_5;

84202020 <Lc_AANC_GetDefaults_4>:
		case 0x409F: return defaults_aancAANC_MONO_16K;
	}
	return((unsigned *)0);
84202020:	02 00       	r0 = Null + Null;

84202022 <Lc_AANC_GetDefaults_5>:
84202022:	d8 4c       	rts;

84202024 <$_aanc_proc_create>:
84202024:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
/******************************************************************************
Public Function Implementations
*/

bool aanc_proc_create(ADAPTIVE_GAIN **pp_ag, unsigned sample_rate)
{
84202026:	54 4c       	SP = SP + 80;
84202028:	42 de       	M[FP + 32] = r0;
8420202a:	4b de       	M[FP + 36] = r1;

    ADAPTIVE_GAIN *p_ag = xzpnew(ADAPTIVE_GAIN);
8420202c:	c3 20       	r1 = Null + 3;
8420202e:	02 f0 9c 40 	r0 = Null + 156;
84202032:	ff fd 27 f0 	call (m) 0x6f8e;
84202036:	3d ea 
84202038:	16 00       	r4 = r0 + Null;
    uint16 fxlms_dmx_words, fxlms_dm_words;
    uint16 ed_dmx_words, ed_dm1_words;
    FXLMS100_FILTER_COEFFS* coeffs;

    if (p_ag == NULL)
8420203a:	10 62       	if NE jump (m) Lc_aanc_proc_create_5;

8420203c <Lc_aanc_proc_create_2>:
    {
        *pp_ag = NULL;
8420203c:	41 d8       	rMAC = M[FP + 32];
8420203e:	08 ee       	M[rMAC + Null] = Null;
        L2_DBG_MSG("AANC_PROC failed to allocate adaptive gain");
84202040:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202044:	88 24       	Null = rMAC - 2;
84202046:	07 68       	if LT jump (m) Lc_aanc_proc_create_4;

84202048 <Lc_aanc_proc_create_3>:
84202048:	55 f1 02 f0 	r0 = Null + 357566445;
8420204c:	ed 4b 
8420204e:	ef fd f8 ff 	call (m) 0x10b0;
84202052:	23 e3 

84202054 <Lc_aanc_proc_create_4>:
        return FALSE;
84202054:	02 00       	r0 = Null + Null;
84202056:	0f f0 fb e5 	jump (m) Lc_aanc_proc_create_30;

8420205a <Lc_aanc_proc_create_5>:
    }

    *pp_ag = p_ag;
8420205a:	41 d8       	rMAC = M[FP + 32];
8420205c:	0e ee       	M[rMAC + Null] = r4;

    p_ag->p_aanc_reinit_flag = NULL;
8420205e:	30 ee       	M[r4 + Null] = Null;

    /* Allocate internal input cbuffer in DM1 */
    if (!aanc_proc_create_cbuffer(&p_ag->p_tmp_int_ip, MALLOC_PREFERENCE_DM1))
84202060:	43 20       	r1 = Null + 1;
84202062:	32 23       	r0 = r4 + 12;
84202064:	05 f0 27 e1 	call (m) Lc_aanc_proc_create_cbuffer_1;
84202068:	10 04       	Null = r0 - Null;
8420206a:	0f 62       	if NE jump (m) Lc_aanc_proc_create_8;

8420206c <Lc_aanc_proc_create_6>:
    {
        aanc_proc_destroy(pp_ag);
8420206c:	42 d8       	r0 = M[FP + 32];
8420206e:	01 f0 29 e7 	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate int mic input buffer");
84202072:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202076:	88 24       	Null = rMAC - 2;
84202078:	ee 69       	if LT jump (m) Lc_aanc_proc_create_4;

8420207a <Lc_aanc_proc_create_7>:
8420207a:	55 f1 02 f0 	r0 = Null + 357566488;
8420207e:	18 50 
84202080:	ef fd f8 ff 	call (m) 0x10b0;
84202084:	31 e1 
84202086:	e7 6f       	jump (m) Lc_aanc_proc_create_4;

84202088 <Lc_aanc_proc_create_8>:
        return FALSE;
    }

    /* Allocate external input cbuffer in DM2 */
    if (!aanc_proc_create_cbuffer(&p_ag->p_tmp_ext_ip, MALLOC_PREFERENCE_DM2))
84202088:	83 20       	r1 = Null + 2;
8420208a:	32 2b       	r0 = r4 + 28;
8420208c:	04 f0 3f ef 	call (m) Lc_aanc_proc_create_cbuffer_1;
84202090:	10 04       	Null = r0 - Null;
84202092:	0f 62       	if NE jump (m) Lc_aanc_proc_create_11;

84202094 <Lc_aanc_proc_create_9>:
    {
        aanc_proc_destroy(pp_ag);
84202094:	42 d8       	r0 = M[FP + 32];
84202096:	01 f0 21 e6 	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate ext mic input buffer");
8420209a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420209e:	88 24       	Null = rMAC - 2;
842020a0:	da 69       	if LT jump (m) Lc_aanc_proc_create_4;

842020a2 <Lc_aanc_proc_create_10>:
842020a2:	55 f1 02 f0 	r0 = Null + 357566538;
842020a6:	4a 50 
842020a8:	ef fd f8 ff 	call (m) 0x10b0;
842020ac:	29 e0 
842020ae:	d3 6f       	jump (m) Lc_aanc_proc_create_4;

842020b0 <Lc_aanc_proc_create_11>:
        return FALSE;
    }

    /* Allocate int mic output cbuffer in DM2 */
    if (!aanc_proc_create_cbuffer(&p_ag->p_tmp_int_op, MALLOC_PREFERENCE_DM2))
842020b0:	83 20       	r1 = Null + 2;
842020b2:	32 28       	r0 = r4 + 16;
842020b4:	04 f0 37 ee 	call (m) Lc_aanc_proc_create_cbuffer_1;
842020b8:	10 04       	Null = r0 - Null;
842020ba:	0f 62       	if NE jump (m) Lc_aanc_proc_create_14;

842020bc <Lc_aanc_proc_create_12>:
    {
        aanc_proc_destroy(pp_ag);
842020bc:	42 d8       	r0 = M[FP + 32];
842020be:	01 f0 39 e4 	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate int mic output buffer");
842020c2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842020c6:	88 24       	Null = rMAC - 2;
842020c8:	c6 69       	if LT jump (m) Lc_aanc_proc_create_4;

842020ca <Lc_aanc_proc_create_13>:
842020ca:	55 f1 02 f0 	r0 = Null + 357566588;
842020ce:	7c 50 
842020d0:	ef fd f7 ff 	call (m) 0x10b0;
842020d4:	21 ef 
842020d6:	bf 6f       	jump (m) Lc_aanc_proc_create_4;

842020d8 <Lc_aanc_proc_create_14>:
        return FALSE;
    }

    /* Allocate ext mic output cbuffer in DM2 */
    if (!aanc_proc_create_cbuffer(&p_ag->p_tmp_ext_op, MALLOC_PREFERENCE_DM2))
842020d8:	83 20       	r1 = Null + 2;
842020da:	32 30       	r0 = r4 + 32;
842020dc:	04 f0 2f ed 	call (m) Lc_aanc_proc_create_cbuffer_1;
842020e0:	10 04       	Null = r0 - Null;
842020e2:	0f 62       	if NE jump (m) Lc_aanc_proc_create_17;

842020e4 <Lc_aanc_proc_create_15>:
    {
        aanc_proc_destroy(pp_ag);
842020e4:	42 d8       	r0 = M[FP + 32];
842020e6:	01 f0 31 e3 	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate ext mic output buffer");
842020ea:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842020ee:	88 24       	Null = rMAC - 2;
842020f0:	b2 69       	if LT jump (m) Lc_aanc_proc_create_4;

842020f2 <Lc_aanc_proc_create_16>:
842020f2:	55 f1 02 f0 	r0 = Null + 357566639;
842020f6:	af 50 
842020f8:	ef fd f7 ff 	call (m) 0x10b0;
842020fc:	39 ed 
842020fe:	ab 6f       	jump (m) Lc_aanc_proc_create_4;

84202100 <Lc_aanc_proc_create_17>:
        return FALSE;
    }

    /* Create playback cbuffer without specific bank allocation */
    p_ag->p_tmp_pb_ip = cbuffer_create_with_malloc(AANC_INTERNAL_BUFFER_SIZE,
                                                   BUF_DESC_SW_BUFFER);
84202100:	02 f0 41 40 	r0 = Null + 65;
84202104:	03 00       	r1 = Null + Null;
84202106:	ff fd 90 f0 	call (m) 0x1421e;
8420210a:	39 e8 
8420210c:	f2 9e       	M[r4 + 44] = r0;
    if (p_ag->p_tmp_pb_ip == NULL)
8420210e:	f1 98       	rMAC = M[r4 + 44];
84202110:	0f 62       	if NE jump (m) Lc_aanc_proc_create_20;

84202112 <Lc_aanc_proc_create_18>:
    {
        aanc_proc_destroy(pp_ag);
84202112:	42 d8       	r0 = M[FP + 32];
84202114:	01 f0 23 e2 	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate playback cbuffer");
84202118:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420211c:	88 24       	Null = rMAC - 2;
8420211e:	9b 69       	if LT jump (m) Lc_aanc_proc_create_4;

84202120 <Lc_aanc_proc_create_19>:
84202120:	55 f1 02 f0 	r0 = Null + 357566690;
84202124:	e2 50 
84202126:	ef fd f7 ff 	call (m) 0x10b0;
8420212a:	2b ec 
8420212c:	94 6f       	jump (m) Lc_aanc_proc_create_4;

8420212e <Lc_aanc_proc_create_20>:
        return FALSE;
    }

    /* Allocate FxLMS and ED100 memory using the mem_table API */
    fxlms_dmx_words = (uint16)(aanc_fxlms100_dmx_bytes()/sizeof(unsigned));
8420212e:	05 f0 2d e7 	call (m) $_aanc_fxlms100_dmx_bytes;
84202132:	57 50       	r5 = r0 LSHIFT -2;
    fxlms_dm_words = (uint16)(AANC_PROC_FXLMS_DM_BYTES/sizeof(unsigned));
    ed_dmx_words = (uint16)(aanc_ed100_dmx_bytes()/sizeof(unsigned));
84202134:	08 f0 35 e9 	call (m) $_aanc_ed100_dmx_bytes;
84202138:	7f f2 da c8 	r8 = r0 LSHIFT -2;
    ed_dm1_words = (uint16)(aanc_ed100_dm1_bytes()/sizeof(unsigned));
8420213c:	08 f0 33 e9 	call (m) $_aanc_ed100_dm1_bytes;
84202140:	7f f2 db c8 	r9 = r0 LSHIFT -2;

    p_ag->p_table = xzpnewn(AANC_PROC_MEM_TABLE_SIZE, malloc_t_entry);
84202144:	c3 20       	r1 = Null + 3;
84202146:	82 39       	r0 = Null + 54;
84202148:	ff fd 27 f0 	call (m) 0x6f8e;
8420214c:	27 e2 
8420214e:	72 8e       	M[r4 + 4] = r0;
84202150:	18 71       	r6 = Null + 3;
84202152:	01 3a       	rMAC = Null + 56;
84202154:	a7 dc       	MH[FP + 40] = r5;
84202156:	e8 f0 15 8c 	MH[FP + 42] = r6;
8420215a:	b1 dc       	MH[FP + 44] = rMAC;
    p_ag->p_table[0] = (malloc_t_entry){
        fxlms_dmx_words, MALLOC_PREFERENCE_NONE,
        offsetof(ADAPTIVE_GAIN, p_fxlms)};
8420215c:	83 12       	r1 = FP + 40;
8420215e:	84 21       	r2 = Null + 6;
84202160:	ff fd c0 f0 	call (m) 0x1a170;
84202164:	31 e0 
84202166:	09 f0 4b 41 	r7 = Null + 331;
8420216a:	47 20       	r5 = Null + 1;
8420216c:	01 3b       	rMAC = Null + 60;
8420216e:	e9 f0 18 8c 	MH[FP + 48] = r7;
84202172:	cf dc       	MH[FP + 50] = r5;
84202174:	d1 dc       	MH[FP + 52] = rMAC;
    p_ag->p_table[1] = (malloc_t_entry){
        fxlms_dm_words, MALLOC_PREFERENCE_DM1,
        offsetof(ADAPTIVE_GAIN, p_fxlms_dm1)};
84202176:	03 13       	r1 = FP + 48;
84202178:	71 88       	rMAC = M[r4 + 4];
8420217a:	84 21       	r2 = Null + 6;
8420217c:	8a 21       	r0 = rMAC + 6;
8420217e:	ff fd bf f0 	call (m) 0x1a170;
84202182:	33 ef 
84202184:	e9 f0 1c 8c 	MH[FP + 56] = r7;
84202188:	81 20       	rMAC = Null + 2;
8420218a:	e9 dc       	MH[FP + 58] = rMAC;
8420218c:	01 f0 40 40 	rMAC = Null + 64;
84202190:	f1 dc       	MH[FP + 60] = rMAC;
    p_ag->p_table[2] = (malloc_t_entry){
        fxlms_dm_words, MALLOC_PREFERENCE_DM2,
        offsetof(ADAPTIVE_GAIN, p_fxlms_dm2)};
84202192:	83 13       	r1 = FP + 56;
84202194:	71 88       	rMAC = M[r4 + 4];
84202196:	84 21       	r2 = Null + 6;
84202198:	0a 23       	r0 = rMAC + 12;
8420219a:	ff fd bf f0 	call (m) 0x1a170;
8420219e:	37 ee 
842021a0:	ea f0 20 8c 	MH[FP + 64] = r8;
842021a4:	01 29       	rMAC = Null + 20;
842021a6:	e8 f0 21 8c 	MH[FP + 66] = r6;
842021aa:	11 dd       	MH[FP + 68] = rMAC;
    p_ag->p_table[3] = (malloc_t_entry){
        ed_dmx_words, MALLOC_PREFERENCE_NONE,
        offsetof(ADAPTIVE_GAIN, p_ed_int)};
842021ac:	03 14       	r1 = FP + 64;
842021ae:	71 88       	rMAC = M[r4 + 4];
842021b0:	84 21       	r2 = Null + 6;
842021b2:	8a 28       	r0 = rMAC + 18;
842021b4:	ff fd bf f0 	call (m) 0x1a170;
842021b8:	3d ed 
842021ba:	eb f0 24 8c 	MH[FP + 72] = r9;
842021be:	01 2a       	rMAC = Null + 24;
842021c0:	2f dd       	MH[FP + 74] = r5;
842021c2:	31 dd       	MH[FP + 76] = rMAC;
    p_ag->p_table[4] = (malloc_t_entry){
        ed_dm1_words, MALLOC_PREFERENCE_DM1,
        offsetof(ADAPTIVE_GAIN, p_ed_int_dm1)};
842021c4:	83 14       	r1 = FP + 72;
842021c6:	71 88       	rMAC = M[r4 + 4];
842021c8:	84 21       	r2 = Null + 6;
842021ca:	0a 2a       	r0 = rMAC + 24;
842021cc:	ff fd bf f0 	call (m) 0x1a170;
842021d0:	25 ed 
842021d2:	ea f0 28 8c 	MH[FP + 80] = r8;
842021d6:	01 31       	rMAC = Null + 36;
842021d8:	e8 f0 29 8c 	MH[FP + 82] = r6;
842021dc:	51 dd       	MH[FP + 84] = rMAC;
    p_ag->p_table[5] = (malloc_t_entry){
        ed_dmx_words, MALLOC_PREFERENCE_NONE,
        offsetof(ADAPTIVE_GAIN, p_ed_ext)};
842021de:	03 15       	r1 = FP + 80;
842021e0:	71 88       	rMAC = M[r4 + 4];
842021e2:	84 21       	r2 = Null + 6;
842021e4:	8a 2b       	r0 = rMAC + 30;
842021e6:	ff fd bf f0 	call (m) 0x1a170;
842021ea:	2b ec 
842021ec:	eb f0 2c 8c 	MH[FP + 88] = r9;
842021f0:	01 32       	rMAC = Null + 40;
842021f2:	6f dd       	MH[FP + 90] = r5;
842021f4:	71 dd       	MH[FP + 92] = rMAC;
    p_ag->p_table[6] = (malloc_t_entry){
        ed_dm1_words, MALLOC_PREFERENCE_DM1,
        offsetof(ADAPTIVE_GAIN, p_ed_ext_dm1)};
842021f6:	83 15       	r1 = FP + 88;
842021f8:	71 88       	rMAC = M[r4 + 4];
842021fa:	84 21       	r2 = Null + 6;
842021fc:	0a 31       	r0 = rMAC + 36;
842021fe:	ff fd bf f0 	call (m) 0x1a170;
84202202:	33 eb 
84202204:	ea f0 30 8c 	MH[FP + 96] = r8;
84202208:	01 38       	rMAC = Null + 48;
8420220a:	e8 f0 31 8c 	MH[FP + 98] = r6;
8420220e:	91 dd       	MH[FP + 100] = rMAC;
    p_ag->p_table[7] = (malloc_t_entry){
        ed_dmx_words, MALLOC_PREFERENCE_NONE,
        offsetof(ADAPTIVE_GAIN, p_ed_pb)};
84202210:	03 16       	r1 = FP + 96;
84202212:	71 88       	rMAC = M[r4 + 4];
84202214:	84 21       	r2 = Null + 6;
84202216:	8a 32       	r0 = rMAC + 42;
84202218:	ff fd bf f0 	call (m) 0x1a170;
8420221c:	39 ea 
8420221e:	eb f0 34 8c 	MH[FP + 104] = r9;
84202222:	01 39       	rMAC = Null + 52;
84202224:	af dd       	MH[FP + 106] = r5;
84202226:	b1 dd       	MH[FP + 108] = rMAC;
    p_ag->p_table[8] = (malloc_t_entry){
        ed_dm1_words, MALLOC_PREFERENCE_DM1,
        offsetof(ADAPTIVE_GAIN, p_ed_pb_dm1)};
84202228:	83 16       	r1 = FP + 104;
8420222a:	71 88       	rMAC = M[r4 + 4];
8420222c:	84 21       	r2 = Null + 6;
8420222e:	0a 38       	r0 = rMAC + 48;
84202230:	ff fd bf f0 	call (m) 0x1a170;
84202234:	21 ea 

    if (!mem_table_zalloc((void *)p_ag, p_ag->p_table, AANC_PROC_MEM_TABLE_SIZE))
84202236:	44 22       	r2 = Null + 9;
84202238:	73 88       	r1 = M[r4 + 4];
8420223a:	32 00       	r0 = r4 + Null;
8420223c:	ff fd 00 f0 	call (m) 0x22d6;
84202240:	3b e4 
84202242:	10 04       	Null = r0 - Null;
84202244:	0f 62       	if NE jump (m) Lc_aanc_proc_create_23;

84202246 <Lc_aanc_proc_create_21>:
    {
        aanc_proc_destroy(pp_ag);
84202246:	42 d8       	r0 = M[FP + 32];
84202248:	87 4e       	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate memory");
8420224a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420224e:	88 24       	Null = rMAC - 2;
84202250:	02 69       	if LT jump (m) Lc_aanc_proc_create_4;

84202252 <Lc_aanc_proc_create_22>:
84202252:	55 f1 02 f0 	r0 = Null + 357566736;
84202256:	10 51 
84202258:	ef fd f7 ff 	call (m) 0x10b0;
8420225c:	39 e2 
8420225e:	ff ff f7 eb 	jump (m) Lc_aanc_proc_create_4;

84202262 <Lc_aanc_proc_create_23>:
        return FALSE;
    }

    /* Create shared ED cbuffer without specific bank allocation */
    p_ag->p_tmp_ed = cbuffer_create_with_malloc(ED100_DEFAULT_BUFFER_SIZE,
                                                BUF_DESC_SW_BUFFER);
84202262:	02 f0 41 40 	r0 = Null + 65;
84202266:	03 00       	r1 = Null + Null;
84202268:	ff fd 8f f0 	call (m) 0x1421e;
8420226c:	37 ed 
8420226e:	b2 8e       	M[r4 + 8] = r0;
    if (p_ag->p_tmp_ed == NULL)
84202270:	b1 88       	rMAC = M[r4 + 8];
84202272:	10 62       	if NE jump (m) Lc_aanc_proc_create_26;

84202274 <Lc_aanc_proc_create_24>:
    {
        aanc_proc_destroy(pp_ag);
84202274:	42 d8       	r0 = M[FP + 32];
84202276:	70 4e       	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to allocate ED cbuffer");
84202278:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420227c:	88 24       	Null = rMAC - 2;
8420227e:	fb ff d7 eb 	if LT jump (m) Lc_aanc_proc_create_4;

84202282 <Lc_aanc_proc_create_25>:
84202282:	55 f1 02 f0 	r0 = Null + 357566772;
84202286:	34 51 
84202288:	ef fd f7 ff 	call (m) 0x10b0;
8420228c:	29 e1 
8420228e:	ff ff c7 eb 	jump (m) Lc_aanc_proc_create_4;

84202292 <Lc_aanc_proc_create_26>:
        return FALSE;
    }

    aanc_ed100_create(p_ag->p_ed_int, p_ag->p_ed_int_dm1, sample_rate);
84202292:	b3 89       	r1 = M[r4 + 24];
84202294:	72 89       	r0 = M[r4 + 20];
84202296:	4c d8       	r2 = M[FP + 36];
84202298:	07 f0 3d ee 	call (m) $_aanc_ed100_create;
    aanc_ed100_create(p_ag->p_ed_ext, p_ag->p_ed_ext_dm1, sample_rate);
8420229c:	b3 98       	r1 = M[r4 + 40];
8420229e:	72 98       	r0 = M[r4 + 36];
842022a0:	4c d8       	r2 = M[FP + 36];
842022a2:	07 f0 33 ee 	call (m) $_aanc_ed100_create;
    aanc_ed100_create(p_ag->p_ed_pb, p_ag->p_ed_pb_dm1, sample_rate);
842022a6:	73 99       	r1 = M[r4 + 52];
842022a8:	32 99       	r0 = M[r4 + 48];
842022aa:	4c d8       	r2 = M[FP + 36];
842022ac:	07 f0 29 ee 	call (m) $_aanc_ed100_create;

    /* Initialize number of taps to allow correct buffer alignment in create */
    p_ag->p_fxlms->p_plant.num_coeffs = AANC_PROC_NUM_TAPS_PLANT;
842022b0:	41 22       	rMAC = Null + 9;
842022b2:	b2 99       	r0 = M[r4 + 56];
842022b4:	21 f0 34 8c 	MH[r0 + 104] = rMAC;
    p_ag->p_fxlms->p_plant.full_num_coeffs = AANC_PROC_NUM_TAPS_PLANT;
842022b8:	b2 99       	r0 = M[r4 + 56];
842022ba:	21 f0 35 8c 	MH[r0 + 106] = rMAC;
    p_ag->p_fxlms->p_control_0.num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
842022be:	b2 99       	r0 = M[r4 + 56];
842022c0:	21 f0 4a 8c 	MH[r0 + 148] = rMAC;
    p_ag->p_fxlms->p_control_0.full_num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
842022c4:	b2 99       	r0 = M[r4 + 56];
842022c6:	21 f0 4b 8c 	MH[r0 + 150] = rMAC;
    p_ag->p_fxlms->p_control_1.num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
842022ca:	b2 99       	r0 = M[r4 + 56];
842022cc:	21 f0 60 8c 	MH[r0 + 192] = rMAC;
    p_ag->p_fxlms->p_control_1.full_num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
842022d0:	b2 99       	r0 = M[r4 + 56];
842022d2:	21 f0 61 8c 	MH[r0 + 194] = rMAC;
    p_ag->p_fxlms->p_bp_int.num_coeffs = AANC_PROC_NUM_TAPS_BP;
842022d6:	41 21       	rMAC = Null + 5;
842022d8:	b2 99       	r0 = M[r4 + 56];
842022da:	21 f0 76 8c 	MH[r0 + 236] = rMAC;
    p_ag->p_fxlms->p_bp_int.full_num_coeffs = AANC_PROC_NUM_TAPS_BP;
842022de:	b2 99       	r0 = M[r4 + 56];
842022e0:	21 f0 77 8c 	MH[r0 + 238] = rMAC;
    p_ag->p_fxlms->p_bp_ext.num_coeffs = AANC_PROC_NUM_TAPS_BP;
842022e4:	b2 99       	r0 = M[r4 + 56];
842022e6:	21 f0 8c 8c 	MH[r0 + 280] = rMAC;
    p_ag->p_fxlms->p_bp_ext.full_num_coeffs = AANC_PROC_NUM_TAPS_BP;
842022ea:	b2 99       	r0 = M[r4 + 56];
842022ec:	21 f0 8d 8c 	MH[r0 + 282] = rMAC;

    aanc_fxlms100_create(p_ag->p_fxlms, p_ag->p_fxlms_dm1, p_ag->p_fxlms_dm2);
842022f0:	34 a8       	r2 = M[r4 + 64];
842022f2:	f3 99       	r1 = M[r4 + 60];
842022f4:	b2 99       	r0 = M[r4 + 56];
842022f6:	04 f0 2b e9 	call (m) $_aanc_fxlms100_create;

    /* Initialize plant model as pass-through */
    coeffs = &p_ag->p_fxlms->p_plant.coeffs;
842022fa:	b1 99       	rMAC = M[r4 + 56];
842022fc:	01 f0 50 44 	rMAC = rMAC + 80;
    coeffs->p_num[0] = FXLMS100_MODEL_COEFF0;
84202300:	10 f0 02 f0 	r0 = Null + 16777216;
84202304:	00 40 
84202306:	0b e8       	r1 = M[rMAC + Null];
84202308:	1a ee       	M[r1 + Null] = r0;
    coeffs->p_den[0] = FXLMS100_MODEL_COEFF0;
8420230a:	49 88       	rMAC = M[rMAC + 4];
8420230c:	0a ee       	M[rMAC + Null] = r0;

    /* Initialize control 0 model as pass-through */
    coeffs = &p_ag->p_fxlms->p_control_0.coeffs;
8420230e:	b1 99       	rMAC = M[r4 + 56];
84202310:	01 f0 7c 44 	rMAC = rMAC + 124;
    coeffs->p_num[0] = FXLMS100_MODEL_COEFF0;
84202314:	0b e8       	r1 = M[rMAC + Null];
84202316:	1a ee       	M[r1 + Null] = r0;
    coeffs->p_den[0] = FXLMS100_MODEL_COEFF0;
84202318:	49 88       	rMAC = M[rMAC + 4];
8420231a:	0a ee       	M[rMAC + Null] = r0;

    p_ag->clip_threshold = AANC_PROC_CLIPPING_THRESHOLD;
8420231c:	ff f3 f1 f7 	rMAC = Null + 1073741823;
84202320:	ff 7b 
84202322:	b1 be       	M[r4 + 104] = rMAC;

    if (!load_aanc_handle(&p_ag->f_handle))
84202324:	62 f0 98 20 	r0 = r4 + 152;
84202328:	08 f0 25 e5 	call (m) $_load_aanc_handle;
8420232c:	10 04       	Null = r0 - Null;
8420232e:	10 62       	if NE jump (m) Lc_aanc_proc_create_29;

84202330 <Lc_aanc_proc_create_27>:
    {
        aanc_proc_destroy(pp_ag);
84202330:	42 d8       	r0 = M[FP + 32];
84202332:	12 4e       	call (m) $_aanc_proc_destroy;
        L2_DBG_MSG("AANC_PROC failed to load feature handle");
84202334:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202338:	88 24       	Null = rMAC - 2;
8420233a:	fb ff 9b ea 	if LT jump (m) Lc_aanc_proc_create_4;

8420233e <Lc_aanc_proc_create_28>:
8420233e:	55 f1 02 f0 	r0 = Null + 357566812;
84202342:	5c 51 
84202344:	ef fd f6 ff 	call (m) 0x10b0;
84202348:	2d eb 
8420234a:	ff ff 8b ea 	jump (m) Lc_aanc_proc_create_4;

8420234e <Lc_aanc_proc_create_29>:
        return FALSE;
    }

    return TRUE;
8420234e:	3a 00       	r0 = r5 + Null;

84202350 <Lc_aanc_proc_create_30>:
}
84202350:	6c 4c       	SP = SP + -80;
84202352:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202354:	d8 4c       	rts;

84202356 <$_aanc_proc_destroy>:

bool aanc_proc_destroy(ADAPTIVE_GAIN **pp_ag)
{
84202356:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202358:	17 00       	r5 = r0 + Null;
    ADAPTIVE_GAIN *p_ag = *pp_ag;

    if (p_ag == NULL)
8420235a:	3e e8       	r4 = M[r5 + Null];
8420235c:	36 60       	if EQ jump (m) Lc_aanc_proc_destroy_5;

8420235e <Lc_aanc_proc_destroy_2>:
    {
        return TRUE;
    }

    aanc_ed100_destroy(p_ag->p_ed_int);
8420235e:	72 89       	r0 = M[r4 + 20];
84202360:	08 f0 25 e2 	call (m) $_aanc_ed100_destroy;
    aanc_ed100_destroy(p_ag->p_ed_ext);
84202364:	72 98       	r0 = M[r4 + 36];
84202366:	08 f0 3f e1 	call (m) $_aanc_ed100_destroy;
    aanc_ed100_destroy(p_ag->p_ed_pb);
8420236a:	32 99       	r0 = M[r4 + 48];
8420236c:	08 f0 39 e1 	call (m) $_aanc_ed100_destroy;

    if (p_ag->p_table != NULL)
84202370:	73 88       	r1 = M[r4 + 4];
84202372:	0a 60       	if EQ jump (m) Lc_aanc_proc_destroy_4;

84202374 <Lc_aanc_proc_destroy_3>:
    {
        mem_table_free((void *)p_ag, p_ag->p_table, AANC_PROC_MEM_TABLE_SIZE);
84202374:	44 22       	r2 = Null + 9;
84202376:	32 00       	r0 = r4 + Null;
84202378:	ef fd ff ff 	call (m) 0x22e4;
8420237c:	2d eb 
        pdelete(p_ag->p_table);
8420237e:	72 88       	r0 = M[r4 + 4];
84202380:	ff fd 26 f0 	call (m) 0x6fbe;
84202384:	3f e1 

84202386 <Lc_aanc_proc_destroy_4>:
    }

    cbuffer_destroy(p_ag->p_tmp_ed);
84202386:	b2 88       	r0 = M[r4 + 8];
84202388:	ff fd 8f f0 	call (m) 0x14302;
8420238c:	3b eb 

    cbuffer_destroy(p_ag->p_tmp_int_ip);
8420238e:	f2 88       	r0 = M[r4 + 12];
84202390:	ff fd 8f f0 	call (m) 0x14302;
84202394:	33 eb 
    cbuffer_destroy(p_ag->p_tmp_ext_ip);
84202396:	f2 89       	r0 = M[r4 + 28];
84202398:	ff fd 8f f0 	call (m) 0x14302;
8420239c:	2b eb 
    cbuffer_destroy(p_ag->p_tmp_pb_ip);
8420239e:	f2 98       	r0 = M[r4 + 44];
842023a0:	ff fd 8f f0 	call (m) 0x14302;
842023a4:	23 eb 

    cbuffer_destroy(p_ag->p_tmp_int_op);
842023a6:	32 89       	r0 = M[r4 + 16];
842023a8:	ff fd 8f f0 	call (m) 0x14302;
842023ac:	3b ea 
    cbuffer_destroy(p_ag->p_tmp_ext_op);
842023ae:	32 98       	r0 = M[r4 + 32];
842023b0:	ff fd 8f f0 	call (m) 0x14302;
842023b4:	33 ea 

    unload_aanc_handle(p_ag->f_handle);
842023b6:	62 f0 26 88 	r0 = M[r4 + 152];
842023ba:	08 f0 35 e3 	call (m) $_unload_aanc_handle;

    pdelete(p_ag);
842023be:	32 00       	r0 = r4 + Null;
842023c0:	ff fd 25 f0 	call (m) 0x6fbe;
842023c4:	3f ef 
    *pp_ag = NULL;
842023c6:	38 ee       	M[r5 + Null] = Null;

842023c8 <Lc_aanc_proc_destroy_5>:
{
    ADAPTIVE_GAIN *p_ag = *pp_ag;

    if (p_ag == NULL)
    {
        return TRUE;
842023c8:	42 20       	r0 = Null + 1;

842023ca <Lc_aanc_proc_destroy_6>:

    pdelete(p_ag);
    *pp_ag = NULL;

    return TRUE;
}
842023ca:	f2 48       	popm <FP, r4, r5, rLink>;
842023cc:	d8 4c       	rts;

842023ce <$_aanc_proc_initialize>:

bool aanc_proc_initialize(AANC_PARAMETERS *p_params, ADAPTIVE_GAIN *p_ag,
                          unsigned ag_start, unsigned *p_flags,
                          bool hard_initialize)
{
842023ce:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842023d0:	50 f3 10 cf 	SP = SP + 160;
842023d4:	1f 00       	r5 = r1 + Null;
842023d6:	22 09       	r8 = r2 + Null;
842023d8:	e9 f3 ff b9 	r7 = M[FP + -4];
    bool ext_ed_disable_e_filter_check;
    bool int_ed_disable_e_filter_check;
    bool pb_ed_disable_e_filter_check;

    /* Initialize pointers to parameters and flags */
    p_ag->p_aanc_params = p_params;
842023dc:	fa be       	M[r5 + 108] = r0;
    p_ag->p_aanc_flags = p_flags;
842023de:	3d bf       	M[r5 + 112] = r3;

    /**************************************************
     * Initialize the FXLMS                           *
     **************************************************/
    p_dmx = p_ag->p_fxlms;
842023e0:	be 99       	r4 = M[r5 + 56];

    /* Initialize buffer pointers */
    p_dmx->p_int_ip = p_ag->p_tmp_int_ip;
842023e2:	f9 88       	rMAC = M[r5 + 12];
842023e4:	31 ee       	M[r4 + Null] = rMAC;
    p_dmx->p_int_op = p_ag->p_tmp_int_op;
842023e6:	39 89       	rMAC = M[r5 + 16];
842023e8:	b1 8e       	M[r4 + 8] = rMAC;
    p_dmx->p_ext_ip = p_ag->p_tmp_ext_ip;
842023ea:	f9 89       	rMAC = M[r5 + 28];
842023ec:	71 8e       	M[r4 + 4] = rMAC;
    p_dmx->p_ext_op = p_ag->p_tmp_ext_op;
842023ee:	39 98       	rMAC = M[r5 + 32];
842023f0:	f1 8e       	M[r4 + 12] = rMAC;

    /* Set FxLMS parameters */
    p_dmx->target_nr = p_params->OFFSET_TARGET_NOISE_REDUCTION;
842023f2:	21 f0 50 88 	rMAC = M[r0 + 320];
842023f6:	31 8f       	M[r4 + 16] = rMAC;
    p_dmx->mu = p_params->OFFSET_MU;
842023f8:	91 88       	rMAC = M[r0 + 8];
842023fa:	71 8f       	M[r4 + 20] = rMAC;
    p_dmx->gamma = p_params->OFFSET_GAMMA;
842023fc:	d1 88       	rMAC = M[r0 + 12];
842023fe:	b1 8f       	M[r4 + 24] = rMAC;
    p_dmx->lambda = p_params->OFFSET_LAMBDA;
84202400:	21 f0 4f 88 	rMAC = M[r0 + 316];
84202404:	31 9e       	M[r4 + 32] = rMAC;
    p_dmx->frame_size = AANC_DEFAULT_FRAME_SIZE;
84202406:	01 f0 40 40 	rMAC = Null + 64;
8420240a:	f1 8f       	M[r4 + 28] = rMAC;
    p_dmx->min_bound = p_params->OFFSET_FXLMS_MIN_BOUND;
8420240c:	21 f0 43 88 	rMAC = M[r0 + 268];
84202410:	f1 9e       	M[r4 + 44] = rMAC;
    p_dmx->max_bound = p_params->OFFSET_FXLMS_MAX_BOUND;
84202412:	21 f0 44 88 	rMAC = M[r0 + 272];
84202416:	31 9f       	M[r4 + 48] = rMAC;
    p_dmx->max_delta = p_params->OFFSET_FXLMS_MAX_DELTA;
84202418:	21 f0 45 88 	rMAC = M[r0 + 276];
8420241c:	71 9f       	M[r4 + 52] = rMAC;

    /* Optimization to reduce the effective number of taps in plant and control
     * filters if there are both trailing numerator and denominator coefficients
     */
    p_params_tmp = p_ag->p_aanc_params;
8420241e:	f9 b8       	rMAC = M[r5 + 108];
    if ((p_params_tmp->OFFSET_AANC_DEBUG &
         AANC_CONFIG_AANC_DEBUG_DISABLE_FILTER_OPTIM) > 0)
84202420:	49 89       	rMAC = M[rMAC + 20];
84202422:	49 c4       	rMAC = rMAC AND 0x200;
84202424:	13 60       	if EQ jump (m) Lc_aanc_proc_initialize_4;

84202426 <Lc_aanc_proc_initialize_2>:
    {
        p_dmx->p_plant.num_coeffs = AANC_PROC_NUM_TAPS_PLANT;
84202426:	41 22       	rMAC = Null + 9;
84202428:	61 f0 34 8c 	MH[r4 + 104] = rMAC;
        p_dmx->p_control_0.num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
8420242c:	61 f0 4a 8c 	MH[r4 + 148] = rMAC;
        p_dmx->p_control_1.num_coeffs = AANC_PROC_NUM_TAPS_CONTROL;
84202430:	61 f0 60 8c 	MH[r4 + 192] = rMAC;
        L4_DBG_MSG("AANC_PROC filters set to default number of coefficients");
84202434:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202438:	08 25       	Null = rMAC - 4;
8420243a:	33 68       	if LT jump (m) Lc_aanc_proc_initialize_6;

8420243c <Lc_aanc_proc_initialize_3>:
8420243c:	55 f1 02 f0 	r0 = Null + 357566852;
84202440:	84 51 
84202442:	ef fd f6 ff 	call (m) 0x10b0;
84202446:	2f e3 
84202448:	2c 6e       	jump (m) Lc_aanc_proc_initialize_6;

8420244a <Lc_aanc_proc_initialize_4>:
    }
    else
    {
        p_dmx->p_plant.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_plant, AANC_PROC_NUM_TAPS_PLANT);
8420244a:	68 f0 68 20 	r6 = r4 + 104;
8420244e:	43 22       	r1 = Null + 9;
84202450:	82 f3 e8 3b 	r0 = r6 + -24;
84202454:	06 f0 25 e6 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
84202458:	82 f0 00 ec 	MH[r6 + Null] = r0;
        p_dmx->p_control_0.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_control_0, AANC_PROC_NUM_TAPS_CONTROL);
8420245c:	68 f0 94 20 	r6 = r4 + 148;
84202460:	43 22       	r1 = Null + 9;
84202462:	82 f3 e8 3b 	r0 = r6 + -24;
84202466:	06 f0 33 e5 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
8420246a:	82 f0 00 ec 	MH[r6 + Null] = r0;
        p_dmx->p_control_1.num_coeffs = aanc_fxlms100_calculate_num_coeffs(
            &p_dmx->p_control_1, AANC_PROC_NUM_TAPS_CONTROL);
8420246e:	68 f0 c0 20 	r6 = r4 + 192;
84202472:	43 22       	r1 = Null + 9;
84202474:	82 f3 e8 3b 	r0 = r6 + -24;
84202478:	06 f0 21 e5 	call (m) $_aanc_fxlms100_calculate_num_coeffs;
8420247c:	82 f0 00 ec 	MH[r6 + Null] = r0;

        L4_DBG_MSG3(
            "AANC_PROC filter coeffs: Plant=%hu, Control 0=%hu, Control 1=%hu",
            p_dmx->p_plant.num_coeffs, p_dmx->p_control_0.num_coeffs,
            p_dmx->p_control_1.num_coeffs);
84202480:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202484:	08 25       	Null = rMAC - 4;
84202486:	0d 68       	if LT jump (m) Lc_aanc_proc_initialize_6;

84202488 <Lc_aanc_proc_initialize_5>:
84202488:	65 f0 60 86 	r3 = MHU[r4 + 192];
8420248c:	64 f0 4a 86 	r2 = MHU[r4 + 148];
84202490:	63 f0 34 86 	r1 = MHU[r4 + 104];
84202494:	55 f1 02 f0 	r0 = Null + 357566908;
84202498:	bc 51 
8420249a:	ef fd f6 ff 	call (m) 0x10ec;
8420249e:	33 e2 

842024a0 <Lc_aanc_proc_initialize_6>:
    }

    if (hard_initialize)
842024a0:	0f f9 00 c2 	Null = r7 - Null;
842024a4:	03 60       	if EQ jump (m) Lc_aanc_proc_initialize_8;

842024a6 <Lc_aanc_proc_initialize_7>:
    {
        p_dmx->initial_gain = ag_start;
842024a6:	6a f0 09 8e 	M[r4 + 36] = r8;

842024aa <Lc_aanc_proc_initialize_8>:
    }

    /* Initialize FxLMS bandpass model */
    p_params_tmp = p_ag->p_aanc_params;
842024aa:	78 f0 1b 88 	r6 = M[r5 + 108];
842024ae:	81 f0 3b 88 	rMAC = M[r6 + 236];
842024b2:	e1 de       	M[FP + 112] = rMAC;
842024b4:	81 f0 3c 88 	rMAC = M[r6 + 240];
842024b8:	e9 de       	M[FP + 116] = rMAC;
842024ba:	81 f0 3d 88 	rMAC = M[r6 + 244];
842024be:	f1 de       	M[FP + 120] = rMAC;
842024c0:	81 f0 3e 88 	rMAC = M[r6 + 248];
842024c4:	f9 de       	M[FP + 124] = rMAC;
842024c6:	81 f0 3f 88 	rMAC = M[r6 + 252];
842024ca:	01 df       	M[FP + 128] = rMAC;
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_INT_0,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_INT_1,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_INT_2,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_INT_3,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_INT_4
    };
842024cc:	03 17       	r1 = FP + 112;
842024ce:	02 12       	r0 = FP + 32;
842024d0:	44 21       	r2 = Null + 5;
842024d2:	ff fd bd f0 	call (m) 0x1a094;
842024d6:	23 ee 
842024d8:	81 f0 36 88 	rMAC = M[r6 + 216];
842024dc:	09 df       	M[FP + 132] = rMAC;
842024de:	81 f0 37 88 	rMAC = M[r6 + 220];
842024e2:	11 df       	M[FP + 136] = rMAC;
842024e4:	81 f0 38 88 	rMAC = M[r6 + 224];
842024e8:	19 df       	M[FP + 140] = rMAC;
842024ea:	81 f0 39 88 	rMAC = M[r6 + 228];
842024ee:	21 df       	M[FP + 144] = rMAC;
842024f0:	81 f0 3a 88 	rMAC = M[r6 + 232];
842024f4:	29 df       	M[FP + 148] = rMAC;
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_INT_0,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_INT_1,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_INT_2,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_INT_3,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_INT_4
    };
842024f6:	43 18       	r1 = FP + 132;
842024f8:	42 13       	r0 = FP + 52;
842024fa:	44 21       	r2 = Null + 5;
842024fc:	ff fd bd f0 	call (m) 0x1a094;
84202500:	39 ec 
84202502:	81 f0 31 88 	rMAC = M[r6 + 196];
84202506:	31 df       	M[FP + 152] = rMAC;
84202508:	81 f0 32 88 	rMAC = M[r6 + 200];
8420250c:	39 df       	M[FP + 156] = rMAC;
8420250e:	81 f0 33 88 	rMAC = M[r6 + 204];
84202512:	41 df       	M[FP + 160] = rMAC;
84202514:	81 f0 34 88 	rMAC = M[r6 + 208];
84202518:	49 df       	M[FP + 164] = rMAC;
8420251a:	81 f0 35 88 	rMAC = M[r6 + 212];
8420251e:	51 df       	M[FP + 168] = rMAC;
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_EXT_0,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_EXT_1,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_EXT_2,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_EXT_3,
        p_params_tmp->OFFSET_BPF_NUMERATOR_COEFF_EXT_4
    };
84202520:	83 19       	r1 = FP + 152;
84202522:	82 14       	r0 = FP + 72;
84202524:	44 21       	r2 = Null + 5;
84202526:	ff fd bd f0 	call (m) 0x1a094;
8420252a:	2f eb 
8420252c:	81 f0 2c 88 	rMAC = M[r6 + 176];
84202530:	59 df       	M[FP + 172] = rMAC;
84202532:	81 f0 2d 88 	rMAC = M[r6 + 180];
84202536:	61 df       	M[FP + 176] = rMAC;
84202538:	81 f0 2e 88 	rMAC = M[r6 + 184];
8420253c:	69 df       	M[FP + 180] = rMAC;
8420253e:	81 f0 2f 88 	rMAC = M[r6 + 188];
84202542:	71 df       	M[FP + 184] = rMAC;
84202544:	81 f0 30 88 	rMAC = M[r6 + 192];
84202548:	79 df       	M[FP + 188] = rMAC;
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_0,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_1,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_2,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_3,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_4
    };
8420254a:	c3 1a       	r1 = FP + 172;
8420254c:	c2 15       	r0 = FP + 92;
8420254e:	44 21       	r2 = Null + 5;
84202550:	ff fd bd f0 	call (m) 0x1a094;
84202554:	25 ea 

    for (i = 0; i < p_dmx->p_bp_ext.num_coeffs; i++)
84202556:	02 00       	r0 = Null + Null;
84202558:	81 14       	rMAC = FP + 72;
8420255a:	c3 15       	r1 = FP + 92;
8420255c:	04 12       	r2 = FP + 32;
8420255e:	45 13       	r3 = FP + 52;

84202560 <Lc_aanc_proc_initialize_9>:
84202560:	68 f0 8c 86 	r6 = MHU[r4 + 280];
84202564:	8f f2 00 c2 	Null = r0 - r6;
84202568:	21 66       	if GE jump (m) Lc_aanc_proc_initialize_11;

8420256a <Lc_aanc_proc_initialize_10>:
    {
        p_dmx->p_bp_ext.coeffs.p_num[i] = bp_num_coeffs_ext[i];
8420256a:	01 f2 d8 c8 	r6 = r0 LSHIFT 2;
8420256e:	1a f0 00 e8 	r8 = M[rMAC + Null];
84202572:	6b f0 40 88 	r9 = M[r4 + 256];
84202576:	ba f0 08 ee 	M[r9 + r6] = r8;
        p_dmx->p_bp_ext.coeffs.p_den[i] = bp_den_coeffs_ext[i];
8420257a:	3a f0 00 e8 	r8 = M[r1 + Null];
8420257e:	6b f0 41 88 	r9 = M[r4 + 260];
84202582:	ba f0 08 ee 	M[r9 + r6] = r8;
        p_dmx->p_bp_int.coeffs.p_num[i] = bp_num_coeffs_int[i];
84202586:	4a f0 00 e8 	r8 = M[r2 + Null];
8420258a:	6b f0 35 88 	r9 = M[r4 + 212];
8420258e:	ba f0 08 ee 	M[r9 + r6] = r8;
        p_dmx->p_bp_int.coeffs.p_den[i] = bp_den_coeffs_int[i];
84202592:	5a f0 00 e8 	r8 = M[r3 + Null];
84202596:	6b f0 36 88 	r9 = M[r4 + 216];
8420259a:	ba f0 08 ee 	M[r9 + r6] = r8;
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_2,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_3,
        p_params_tmp->OFFSET_BPF_DENOMINATOR_COEFF_EXT_4
    };

    for (i = 0; i < p_dmx->p_bp_ext.num_coeffs; i++)
8420259e:	52 20       	r0 = r0 + 1;
842025a0:	09 21       	rMAC = rMAC + 4;
842025a2:	1b 21       	r1 = r1 + 4;
842025a4:	24 21       	r2 = r2 + 4;
842025a6:	2d 21       	r3 = r3 + 4;
842025a8:	dc 6f       	jump (m) Lc_aanc_proc_initialize_9;

842025aa <Lc_aanc_proc_initialize_11>:
        p_dmx->p_bp_ext.coeffs.p_den[i] = bp_den_coeffs_ext[i];
        p_dmx->p_bp_int.coeffs.p_num[i] = bp_num_coeffs_int[i];
        p_dmx->p_bp_int.coeffs.p_den[i] = bp_den_coeffs_int[i];
    }

    aanc_fxlms100_initialize(p_ag->f_handle, p_ag->p_fxlms, hard_initialize);
842025aa:	bb 99       	r1 = M[r5 + 56];
842025ac:	72 f0 26 88 	r0 = M[r5 + 152];
842025b0:	4c 08       	r2 = r7 + Null;
842025b2:	03 f0 2b e8 	call (m) $_aanc_fxlms100_initialize;

    /**************************************************
     * Initialize the EDs                             *
     **************************************************/
    ext_ed_disable_e_filter_check = FALSE;
842025b6:	01 09       	r7 = Null + Null;
    p_params_tmp = p_ag->p_aanc_params;
842025b8:	fe b8       	r4 = M[r5 + 108];
    if (p_params_tmp->OFFSET_AANC_DEBUG & \
        AANC_CONFIG_AANC_DEBUG_DISABLE_ED_EXT_E_FILTER_CHECK)
842025ba:	72 89       	r0 = M[r4 + 20];
842025bc:	51 c2       	rMAC = r0 AND 0x20;
842025be:	02 60       	if EQ jump (m) Lc_aanc_proc_initialize_13;

842025c0 <Lc_aanc_proc_initialize_12>:
    {
        ext_ed_disable_e_filter_check = TRUE;
842025c0:	09 71       	r7 = Null + 1;

842025c2 <Lc_aanc_proc_initialize_13>:
    }
    int_ed_disable_e_filter_check = FALSE;
842025c2:	01 00       	rMAC = Null + Null;
    if (p_params_tmp->OFFSET_AANC_DEBUG & \
        AANC_CONFIG_AANC_DEBUG_DISABLE_ED_INT_E_FILTER_CHECK)
842025c4:	d3 c1       	r1 = r0 AND 0x10;
842025c6:	02 60       	if EQ jump (m) Lc_aanc_proc_initialize_15;

842025c8 <Lc_aanc_proc_initialize_14>:
    {
        int_ed_disable_e_filter_check = TRUE;
842025c8:	41 20       	rMAC = Null + 1;

842025ca <Lc_aanc_proc_initialize_15>:
    }
    pb_ed_disable_e_filter_check = FALSE;
842025ca:	02 09       	r8 = Null + Null;
    if (p_params_tmp->OFFSET_AANC_DEBUG & \
        AANC_CONFIG_AANC_DEBUG_DISABLE_ED_PB_E_FILTER_CHECK)
842025cc:	d2 c2       	r0 = r0 AND 0x40;
842025ce:	02 60       	if EQ jump (m) Lc_aanc_proc_initialize_17;

842025d0 <Lc_aanc_proc_initialize_16>:
    {
        pb_ed_disable_e_filter_check = TRUE;
842025d0:	0a 71       	r8 = Null + 1;

842025d2 <Lc_aanc_proc_initialize_17>:
    }

    p_ag->p_ed_int->p_input = p_ag->p_tmp_int_ip;
842025d2:	fa 88       	r0 = M[r5 + 12];
842025d4:	7b 89       	r1 = M[r5 + 20];
842025d6:	1a ee       	M[r1 + Null] = r0;
    p_ag->p_ed_int->p_tmp = p_ag->p_tmp_ed;
842025d8:	ba 88       	r0 = M[r5 + 8];
842025da:	7b 89       	r1 = M[r5 + 20];
842025dc:	5a 8e       	M[r1 + 4] = r0;
    p_ag->p_ed_int->frame_size = AANC_DEFAULT_FRAME_SIZE;
842025de:	08 f0 40 40 	r6 = Null + 64;
842025e2:	7a 89       	r0 = M[r5 + 20];
842025e4:	28 f0 03 8e 	M[r0 + 12] = r6;
    p_ag->p_ed_int->attack_time = p_params_tmp->OFFSET_ED_INT_ATTACK;
842025e8:	32 a9       	r0 = M[r4 + 80];
842025ea:	7b 89       	r1 = M[r5 + 20];
842025ec:	1a 8f       	M[r1 + 16] = r0;
    p_ag->p_ed_int->decay_time = p_params_tmp->OFFSET_ED_INT_DECAY;
842025ee:	72 a9       	r0 = M[r4 + 84];
842025f0:	7b 89       	r1 = M[r5 + 20];
842025f2:	5a 8f       	M[r1 + 20] = r0;
    p_ag->p_ed_int->envelope_time = p_params_tmp->OFFSET_ED_INT_ENVELOPE;
842025f4:	b2 a9       	r0 = M[r4 + 88];
842025f6:	7b 89       	r1 = M[r5 + 20];
842025f8:	9a 8f       	M[r1 + 24] = r0;
    p_ag->p_ed_int->init_frame_time = p_params_tmp->OFFSET_ED_INT_INIT_FRAME;
842025fa:	f2 a9       	r0 = M[r4 + 92];
842025fc:	7b 89       	r1 = M[r5 + 20];
842025fe:	da 8f       	M[r1 + 28] = r0;
    p_ag->p_ed_int->ratio = p_params_tmp->OFFSET_ED_INT_RATIO;
84202600:	32 b8       	r0 = M[r4 + 96];
84202602:	7b 89       	r1 = M[r5 + 20];
84202604:	1a 9e       	M[r1 + 32] = r0;
    p_ag->p_ed_int->min_signal = p_params_tmp->OFFSET_ED_INT_MIN_SIGNAL;
84202606:	72 b8       	r0 = M[r4 + 100];
84202608:	7b 89       	r1 = M[r5 + 20];
8420260a:	5a 9e       	M[r1 + 36] = r0;
    p_ag->p_ed_int->min_max_envelope = p_params_tmp->OFFSET_ED_INT_MIN_MAX_ENVELOPE;
8420260c:	b2 b8       	r0 = M[r4 + 104];
8420260e:	7b 89       	r1 = M[r5 + 20];
84202610:	9a 9e       	M[r1 + 40] = r0;
    p_ag->p_ed_int->delta_th = p_params_tmp->OFFSET_ED_INT_DELTA_TH;
84202612:	f2 b8       	r0 = M[r4 + 108];
84202614:	7b 89       	r1 = M[r5 + 20];
84202616:	da 9e       	M[r1 + 44] = r0;
    p_ag->p_ed_int->count_th = p_params_tmp->OFFSET_ED_INT_COUNT_TH;
84202618:	32 b9       	r0 = M[r4 + 112];
8420261a:	7b 89       	r1 = M[r5 + 20];
8420261c:	1a 9f       	M[r1 + 48] = r0;
    p_ag->p_ed_int->hold_frames = p_params_tmp->OFFSET_ED_INT_HOLD_FRAMES;
8420261e:	72 b9       	r0 = M[r4 + 116];
84202620:	7b 89       	r1 = M[r5 + 20];
84202622:	5a 9f       	M[r1 + 52] = r0;
    p_ag->p_ed_int->e_min_threshold = p_params_tmp->OFFSET_ED_INT_E_FILTER_MIN_THRESHOLD;
84202624:	b2 b9       	r0 = M[r4 + 120];
84202626:	7b 89       	r1 = M[r5 + 20];
84202628:	9a 9f       	M[r1 + 56] = r0;
    p_ag->p_ed_int->e_min_counter_threshold = p_params_tmp->OFFSET_ED_INT_E_FILTER_MIN_COUNTER_THRESHOLD;
8420262a:	f2 b9       	r0 = M[r4 + 124];
8420262c:	7b 89       	r1 = M[r5 + 20];
8420262e:	da 9f       	M[r1 + 60] = r0;
    p_ag->p_ed_int->e_min_check_disabled = int_ed_disable_e_filter_check;
84202630:	7a 89       	r0 = M[r5 + 20];
84202632:	11 ae       	M[r0 + 64] = rMAC;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_int);
84202634:	7b 89       	r1 = M[r5 + 20];
84202636:	72 f0 26 88 	r0 = M[r5 + 152];
8420263a:	06 f0 21 e5 	call (m) $_aanc_ed100_initialize;

    p_ag->p_ed_ext->p_input = p_ag->p_tmp_ext_ip;
8420263e:	f9 89       	rMAC = M[r5 + 28];
84202640:	7a 98       	r0 = M[r5 + 36];
84202642:	11 ee       	M[r0 + Null] = rMAC;
    p_ag->p_ed_ext->p_tmp = p_ag->p_tmp_ed;
84202644:	b9 88       	rMAC = M[r5 + 8];
84202646:	7a 98       	r0 = M[r5 + 36];
84202648:	51 8e       	M[r0 + 4] = rMAC;
    p_ag->p_ed_ext->frame_size = AANC_DEFAULT_FRAME_SIZE;
8420264a:	79 98       	rMAC = M[r5 + 36];
8420264c:	18 f0 03 8e 	M[rMAC + 12] = r6;
    p_ag->p_ed_ext->attack_time = p_params_tmp->OFFSET_ED_EXT_ATTACK;
84202650:	31 98       	rMAC = M[r4 + 32];
84202652:	7a 98       	r0 = M[r5 + 36];
84202654:	11 8f       	M[r0 + 16] = rMAC;
    p_ag->p_ed_ext->decay_time = p_params_tmp->OFFSET_ED_EXT_DECAY;
84202656:	71 98       	rMAC = M[r4 + 36];
84202658:	7a 98       	r0 = M[r5 + 36];
8420265a:	51 8f       	M[r0 + 20] = rMAC;
    p_ag->p_ed_ext->envelope_time = p_params_tmp->OFFSET_ED_EXT_ENVELOPE;
8420265c:	b1 98       	rMAC = M[r4 + 40];
8420265e:	7a 98       	r0 = M[r5 + 36];
84202660:	91 8f       	M[r0 + 24] = rMAC;
    p_ag->p_ed_ext->init_frame_time = p_params_tmp->OFFSET_ED_EXT_INIT_FRAME;
84202662:	f1 98       	rMAC = M[r4 + 44];
84202664:	7a 98       	r0 = M[r5 + 36];
84202666:	d1 8f       	M[r0 + 28] = rMAC;
    p_ag->p_ed_ext->ratio = p_params_tmp->OFFSET_ED_EXT_RATIO;
84202668:	31 99       	rMAC = M[r4 + 48];
8420266a:	7a 98       	r0 = M[r5 + 36];
8420266c:	11 9e       	M[r0 + 32] = rMAC;
    p_ag->p_ed_ext->min_signal = p_params_tmp->OFFSET_ED_EXT_MIN_SIGNAL;
8420266e:	71 99       	rMAC = M[r4 + 52];
84202670:	7a 98       	r0 = M[r5 + 36];
84202672:	51 9e       	M[r0 + 36] = rMAC;
    p_ag->p_ed_ext->min_max_envelope = p_params_tmp->OFFSET_ED_EXT_MIN_MAX_ENVELOPE;
84202674:	b1 99       	rMAC = M[r4 + 56];
84202676:	7a 98       	r0 = M[r5 + 36];
84202678:	91 9e       	M[r0 + 40] = rMAC;
    p_ag->p_ed_ext->delta_th = p_params_tmp->OFFSET_ED_EXT_DELTA_TH;
8420267a:	f1 99       	rMAC = M[r4 + 60];
8420267c:	7a 98       	r0 = M[r5 + 36];
8420267e:	d1 9e       	M[r0 + 44] = rMAC;
    p_ag->p_ed_ext->count_th = p_params_tmp->OFFSET_ED_EXT_COUNT_TH;
84202680:	31 a8       	rMAC = M[r4 + 64];
84202682:	7a 98       	r0 = M[r5 + 36];
84202684:	11 9f       	M[r0 + 48] = rMAC;
    p_ag->p_ed_ext->hold_frames = p_params_tmp->OFFSET_ED_EXT_HOLD_FRAMES;
84202686:	71 a8       	rMAC = M[r4 + 68];
84202688:	7a 98       	r0 = M[r5 + 36];
8420268a:	51 9f       	M[r0 + 52] = rMAC;
    p_ag->p_ed_ext->e_min_threshold = p_params_tmp->OFFSET_ED_EXT_E_FILTER_MIN_THRESHOLD;
8420268c:	b1 a8       	rMAC = M[r4 + 72];
8420268e:	7a 98       	r0 = M[r5 + 36];
84202690:	91 9f       	M[r0 + 56] = rMAC;
    p_ag->p_ed_ext->e_min_counter_threshold = p_params_tmp->OFFSET_ED_EXT_E_FILTER_MIN_COUNTER_THRESHOLD;
84202692:	f1 a8       	rMAC = M[r4 + 76];
84202694:	7a 98       	r0 = M[r5 + 36];
84202696:	d1 9f       	M[r0 + 60] = rMAC;
    p_ag->p_ed_ext->e_min_check_disabled = ext_ed_disable_e_filter_check;
84202698:	79 98       	rMAC = M[r5 + 36];
8420269a:	19 f0 10 8e 	M[rMAC + 64] = r7;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_ext);
8420269e:	7b 98       	r1 = M[r5 + 36];
842026a0:	72 f0 26 88 	r0 = M[r5 + 152];
842026a4:	06 f0 37 e1 	call (m) $_aanc_ed100_initialize;

    p_ag->p_ed_pb->p_input = p_ag->p_tmp_pb_ip;
842026a8:	f9 98       	rMAC = M[r5 + 44];
842026aa:	3a 99       	r0 = M[r5 + 48];
842026ac:	11 ee       	M[r0 + Null] = rMAC;
    p_ag->p_ed_pb->p_tmp = p_ag->p_tmp_ed;
842026ae:	b9 88       	rMAC = M[r5 + 8];
842026b0:	3a 99       	r0 = M[r5 + 48];
842026b2:	51 8e       	M[r0 + 4] = rMAC;
    p_ag->p_ed_pb->frame_size = AANC_DEFAULT_FRAME_SIZE;
842026b4:	39 99       	rMAC = M[r5 + 48];
842026b6:	18 f0 03 8e 	M[rMAC + 12] = r6;
    p_ag->p_ed_pb->attack_time = p_params_tmp->OFFSET_ED_PB_ATTACK;
842026ba:	61 f0 20 88 	rMAC = M[r4 + 128];
842026be:	3a 99       	r0 = M[r5 + 48];
842026c0:	11 8f       	M[r0 + 16] = rMAC;
    p_ag->p_ed_pb->decay_time = p_params_tmp->OFFSET_ED_PB_DECAY;
842026c2:	61 f0 21 88 	rMAC = M[r4 + 132];
842026c6:	3a 99       	r0 = M[r5 + 48];
842026c8:	51 8f       	M[r0 + 20] = rMAC;
    p_ag->p_ed_pb->envelope_time = p_params_tmp->OFFSET_ED_PB_ENVELOPE;
842026ca:	61 f0 22 88 	rMAC = M[r4 + 136];
842026ce:	3a 99       	r0 = M[r5 + 48];
842026d0:	91 8f       	M[r0 + 24] = rMAC;
    p_ag->p_ed_pb->init_frame_time = p_params_tmp->OFFSET_ED_PB_INIT_FRAME;
842026d2:	61 f0 23 88 	rMAC = M[r4 + 140];
842026d6:	3a 99       	r0 = M[r5 + 48];
842026d8:	d1 8f       	M[r0 + 28] = rMAC;
    p_ag->p_ed_pb->ratio = p_params_tmp->OFFSET_ED_PB_RATIO;
842026da:	61 f0 24 88 	rMAC = M[r4 + 144];
842026de:	3a 99       	r0 = M[r5 + 48];
842026e0:	11 9e       	M[r0 + 32] = rMAC;
    p_ag->p_ed_pb->min_signal = p_params_tmp->OFFSET_ED_PB_MIN_SIGNAL;
842026e2:	61 f0 25 88 	rMAC = M[r4 + 148];
842026e6:	3a 99       	r0 = M[r5 + 48];
842026e8:	51 9e       	M[r0 + 36] = rMAC;
    p_ag->p_ed_pb->min_max_envelope = p_params_tmp->OFFSET_ED_PB_MIN_MAX_ENVELOPE;
842026ea:	61 f0 26 88 	rMAC = M[r4 + 152];
842026ee:	3a 99       	r0 = M[r5 + 48];
842026f0:	91 9e       	M[r0 + 40] = rMAC;
    p_ag->p_ed_pb->delta_th = p_params_tmp->OFFSET_ED_PB_DELTA_TH;
842026f2:	61 f0 27 88 	rMAC = M[r4 + 156];
842026f6:	3a 99       	r0 = M[r5 + 48];
842026f8:	d1 9e       	M[r0 + 44] = rMAC;
    p_ag->p_ed_pb->count_th = p_params_tmp->OFFSET_ED_PB_COUNT_TH;
842026fa:	61 f0 28 88 	rMAC = M[r4 + 160];
842026fe:	3a 99       	r0 = M[r5 + 48];
84202700:	11 9f       	M[r0 + 48] = rMAC;
    p_ag->p_ed_pb->hold_frames = p_params_tmp->OFFSET_ED_PB_HOLD_FRAMES;
84202702:	61 f0 29 88 	rMAC = M[r4 + 164];
84202706:	3a 99       	r0 = M[r5 + 48];
84202708:	51 9f       	M[r0 + 52] = rMAC;
    p_ag->p_ed_pb->e_min_threshold = p_params_tmp->OFFSET_ED_PB_E_FILTER_MIN_THRESHOLD;
8420270a:	61 f0 2a 88 	rMAC = M[r4 + 168];
8420270e:	3a 99       	r0 = M[r5 + 48];
84202710:	91 9f       	M[r0 + 56] = rMAC;
    p_ag->p_ed_pb->e_min_counter_threshold = p_params_tmp->OFFSET_ED_PB_E_FILTER_MIN_COUNTER_THRESHOLD;
84202712:	61 f0 2b 88 	rMAC = M[r4 + 172];
84202716:	3a 99       	r0 = M[r5 + 48];
84202718:	d1 9f       	M[r0 + 60] = rMAC;
    p_ag->p_ed_pb->e_min_check_disabled = pb_ed_disable_e_filter_check;
8420271a:	39 99       	rMAC = M[r5 + 48];
8420271c:	1a f0 10 8e 	M[rMAC + 64] = r8;
    aanc_ed100_initialize(p_ag->f_handle, p_ag->p_ed_pb);
84202720:	3b 99       	r1 = M[r5 + 48];
84202722:	72 f0 26 88 	r0 = M[r5 + 152];
84202726:	05 f0 35 ed 	call (m) $_aanc_ed100_initialize;
    /**************************************************
     * Initialize Clipping                            *
     **************************************************/
    /* TODO: set to a function */
    aanc_proc_initialize_clip_detect(
        &p_ag->clip_ext, p_params_tmp->OFFSET_CLIPPING_DURATION_EXT);
8420272a:	63 f0 40 88 	r1 = M[r4 + 256];
8420272e:	72 f0 44 20 	r0 = r5 + 68;
84202732:	01 f0 2f ed 	call (m) Lc_aanc_proc_initialize_clip_detect_1;
    aanc_proc_initialize_clip_detect(
        &p_ag->clip_int, p_params_tmp->OFFSET_CLIPPING_DURATION_INT);
84202736:	63 f0 41 88 	r1 = M[r4 + 260];
8420273a:	72 f0 50 20 	r0 = r5 + 80;
8420273e:	01 f0 23 ed 	call (m) Lc_aanc_proc_initialize_clip_detect_1;
    aanc_proc_initialize_clip_detect(
        &p_ag->clip_pb, p_params_tmp->OFFSET_CLIPPING_DURATION_PB);
84202742:	63 f0 42 88 	r1 = M[r4 + 264];
84202746:	72 f0 5c 20 	r0 = r5 + 92;
8420274a:	01 f0 37 ec 	call (m) Lc_aanc_proc_initialize_clip_detect_1;

    return TRUE;
8420274e:	42 20       	r0 = Null + 1;

84202750 <Lc_aanc_proc_initialize_18>:
}
84202750:	b0 f3 10 cf 	SP = SP + -160;
84202754:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202756:	d8 4c       	rts;

84202758 <$_aanc_proc_process_data>:

bool aanc_proc_process_data(ADAPTIVE_GAIN *p_ag, bool calculate_gain)
{
84202758:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420275a:	16 00       	r4 = r0 + Null;
8420275c:	1b 09       	r9 = r1 + Null;
    AANC_PARAMETERS *p_params;
    int quiet_mode_lo_threshold, quiet_mode_hi_threshold;
    bool clip_int_disable, clip_ext_disable, clip_pb_disable, clip_disable;

    /* Copy input data to internal data buffers */
    cbuffer_copy(p_ag->p_tmp_int_ip, p_ag->p_mic_int_ip, AANC_DEFAULT_FRAME_SIZE);
8420275e:	04 f0 40 40 	r2 = Null + 64;
84202762:	f3 b9       	r1 = M[r4 + 124];
84202764:	f2 88       	r0 = M[r4 + 12];
84202766:	ff fd 5b f2 	call (m) 0x4dda4;
8420276a:	3f e1 
    cbuffer_copy(p_ag->p_tmp_ext_ip, p_ag->p_mic_ext_ip, AANC_DEFAULT_FRAME_SIZE);
8420276c:	04 f0 40 40 	r2 = Null + 64;
84202770:	63 f0 20 88 	r1 = M[r4 + 128];
84202774:	f2 89       	r0 = M[r4 + 28];
84202776:	ff fd 5b f2 	call (m) 0x4dda4;
8420277a:	2f e1 

    /* Copy playback data to internal data buffers if connected */
    if (p_ag->p_playback_ip != NULL)
8420277c:	63 f0 21 88 	r1 = M[r4 + 132];
84202780:	07 60       	if EQ jump (m) Lc_aanc_proc_process_data_3;

84202782 <Lc_aanc_proc_process_data_2>:
    {
        cbuffer_copy(p_ag->p_tmp_pb_ip, p_ag->p_playback_ip,
                     AANC_DEFAULT_FRAME_SIZE);
84202782:	04 f0 40 40 	r2 = Null + 64;
84202786:	f2 98       	r0 = M[r4 + 44];
84202788:	ff fd 5b f2 	call (m) 0x4dda4;
8420278c:	3d e0 

8420278e <Lc_aanc_proc_process_data_3>:
    }

    /* Copy fbmon data through if connected */
    if (p_ag->p_fbmon_ip != NULL)
8420278e:	b2 b9       	r0 = M[r4 + 120];
84202790:	11 60       	if EQ jump (m) Lc_aanc_proc_process_data_7;

84202792 <Lc_aanc_proc_process_data_4>:
    {
        if (p_ag->p_fbmon_op != NULL)
84202792:	61 f0 22 88 	rMAC = M[r4 + 136];
84202796:	09 60       	if EQ jump (m) Lc_aanc_proc_process_data_6;

84202798 <Lc_aanc_proc_process_data_5>:
        {
            cbuffer_copy(p_ag->p_fbmon_op, p_ag->p_fbmon_ip,
                         AANC_DEFAULT_FRAME_SIZE);
84202798:	04 f0 40 40 	r2 = Null + 64;
8420279c:	13 00       	r1 = r0 + Null;
8420279e:	0a 00       	r0 = rMAC + Null;
842027a0:	ff fd 5b f2 	call (m) 0x4dda4;
842027a4:	25 e0 
842027a6:	06 6e       	jump (m) Lc_aanc_proc_process_data_7;

842027a8 <Lc_aanc_proc_process_data_6>:
        }
        else
        {
            cbuffer_discard_data(p_ag->p_fbmon_ip, AANC_DEFAULT_FRAME_SIZE);
842027a8:	03 f0 40 40 	r1 = Null + 64;
842027ac:	ff fd 5a f2 	call (m) 0x4dc8c;
842027b0:	21 e7 

842027b2 <Lc_aanc_proc_process_data_7>:
        }
    }

    /* Clear all flags connected with processing data but persist quiet mode    */
    flags_pre_proc = *p_ag->p_aanc_flags & (AANC_MODEL_MASK | AANC_FLAGS_QUIET_MODE);
842027b2:	31 b9       	rMAC = M[r4 + 112];
842027b4:	09 e8       	rMAC = M[rMAC + Null];
842027b6:	0f f0 18 f8 	r6 = rMAC AND 0x1f0000;
842027ba:	00 00 

    /* Determine clip detection enable/disable  */
    debug_config = p_ag->p_aanc_params->OFFSET_AANC_DEBUG;
842027bc:	f1 b8       	rMAC = M[r4 + 108];
842027be:	1a f0 05 88 	r8 = M[rMAC + 20];
    clip_int_disable = debug_config & AANC_CONFIG_AANC_DEBUG_DISABLE_CLIPPING_DETECT_INT;
    clip_ext_disable = debug_config & AANC_CONFIG_AANC_DEBUG_DISABLE_CLIPPING_DETECT_EXT;
842027c2:	a2 f1 00 00 	r0 = r8 AND 0x2000;
    clip_pb_disable = debug_config & AANC_CONFIG_AANC_DEBUG_DISABLE_CLIPPING_DETECT_PB;
842027c6:	a3 f2 00 00 	r1 = r8 AND 0x4000;
    clip_disable = clip_int_disable && clip_ext_disable && clip_pb_disable;
842027ca:	a1 f0 00 10 	rMAC = r8 AND 0x1000;
842027ce:	05 60       	if EQ jump (m) Lc_aanc_proc_process_data_10;

842027d0 <Lc_aanc_proc_process_data_8>:
842027d0:	10 04       	Null = r0 - Null;
842027d2:	03 60       	if EQ jump (m) Lc_aanc_proc_process_data_10;

842027d4 <Lc_aanc_proc_process_data_9>:
842027d4:	18 04       	Null = r1 - Null;
842027d6:	58 62       	if NE jump (m) Lc_aanc_proc_process_data_22;

842027d8 <Lc_aanc_proc_process_data_10>:

    /* Clipping detection on the input mics */
    if (!(clip_disable))
    {
        aanc_proc_clipping_peak_detect(p_ag);
842027d8:	32 00       	r0 = r4 + Null;
842027da:	01 f0 3f e8 	call (m) $_aanc_proc_clipping_peak_detect;
        aanc_proc_process_clip_detect(&p_ag->clip_ext);
842027de:	62 f0 44 20 	r0 = r4 + 68;
842027e2:	01 f0 3f e6 	call (m) Lc_aanc_proc_process_clip_detect_1;
        aanc_proc_process_clip_detect(&p_ag->clip_int);
842027e6:	62 f0 50 20 	r0 = r4 + 80;
842027ea:	01 f0 37 e6 	call (m) Lc_aanc_proc_process_clip_detect_1;
        aanc_proc_process_clip_detect(&p_ag->clip_pb);
842027ee:	62 f0 5c 20 	r0 = r4 + 92;
842027f2:	01 f0 2f e6 	call (m) Lc_aanc_proc_process_clip_detect_1;

        clip_det = p_ag->clip_ext.detected * AANC_FLAGS_CLIPPING_EXT;
842027f6:	62 f0 4e 82 	r0 = MBU[r4 + 78];
842027fa:	04 f2 d7 d8 	r5 = r0 LSHIFT 9;
        clip_det |= p_ag->clip_int.detected * AANC_FLAGS_CLIPPING_INT;
842027fe:	62 f0 5a 82 	r0 = MBU[r4 + 90];
84202802:	d2 55       	r0 = r0 LSHIFT 8;
84202804:	bf 12       	r5 = r5 OR r0;
        clip_det |= p_ag->clip_pb.detected * AANC_FLAGS_CLIPPING_PLAYBACK;
84202806:	62 f0 66 82 	r0 = MBU[r4 + 102];
8420280a:	05 f2 d2 c8 	r0 = r0 LSHIFT 10;

        if (clip_det > 0)
8420280e:	bf 12       	r5 = r5 OR r0;
84202810:	3b 60       	if EQ jump (m) Lc_aanc_proc_process_data_22;

84202812 <Lc_aanc_proc_process_data_11>:
        {
            /* Copy input data to output if terminals are connected otherwise
             * discard data.
             */
            if (p_ag->p_mic_int_op != NULL)
84202812:	62 f0 23 88 	r0 = M[r4 + 140];
84202816:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_13;

84202818 <Lc_aanc_proc_process_data_12>:
            {
                cbuffer_copy(p_ag->p_mic_int_op, p_ag->p_tmp_int_ip,
                             AANC_DEFAULT_FRAME_SIZE);
84202818:	04 f0 40 40 	r2 = Null + 64;
8420281c:	f3 88       	r1 = M[r4 + 12];
8420281e:	ff fd 5a f2 	call (m) 0x4dda4;
84202822:	27 ec 
84202824:	07 6e       	jump (m) Lc_aanc_proc_process_data_14;

84202826 <Lc_aanc_proc_process_data_13>:
            }
            else
            {
                cbuffer_discard_data(p_ag->p_tmp_int_ip,
                                     AANC_DEFAULT_FRAME_SIZE);
84202826:	03 f0 40 40 	r1 = Null + 64;
8420282a:	f2 88       	r0 = M[r4 + 12];
8420282c:	ff fd 5a f2 	call (m) 0x4dc8c;
84202830:	21 e3 

84202832 <Lc_aanc_proc_process_data_14>:
            }

            if (p_ag->p_mic_ext_op != NULL)
84202832:	62 f0 24 88 	r0 = M[r4 + 144];
84202836:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_16;

84202838 <Lc_aanc_proc_process_data_15>:
            {
                cbuffer_copy(p_ag->p_mic_ext_op, p_ag->p_tmp_ext_ip,
                             AANC_DEFAULT_FRAME_SIZE);
84202838:	04 f0 40 40 	r2 = Null + 64;
8420283c:	f3 89       	r1 = M[r4 + 28];
8420283e:	ff fd 5a f2 	call (m) 0x4dda4;
84202842:	27 eb 
84202844:	07 6e       	jump (m) Lc_aanc_proc_process_data_17;

84202846 <Lc_aanc_proc_process_data_16>:
            }
            else
            {
                cbuffer_discard_data(p_ag->p_tmp_ext_ip,
                                     AANC_DEFAULT_FRAME_SIZE);
84202846:	03 f0 40 40 	r1 = Null + 64;
8420284a:	f2 89       	r0 = M[r4 + 28];
8420284c:	ff fd 5a f2 	call (m) 0x4dc8c;
84202850:	21 e2 

84202852 <Lc_aanc_proc_process_data_17>:
            }

            /* Copy or discard data on the playback stream */
            if (p_ag->p_playback_ip != NULL) {
84202852:	61 f0 21 88 	rMAC = M[r4 + 132];
84202856:	10 60       	if EQ jump (m) Lc_aanc_proc_process_data_21;

84202858 <Lc_aanc_proc_process_data_18>:
                if (p_ag->p_playback_op != NULL)
84202858:	72 b9       	r0 = M[r4 + 116];
8420285a:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_20;

8420285c <Lc_aanc_proc_process_data_19>:
                {
                    cbuffer_copy(p_ag->p_playback_op, p_ag->p_tmp_pb_ip,
                                AANC_DEFAULT_FRAME_SIZE);
8420285c:	04 f0 40 40 	r2 = Null + 64;
84202860:	f3 98       	r1 = M[r4 + 44];
84202862:	ff fd 5a f2 	call (m) 0x4dda4;
84202866:	23 ea 
84202868:	07 6e       	jump (m) Lc_aanc_proc_process_data_21;

8420286a <Lc_aanc_proc_process_data_20>:
                }
                else
                {
                    cbuffer_discard_data(p_ag->p_tmp_pb_ip,
                                        AANC_DEFAULT_FRAME_SIZE);
8420286a:	03 f0 40 40 	r1 = Null + 64;
8420286e:	f2 98       	r0 = M[r4 + 44];
84202870:	ff fd 5a f2 	call (m) 0x4dc8c;
84202874:	3d e0 

84202876 <Lc_aanc_proc_process_data_21>:
                }
            }

            flags_pre_proc |= clip_det;
84202876:	00 f7 78 c8 	r6 = r6 OR r5;
            *p_ag->p_aanc_flags = flags_pre_proc;
8420287a:	31 b9       	rMAC = M[r4 + 112];
8420287c:	18 f0 00 ee 	M[rMAC + Null] = r6;
            return FALSE;
84202880:	02 00       	r0 = Null + Null;
84202882:	0f f0 85 e4 	jump (m) Lc_aanc_proc_process_data_66;

84202886 <Lc_aanc_proc_process_data_22>:
        }
    }

    /* ED process ext mic */
    config = p_ag->p_aanc_params->OFFSET_AANC_CONFIG;
84202886:	f1 b8       	rMAC = M[r4 + 108];
84202888:	19 f0 00 e8 	r7 = M[rMAC + Null];
    if (!(config & AANC_CONFIG_AANC_CONFIG_DISABLE_ED_EXT))
8420288c:	91 f0 02 00 	rMAC = r7 AND 0x2;
84202890:	31 62       	if NE jump (m) Lc_aanc_proc_process_data_32;

84202892 <Lc_aanc_proc_process_data_23>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_ext);
84202892:	73 98       	r1 = M[r4 + 36];
84202894:	62 f0 26 88 	r0 = M[r4 + 152];
84202898:	05 f0 23 e4 	call (m) $_aanc_ed100_process_data;

        /* Catch external ED detection */
        if (p_ag->p_ed_ext->detection)
8420289c:	71 98       	rMAC = M[r4 + 36];
8420289e:	08 a9       	Null = M[rMAC + 80];
842028a0:	0d 60       	if EQ jump (m) Lc_aanc_proc_process_data_26;

842028a2 <Lc_aanc_proc_process_data_24>:
        {
            flags_pre_proc |= AANC_FLAGS_ED_EXT;
842028a2:	10 f8 58 c8 	r6 = r6 OR 0x20;
            L4_DBG_MSG("AANC_PROC ED Ext Detection");
842028a6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842028aa:	08 25       	Null = rMAC - 4;
842028ac:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_26;

842028ae <Lc_aanc_proc_process_data_25>:
842028ae:	55 f1 02 f0 	r0 = Null + 357566973;
842028b2:	fd 51 
842028b4:	ef fd f3 ff 	call (m) 0x10b0;
842028b8:	3d ef 

842028ba <Lc_aanc_proc_process_data_26>:
        }

        p_params = p_ag->p_aanc_params;
842028ba:	f1 b8       	rMAC = M[r4 + 108];
        quiet_mode_lo_threshold = p_params->OFFSET_QUIET_MODE_LO_THRESHOLD;
842028bc:	ca 89       	r0 = M[rMAC + 28];
        quiet_mode_hi_threshold = p_params->OFFSET_QUIET_MODE_HI_THRESHOLD;
842028be:	89 89       	rMAC = M[rMAC + 24];
        /* Threshold detect on external ED */
        if (p_ag->p_ed_ext->spl < quiet_mode_lo_threshold)
842028c0:	73 98       	r1 = M[r4 + 36];
842028c2:	5b a8       	r1 = M[r1 + 68];
842028c4:	98 04       	Null = r1 - r0;
842028c6:	10 66       	if GE jump (m) Lc_aanc_proc_process_data_30;

842028c8 <Lc_aanc_proc_process_data_27>:
        {
            L4_DBG_MSG("AANC_PROC ED Ext below quiet mode low threshold");
842028c8:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842028cc:	08 25       	Null = rMAC - 4;
842028ce:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_29;

842028d0 <Lc_aanc_proc_process_data_28>:
842028d0:	55 f1 02 f0 	r0 = Null + 357567000;
842028d4:	18 52 
842028d6:	ef fd f3 ff 	call (m) 0x10b0;
842028da:	3b ee 

842028dc <Lc_aanc_proc_process_data_29>:
            /* Set quiet mode flag */
            flags_pre_proc |= AANC_FLAGS_QUIET_MODE;
842028dc:	01 f0 00 f0 	r6 = r6 OR 0x100000;
842028e0:	00 f8 58 c8 
842028e4:	07 6e       	jump (m) Lc_aanc_proc_process_data_32;

842028e6 <Lc_aanc_proc_process_data_30>:
        }
        else if (p_ag->p_ed_ext->spl > quiet_mode_hi_threshold)
842028e6:	58 04       	Null = r1 - rMAC;
842028e8:	05 6c       	if LE jump (m) Lc_aanc_proc_process_data_32;

842028ea <Lc_aanc_proc_process_data_31>:
        {
            /* Reset quiet mode flag */
            flags_pre_proc &= AANC_PROC_QUIET_MODE_RESET_FLAG;
842028ea:	03 f0 f7 ff 	r6 = r6 AND 0x7fefffff;
842028ee:	88 ff ff 1f 

842028f2 <Lc_aanc_proc_process_data_32>:
        }
    }

    /* ED process int mic */
    if (!(config & AANC_CONFIG_AANC_CONFIG_DISABLE_ED_INT))
842028f2:	91 f0 01 00 	rMAC = r7 AND 0x1;
842028f6:	15 62       	if NE jump (m) Lc_aanc_proc_process_data_36;

842028f8 <Lc_aanc_proc_process_data_33>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_int);
842028f8:	73 89       	r1 = M[r4 + 20];
842028fa:	62 f0 26 88 	r0 = M[r4 + 152];
842028fe:	05 f0 3d e0 	call (m) $_aanc_ed100_process_data;
        if (p_ag->p_ed_int->detection)
84202902:	71 89       	rMAC = M[r4 + 20];
84202904:	08 a9       	Null = M[rMAC + 80];
84202906:	0d 60       	if EQ jump (m) Lc_aanc_proc_process_data_36;

84202908 <Lc_aanc_proc_process_data_34>:
        {
            flags_pre_proc |= AANC_FLAGS_ED_INT;
84202908:	08 f8 58 c8 	r6 = r6 OR 0x10;
            L4_DBG_MSG("AANC_PROC: ED Int Detection");
8420290c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202910:	08 25       	Null = rMAC - 4;
84202912:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_36;

84202914 <Lc_aanc_proc_process_data_35>:
84202914:	55 f1 02 f0 	r0 = Null + 357567048;
84202918:	48 52 
8420291a:	ef fd f3 ff 	call (m) 0x10b0;
8420291e:	37 ec 

84202920 <Lc_aanc_proc_process_data_36>:
        }
    }

    self_speech = FALSE;
84202920:	07 00       	r5 = Null + Null;
    if (!(config & AANC_CONFIG_AANC_CONFIG_DISABLE_SELF_SPEECH))
84202922:	91 f0 08 00 	rMAC = r7 AND 0x8;
84202926:	16 62       	if NE jump (m) Lc_aanc_proc_process_data_40;

84202928 <Lc_aanc_proc_process_data_37>:
    {
        /* ED process self-speech */
        self_speech = aanc_ed100_self_speech_detect(
            p_ag->p_ed_int, p_ag->p_ed_ext,
            p_ag->p_aanc_params->OFFSET_SELF_SPEECH_THRESHOLD);
84202928:	f1 b8       	rMAC = M[r4 + 108];
8420292a:	73 98       	r1 = M[r4 + 36];
8420292c:	14 f0 4e 88 	r2 = M[rMAC + 312];
84202930:	72 89       	r0 = M[r4 + 20];
84202932:	05 f0 27 e4 	call (m) $_aanc_ed100_self_speech_detect;
84202936:	17 00       	r5 = r0 + Null;
        if (self_speech)
84202938:	0d 60       	if EQ jump (m) Lc_aanc_proc_process_data_40;

8420293a <Lc_aanc_proc_process_data_38>:
        {
            flags_pre_proc |= AANC_FLAGS_SELF_SPEECH;
8420293a:	40 f8 58 c8 	r6 = r6 OR 0x80;
            L4_DBG_MSG("AANC_PROC: Self Speech Detection");
8420293e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202942:	08 25       	Null = rMAC - 4;
84202944:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_40;

84202946 <Lc_aanc_proc_process_data_39>:
84202946:	55 f1 02 f0 	r0 = Null + 357567076;
8420294a:	64 52 
8420294c:	ef fd f3 ff 	call (m) 0x10b0;
84202950:	25 eb 

84202952 <Lc_aanc_proc_process_data_40>:
        }
    }

    /* ED process playback */
    if (p_ag->p_playback_ip != NULL &&
        !(config & AANC_CONFIG_AANC_CONFIG_DISABLE_ED_PB))
84202952:	61 f0 21 88 	rMAC = M[r4 + 132];
84202956:	18 60       	if EQ jump (m) Lc_aanc_proc_process_data_45;

84202958 <Lc_aanc_proc_process_data_41>:
84202958:	91 f0 04 00 	rMAC = r7 AND 0x4;
8420295c:	15 62       	if NE jump (m) Lc_aanc_proc_process_data_45;

8420295e <Lc_aanc_proc_process_data_42>:
    {
        aanc_ed100_process_data(p_ag->f_handle, p_ag->p_ed_pb);
8420295e:	33 99       	r1 = M[r4 + 48];
84202960:	62 f0 26 88 	r0 = M[r4 + 152];
84202964:	04 f0 37 ed 	call (m) $_aanc_ed100_process_data;
        if (p_ag->p_ed_pb->detection)
84202968:	31 99       	rMAC = M[r4 + 48];
8420296a:	08 a9       	Null = M[rMAC + 80];
8420296c:	0d 60       	if EQ jump (m) Lc_aanc_proc_process_data_45;

8420296e <Lc_aanc_proc_process_data_43>:
        {
            flags_pre_proc |= AANC_FLAGS_ED_PLAYBACK;
8420296e:	20 f8 58 c8 	r6 = r6 OR 0x40;
            L4_DBG_MSG("AANC_PROC: ED Playback Detection");
84202972:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202976:	08 25       	Null = rMAC - 4;
84202978:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_45;

8420297a <Lc_aanc_proc_process_data_44>:
8420297a:	55 f1 02 f0 	r0 = Null + 357567109;
8420297e:	85 52 
84202980:	ef fd f3 ff 	call (m) 0x10b0;
84202984:	31 e9 

84202986 <Lc_aanc_proc_process_data_45>:
        }
    }

    /* Update flags */
    *p_ag->p_aanc_flags = flags_pre_proc;
84202986:	31 b9       	rMAC = M[r4 + 112];
84202988:	18 f0 00 ee 	M[rMAC + Null] = r6;

    /* Reference the working buffer used at the end to copy or discard data.
     * If adaptive gain calculation runs this is updated to the temporary output
     * buffers.
     */
    tCbuffer *p_int_working_buffer = p_ag->p_tmp_int_ip;
8420298c:	68 f0 03 88 	r6 = M[r4 + 12];
    tCbuffer *p_ext_working_buffer = p_ag->p_tmp_ext_ip;
84202990:	69 f0 07 88 	r7 = M[r4 + 28];

    /* Call adaptive ANC function */
    if (!p_ag->p_ed_ext->detection && !p_ag->p_ed_int->detection &&
        !p_ag->p_ed_pb->detection  && !self_speech && calculate_gain)
84202994:	71 98       	rMAC = M[r4 + 36];
84202996:	08 a9       	Null = M[rMAC + 80];
84202998:	44 62       	if NE jump (m) Lc_aanc_proc_process_data_55;

8420299a <Lc_aanc_proc_process_data_46>:
8420299a:	71 89       	rMAC = M[r4 + 20];
8420299c:	08 a9       	Null = M[rMAC + 80];
8420299e:	41 62       	if NE jump (m) Lc_aanc_proc_process_data_55;

842029a0 <Lc_aanc_proc_process_data_47>:
842029a0:	31 99       	rMAC = M[r4 + 48];
842029a2:	08 a9       	Null = M[rMAC + 80];
842029a4:	3e 62       	if NE jump (m) Lc_aanc_proc_process_data_55;

842029a6 <Lc_aanc_proc_process_data_48>:
842029a6:	38 04       	Null = r5 - Null;
842029a8:	3c 62       	if NE jump (m) Lc_aanc_proc_process_data_55;

842029aa <Lc_aanc_proc_process_data_49>:
842029aa:	0f fb 00 c2 	Null = r9 - Null;
842029ae:	39 60       	if EQ jump (m) Lc_aanc_proc_process_data_55;

842029b0 <Lc_aanc_proc_process_data_50>:
    {
        L5_DBG_MSG("AANC_PROC: Calculate new gain");
842029b0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842029b4:	48 25       	Null = rMAC - 5;
842029b6:	07 68       	if LT jump (m) Lc_aanc_proc_process_data_52;

842029b8 <Lc_aanc_proc_process_data_51>:
842029b8:	55 f1 02 f0 	r0 = Null + 357567142;
842029bc:	a6 52 
842029be:	ef fd f3 ff 	call (m) 0x10b0;
842029c2:	33 e7 

842029c4 <Lc_aanc_proc_process_data_52>:
        /* Get control for whether the read pointer is updated or not
           If MUX_SEL_ALGORITHM we update the read pointer because the input
           buffer is not copied later. If not we don't update it so that the
           input buffer is correctly copied to the output.  */
        mux_sel_algorithm = \
        debug_config & AANC_CONFIG_AANC_DEBUG_MUX_SEL_ALGORITHM;
842029c4:	a7 f0 00 01 	r5 = r8 AND 0x100;
        p_ag->p_fxlms->read_ptr_upd = mux_sel_algorithm;
842029c8:	b1 99       	rMAC = M[r4 + 56];
842029ca:	8f 9e       	M[rMAC + 40] = r5;

        if (aanc_fxlms100_process_data(p_ag->f_handle, p_ag->p_fxlms))
842029cc:	b3 99       	r1 = M[r4 + 56];
842029ce:	62 f0 26 88 	r0 = M[r4 + 152];
842029d2:	02 f0 25 e2 	call (m) $_aanc_fxlms100_process_data;
842029d6:	10 04       	Null = r0 - Null;
842029d8:	24 60       	if EQ jump (m) Lc_aanc_proc_process_data_55;

842029da <Lc_aanc_proc_process_data_53>:
        {
            *p_ag->p_aanc_flags |= p_ag->p_fxlms->flags;
842029da:	31 b9       	rMAC = M[r4 + 112];
842029dc:	b2 99       	r0 = M[r4 + 56];
842029de:	0b e8       	r1 = M[rMAC + Null];
842029e0:	12 a8       	r0 = M[r0 + 64];
842029e2:	d2 12       	r0 = r0 OR r1;
842029e4:	0a ee       	M[rMAC + Null] = r0;
            if (mux_sel_algorithm)
842029e6:	38 04       	Null = r5 - Null;
842029e8:	1c 60       	if EQ jump (m) Lc_aanc_proc_process_data_55;

842029ea <Lc_aanc_proc_process_data_54>:
            {
                p_int_working_buffer = p_ag->p_tmp_int_op;
842029ea:	68 f0 04 88 	r6 = M[r4 + 16];
                p_ext_working_buffer = p_ag->p_tmp_ext_op;
842029ee:	32 98       	r0 = M[r4 + 32];
842029f0:	11 09       	r7 = r0 + Null;

                cbuffer_advance_write_ptr(p_ag->p_tmp_ext_op,
                                          AANC_DEFAULT_FRAME_SIZE);
842029f2:	03 f0 40 40 	r1 = Null + 64;
842029f6:	ff fd 58 f2 	call (m) 0x4dbb0;
842029fa:	3b ed 
                cbuffer_advance_write_ptr(p_ag->p_tmp_int_op,
                                          AANC_DEFAULT_FRAME_SIZE);
842029fc:	03 f0 40 40 	r1 = Null + 64;
84202a00:	32 89       	r0 = M[r4 + 16];
84202a02:	ff fd 58 f2 	call (m) 0x4dbb0;
84202a06:	2f ed 
                cbuffer_advance_read_ptr(p_ag->p_tmp_ext_ip,
                                         AANC_DEFAULT_FRAME_SIZE);
84202a08:	03 f0 40 40 	r1 = Null + 64;
84202a0c:	f2 89       	r0 = M[r4 + 28];
84202a0e:	ff fd 58 f2 	call (m) 0x4db68;
84202a12:	3b ea 
                cbuffer_advance_read_ptr(p_ag->p_tmp_int_ip,
                                         AANC_DEFAULT_FRAME_SIZE);
84202a14:	03 f0 40 40 	r1 = Null + 64;
84202a18:	f2 88       	r0 = M[r4 + 12];
84202a1a:	ff fd 58 f2 	call (m) 0x4db68;
84202a1e:	2f ea 

84202a20 <Lc_aanc_proc_process_data_55>:
    }

    /* Copy internal buffers to the output buffers if they are connected
    * otherwise discard the data.
    */
    if (p_ag->p_mic_int_op != NULL)
84202a20:	62 f0 23 88 	r0 = M[r4 + 140];
84202a24:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_57;

84202a26 <Lc_aanc_proc_process_data_56>:
    {
        cbuffer_copy(p_ag->p_mic_int_op, p_int_working_buffer,
                     AANC_DEFAULT_FRAME_SIZE);
84202a26:	04 f0 40 40 	r2 = Null + 64;
84202a2a:	43 08       	r1 = r6 + Null;
84202a2c:	ff fd 59 f2 	call (m) 0x4dda4;
84202a30:	39 eb 
84202a32:	07 6e       	jump (m) Lc_aanc_proc_process_data_58;

84202a34 <Lc_aanc_proc_process_data_57>:
    }
    else
    {
        cbuffer_discard_data(p_int_working_buffer, AANC_DEFAULT_FRAME_SIZE);
84202a34:	03 f0 40 40 	r1 = Null + 64;
84202a38:	42 08       	r0 = r6 + Null;
84202a3a:	ff fd 59 f2 	call (m) 0x4dc8c;
84202a3e:	33 e2 

84202a40 <Lc_aanc_proc_process_data_58>:
    }

    if (p_ag->p_mic_ext_op != NULL)
84202a40:	62 f0 24 88 	r0 = M[r4 + 144];
84202a44:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_60;

84202a46 <Lc_aanc_proc_process_data_59>:
    {
        cbuffer_copy(p_ag->p_mic_ext_op, p_ext_working_buffer,
                     AANC_DEFAULT_FRAME_SIZE);
84202a46:	04 f0 40 40 	r2 = Null + 64;
84202a4a:	4b 08       	r1 = r7 + Null;
84202a4c:	ff fd 59 f2 	call (m) 0x4dda4;
84202a50:	39 ea 
84202a52:	07 6e       	jump (m) Lc_aanc_proc_process_data_61;

84202a54 <Lc_aanc_proc_process_data_60>:
    }
    else
    {
        cbuffer_discard_data(p_ext_working_buffer, AANC_DEFAULT_FRAME_SIZE);
84202a54:	03 f0 40 40 	r1 = Null + 64;
84202a58:	4a 08       	r0 = r7 + Null;
84202a5a:	ff fd 59 f2 	call (m) 0x4dc8c;
84202a5e:	33 e1 

84202a60 <Lc_aanc_proc_process_data_61>:
    }

    /* Copy or discard data on the internal playback stream buffer */
    if (p_ag->p_playback_ip != NULL) {
84202a60:	61 f0 21 88 	rMAC = M[r4 + 132];
84202a64:	10 60       	if EQ jump (m) Lc_aanc_proc_process_data_65;

84202a66 <Lc_aanc_proc_process_data_62>:
        if (p_ag->p_playback_op != NULL)
84202a66:	72 b9       	r0 = M[r4 + 116];
84202a68:	08 60       	if EQ jump (m) Lc_aanc_proc_process_data_64;

84202a6a <Lc_aanc_proc_process_data_63>:
        {
            cbuffer_copy(p_ag->p_playback_op, p_ag->p_tmp_pb_ip,
                        AANC_DEFAULT_FRAME_SIZE);
84202a6a:	04 f0 40 40 	r2 = Null + 64;
84202a6e:	f3 98       	r1 = M[r4 + 44];
84202a70:	ff fd 59 f2 	call (m) 0x4dda4;
84202a74:	35 e9 
84202a76:	07 6e       	jump (m) Lc_aanc_proc_process_data_65;

84202a78 <Lc_aanc_proc_process_data_64>:
        }
        else
        {
            cbuffer_discard_data(p_ag->p_tmp_pb_ip,
                                 AANC_DEFAULT_FRAME_SIZE);
84202a78:	03 f0 40 40 	r1 = Null + 64;
84202a7c:	f2 98       	r0 = M[r4 + 44];
84202a7e:	ff fd 59 f2 	call (m) 0x4dc8c;
84202a82:	2f e0 

84202a84 <Lc_aanc_proc_process_data_65>:
        }
    }

    return TRUE;
84202a84:	42 20       	r0 = Null + 1;

84202a86 <Lc_aanc_proc_process_data_66>:
}
84202a86:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202a88:	d8 4c       	rts;

84202a8a <Lc_aanc_proc_create_cbuffer_1>:
 * \param  malloc_pref  Malloc preference.
 *
 * \return  boolean indicating success or failure.
 */
static bool aanc_proc_create_cbuffer(tCbuffer **pp_buffer, unsigned malloc_pref)
{
84202a8a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202a8c:	16 00       	r4 = r0 + Null;
    /* Allocate buffer memory explicitly */
    int *ptr = xzppnewn(AANC_INTERNAL_BUFFER_SIZE, int, malloc_pref);
84202a8e:	02 f0 04 41 	r0 = Null + 260;
84202a92:	ff fd 22 f0 	call (m) 0x6f8e;
84202a96:	3d e7 
84202a98:	17 00       	r5 = r0 + Null;

    if (ptr == NULL)
84202a9a:	0e 60       	if EQ jump (m) Lc_aanc_proc_create_cbuffer_4;

84202a9c <Lc_aanc_proc_create_cbuffer_2>:
        return FALSE;
    }

    /* Wrap allocated memory in a cbuffer */
    *pp_buffer = cbuffer_create(ptr, AANC_INTERNAL_BUFFER_SIZE,
                               BUF_DESC_SW_BUFFER);
84202a9c:	03 f0 41 40 	r1 = Null + 65;
84202aa0:	04 00       	r2 = Null + Null;
84202aa2:	ff fd 8b f0 	call (m) 0x141c4;
84202aa6:	23 e9 
84202aa8:	32 ee       	M[r4 + Null] = r0;
    if (*pp_buffer == NULL)
84202aaa:	31 e8       	rMAC = M[r4 + Null];
84202aac:	07 62       	if NE jump (m) Lc_aanc_proc_create_cbuffer_5;

84202aae <Lc_aanc_proc_create_cbuffer_3>:
    {
        pdelete(ptr);
84202aae:	3a 00       	r0 = r5 + Null;
84202ab0:	ff fd 22 f0 	call (m) 0x6fbe;
84202ab4:	2f e8 

84202ab6 <Lc_aanc_proc_create_cbuffer_4>:
    /* Allocate buffer memory explicitly */
    int *ptr = xzppnewn(AANC_INTERNAL_BUFFER_SIZE, int, malloc_pref);

    if (ptr == NULL)
    {
        return FALSE;
84202ab6:	02 00       	r0 = Null + Null;
84202ab8:	02 6e       	jump (m) Lc_aanc_proc_create_cbuffer_6;

84202aba <Lc_aanc_proc_create_cbuffer_5>:
        ptr = NULL;

        return FALSE;
    }

    return TRUE;
84202aba:	42 20       	r0 = Null + 1;

84202abc <Lc_aanc_proc_create_cbuffer_6>:
}
84202abc:	f2 48       	popm <FP, r4, r5, rLink>;
84202abe:	d8 4c       	rts;

84202ac0 <Lc_aanc_proc_process_clip_detect_1>:
 * for a given duration (frames).
 */
static void aanc_proc_process_clip_detect(AANC_CLIP_DETECT *p_clip)
{
    /* Disabled resets the flag */
    if (p_clip->disabled)
84202ac0:	51 92       	rMAC = MBU[r0 + 9];
84202ac2:	03 60       	if EQ jump (m) Lc_aanc_proc_process_clip_detect_3;

84202ac4 <Lc_aanc_proc_process_clip_detect_2>:
    {
        p_clip->detected = FALSE;
84202ac4:	90 9a       	MB[r0 + 10] = Null;
84202ac6:	0c 6e       	jump (m) Lc_aanc_proc_process_clip_detect_7;

84202ac8 <Lc_aanc_proc_process_clip_detect_3>:
    }
    else
    {
        /* Detection sets the flag and resets the counter */
        if (p_clip->frame_detect)
84202ac8:	11 92       	rMAC = MBU[r0 + 8];
84202aca:	06 60       	if EQ jump (m) Lc_aanc_proc_process_clip_detect_5;

84202acc <Lc_aanc_proc_process_clip_detect_4>:
        {
            p_clip->counter = p_clip->duration;
84202acc:	91 86       	rMAC = MHU[r0 + 4];
84202ace:	d1 8c       	MH[r0 + 6] = rMAC;
            p_clip->detected = TRUE;
84202ad0:	41 20       	rMAC = Null + 1;
84202ad2:	91 9a       	MB[r0 + 10] = rMAC;
84202ad4:	05 6e       	jump (m) Lc_aanc_proc_process_clip_detect_7;

84202ad6 <Lc_aanc_proc_process_clip_detect_5>:
        }
        else
        {
            /* No detection decrements the counter until 0 */
            if (p_clip->counter > 0)
84202ad6:	d1 86       	rMAC = MHU[r0 + 6];
84202ad8:	f6 61       	if EQ jump (m) Lc_aanc_proc_process_clip_detect_2;

84202ada <Lc_aanc_proc_process_clip_detect_6>:
            {
                p_clip->counter--;
84202ada:	49 24       	rMAC = rMAC - 1;
84202adc:	d1 8c       	MH[r0 + 6] = rMAC;

84202ade <Lc_aanc_proc_process_clip_detect_7>:
84202ade:	d8 4c       	rts;

84202ae0 <Lc_aanc_proc_initialize_clip_detect_1>:
 */
static void aanc_proc_initialize_clip_detect(AANC_CLIP_DETECT *p_clip,
                                             unsigned duration)
{
    /* Convert duration in seconds to frames */
    p_clip->duration = (uint16)((duration * AANC_FRAME_RATE) >> 20);
84202ae0:	7d f3 93 c9 	r1 = r1 * 250 (int);
84202ae4:	db 52       	r1 = r1 LSHIFT -20;
84202ae6:	93 8c       	MH[r0 + 4] = r1;
    p_clip->counter = 0;
84202ae8:	d0 8c       	MH[r0 + 6] = Null;
    p_clip->detected = FALSE;
84202aea:	90 9a       	MB[r0 + 10] = Null;

84202aec <Lc_aanc_proc_initialize_clip_detect_2>:
84202aec:	d8 4c       	rts;

84202aee <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aanc_mono_16k_cap_data;
84202aee:	01 f0 02 f3 	r0 = Null + 1441792;
84202af2:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84202af4:	00 f0 4c 5a 	Null = Null + 3660;

84202af8 <$_aanc_proc_clipping_peak_detect>:
.MODULE $M.aanc_proc.clipping_peak_detect;
    .CODESEGMENT PM;

$_aanc_proc_clipping_peak_detect:

    PUSH_ALL_C;
84202af8:	fc fa 40 e0 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
84202afc:	07 f0 47 e4 	pushm <I0, I1, I2, I4, I5, I6>;
84202b00:	70 ff 40 e4 	pushm <M0, M1, M2, L0, L1, L4, L5>;

    r9 = r0;
84202b04:	13 09       	r9 = r0 + Null;
    r4 = M[r9 + $aanc_proc._ADAPTIVE_GAIN_struct.CLIP_THRESHOLD_FIELD];
84202b06:	b6 f0 1a 88 	r4 = M[r9 + 104];

    // Get cbuffer details for DM1 input
    r0 = M[r9 + $aanc_proc._ADAPTIVE_GAIN_struct.P_TMP_INT_IP_FIELD];
84202b0a:	b2 f0 03 88 	r0 = M[r9 + 12];
    call $cbuffer.get_read_address_and_size_and_start_address;
84202b0e:	ff fd 5a f2 	call (m) 0x4df66;
84202b12:	39 e2 
    push r2;
84202b14:	00 f0 34 cf 	push r2;
    pop B0;
84202b18:	00 f6 3a cf 	pop B0;
    I0 = r0;
84202b1c:	10 0a       	I0 = r0 + Null;
    L0 = r1;
84202b1e:	1c 0b       	L0 = r1 + Null;

    // Get cbuffer details for DM2 input
    r0 = M[r9 + $aanc_proc._ADAPTIVE_GAIN_struct.P_TMP_EXT_IP_FIELD];
84202b20:	b2 f0 07 88 	r0 = M[r9 + 28];
    call $cbuffer.get_read_address_and_size_and_start_address;
84202b24:	ff fd 5a f2 	call (m) 0x4df66;
84202b28:	23 e2 
    push r2;
84202b2a:	00 f0 34 cf 	push r2;
    pop B4;
84202b2e:	00 f6 3c cf 	pop B4;
    I4 = r0;
84202b32:	14 0a       	I4 = r0 + Null;
    L4 = r1;
84202b34:	1e 0b       	L4 = r1 + Null;

    r10 = $aanc_proc.FRAME_SIZE;
84202b36:	0c f0 40 40 	r10 = Null + 64;

    r3 = 0; // Internal mic clipping detection
84202b3a:	05 00       	r3 = Null + Null;
    r5 = 0; // Internal mic clipping detection
84202b3c:	07 00       	r5 = Null + Null;

    r7 = M[r9 + $aanc_proc.PEAK_INT_FIELD];
84202b3e:	b9 f0 14 88 	r7 = M[r9 + 80];
    r8 = M[r9 + $aanc_proc.PEAK_EXT_FIELD];
84202b42:	ba f0 11 88 	r8 = M[r9 + 68];

    do detect_mic_clipping;
84202b46:	11 4c       	do (m) $M.aanc_proc.clipping_peak_detect.detect_mic_clipping;
        r0 = M[I0, MK1], r2 = M[I4, MK1];
84202b48:	41 f1 32 d0 	Null = Null + Null, r0 = M[I0,4], r2 = M[I4,4];
        r0 = ABS r0; // r0 = Int Mic (I0)
84202b4c:	4f f2 42 ce 	r0 = ABS r0;
        r7 = MAX r0; // Peak detect int mic
84202b50:	6f f2 49 ce 	r7 = MAX r0;
        r2 = ABS r2; // r2 = Ext Mic (I4)
84202b54:	4f f4 44 ce 	r2 = ABS r2;
        r8 = MAX r2; // Peak detect ext mic
84202b58:	6f f4 4a ce 	r8 = MAX r2;
        Null = r0 - r4;
84202b5c:	90 05       	Null = r0 - r4;
        if GE r3 = 1;
84202b5e:	2a f0 45 ce 	if GE r3 = Null + 1;
        Null = r2 - r4;
84202b62:	a0 05       	Null = r2 - r4;
        if GE r5 = 1;
84202b64:	2a f0 47 ce 	if GE r5 = Null + 1;

84202b68 <$M.aanc_proc.clipping_peak_detect.detect_mic_clipping>:
    detect_mic_clipping:

    MB[r9 + $aanc_proc.CLIP_INT_FIELD] = r3;
84202b68:	b5 f0 58 8a 	MB[r9 + 88] = r3;
    MB[r9 + $aanc_proc.CLIP_EXT_FIELD] = r5;
84202b6c:	b7 f0 4c 8a 	MB[r9 + 76] = r5;
    M[r9 + $aanc_proc.PEAK_INT_FIELD] = r7;
84202b70:	b9 f0 14 8e 	M[r9 + 80] = r7;
    M[r9 + $aanc_proc.PEAK_EXT_FIELD] = r8;
84202b74:	ba f0 11 8e 	M[r9 + 68] = r8;

    // Do clipping and peak detect on the playback channel
    r0 = M[r9 + $aanc_proc._ADAPTIVE_GAIN_struct.P_PLAYBACK_IP_FIELD];
84202b78:	b2 f0 21 88 	r0 = M[r9 + 132];
    if Z jump done_detection;
84202b7c:	21 60       	if EQ jump (m) $M.aanc_proc.clipping_peak_detect.done_detection;

    r0 = M[r9 + $aanc_proc._ADAPTIVE_GAIN_struct.P_TMP_PB_IP_FIELD];
84202b7e:	b2 f0 0b 88 	r0 = M[r9 + 44];
    call $cbuffer.get_read_address_and_size_and_start_address;
84202b82:	ff fd 59 f2 	call (m) 0x4df66;
84202b86:	25 ef 
    push r2;
84202b88:	00 f0 34 cf 	push r2;
    pop B0;
84202b8c:	00 f6 3a cf 	pop B0;
    I0 = r0;
84202b90:	10 0a       	I0 = r0 + Null;
    L0 = r1;
84202b92:	1c 0b       	L0 = r1 + Null;

    r3 = 0;
84202b94:	05 00       	r3 = Null + Null;
    r10 = $aanc_proc.FRAME_SIZE;
84202b96:	0c f0 40 40 	r10 = Null + 64;
    r5 = $M.AANC.FLAGS.CLIPPING_PLAYBACK;
84202b9a:	07 f0 00 48 	r5 = Null + 1024;
    r7 = M[r9 + $aanc_proc.PEAK_PB_FIELD];
84202b9e:	b9 f0 17 88 	r7 = M[r9 + 92];
    do detect_pb_clipping;
84202ba2:	0a 4c       	do (m) $M.aanc_proc.clipping_peak_detect.detect_pb_clipping;
        r0 = M[I0, MK1];
84202ba4:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];
        r0 = ABS r0; // r0 = Playback (I0)
84202ba8:	4f f2 42 ce 	r0 = ABS r0;
        r7 = MAX r0; // Peak detect playback signal
84202bac:	6f f2 49 ce 	r7 = MAX r0;
        Null = r0 - r4;
84202bb0:	90 05       	Null = r0 - r4;
        if GE r3 = 1;
84202bb2:	2a f0 45 ce 	if GE r3 = Null + 1;

84202bb6 <$M.aanc_proc.clipping_peak_detect.detect_pb_clipping>:
    detect_pb_clipping:

    MB[r9 + $aanc_proc.CLIP_PB_FIELD] = r3;
84202bb6:	b5 f0 64 8a 	MB[r9 + 100] = r3;
    M[r9 + $aanc_proc.PEAK_PB_FIELD] = r7;
84202bba:	b9 f0 17 8e 	M[r9 + 92] = r7;

84202bbe <$M.aanc_proc.clipping_peak_detect.done_detection>:

done_detection:
    POP_ALL_C; // POP_ALL_C won't touch r0-r3
84202bbe:	70 ff 60 e4 	popm <M0, M1, M2, L0, L1, L4, L5>;
84202bc2:	07 f0 67 e4 	popm <I0, I1, I2, I4, I5, I6>;
84202bc6:	fc fa 60 e0 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
    r0 = 1;
84202bca:	42 20       	r0 = Null + 1;

    rts;
84202bcc:	d8 4c       	rts;

84202bce <$_aanc_proc_calc_gain_db>:
.MODULE $M.aanc_proc.calc_gain_db;
    .CODESEGMENT PM;

$_aanc_proc_calc_gain_db:

    pushm <r6, rLink>;
84202bce:	90 1c       	pushm <r6, rLink>;

    Null = r0;
84202bd0:	10 00       	Null = r0 + Null;
    if Z jump return_early;
84202bd2:	0e 60       	if EQ jump (m) $M.aanc_proc.calc_gain_db.return_early;

84202bd4 <$M.aanc_proc.calc_gain_db.calc_fine_gain_db>:

calc_fine_gain_db:
    rMAC = r0; // Copy fine gain to rMAC, in Q40.32
84202bd4:	11 00       	rMAC = r0 + Null;
    r3 = r1 * $aanc_proc.COARSE_GAIN_TO_DB (int); // Store coarse gain dB value in r3
84202bd6:	9d 41       	r3 = r1 * 6 (int);

    // Fine gain measured relative to 128, so needs to be scaled by 2^-7
    // log2_table takes input (rMAC) in Q9.63, so shift rMAC by 63-32-7=24
    rMAC = rMAC ASHIFT $aanc_proc.FINE_GAIN_LOG2_SHIFT_AMT (72bit);
84202bd8:	49 5f       	rMAC = rMAC ASHIFT 24 (56bit);
    r3 = r3 ASHIFT $aanc_proc.COARSE_GAIN_DB_SHIFT_AMT; // Coarse gain (dB) in Q12.20
84202bda:	ed 5e       	r3 = r3 ASHIFT 20;

    call $math.log2_table;
84202bdc:	ff fd 6d f4 	call 0x9064c;
84202be0:	30 e3 

    // Convert to dB by using multiplying factor of 20/log2(10)
    rMAC = r0 * $aanc_proc.LOG2_TO_DB_CONV_FACTOR;
84202be2:	02 f3 30 fa 	rMAC = r0 * 0.376287494786083698272705078125 (SS);
84202be6:	4a f2 d1 cc 
    r0 = rMAC + r3; // Add coarse gain (dB) and fine gain (dB)
84202bea:	4a 01       	r0 = rMAC + r3;
    jump return_db_gain;
84202bec:	04 6e       	jump (m) $M.aanc_proc.calc_gain_db.return_db_gain;

84202bee <$M.aanc_proc.calc_gain_db.return_early>:

return_early:
    r0 = MININT;
84202bee:	00 f8 02 f0 	r0 = Null + -2147483648;
84202bf2:	00 40 

84202bf4 <$M.aanc_proc.calc_gain_db.return_db_gain>:

return_db_gain:
    popm <r6, rLink>;
84202bf4:	90 48       	popm <r6, rLink>;

    rts;
84202bf6:	d8 4c       	rts;
