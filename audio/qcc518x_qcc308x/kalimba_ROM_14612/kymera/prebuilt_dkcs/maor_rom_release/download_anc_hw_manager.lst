
/home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/tools/KCSMaker/out/14612/maor_rom_release/download/debugbin/download_anc_hw_manager.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_ahm_create>:
Capability API Handlers
*/

bool ahm_create(OPERATOR_DATA *op_data, void *message_data,
                 unsigned *response_id, void **resp_data)
{
84200000:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200002:	16 00       	r4 = r0 + Null;
84200004:	29 09       	r7 = r3 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200006:	ff fd 04 f0 	call (m) 0x8ea;
8420000a:	25 e7 
8420000c:	42 de       	M[FP + 32] = r0;
    unsigned *p_default_params;     /* Pointer to default params */
    unsigned *p_cap_params;         /* Pointer to capability params */
    CPS_PARAM_DEF *p_param_def;     /* Pointer to parameter definition */
    int i;
    AHM_GAIN *p_path, *p_nom_path;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
8420000e:	72 88       	r0 = M[r4 + 4];
84200010:	52 55       	r0 = r0 LSHIFT 6;
84200012:	40 f0 00 f2 	rMAC = r0 OR 0x4000;
84200016:	51 d8 
84200018:	49 de       	M[FP + 36] = rMAC;
    /* NB: create is passed a zero-initialized structure so any fields not
     * explicitly initialized are 0.
     */

    L5_DBG_MSG2("OPID: %x, AHM Create: p_ext_data at %p",ext_op_id, p_ext_data);
8420001a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420001e:	48 25       	Null = rMAC - 5;
84200020:	09 68       	if LT jump (m) Lc_ahm_create_3;

84200022 <Lc_ahm_create_2>:
84200022:	55 f1 02 f0 	r0 = Null + 357564500;
84200026:	54 40 
84200028:	44 d8       	r2 = M[FP + 32];
8420002a:	4b d8       	r1 = M[FP + 36];
8420002c:	ff fd 08 f0 	call (m) 0x10d6;
84200030:	2b e5 

84200032 <Lc_ahm_create_3>:
    if (!base_op_create_lite(op_data, resp_data))
84200032:	4b 08       	r1 = r7 + Null;
84200034:	32 00       	r0 = r4 + Null;
84200036:	ff fd 04 f0 	call (m) 0x850;
8420003a:	3b e0 
8420003c:	10 04       	Null = r0 - Null;
8420003e:	b1 60       	if EQ jump (m) Lc_ahm_create_17;

84200040 <Lc_ahm_create_4>:
    {
        return FALSE;
    }

    /* Initialize capid and sample rate fields */
    p_ext_data->cap_id = ANC_HW_MANAGER_CAP_ID;
84200040:	21 f0 b8 40 	rMAC = Null + 16568;
84200044:	42 d8       	r0 = M[FP + 32];
84200046:	11 ee       	M[r0 + Null] = rMAC;

    /* Multi-channel create */
    if(!aud_cur_create(op_data, AHM_MAX_SOURCES, AHM_MAX_SINKS))
84200048:	c4 20       	r2 = Null + 3;
8420004a:	23 00       	r1 = r2 + Null;
8420004c:	32 00       	r0 = r4 + Null;
8420004e:	16 f0 37 ea 	call (m) $_aud_cur_create;
84200052:	10 04       	Null = r0 - Null;
84200054:	a6 60       	if EQ jump (m) Lc_ahm_create_17;

84200056 <Lc_ahm_create_5>:
    {
        return FALSE;
    }
    aud_cur_set_callbacks(op_data, ahm_start_hook, ahm_stop_hook, NULL, NULL, NULL);
84200056:	00 f0 30 cf 	push Null;
8420005a:	42 f0 04 f0 	r2 = Null + 69207185;
8420005e:	91 48 
84200060:	42 f0 03 f0 	r1 = Null + 69207075;
84200064:	23 48 
84200066:	05 00       	r3 = Null + Null;
84200068:	00 f0 30 cf 	push Null;
8420006c:	32 00       	r0 = r4 + Null;
8420006e:	18 f0 33 e2 	call (m) $_aud_cur_set_callbacks;
84200072:	7e 4c       	SP = SP + -8;
    aud_cur_set_flags(op_data,
                      AHM_SUPPORTS_IN_PLACE,
                      AHM_SUPPORTS_METADATA,
                      AHM_DYNAMIC_BUFFERS);
84200074:	45 20       	r3 = Null + 1;
84200076:	2c 00       	r2 = r3 + Null;
84200078:	23 00       	r1 = r2 + Null;
8420007a:	32 00       	r0 = r4 + Null;
8420007c:	18 f0 27 e3 	call (m) $_aud_cur_set_flags;
    aud_cur_set_min_terminal_masks(op_data,
                                   AHM_SOURCE_VALID_MASK,
                                   AHM_SINK_VALID_MASK);
84200080:	04 00       	r2 = Null + Null;
84200082:	03 00       	r1 = Null + Null;
84200084:	32 00       	r0 = r4 + Null;
84200086:	18 f0 37 e3 	call (m) $_aud_cur_set_min_terminal_masks;

    /* Initialize parameters */
    p_default_params = (unsigned*) ANC_HW_MANAGER_GetDefaults(p_ext_data->cap_id);
8420008a:	41 d8       	rMAC = M[FP + 32];
8420008c:	0a e8       	r0 = M[rMAC + Null];
8420008e:	16 f0 3d e7 	call (m) $_ANC_HW_MANAGER_GetDefaults;
84200092:	17 00       	r5 = r0 + Null;
    p_cap_params = (unsigned*) &p_ext_data->ahm_cap_params;
84200094:	41 d8       	rMAC = M[FP + 32];
84200096:	18 f0 04 20 	r6 = rMAC + 4;
    p_param_def = aud_cur_get_cps(op_data);
8420009a:	32 00       	r0 = r4 + Null;
8420009c:	18 f0 35 e3 	call (m) $_aud_cur_get_cps;
    if(!cpsInitParameters(p_param_def,
                          p_default_params,
                          p_cap_params,
                          sizeof(ANC_HW_MANAGER_PARAMETERS)))
842000a0:	05 f0 5c 40 	r3 = Null + 92;
842000a4:	44 08       	r2 = r6 + Null;
842000a6:	3b 00       	r1 = r5 + Null;
842000a8:	ff fd 05 f0 	call (m) 0xb2a;
842000ac:	23 e4 
842000ae:	10 04       	Null = r0 - Null;
842000b0:	08 62       	if NE jump (m) Lc_ahm_create_7;

842000b2 <Lc_ahm_create_6>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842000b2:	01 f0 00 60 	rMAC = Null + 4096;
842000b6:	92 f0 00 e8 	r0 = M[r7 + Null];
842000ba:	51 8e       	M[r0 + 4] = rMAC;
842000bc:	0f f0 9b e5 	jump (m) Lc_ahm_create_36;

842000c0 <Lc_ahm_create_7>:
    {
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    p_ext_data->sample_rate = (unsigned)stream_if_get_system_sampling_rate();
842000c0:	ff fd 45 f0 	call (m) 0x8b34;
842000c4:	35 e3 
842000c6:	41 d8       	rMAC = M[FP + 32];
842000c8:	0a bf       	M[rMAC + 112] = r0;
842000ca:	0a 00       	r0 = rMAC + Null;

    /* Initialize system mode. */
    p_ext_data->cur_mode = ANC_HW_MANAGER_SYSMODE_FULL;
842000cc:	81 20       	rMAC = Null + 2;
842000ce:	11 be       	M[r0 + 96] = rMAC;
    p_ext_data->host_mode = ANC_HW_MANAGER_SYSMODE_FULL;
842000d0:	51 be       	M[r0 + 100] = rMAC;
    p_ext_data->qact_mode = ANC_HW_MANAGER_SYSMODE_FULL;
842000d2:	91 be       	M[r0 + 104] = rMAC;

    p_ext_data->config.channel = AHM_ANC_INSTANCE_ANC0_ID;
842000d4:	41 20       	rMAC = Null + 1;
842000d6:	13 00       	r1 = r0 + Null;
842000d8:	21 f0 a8 8a 	MB[r0 + 168] = rMAC;
    /* Default to hybrid: ff path is FFB, fb path is FFA */
    p_ext_data->config.ff_path = AHM_ANC_PATH_FFB_ID;
842000dc:	82 20       	r0 = Null + 2;
842000de:	32 f0 a9 8a 	MB[r1 + 169] = r0;
842000e2:	1a 00       	r0 = r1 + Null;
    p_ext_data->config.fb_path = AHM_ANC_PATH_FFA_ID;
842000e4:	21 f0 aa 8a 	MB[r0 + 170] = rMAC;
    p_ext_data->anc_clock_check_value = AHM_HYBRID_ENABLE;
842000e8:	c1 23       	rMAC = Null + 15;
842000ea:	21 f0 56 8c 	MH[r0 + 172] = rMAC;
    /* Default to clock check was OK */
    p_ext_data->clock_status = TRUE;
842000ee:	41 20       	rMAC = Null + 1;
842000f0:	21 f0 ae 8a 	MB[r0 + 174] = rMAC;

    p_ext_data->p_cur_gain = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
842000f4:	43 21       	r1 = Null + 5;
842000f6:	02 29       	r0 = Null + 20;
842000f8:	ff fd 37 f0 	call (m) 0x6f8e;
842000fc:	37 e4 
842000fe:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_cur_gain == NULL)
84200100:	4a bf       	M[rMAC + 116] = r0;
84200102:	08 62       	if NE jump (m) Lc_ahm_create_9;

84200104 <Lc_ahm_create_8>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate current gain", ext_op_id);
84200104:	55 f1 02 f0 	r0 = Null + 357564539;
84200108:	7b 40 
8420010a:	4b d8       	r1 = M[FP + 36];
8420010c:	ff fd 07 f0 	call (m) 0x10c2;
84200110:	37 ed 

84200112 <Lc_ahm_create_9>:
    }
    p_ext_data->p_cur_gain1 = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
84200112:	43 21       	r1 = Null + 5;
84200114:	02 29       	r0 = Null + 20;
84200116:	ff fd 37 f0 	call (m) 0x6f8e;
8420011a:	39 e3 
8420011c:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_cur_gain1 == NULL)
8420011e:	8a bf       	M[rMAC + 120] = r0;
84200120:	08 62       	if NE jump (m) Lc_ahm_create_11;

84200122 <Lc_ahm_create_10>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate current gain1", ext_op_id);
84200122:	55 f1 02 f0 	r0 = Null + 357564586;
84200126:	aa 40 
84200128:	4b d8       	r1 = M[FP + 36];
8420012a:	ff fd 07 f0 	call (m) 0x10c2;
8420012e:	39 ec 

84200130 <Lc_ahm_create_11>:
    }
    p_ext_data->p_prev_gain = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
84200130:	43 21       	r1 = Null + 5;
84200132:	02 29       	r0 = Null + 20;
84200134:	ff fd 37 f0 	call (m) 0x6f8e;
84200138:	3b e2 
8420013a:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_prev_gain == NULL)
8420013c:	ca bf       	M[rMAC + 124] = r0;
8420013e:	08 62       	if NE jump (m) Lc_ahm_create_13;

84200140 <Lc_ahm_create_12>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate previous gain", ext_op_id);
84200140:	55 f1 02 f0 	r0 = Null + 357564634;
84200144:	da 40 
84200146:	4b d8       	r1 = M[FP + 36];
84200148:	ff fd 07 f0 	call (m) 0x10c2;
8420014c:	3b eb 

8420014e <Lc_ahm_create_13>:
    }
    ahm_initialize_prev_gain(p_ext_data->p_prev_gain);
8420014e:	41 d8       	rMAC = M[FP + 32];
84200150:	ca b9       	r0 = M[rMAC + 124];
84200152:	11 f0 3b e4 	call (m) $_ahm_initialize_prev_gain;
    p_ext_data->p_prev_gain1 = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
84200156:	43 21       	r1 = Null + 5;
84200158:	02 29       	r0 = Null + 20;
8420015a:	ff fd 37 f0 	call (m) 0x6f8e;
8420015e:	35 e1 
84200160:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_prev_gain1 == NULL)
84200162:	12 f0 20 8e 	M[rMAC + 128] = r0;
84200166:	08 62       	if NE jump (m) Lc_ahm_create_15;

84200168 <Lc_ahm_create_14>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate previous gain1", ext_op_id);
84200168:	55 f1 02 f0 	r0 = Null + 357564682;
8420016c:	0a 41 
8420016e:	4b d8       	r1 = M[FP + 36];
84200170:	ff fd 07 f0 	call (m) 0x10c2;
84200174:	33 ea 

84200176 <Lc_ahm_create_15>:
    }
    ahm_initialize_prev_gain(p_ext_data->p_prev_gain1);
84200176:	41 d8       	rMAC = M[FP + 32];
84200178:	12 f0 20 88 	r0 = M[rMAC + 128];
8420017c:	11 f0 31 e3 	call (m) $_ahm_initialize_prev_gain;
    p_ext_data->p_static_gain = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
84200180:	43 21       	r1 = Null + 5;
84200182:	02 29       	r0 = Null + 20;
84200184:	ff fd 37 f0 	call (m) 0x6f8e;
84200188:	2b e0 
8420018a:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_static_gain == NULL)
8420018c:	12 f0 21 8e 	M[rMAC + 132] = r0;
84200190:	0a 62       	if NE jump (m) Lc_ahm_create_18;

84200192 <Lc_ahm_create_16>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate static gain", ext_op_id);
84200192:	55 f1 02 f0 	r0 = Null + 357564731;
84200196:	3b 41 
84200198:	4b d8       	r1 = M[FP + 36];
8420019a:	ff fd 07 f0 	call (m) 0x10c2;
8420019e:	29 e9 

842001a0 <Lc_ahm_create_17>:
     */

    L5_DBG_MSG2("OPID: %x, AHM Create: p_ext_data at %p",ext_op_id, p_ext_data);
    if (!base_op_create_lite(op_data, resp_data))
    {
        return FALSE;
842001a0:	02 00       	r0 = Null + Null;
842001a2:	db 6e       	jump (m) Lc_ahm_create_37;

842001a4 <Lc_ahm_create_18>:
    if (p_ext_data->p_static_gain == NULL)
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate static gain", ext_op_id);
        return FALSE;
    }
    p_ext_data->p_static_gain1 = xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
842001a4:	43 21       	r1 = Null + 5;
842001a6:	02 29       	r0 = Null + 20;
842001a8:	ff fd 36 f0 	call (m) 0x6f8e;
842001ac:	27 ef 
842001ae:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_static_gain1 == NULL)
842001b0:	12 f0 22 8e 	M[rMAC + 136] = r0;
842001b4:	09 62       	if NE jump (m) Lc_ahm_create_20;

842001b6 <Lc_ahm_create_19>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate inst1 static gain", ext_op_id);
842001b6:	55 f1 02 f0 	r0 = Null + 357564777;
842001ba:	69 41 
842001bc:	4b d8       	r1 = M[FP + 36];
842001be:	ff fd 07 f0 	call (m) 0x10c2;
842001c2:	25 e8 
842001c4:	ee 6f       	jump (m) Lc_ahm_create_17;

842001c6 <Lc_ahm_create_20>:
        return FALSE;
    }
    p_ext_data->p_nominal_gain = \
        xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
842001c6:	43 21       	r1 = Null + 5;
842001c8:	02 29       	r0 = Null + 20;
842001ca:	ff fd 36 f0 	call (m) 0x6f8e;
842001ce:	25 ee 
842001d0:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_nominal_gain == NULL)
842001d2:	12 f0 23 8e 	M[rMAC + 140] = r0;
842001d6:	09 62       	if NE jump (m) Lc_ahm_create_22;

842001d8 <Lc_ahm_create_21>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate nominal gain", ext_op_id);
842001d8:	55 f1 02 f0 	r0 = Null + 357564829;
842001dc:	9d 41 
842001de:	4b d8       	r1 = M[FP + 36];
842001e0:	ff fd 07 f0 	call (m) 0x10c2;
842001e4:	23 e7 
842001e6:	dd 6f       	jump (m) Lc_ahm_create_17;

842001e8 <Lc_ahm_create_22>:
        return FALSE;
    }
    p_ext_data->p_nominal_gain1 = \
        xzppnew(AHM_GAIN_BANK, MALLOC_PREFERENCE_SHARED);
842001e8:	43 21       	r1 = Null + 5;
842001ea:	02 29       	r0 = Null + 20;
842001ec:	ff fd 36 f0 	call (m) 0x6f8e;
842001f0:	23 ed 
842001f2:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_nominal_gain1 == NULL)
842001f4:	12 f0 24 8e 	M[rMAC + 144] = r0;
842001f8:	09 62       	if NE jump (m) Lc_ahm_create_24;

842001fa <Lc_ahm_create_23>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: failed to allocate nominal gain1", ext_op_id);
842001fa:	55 f1 02 f0 	r0 = Null + 357564876;
842001fe:	cc 41 
84200200:	4b d8       	r1 = M[FP + 36];
84200202:	ff fd 07 f0 	call (m) 0x10c2;
84200206:	21 e6 
84200208:	cc 6f       	jump (m) Lc_ahm_create_17;

8420020a <Lc_ahm_create_24>:
        return FALSE;
    }
    p_ext_data->p_iir_filter_inst1 = \
        xzppnew(AHM_IIR_FILTER_BANK, MALLOC_PREFERENCE_NONE);
8420020a:	c3 20       	r1 = Null + 3;
8420020c:	02 f0 cc 40 	r0 = Null + 204;
84200210:	ff fd 36 f0 	call (m) 0x6f8e;
84200214:	3f eb 
84200216:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_iir_filter_inst1 == NULL)
84200218:	12 f0 a2 8e 	M[rMAC + 648] = r0;
8420021c:	09 62       	if NE jump (m) Lc_ahm_create_26;

8420021e <Lc_ahm_create_25>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: Failed to allocate IIR Filter1", ext_op_id);
8420021e:	55 f1 02 f0 	r0 = Null + 357564924;
84200222:	fc 41 
84200224:	4b d8       	r1 = M[FP + 36];
84200226:	ff fd 07 f0 	call (m) 0x10c2;
8420022a:	3d e4 
8420022c:	ba 6f       	jump (m) Lc_ahm_create_17;

8420022e <Lc_ahm_create_26>:
        return FALSE;
    }
    p_ext_data->p_iir_filter_inst2 = \
        xzppnew(AHM_IIR_FILTER_BANK, MALLOC_PREFERENCE_NONE);
8420022e:	c3 20       	r1 = Null + 3;
84200230:	02 f0 cc 40 	r0 = Null + 204;
84200234:	ff fd 36 f0 	call (m) 0x6f8e;
84200238:	3b ea 
8420023a:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_iir_filter_inst2 == NULL)
8420023c:	12 f0 a3 8e 	M[rMAC + 652] = r0;
84200240:	09 62       	if NE jump (m) Lc_ahm_create_28;

84200242 <Lc_ahm_create_27>:
    {
        L0_DBG_MSG1("OPID: %x, AHM:Failed to allocate IIR Filter2", ext_op_id);
84200242:	55 f1 02 f0 	r0 = Null + 357564970;
84200246:	2a 42 
84200248:	4b d8       	r1 = M[FP + 36];
8420024a:	ff fd 07 f0 	call (m) 0x10c2;
8420024e:	39 e3 
84200250:	a8 6f       	jump (m) Lc_ahm_create_17;

84200252 <Lc_ahm_create_28>:
        return FALSE;

    }
    /* previous filter place holder */
    p_ext_data->p_prev_iir_filter_inst1 = \
        xzppnew(AHM_IIR_FILTER_BANK, MALLOC_PREFERENCE_NONE);
84200252:	c3 20       	r1 = Null + 3;
84200254:	02 f0 cc 40 	r0 = Null + 204;
84200258:	ff fd 36 f0 	call (m) 0x6f8e;
8420025c:	37 e9 
8420025e:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_prev_iir_filter_inst1 == NULL)
84200260:	12 f0 a4 8e 	M[rMAC + 656] = r0;
84200264:	09 62       	if NE jump (m) Lc_ahm_create_30;

84200266 <Lc_ahm_create_29>:
    {
        L0_DBG_MSG1("OPID: %x, AHM: Failed to allocate IIR Filter1 Place-holder", ext_op_id);
84200266:	55 f1 02 f0 	r0 = Null + 357565015;
8420026a:	57 42 
8420026c:	4b d8       	r1 = M[FP + 36];
8420026e:	ff fd 07 f0 	call (m) 0x10c2;
84200272:	35 e2 
84200274:	96 6f       	jump (m) Lc_ahm_create_17;

84200276 <Lc_ahm_create_30>:
        return FALSE;
    }
    p_ext_data->p_prev_iir_filter_inst2 = \
        xzppnew(AHM_IIR_FILTER_BANK, MALLOC_PREFERENCE_NONE);
84200276:	c3 20       	r1 = Null + 3;
84200278:	02 f0 cc 40 	r0 = Null + 204;
8420027c:	ff fd 36 f0 	call (m) 0x6f8e;
84200280:	33 e8 
84200282:	41 d8       	rMAC = M[FP + 32];
    if (p_ext_data->p_prev_iir_filter_inst2 == NULL)
84200284:	12 f0 a5 8e 	M[rMAC + 660] = r0;
84200288:	09 62       	if NE jump (m) Lc_ahm_create_32;

8420028a <Lc_ahm_create_31>:
    {
        L0_DBG_MSG1("OPID: %x, AHM:Failed to allocate IIR Filter2 Place-holder", ext_op_id);
8420028a:	55 f1 02 f0 	r0 = Null + 357565074;
8420028e:	92 42 
84200290:	4b d8       	r1 = M[FP + 36];
84200292:	ff fd 07 f0 	call (m) 0x10c2;
84200296:	31 e1 
84200298:	84 6f       	jump (m) Lc_ahm_create_17;

8420029a <Lc_ahm_create_32>:
        return FALSE;
    }

    p_path = &p_ext_data->p_cur_gain->ff;
8420029a:	41 d8       	rMAC = M[FP + 32];
8420029c:	10 f0 0b f0 	r9 = Null + 16777216;
842002a0:	00 40 
842002a2:	1a f0 1d 88 	r8 = M[rMAC + 116];
842002a6:	01 f0 2c 45 	rMAC = rMAC + 300;
    p_nom_path = &p_ext_data->p_nominal_gain->ff;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842002aa:	06 00       	r4 = Null + Null;
842002ac:	0f 00       	r5 = rMAC + Null;
842002ae:	18 f3 98 3b 	r6 = rMAC + -104;
842002b2:	19 f0 24 20 	r7 = rMAC + 36;

842002b6 <Lc_ahm_create_33>:
    {
        /* Create the fine gain ramps */
        p_ext_data->p_fine_delta_ramp[i] = \
            ahm_list_fine_gain_add(&p_ext_data->p_fine_delta_head[i], ext_op_id);
842002b6:	72 f3 e8 3b 	r0 = r5 + -24;
842002ba:	4b d8       	r1 = M[FP + 36];
842002bc:	11 f0 2d ea 	call (m) $_ahm_list_fine_gain_add;
842002c0:	3a ee       	M[r5 + Null] = r0;
        if (p_ext_data->p_fine_delta_ramp[i] == NULL)
842002c2:	39 e8       	rMAC = M[r5 + Null];
842002c4:	6e 61       	if EQ jump (m) Lc_ahm_create_17;

842002c6 <Lc_ahm_create_34>:
        {
            return FALSE;
        }
        p_ext_data->p_fine_delta_ramp[i]->gain_delta = AHM_DELTA_NOMINAL;
842002c6:	1b f0 00 ee 	M[rMAC + Null] = r9;

        /* Point the delta fine ramps to the right gains */
        p_ext_data->fine_ramp[i].p_cur = &p_path->fine;
842002ca:	a1 f0 02 20 	rMAC = r8 + 2;
842002ce:	81 f0 02 8e 	M[r6 + 8] = rMAC;
        p_ext_data->fine_ramp[i].p_gain = p_ext_data->p_fine_delta_ramp[i];
842002d2:	3a e8       	r0 = M[r5 + Null];
842002d4:	82 f0 00 ee 	M[r6 + Null] = r0;

        /* Initialize the nominal gain pointers */
        p_ext_data->p_fine_nominal[i] = &p_ext_data->ahm_fine_nominal[i];
842002d8:	79 f0 03 8e 	M[r5 + 12] = r7;
        /* Use same static gains (i.e ahm nominal nominal) for both instances */
        p_ext_data->p_fine_nominal1[i] = &p_ext_data->ahm_fine_nominal1[i];
842002dc:	92 f0 48 20 	r0 = r7 + 72;
842002e0:	ba 8f       	M[r5 + 24] = r0;

        p_path++;
842002e2:	1a f0 02 20 	r8 = rMAC + 2;
    }

    p_path = &p_ext_data->p_cur_gain->ff;
    p_nom_path = &p_ext_data->p_nominal_gain->ff;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842002e6:	76 20       	r4 = r4 + 1;
842002e8:	3f 21       	r5 = r5 + 4;
842002ea:	08 f0 20 44 	r6 = r6 + 32;
842002ee:	c1 75       	r7 = r7 + 24;
842002f0:	f0 24       	Null = r4 - 3;
842002f2:	e2 69       	if LT jump (m) Lc_ahm_create_33;

842002f4 <Lc_ahm_create_35>:

        p_path++;
        p_nom_path++;
    }

    p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID].path = AHM_EVENT_ID_FF_RAMP;
842002f4:	41 d8       	rMAC = M[FP + 32];
842002f6:	0a 00       	r0 = rMAC + Null;
842002f8:	10 f0 68 8c 	MH[rMAC + 208] = Null;
    p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID].path = AHM_EVENT_ID_FB_RAMP;
842002fc:	41 20       	rMAC = Null + 1;
842002fe:	21 f0 78 8c 	MH[r0 + 240] = rMAC;
    p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID].path = AHM_EVENT_ID_EC_RAMP;
84200302:	c1 21       	rMAC = Null + 7;
84200304:	21 f0 88 8c 	MH[r0 + 272] = rMAC;

    p_ext_data->timer_period = AHM_DEF_TIMER_PERIOD_US;
84200308:	01 f0 fa 40 	rMAC = Null + 250;
8420030c:	21 f0 ae 8e 	M[r0 + 696] = rMAC;
    p_ext_data->timer_decimation = AHM_DEF_TIMER_DECIMATION;
84200310:	01 21       	rMAC = Null + 4;
84200312:	21 f0 60 8d 	MH[r0 + 704] = rMAC;
84200316:	11 00       	rMAC = r0 + Null;
    p_ext_data->samples_per_period = \
        ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                    p_ext_data->timer_period,
                                    p_ext_data->timer_decimation);
84200318:	09 b9       	rMAC = M[rMAC + 112];
{
    /* sample_rate / 1000 = samples per ms
     * timer_period / 1000 * decimation = period in ms
     * multiply together for samples per period
     */
    unsigned raw_samples = (sample_rate * timer_period) / 1000000;
8420031a:	7d f1 92 c9 	r0 = rMAC * 250 (int);
8420031e:	00 f0 a3 f7 	r1 = Null + 1000000;
84200322:	40 42 
84200324:	ff fd cf f0 	call (m) 0x1a136;
84200328:	33 e0 
    return raw_samples * (unsigned)decimation;
8420032a:	52 54       	r0 = r0 LSHIFT 2;
}
8420032c:	41 d8       	rMAC = M[FP + 32];
8420032e:	12 f0 ad 8e 	M[rMAC + 692] = r0;
84200332:	0a 00       	r0 = rMAC + Null;
    p_ext_data->timer_decimation = AHM_DEF_TIMER_DECIMATION;
    p_ext_data->samples_per_period = \
        ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                    p_ext_data->timer_period,
                                    p_ext_data->timer_decimation);
    p_ext_data->fast_rate = AHM_DEF_FAST_RATE;
84200334:	01 f0 a0 5b 	rMAC = Null + 4000;
84200338:	21 f0 b1 8e 	M[r0 + 708] = rMAC;
    p_ext_data->slow_rate = AHM_DEF_SLOW_RATE;
8420033c:	01 f0 e8 43 	rMAC = Null + 1000;
84200340:	21 f0 b2 8e 	M[r0 + 712] = rMAC;

    /* Turn on double banking for ANC HW Filter coefficients for both
       ANC instances */
    #ifndef RUNNING_ON_KALSIM
       stream_anc_select_active_iir_coeffs(STREAM_ANC_INSTANCE_ANC01_MASK,
                                           STREAM_ANC_BANK_BACKGROUND);
84200344:	43 20       	r1 = Null + 1;
84200346:	c2 20       	r0 = Null + 3;
84200348:	ff fd 64 f0 	call (m) 0xccf2;
8420034c:	2b ed 
    #endif

    /* Initialize AHM event message */
    p_ext_data->event_msg.ext_op_id = ext_op_id;
8420034e:	4a d8       	r0 = M[FP + 36];
84200350:	41 d8       	rMAC = M[FP + 32];
84200352:	12 f0 27 8e 	M[rMAC + 156] = r0;

84200356 <Lc_ahm_create_36>:
                          p_default_params,
                          p_cap_params,
                          sizeof(ANC_HW_MANAGER_PARAMETERS)))
    {
        base_op_change_response_status(resp_data, STATUS_CMD_FAILED);
        return TRUE;
84200356:	42 20       	r0 = Null + 1;

84200358 <Lc_ahm_create_37>:
    #endif

    /* Initialize AHM event message */
    p_ext_data->event_msg.ext_op_id = ext_op_id;
    return TRUE;
}
84200358:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420035a:	d8 4c       	rts;

8420035c <$_ahm_destroy>:

bool ahm_destroy(OPERATOR_DATA *op_data, void *message_data,
                  unsigned *response_id, void **resp_data)
{
8420035c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420035e:	10 09       	r6 = r0 + Null;
84200360:	2f 00       	r5 = r3 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200362:	ff fd 02 f0 	call (m) 0x8ea;
84200366:	29 ec 
84200368:	16 00       	r4 = r0 + Null;
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);
    int i;

    /* call base_op destroy that creates and fills response message, too */
    if (!base_op_destroy_lite(op_data, resp_data))
8420036a:	3b 00       	r1 = r5 + Null;
8420036c:	42 08       	r0 = r6 + Null;
8420036e:	ff fd 02 f0 	call (m) 0x834;
84200372:	27 e6 
84200374:	10 04       	Null = r0 - Null;
84200376:	03 62       	if NE jump (m) Lc_ahm_destroy_3;

84200378 <Lc_ahm_destroy_2>:
    {
        return FALSE;
84200378:	02 00       	r0 = Null + Null;
8420037a:	52 6e       	jump (m) Lc_ahm_destroy_6;

8420037c <Lc_ahm_destroy_3>:
    }
    aud_cur_destroy(op_data);
8420037c:	42 08       	r0 = r6 + Null;
8420037e:	15 f0 25 e5 	call (m) $_aud_cur_destroy;

    pdelete(p_ext_data->p_cur_gain);
84200382:	72 b9       	r0 = M[r4 + 116];
84200384:	ff fd 36 f0 	call (m) 0x6fbe;
84200388:	3b e1 
    pdelete(p_ext_data->p_cur_gain1);
8420038a:	b2 b9       	r0 = M[r4 + 120];
8420038c:	ff fd 36 f0 	call (m) 0x6fbe;
84200390:	33 e1 
    pdelete(p_ext_data->p_prev_gain);
84200392:	f2 b9       	r0 = M[r4 + 124];
84200394:	ff fd 36 f0 	call (m) 0x6fbe;
84200398:	2b e1 
    pdelete(p_ext_data->p_prev_gain1);
8420039a:	62 f0 20 88 	r0 = M[r4 + 128];
8420039e:	ff fd 36 f0 	call (m) 0x6fbe;
842003a2:	21 e1 
    pdelete(p_ext_data->p_static_gain);
842003a4:	62 f0 21 88 	r0 = M[r4 + 132];
842003a8:	ff fd 36 f0 	call (m) 0x6fbe;
842003ac:	37 e0 
    pdelete(p_ext_data->p_static_gain1);
842003ae:	62 f0 22 88 	r0 = M[r4 + 136];
842003b2:	ff fd 36 f0 	call (m) 0x6fbe;
842003b6:	2d e0 
    pdelete(p_ext_data->p_nominal_gain);
842003b8:	62 f0 23 88 	r0 = M[r4 + 140];
842003bc:	ff fd 36 f0 	call (m) 0x6fbe;
842003c0:	23 e0 
    pdelete(p_ext_data->p_nominal_gain1);
842003c2:	62 f0 24 88 	r0 = M[r4 + 144];
842003c6:	ff fd 35 f0 	call (m) 0x6fbe;
842003ca:	39 ef 
    pdelete(p_ext_data->p_iir_filter_inst1);
842003cc:	62 f0 a2 88 	r0 = M[r4 + 648];
842003d0:	ff fd 35 f0 	call (m) 0x6fbe;
842003d4:	2f ef 
    pdelete(p_ext_data->p_iir_filter_inst2);
842003d6:	62 f0 a3 88 	r0 = M[r4 + 652];
842003da:	ff fd 35 f0 	call (m) 0x6fbe;
842003de:	25 ef 
    pdelete(p_ext_data->p_prev_iir_filter_inst1);
842003e0:	62 f0 a4 88 	r0 = M[r4 + 656];
842003e4:	ff fd 35 f0 	call (m) 0x6fbe;
842003e8:	3b ee 
    pdelete(p_ext_data->p_prev_iir_filter_inst2);
842003ea:	62 f0 a5 88 	r0 = M[r4 + 660];
842003ee:	ff fd 35 f0 	call (m) 0x6fbe;
842003f2:	31 ee 

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842003f4:	07 00       	r5 = Null + Null;
842003f6:	06 f0 14 45 	r4 = r4 + 276;

842003fa <Lc_ahm_destroy_4>:
    {
        ahm_list_fine_gain_remove(&p_ext_data->p_fine_delta_head[i],
                                  p_ext_data->p_fine_delta_ramp[i],
                                  INT_TO_EXT_OPID(op_data->id));
842003fa:	82 f0 01 88 	r0 = M[r6 + 4];
842003fe:	b3 89       	r1 = M[r4 + 24];
84200400:	52 55       	r0 = r0 LSHIFT 6;
84200402:	40 f0 00 f2 	r2 = r0 OR 0x4000;
84200406:	54 d8 
84200408:	32 00       	r0 = r4 + Null;
8420040a:	11 f0 31 e1 	call (m) $_ahm_list_fine_gain_remove;
        ahm_list_destroy(&p_ext_data->p_fine_delta_head[i]);
8420040e:	32 00       	r0 = r4 + Null;
84200410:	11 f0 27 e4 	call (m) $_ahm_list_destroy;
    pdelete(p_ext_data->p_iir_filter_inst1);
    pdelete(p_ext_data->p_iir_filter_inst2);
    pdelete(p_ext_data->p_prev_iir_filter_inst1);
    pdelete(p_ext_data->p_prev_iir_filter_inst2);

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84200414:	7f 20       	r5 = r5 + 1;
84200416:	36 21       	r4 = r4 + 4;
84200418:	f8 24       	Null = r5 - 3;
8420041a:	f0 69       	if LT jump (m) Lc_ahm_destroy_4;

8420041c <Lc_ahm_destroy_5>:
                                  p_ext_data->p_fine_delta_ramp[i],
                                  INT_TO_EXT_OPID(op_data->id));
        ahm_list_destroy(&p_ext_data->p_fine_delta_head[i]);
    }

    return TRUE;
8420041c:	42 20       	r0 = Null + 1;

8420041e <Lc_ahm_destroy_6>:
}
8420041e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200420:	d8 4c       	rts;

84200422 <$_ahm_start_hook>:

bool ahm_start_hook(OPERATOR_DATA *op_data)
{
84200422:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200424:	16 00       	r4 = r0 + Null;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84200426:	ff fd 02 f0 	call (m) 0x934;
8420042a:	2f e8 
8420042c:	10 09       	r6 = r0 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
8420042e:	32 00       	r0 = r4 + Null;
84200430:	ff fd 02 f0 	call (m) 0x8ea;
84200434:	3b e5 
84200436:	17 00       	r5 = r0 + Null;
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    /* Start a casual timer task if there are no connections */
    if (p_class_data->sinks.connected == 0 &&
        p_class_data->sources.connected == 0 &&
        p_ext_data->timer_period > 0)
84200438:	81 f0 07 86 	rMAC = MHU[r6 + 14];
8420043c:	27 62       	if NE jump (m) Lc_ahm_start_hook_7;

8420043e <Lc_ahm_start_hook_2>:
8420043e:	81 f0 0d 86 	rMAC = MHU[r6 + 26];
84200442:	24 62       	if NE jump (m) Lc_ahm_start_hook_7;

84200444 <Lc_ahm_start_hook_3>:
84200444:	70 f0 ae 88 	Null = M[r5 + 696];
84200448:	21 60       	if EQ jump (m) Lc_ahm_start_hook_7;

8420044a <Lc_ahm_start_hook_4>:
    {
        L4_DBG_MSG1("OPID: %x, AHM starting timer", INT_TO_EXT_OPID(op_data->id));
8420044a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420044e:	08 25       	Null = rMAC - 4;
84200450:	0c 68       	if LT jump (m) Lc_ahm_start_hook_6;

84200452 <Lc_ahm_start_hook_5>:
84200452:	72 88       	r0 = M[r4 + 4];
84200454:	52 55       	r0 = r0 LSHIFT 6;
84200456:	40 f0 00 f2 	r1 = r0 OR 0x4000;
8420045a:	53 d8 
8420045c:	55 f1 02 f0 	r0 = Null + 357565132;
84200460:	cc 42 
84200462:	ff fd 06 f0 	call (m) 0x10c2;
84200466:	21 e3 

84200468 <Lc_ahm_start_hook_6>:
        p_ext_data->timer_id=timer_schedule_bg_event_in(p_ext_data->timer_period,
                                                        ahm_timer_cb,
                                                        (void*)op_data);
84200468:	42 f0 08 f0 	r6 = Null + 69210797;
8420046c:	ad 62 
8420046e:	79 f0 ae 88 	r7 = M[r5 + 696];
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    /* Convert time_in to be absolute time */
    TIME event_time = time_add(time_get_time(), time_in);
84200472:	ff fd 31 f0 	call (m) 0x679c;
84200476:	2b e9 
84200478:	4a 0c       	r0 = r7 + r0;

    /* earliest and latest time is the same */
    return create_add_casual_event(
                event_time, event_time, TimerEventFunction, data_pointer);
8420047a:	35 00       	r3 = r4 + Null;
8420047c:	44 08       	r2 = r6 + Null;
8420047e:	13 00       	r1 = r0 + Null;
84200480:	ff fd 31 f0 	call (m) 0x6820;
84200484:	21 ed 
}
84200486:	72 f0 af 8e 	M[r5 + 700] = r0;

8420048a <Lc_ahm_start_hook_7>:
    }


    return TRUE;
8420048a:	42 20       	r0 = Null + 1;

8420048c <Lc_ahm_start_hook_8>:
}
8420048c:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420048e:	d8 4c       	rts;

84200490 <$_ahm_stop_hook>:

bool ahm_stop_hook(OPERATOR_DATA *op_data)
{
84200490:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200492:	17 00       	r5 = r0 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200494:	ff fd 02 f0 	call (m) 0x8ea;
84200498:	37 e2 
8420049a:	16 00       	r4 = r0 + Null;
bool ahm_stop_hook(OPERATOR_DATA *op_data)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    /* Cancel casual timer */
    L4_DBG_MSG1("OPID: %x, AHM stopping timer", INT_TO_EXT_OPID(op_data->id));
8420049c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842004a0:	08 25       	Null = rMAC - 4;
842004a2:	0c 68       	if LT jump (m) Lc_ahm_stop_hook_3;

842004a4 <Lc_ahm_stop_hook_2>:
842004a4:	7a 88       	r0 = M[r5 + 4];
842004a6:	52 55       	r0 = r0 LSHIFT 6;
842004a8:	40 f0 00 f2 	r1 = r0 OR 0x4000;
842004ac:	53 d8 
842004ae:	55 f1 02 f0 	r0 = Null + 357565161;
842004b2:	e9 42 
842004b4:	ff fd 06 f0 	call (m) 0x10c2;
842004b8:	2f e0 

842004ba <Lc_ahm_stop_hook_3>:
    timer_cancel_event(p_ext_data->timer_id);
842004ba:	62 f0 af 88 	r0 = M[r4 + 700];
 */
extern bool timer_cancel_event_ret(tTimerId timer_id, uint16 *piarg, void **pdata);

INLINE_SECTION static inline void timer_cancel_event(tTimerId timer_id)
{
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
842004be:	04 00       	r2 = Null + Null;
842004c0:	03 00       	r1 = Null + Null;
842004c2:	ff fd 32 f0 	call (m) 0x6936;
842004c6:	35 e3 

    return TRUE;
842004c8:	42 20       	r0 = Null + 1;

842004ca <Lc_ahm_stop_hook_4>:
}
842004ca:	f2 48       	popm <FP, r4, r5, rLink>;
842004cc:	d8 4c       	rts;

842004ce <$_ahm_opmsg_set_control>:
}

bool ahm_opmsg_set_control(OPERATOR_DATA *op_data, void *message_data,
                            unsigned *resp_length,
                            OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004ce:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842004d0:	53 4c       	SP = SP + 76;
842004d2:	11 09       	r7 = r0 + Null;
842004d4:	43 de       	M[FP + 32] = r1;
842004d6:	27 00       	r5 = r2 + Null;
842004d8:	4d de       	M[FP + 36] = r3;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842004da:	ff fd 02 f0 	call (m) 0x8ea;
842004de:	31 e0 
842004e0:	16 00       	r4 = r0 + Null;

    unsigned sel_override, sel_bank, sel_type;
    AHM_GAIN *p_sel_bank;
    uint16 *p_override;
    AHM_RAMP_CONFIG cfg;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
842004e2:	92 f0 01 88 	r0 = M[r7 + 4];
842004e6:	52 55       	r0 = r0 LSHIFT 6;
842004e8:	40 f0 00 f2 	rMAC = r0 OR 0x4000;
842004ec:	51 d8 
842004ee:	51 de       	M[FP + 40] = rMAC;
    if(!cps_control_setup(message_data, resp_length, resp_data, &num_controls))
842004f0:	c5 14       	r3 = FP + 76;
842004f2:	3b 00       	r1 = r5 + Null;
842004f4:	4c d8       	r2 = M[FP + 36];
842004f6:	42 d8       	r0 = M[FP + 32];
842004f8:	ff fd 04 f0 	call (m) 0xe9e;
842004fc:	27 ed 
842004fe:	10 04       	Null = r0 - Null;
84200500:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_3;

84200502 <Lc_ahm_opmsg_set_control_2>:
    {
       return FALSE;
84200502:	02 00       	r0 = Null + Null;
84200504:	0f f0 bf e9 	jump (m) Lc_ahm_opmsg_set_control_86;

84200508 <Lc_ahm_opmsg_set_control_3>:
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_control Fn entry", ext_op_id);


    /* Iterate through the control messages looking for mode and gain override
     * messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
84200508:	58 de       	M[FP + 44] = Null;
8420050a:	c1 23       	rMAC = Null + 15;
8420050c:	0b 71       	r9 = Null + 1;
8420050e:	61 de       	M[FP + 48] = rMAC;
84200510:	41 22       	rMAC = Null + 9;
84200512:	69 de       	M[FP + 52] = rMAC;
84200514:	41 20       	rMAC = Null + 1;
84200516:	71 de       	M[FP + 56] = rMAC;
84200518:	81 20       	rMAC = Null + 2;
8420051a:	79 de       	M[FP + 60] = rMAC;
8420051c:	81 21       	rMAC = Null + 6;
8420051e:	81 de       	M[FP + 64] = rMAC;
84200520:	01 21       	rMAC = Null + 4;
84200522:	89 de       	M[FP + 68] = rMAC;
84200524:	c1 20       	rMAC = Null + 3;
84200526:	91 de       	M[FP + 72] = rMAC;
    for (i=0; i<num_controls; i++)
84200528:	02 09       	r8 = Null + Null;
8420052a:	04 6e       	jump (m) Lc_ahm_opmsg_set_control_6;

8420052c <Lc_ahm_opmsg_set_control_4>:

            ahm_write_gain_generic(op_data);
            continue;
        }

        result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
8420052c:	01 21       	rMAC = Null + 4;
8420052e:	59 de       	M[FP + 44] = rMAC;

84200530 <Lc_ahm_opmsg_set_control_5>:


    /* Iterate through the control messages looking for mode and gain override
     * messages */
    result = OPMSG_RESULT_STATES_NORMAL_STATE;
    for (i=0; i<num_controls; i++)
84200530:	0a 75       	r8 = r8 + 1;

84200532 <Lc_ahm_opmsg_set_control_6>:
84200532:	99 d8       	rMAC = M[FP + 76];
84200534:	1f fa 00 c2 	Null = r8 - rMAC;
84200538:	02 f0 a7 e0 	if C jump (m) Lc_ahm_opmsg_set_control_10;

8420053c <Lc_ahm_opmsg_set_control_7>:
    {
        ctrl_id = cps_control_get(message_data, i, &ctrl_value, &ctrl_src);
8420053c:	05 15       	r3 = FP + 80;
8420053e:	44 15       	r2 = FP + 84;
84200540:	53 08       	r1 = r8 + Null;
84200542:	42 d8       	r0 = M[FP + 32];
84200544:	ff fd 04 f0 	call (m) 0xee2;
84200548:	3f ec 
8420054a:	17 00       	r5 = r0 + Null;

        /* Mode override */
        if (ctrl_id == OPMSG_CONTROL_MODE_ID)
8420054c:	78 24       	Null = r5 - 1;
8420054e:	34 62       	if NE jump (m) Lc_ahm_opmsg_set_control_17;

84200550 <Lc_ahm_opmsg_set_control_8>:
        {
            ctrl_value &= AHM_SYSMODE_MASK;
84200550:	a9 d8       	rMAC = M[FP + 84];
84200552:	09 c1       	rMAC = rMAC AND 0x7;
84200554:	a9 de       	M[FP + 84] = rMAC;
            /* Check for valid mode */
            if (ctrl_value >= ANC_HW_MANAGER_SYSMODE_MAX_MODES)
84200556:	c8 25       	Null = rMAC - 7;
84200558:	0c 64       	if NC jump (m) Lc_ahm_opmsg_set_control_12;

8420055a <Lc_ahm_opmsg_set_control_9>:
            {
                result = OPMSG_RESULT_STATES_INVALID_CONTROL_VALUE;
8420055a:	41 21       	rMAC = Null + 5;
8420055c:	59 de       	M[FP + 44] = rMAC;

8420055e <Lc_ahm_opmsg_set_control_10>:

        result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
    }

    /* Set current operating mode based on override */
    if (p_ext_data->ovr_control & AHM_CONTROL_MODE_OVERRIDE)
8420055e:	f1 b8       	rMAC = M[r4 + 108];
84200560:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
84200564:	00 f0 cf e8 	if EQ jump (m) Lc_ahm_opmsg_set_control_84;

84200568 <Lc_ahm_opmsg_set_control_11>:
    {
        p_ext_data->cur_mode = p_ext_data->qact_mode;
84200568:	b1 b8       	rMAC = M[r4 + 104];
8420056a:	31 be       	M[r4 + 96] = rMAC;
8420056c:	0f f0 cb e8 	jump (m) Lc_ahm_opmsg_set_control_85;

84200570 <Lc_ahm_opmsg_set_control_12>:
                result = OPMSG_RESULT_STATES_INVALID_CONTROL_VALUE;
                break;
            }

            /* Ensure any gain updates on a mode change occur */
            ahm_initialize_prev_gain(p_ext_data->p_prev_gain);
84200570:	f2 b9       	r0 = M[r4 + 124];
84200572:	0f f0 3b e3 	call (m) $_ahm_initialize_prev_gain;
            ahm_initialize_prev_gain(p_ext_data->p_prev_gain1);
84200576:	62 f0 20 88 	r0 = M[r4 + 128];
8420057a:	0f f0 33 e3 	call (m) $_ahm_initialize_prev_gain;
            ahm_set_mode(op_data, p_ext_data, ctrl_value);
8420057e:	ac d8       	r2 = M[FP + 84];
84200580:	33 00       	r1 = r4 + Null;
84200582:	4a 08       	r0 = r7 + Null;
84200584:	08 f0 2d e4 	call (m) Lc_ahm_set_mode_1;

            /* Determine control mode source and set override flags for mode */
            if (ctrl_src == CPS_SOURCE_HOST)
84200588:	e1 f0 50 80 	rMAC = MBS[FP + 80];
8420058c:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_14;

8420058e <Lc_ahm_opmsg_set_control_13>:
            {
                p_ext_data->host_mode = ctrl_value;
8420058e:	a9 d8       	rMAC = M[FP + 84];
84200590:	71 be       	M[r4 + 100] = rMAC;
84200592:	cf 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

84200594 <Lc_ahm_opmsg_set_control_14>:
            }
            else
            {
                p_ext_data->qact_mode = ctrl_value;
84200594:	a9 d8       	rMAC = M[FP + 84];
84200596:	b1 be       	M[r4 + 104] = rMAC;
                /* Set or clear the QACT override flag.
                * &= is used to preserve the state of the gain bits in the
                * override word.
                */
                if (ctrl_src == CPS_SOURCE_OBPM_ENABLE)
84200598:	e1 f0 50 80 	rMAC = MBS[FP + 80];
8420059c:	88 24       	Null = rMAC - 2;
8420059e:	07 62       	if NE jump (m) Lc_ahm_opmsg_set_control_16;

842005a0 <Lc_ahm_opmsg_set_control_15>:
                {
                    p_ext_data->ovr_control |= AHM_CONTROL_MODE_OVERRIDE;
842005a0:	f1 b8       	rMAC = M[r4 + 108];
842005a2:	20 f0 00 f1 	rMAC = rMAC OR 0x2000;
842005a6:	51 d8 
842005a8:	f1 be       	M[r4 + 108] = rMAC;
842005aa:	c3 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

842005ac <Lc_ahm_opmsg_set_control_16>:
                }
                else
                {
                    p_ext_data->ovr_control &= AHM_OVERRIDE_MODE_MASK;
842005ac:	f1 b8       	rMAC = M[r4 + 108];
842005ae:	11 f6 ff 1f 	rMAC = rMAC AND 0xdfff;
842005b2:	f1 be       	M[r4 + 108] = rMAC;
842005b4:	be 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

842005b6 <Lc_ahm_opmsg_set_control_17>:

            continue;
        }

        /* In/Out of Ear control */
        else if (ctrl_id == ANC_HW_MANAGER_CONSTANT_IN_OUT_EAR_CTRL)
842005b6:	f8 24       	Null = r5 - 3;
842005b8:	07 62       	if NE jump (m) Lc_ahm_opmsg_set_control_19;

842005ba <Lc_ahm_opmsg_set_control_18>:
        {
            ctrl_value &= 0x01;
842005ba:	a9 d8       	rMAC = M[FP + 84];
842005bc:	09 c0       	rMAC = rMAC AND 0x1;
842005be:	a9 de       	M[FP + 84] = rMAC;
            p_ext_data->in_out_status = ctrl_value;
842005c0:	61 f0 af 8a 	MB[r4 + 175] = rMAC;

            /* No override flags indicated for in/out of ear */
            continue;
842005c4:	b6 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

842005c6 <Lc_ahm_opmsg_set_control_19>:
        }
        /* Channel control */
        else if (ctrl_id == ANC_HW_MANAGER_CONSTANT_CHANNEL_CTRL)
842005c6:	38 25       	Null = r5 - 4;
842005c8:	4d 62       	if NE jump (m) Lc_ahm_opmsg_set_control_22;

842005ca <Lc_ahm_opmsg_set_control_20>:
        {
            ctrl_value &= 0x7;
842005ca:	a9 d8       	rMAC = M[FP + 84];
842005cc:	09 c1       	rMAC = rMAC AND 0x7;
842005ce:	a9 de       	M[FP + 84] = rMAC;
            p_ext_data->config.channel = (AHM_ANC_INSTANCE)ctrl_value;
842005d0:	61 f0 a8 8a 	MB[r4 + 168] = rMAC;

            /* Copy instance0's current and previous gains to instance1's */
            if(ctrl_value == AHM_ANC_INSTANCE_DUAL_ID)
842005d4:	a9 d8       	rMAC = M[FP + 84];
842005d6:	08 25       	Null = rMAC - 4;
842005d8:	ac 63       	if NE jump (m) Lc_ahm_opmsg_set_control_5;

842005da <Lc_ahm_opmsg_set_control_21>:
            {
                p_ext_data->p_cur_gain1->ff = p_ext_data->p_cur_gain->ff;
842005da:	61 f0 78 20 	rMAC = r4 + 120;
842005de:	12 f3 ff b9 	r0 = M[rMAC + -4];
842005e2:	0b e8       	r1 = M[rMAC + Null];
842005e4:	14 e6       	r2 = MHU[r0 + Null];
842005e6:	55 86       	r3 = MHU[r0 + 2];
842005e8:	1c ec       	MH[r1 + Null] = r2;
842005ea:	5d 8c       	MH[r1 + 2] = r3;
                p_ext_data->p_cur_gain1->fb = p_ext_data->p_cur_gain->fb;
842005ec:	72 b9       	r0 = M[r4 + 116];
842005ee:	b3 b9       	r1 = M[r4 + 120];
842005f0:	94 86       	r2 = MHU[r0 + 4];
842005f2:	d5 86       	r3 = MHU[r0 + 6];
842005f4:	9c 8c       	MH[r1 + 4] = r2;
842005f6:	dd 8c       	MH[r1 + 6] = r3;
                p_ext_data->p_cur_gain1->ec = p_ext_data->p_cur_gain->ec;
842005f8:	72 b9       	r0 = M[r4 + 116];
842005fa:	b3 b9       	r1 = M[r4 + 120];
842005fc:	14 87       	r2 = MHU[r0 + 8];
842005fe:	55 87       	r3 = MHU[r0 + 10];
84200600:	1c 8d       	MH[r1 + 8] = r2;
84200602:	5d 8d       	MH[r1 + 10] = r3;
                p_ext_data->p_cur_gain1->rx_ffa_mix = p_ext_data->p_cur_gain->rx_ffa_mix;
84200604:	72 b9       	r0 = M[r4 + 116];
84200606:	b3 b9       	r1 = M[r4 + 120];
84200608:	94 87       	r2 = MHU[r0 + 12];
8420060a:	d5 87       	r3 = MHU[r0 + 14];
8420060c:	9c 8d       	MH[r1 + 12] = r2;
8420060e:	dd 8d       	MH[r1 + 14] = r3;
                p_ext_data->p_cur_gain1->rx_ffb_mix = p_ext_data->p_cur_gain->rx_ffb_mix;
84200610:	72 b9       	r0 = M[r4 + 116];
84200612:	b3 b9       	r1 = M[r4 + 120];
84200614:	14 96       	r2 = MHU[r0 + 16];
84200616:	55 96       	r3 = MHU[r0 + 18];
84200618:	1c 9c       	MH[r1 + 16] = r2;
8420061a:	5d 9c       	MH[r1 + 18] = r3;

                p_ext_data->p_prev_gain1->ff = p_ext_data->p_prev_gain->ff;
8420061c:	4a 88       	r0 = M[rMAC + 4];
8420061e:	89 88       	rMAC = M[rMAC + 8];
84200620:	13 e6       	r1 = MHU[r0 + Null];
84200622:	54 86       	r2 = MHU[r0 + 2];
84200624:	0b ec       	MH[rMAC + Null] = r1;
84200626:	4c 8c       	MH[rMAC + 2] = r2;
                p_ext_data->p_prev_gain1->fb = p_ext_data->p_prev_gain->fb;
84200628:	f1 b9       	rMAC = M[r4 + 124];
8420062a:	62 f0 20 88 	r0 = M[r4 + 128];
8420062e:	8b 86       	r1 = MHU[rMAC + 4];
84200630:	cc 86       	r2 = MHU[rMAC + 6];
84200632:	93 8c       	MH[r0 + 4] = r1;
84200634:	d4 8c       	MH[r0 + 6] = r2;
                p_ext_data->p_prev_gain1->ec = p_ext_data->p_prev_gain->ec;
84200636:	f1 b9       	rMAC = M[r4 + 124];
84200638:	62 f0 20 88 	r0 = M[r4 + 128];
8420063c:	0b 87       	r1 = MHU[rMAC + 8];
8420063e:	4c 87       	r2 = MHU[rMAC + 10];
84200640:	13 8d       	MH[r0 + 8] = r1;
84200642:	54 8d       	MH[r0 + 10] = r2;
                p_ext_data->p_prev_gain1->rx_ffa_mix = p_ext_data->p_prev_gain->rx_ffa_mix;
84200644:	f1 b9       	rMAC = M[r4 + 124];
84200646:	62 f0 20 88 	r0 = M[r4 + 128];
8420064a:	8b 87       	r1 = MHU[rMAC + 12];
8420064c:	cc 87       	r2 = MHU[rMAC + 14];
8420064e:	93 8d       	MH[r0 + 12] = r1;
84200650:	d4 8d       	MH[r0 + 14] = r2;
                p_ext_data->p_prev_gain1->rx_ffb_mix = p_ext_data->p_prev_gain->rx_ffb_mix;
84200652:	f1 b9       	rMAC = M[r4 + 124];
84200654:	62 f0 20 88 	r0 = M[r4 + 128];
84200658:	0b 96       	r1 = MHU[rMAC + 16];
8420065a:	4c 96       	r2 = MHU[rMAC + 18];
8420065c:	13 9c       	MH[r0 + 16] = r1;
8420065e:	54 9c       	MH[r0 + 18] = r2;
84200660:	68 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

84200662 <Lc_ahm_opmsg_set_control_22>:
            /* No override flags indicated for channel */
            continue;
        }

        /* Feedforward control */
        else if (ctrl_id == ANC_HW_MANAGER_CONSTANT_FEEDFORWARD_CTRL)
84200662:	78 25       	Null = r5 - 5;
84200664:	29 62       	if NE jump (m) Lc_ahm_opmsg_set_control_28;

84200666 <Lc_ahm_opmsg_set_control_23>:
        {
            ctrl_value &= 0x1;
84200666:	a9 d8       	rMAC = M[FP + 84];
84200668:	09 c0       	rMAC = rMAC AND 0x1;
            if (ctrl_value == 0)
8420066a:	a9 de       	M[FP + 84] = rMAC;
8420066c:	0c 62       	if NE jump (m) Lc_ahm_opmsg_set_control_25;

8420066e <Lc_ahm_opmsg_set_control_24>:
            {
                /* hybrid */
                p_ext_data->config.ff_path = AHM_ANC_PATH_FFB_ID;
8420066e:	79 d8       	rMAC = M[FP + 60];
84200670:	61 f0 a9 8a 	MB[r4 + 169] = rMAC;
                p_ext_data->config.fb_path = AHM_ANC_PATH_FFA_ID;
84200674:	6b f0 aa 8a 	MB[r4 + 170] = r9;
                p_ext_data->anc_clock_check_value = AHM_HYBRID_ENABLE;
84200678:	61 d8       	rMAC = M[FP + 48];
8420067a:	61 f0 56 8c 	MH[r4 + 172] = rMAC;
                p_ext_data->mode = AHM_HYBRID_ENABLE;
8420067e:	61 f0 68 8d 	MH[r4 + 720] = rMAC;
84200682:	0a 6e       	jump (m) Lc_ahm_opmsg_set_control_26;

84200684 <Lc_ahm_opmsg_set_control_25>:
            }
            else
            {
                /* feedforward only */
                p_ext_data->config.ff_path = AHM_ANC_PATH_FFA_ID;
84200684:	6b f0 a9 8a 	MB[r4 + 169] = r9;
                p_ext_data->config.fb_path = AHM_ANC_PATH_NONE_ID;
84200688:	60 f0 aa 8a 	MB[r4 + 170] = Null;
                p_ext_data->anc_clock_check_value = AHM_FEEDFORWARD_ENABLE;
8420068c:	69 d8       	rMAC = M[FP + 52];
8420068e:	61 f0 56 8c 	MH[r4 + 172] = rMAC;
                p_ext_data->mode = AHM_FEEDFORWARD_ENABLE;
84200692:	61 f0 68 8d 	MH[r4 + 720] = rMAC;

84200696 <Lc_ahm_opmsg_set_control_26>:
            }
            L4_DBG_MSG3("OPID: %x, AHM feedforward override: %d - %d",
                        ext_op_id, p_ext_data->config.ff_path,
                        p_ext_data->config.fb_path);
84200696:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420069a:	08 25       	Null = rMAC - 4;
8420069c:	4a 69       	if LT jump (m) Lc_ahm_opmsg_set_control_5;

8420069e <Lc_ahm_opmsg_set_control_27>:
8420069e:	65 f0 aa 80 	r3 = MBS[r4 + 170];
842006a2:	64 f0 a9 80 	r2 = MBS[r4 + 169];
842006a6:	55 f1 02 f0 	r0 = Null + 357565222;
842006aa:	26 43 
842006ac:	53 d8       	r1 = M[FP + 40];
842006ae:	ff fd 05 f0 	call (m) 0x10ec;
842006b2:	3f e1 
842006b4:	3e 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

842006b6 <Lc_ahm_opmsg_set_control_28>:
            /* No override flags indicated for feedforward */
            continue;
        }

        /* Ambient mode control */
        else if (ctrl_id == ANC_HW_MANAGER_CONSTANT_AMBIENT_CTRL)
842006b6:	b8 25       	Null = r5 - 6;
842006b8:	19 62       	if NE jump (m) Lc_ahm_opmsg_set_control_34;

842006ba <Lc_ahm_opmsg_set_control_29>:
        {
            ctrl_value &= 0x1;
842006ba:	a9 d8       	rMAC = M[FP + 84];
842006bc:	09 c0       	rMAC = rMAC AND 0x1;
            if (ctrl_value == 0)
842006be:	a9 de       	M[FP + 84] = rMAC;
842006c0:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_31;

842006c2 <Lc_ahm_opmsg_set_control_30>:
            {
                /* Adaptive ANC mode */
                p_ext_data->aamb_mode = ANC_HW_MANAGER_AMBIENT_CTRL_AANC;
842006c2:	60 f0 cc 9a 	MB[r4 + 716] = Null;
842006c6:	04 6e       	jump (m) Lc_ahm_opmsg_set_control_32;

842006c8 <Lc_ahm_opmsg_set_control_31>:
            }
            else
            {
                /* Adaptive ambient mode */
                p_ext_data->aamb_mode = ANC_HW_MANAGER_AMBIENT_CTRL_AAMB;
842006c8:	71 d8       	rMAC = M[FP + 56];
842006ca:	61 f0 cc 9a 	MB[r4 + 716] = rMAC;

842006ce <Lc_ahm_opmsg_set_control_32>:
            }
            L4_DBG_MSG2("OPID: %x, AHM adaptive ambient mode: %d ",
                        ext_op_id, p_ext_data->aamb_mode);
842006ce:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842006d2:	08 25       	Null = rMAC - 4;
842006d4:	2e 69       	if LT jump (m) Lc_ahm_opmsg_set_control_5;

842006d6 <Lc_ahm_opmsg_set_control_33>:
842006d6:	64 f0 cc 92 	r2 = MBU[r4 + 716];
842006da:	55 f1 02 f0 	r0 = Null + 357565266;
842006de:	52 43 
842006e0:	53 d8       	r1 = M[FP + 40];
842006e2:	ff fd 04 f0 	call (m) 0x10d6;
842006e6:	35 ef 
842006e8:	24 6f       	jump (m) Lc_ahm_opmsg_set_control_5;

842006ea <Lc_ahm_opmsg_set_control_34>:

            continue;
        }
        else if (ctrl_id == ANC_HW_MANAGER_CONSTANT_TRIGGER_CTRL)
842006ea:	f8 25       	Null = r5 - 7;
842006ec:	dd 62       	if NE jump (m) Lc_ahm_opmsg_set_control_64;

842006ee <Lc_ahm_opmsg_set_control_35>:
        {

            ctrl_value &= 0x3;
842006ee:	a9 d8       	rMAC = M[FP + 84];
842006f0:	89 c0       	rMAC = rMAC AND 0x3;
            switch(ctrl_value)
842006f2:	a9 de       	M[FP + 84] = rMAC;
842006f4:	70 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_50;

842006f6 <Lc_ahm_opmsg_set_control_36>:
842006f6:	48 24       	Null = rMAC - 1;
842006f8:	72 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_51;

842006fa <Lc_ahm_opmsg_set_control_37>:
842006fa:	88 24       	Null = rMAC - 2;
842006fc:	1a 63       	if NE jump (m) Lc_ahm_opmsg_set_control_5;

842006fe <Lc_ahm_opmsg_set_control_38>:
                    p_ext_data->cur_mode = ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION;
                    p_ext_data->host_mode = ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION;
                    break;

                case ANC_HW_MANAGER_TRIGGER_DIFFERENT:
                    p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID].state = AHM_RAMP_IDLE;
842006fe:	89 d8       	rMAC = M[FP + 68];
84200700:	61 f0 c0 8a 	MB[r4 + 192] = rMAC;
                    p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID].state = AHM_RAMP_IDLE;
84200704:	61 f0 e0 8a 	MB[r4 + 224] = rMAC;
                    p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID].state = AHM_RAMP_IDLE;
84200708:	61 f0 00 8b 	MB[r4 + 256] = rMAC;

                    DEBUG_AHM("OPID: %x, Different ANC mode transition", ext_op_id);
                    p_ext_data->trigger_mode = AHM_TRIGGER_DIFFERENT;
8420070c:	91 d8       	rMAC = M[FP + 72];
8420070e:	61 f0 cd 9a 	MB[r4 + 717] = rMAC;
84200712:	4a 08       	r0 = r7 + Null;
84200714:	ff fd 01 f0 	call (m) 0x934;
84200718:	21 e1 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
8420071a:	10 ea       	MB[r0 + Null] = Null;
                    aud_cur_set_reinit(op_data, FALSE);
                    /* Ramp down gains in relevant paths to zero and no delay if required */
                    configure_ramp_down(&cfg, p_ext_data, ANC_HW_MANAGER_TRIGGER_DIFFERENT );
8420071c:	84 20       	r2 = Null + 2;
8420071e:	82 15       	r0 = FP + 88;
84200720:	33 00       	r1 = r4 + Null;
84200722:	07 f0 2b e0 	call (m) Lc_configure_ramp_down_1;
                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID])
84200726:	60 f0 a6 88 	Null = M[r4 + 664];
8420072a:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_40;

8420072c <Lc_ahm_opmsg_set_control_39>:
8420072c:	60 f0 a9 88 	Null = M[r4 + 676];
84200730:	15 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_42;

84200732 <Lc_ahm_opmsg_set_control_40>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down in FF path for Different ANC mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                       &cfg);
84200732:	68 f0 b4 20 	r6 = r4 + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200736:	4a 08       	r0 = r7 + Null;
84200738:	ff fd 00 f0 	call (m) 0x8ea;
8420073c:	33 ed 
8420073e:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84200740:	74 f0 94 20 	r2 = r5 + 148;
84200744:	83 15       	r1 = FP + 88;
84200746:	42 08       	r0 = r6 + Null;
84200748:	0e f0 25 e8 	call (m) $_ahm_initialize_delta_ramp;
8420074c:	10 04       	Null = r0 - Null;
8420074e:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_42;

84200750 <Lc_ahm_opmsg_set_control_41>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84200750:	73 f0 94 20 	r1 = r5 + 148;
84200754:	4a 08       	r0 = r7 + Null;
84200756:	06 f0 2f e8 	call (m) Lc_ahm_send_event_message_1;

8420075a <Lc_ahm_opmsg_set_control_42>:
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                       &cfg);
                    }
                    cfg.nominal_gain =p_ext_data->p_nominal_gain->fb.fine;
8420075a:	61 f0 23 88 	rMAC = M[r4 + 140];
8420075e:	c9 86       	rMAC = MHU[rMAC + 6];
84200760:	69 dd       	MH[FP + 90] = rMAC;
                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID])
84200762:	60 f0 a7 88 	Null = M[r4 + 668];
84200766:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_44;

84200768 <Lc_ahm_opmsg_set_control_43>:
84200768:	60 f0 aa 88 	Null = M[r4 + 680];
8420076c:	15 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_46;

8420076e <Lc_ahm_opmsg_set_control_44>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down in FF path for Different ANC mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                       &cfg);
8420076e:	68 f0 d4 20 	r6 = r4 + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200772:	4a 08       	r0 = r7 + Null;
84200774:	ff fd 00 f0 	call (m) 0x8ea;
84200778:	37 eb 
8420077a:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
8420077c:	74 f0 94 20 	r2 = r5 + 148;
84200780:	83 15       	r1 = FP + 88;
84200782:	42 08       	r0 = r6 + Null;
84200784:	0e f0 29 e6 	call (m) $_ahm_initialize_delta_ramp;
84200788:	10 04       	Null = r0 - Null;
8420078a:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_46;

8420078c <Lc_ahm_opmsg_set_control_45>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420078c:	73 f0 94 20 	r1 = r5 + 148;
84200790:	4a 08       	r0 = r7 + Null;
84200792:	06 f0 33 e6 	call (m) Lc_ahm_send_event_message_1;

84200796 <Lc_ahm_opmsg_set_control_46>:
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                       &cfg);
                    }

                    cfg.nominal_gain =p_ext_data->p_nominal_gain->ec.fine;
84200796:	61 f0 23 88 	rMAC = M[r4 + 140];
8420079a:	49 87       	rMAC = MHU[rMAC + 10];
8420079c:	69 dd       	MH[FP + 90] = rMAC;
                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID])
8420079e:	60 f0 a8 88 	Null = M[r4 + 672];
842007a2:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_48;

842007a4 <Lc_ahm_opmsg_set_control_47>:
842007a4:	60 f0 ab 88 	Null = M[r4 + 684];
842007a8:	78 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_63;

842007aa <Lc_ahm_opmsg_set_control_48>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down in FF path for Different ANC mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                       &cfg);
842007aa:	68 f0 f4 20 	r6 = r4 + 244;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842007ae:	4a 08       	r0 = r7 + Null;
842007b0:	ff fd 00 f0 	call (m) 0x8ea;
842007b4:	3b e9 
842007b6:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
842007b8:	74 f0 94 20 	r2 = r5 + 148;
842007bc:	83 15       	r1 = FP + 88;
842007be:	42 08       	r0 = r6 + Null;
842007c0:	0e f0 2d e4 	call (m) $_ahm_initialize_delta_ramp;
842007c4:	10 04       	Null = r0 - Null;
842007c6:	69 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_63;

842007c8 <Lc_ahm_opmsg_set_control_49>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
842007c8:	73 f0 94 20 	r1 = r5 + 148;
842007cc:	4a 08       	r0 = r7 + Null;
842007ce:	06 f0 37 e4 	call (m) Lc_ahm_send_event_message_1;
842007d2:	63 6e       	jump (m) Lc_ahm_opmsg_set_control_63;

842007d4 <Lc_ahm_opmsg_set_control_50>:
            ctrl_value &= 0x3;
            switch(ctrl_value)
            {
                case ANC_HW_MANAGER_TRIGGER_START:
                    DEBUG_AHM("OPID: %x, Enabling ANC, No Mode transition ", ext_op_id);
                    p_ext_data->trigger_mode =AHM_TRIGGER_START;
842007d4:	6b f0 cd 9a 	MB[r4 + 717] = r9;
                    break;
842007d8:	ff ff d9 ea 	jump (m) Lc_ahm_opmsg_set_control_5;

842007dc <Lc_ahm_opmsg_set_control_51>:

                case ANC_HW_MANAGER_TRIGGER_SIMILAR:
                    DEBUG_AHM("OPID: %x, Similar ANC Mode Transition", ext_op_id);
                    p_ext_data->trigger_mode = AHM_TRIGGER_SIMILAR;
842007dc:	79 d8       	rMAC = M[FP + 60];
842007de:	61 f0 cd 9a 	MB[r4 + 717] = rMAC;
                    /* Ramp down gains in relevant paths to zero and no delay if required */
                    configure_ramp_down(&cfg, p_ext_data, ANC_HW_MANAGER_TRIGGER_SIMILAR);
842007e2:	82 15       	r0 = FP + 88;
842007e4:	5c 08       	r2 = r9 + Null;
842007e6:	33 00       	r1 = r4 + Null;
842007e8:	06 f0 25 ea 	call (m) Lc_configure_ramp_down_1;

                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID])
842007ec:	60 f0 a6 88 	Null = M[r4 + 664];
842007f0:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_53;

842007f2 <Lc_ahm_opmsg_set_control_52>:
842007f2:	60 f0 a9 88 	Null = M[r4 + 676];
842007f6:	15 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_55;

842007f8 <Lc_ahm_opmsg_set_control_53>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down in FF path for similar ANC mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                       &cfg);
842007f8:	68 f0 b4 20 	r6 = r4 + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842007fc:	4a 08       	r0 = r7 + Null;
842007fe:	ff fd 00 f0 	call (m) 0x8ea;
84200802:	2d e7 
84200804:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84200806:	74 f0 94 20 	r2 = r5 + 148;
8420080a:	83 15       	r1 = FP + 88;
8420080c:	42 08       	r0 = r6 + Null;
8420080e:	0e f0 3f e1 	call (m) $_ahm_initialize_delta_ramp;
84200812:	10 04       	Null = r0 - Null;
84200814:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_55;

84200816 <Lc_ahm_opmsg_set_control_54>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84200816:	73 f0 94 20 	r1 = r5 + 148;
8420081a:	4a 08       	r0 = r7 + Null;
8420081c:	06 f0 29 e2 	call (m) Lc_ahm_send_event_message_1;

84200820 <Lc_ahm_opmsg_set_control_55>:
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                       &cfg);
                    }
                    cfg.nominal_gain =p_ext_data->p_nominal_gain->fb.fine;
84200820:	61 f0 23 88 	rMAC = M[r4 + 140];
84200824:	c9 86       	rMAC = MHU[rMAC + 6];
84200826:	69 dd       	MH[FP + 90] = rMAC;
                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID])
84200828:	60 f0 a7 88 	Null = M[r4 + 668];
8420082c:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_57;

8420082e <Lc_ahm_opmsg_set_control_56>:
8420082e:	60 f0 aa 88 	Null = M[r4 + 680];
84200832:	15 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_59;

84200834 <Lc_ahm_opmsg_set_control_57>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down  in FB path for similar ANC mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                       &cfg);
84200834:	68 f0 d4 20 	r6 = r4 + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200838:	4a 08       	r0 = r7 + Null;
8420083a:	ff fd 00 f0 	call (m) 0x8ea;
8420083e:	31 e5 
84200840:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84200842:	74 f0 94 20 	r2 = r5 + 148;
84200846:	83 15       	r1 = FP + 88;
84200848:	42 08       	r0 = r6 + Null;
8420084a:	0e f0 23 e0 	call (m) $_ahm_initialize_delta_ramp;
8420084e:	10 04       	Null = r0 - Null;
84200850:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_59;

84200852 <Lc_ahm_opmsg_set_control_58>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84200852:	73 f0 94 20 	r1 = r5 + 148;
84200856:	4a 08       	r0 = r7 + Null;
84200858:	06 f0 2d e0 	call (m) Lc_ahm_send_event_message_1;

8420085c <Lc_ahm_opmsg_set_control_59>:
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                       &cfg);
                    }
                    cfg.nominal_gain =p_ext_data->p_nominal_gain->ec.fine;
8420085c:	61 f0 23 88 	rMAC = M[r4 + 140];
84200860:	49 87       	rMAC = MHU[rMAC + 10];
84200862:	69 dd       	MH[FP + 90] = rMAC;

                    if (p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID])
84200864:	60 f0 a8 88 	Null = M[r4 + 672];
84200868:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_control_61;

8420086a <Lc_ahm_opmsg_set_control_60>:
8420086a:	60 f0 ab 88 	Null = M[r4 + 684];
8420086e:	15 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_63;

84200870 <Lc_ahm_opmsg_set_control_61>:
                    {
                        DEBUG_AHM("OPID: %x, Initialising delta ramp for ramp down in EC path for similar ANC Mode!",
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                       &cfg);
84200870:	68 f0 f4 20 	r6 = r4 + 244;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200874:	4a 08       	r0 = r7 + Null;
84200876:	ff fd 00 f0 	call (m) 0x8ea;
8420087a:	35 e3 
8420087c:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
8420087e:	74 f0 94 20 	r2 = r5 + 148;
84200882:	83 15       	r1 = FP + 88;
84200884:	42 08       	r0 = r6 + Null;
84200886:	0d f0 27 ee 	call (m) $_ahm_initialize_delta_ramp;
8420088a:	10 04       	Null = r0 - Null;
8420088c:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_63;

8420088e <Lc_ahm_opmsg_set_control_62>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420088e:	73 f0 94 20 	r1 = r5 + 148;
84200892:	4a 08       	r0 = r7 + Null;
84200894:	05 f0 31 ee 	call (m) Lc_ahm_send_event_message_1;

84200898 <Lc_ahm_opmsg_set_control_63>:
                                  ext_op_id);
                        ahm_init_delta_ramp_and_notify(op_data,
                                                       &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                       &cfg);
                    }
                    p_ext_data->ramp_status = AHM_RAMP_DOWN;
84200898:	6b f0 ce 9a 	MB[r4 + 718] = r9;
                    p_ext_data->cur_mode = ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION;
8420089c:	81 d8       	rMAC = M[FP + 64];
8420089e:	31 be       	M[r4 + 96] = rMAC;
                    p_ext_data->host_mode = ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION;
842008a0:	71 be       	M[r4 + 100] = rMAC;
                    break;
842008a2:	ff ff 8f e9 	jump (m) Lc_ahm_opmsg_set_control_5;

842008a6 <Lc_ahm_opmsg_set_control_64>:

            continue;

        }
        else if (ctrl_id >= ANC_HW_MANAGER_CONSTANT_FF_COARSE_GAIN_CTRL &&
                  ctrl_id <= ANC_HW_MANAGER_CONSTANT_RX_FFB_MIX_FINE_GAIN_CTRL)
842008a6:	b8 26       	Null = r5 - 10;
842008a8:	f3 ff 85 e9 	if NC jump (m) Lc_ahm_opmsg_set_control_4;

842008ac <Lc_ahm_opmsg_set_control_65>:
842008ac:	f8 2c       	Null = r5 - 19;
842008ae:	f8 ff ff e8 	if HI jump (m) Lc_ahm_opmsg_set_control_4;

842008b2 <Lc_ahm_opmsg_set_control_66>:
        {
            ahm_initialize_prev_gain(p_ext_data->p_prev_gain);
842008b2:	f2 b9       	r0 = M[r4 + 124];
842008b4:	0d f0 39 e9 	call (m) $_ahm_initialize_prev_gain;

            cfg.delay = 0;
842008b8:	b8 de       	M[FP + 92] = Null;
            cfg.duration = p_ext_data->ahm_cap_params.OFFSET_OVERRIDE_RAMP_DURATION;
842008ba:	31 99       	rMAC = M[r4 + 48];
842008bc:	c1 de       	M[FP + 96] = rMAC;
            cfg.target = (uint16)ctrl_value;
842008be:	a9 d8       	rMAC = M[FP + 84];
842008c0:	61 dd       	MH[FP + 88] = rMAC;
            cfg.slow_rate = p_ext_data->slow_rate;
842008c2:	62 f0 b2 88 	r0 = M[r4 + 712];
842008c6:	ca de       	M[FP + 100] = r0;
            cfg.fast_rate = p_ext_data->fast_rate;
842008c8:	62 f0 b1 88 	r0 = M[r4 + 708];
842008cc:	d2 de       	M[FP + 104] = r0;

            switch (ctrl_id)
842008ce:	f8 26       	Null = r5 - 11;
842008d0:	1c 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_71;

842008d2 <Lc_ahm_opmsg_set_control_67>:
842008d2:	78 27       	Null = r5 - 13;
842008d4:	33 62       	if NE jump (m) Lc_ahm_opmsg_set_control_74;

842008d6 <Lc_ahm_opmsg_set_control_68>:
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                   &cfg);
                break;
                case ANC_HW_MANAGER_CONSTANT_FB_FINE_GAIN_CTRL:
                    cfg.nominal_gain = (uint16)ctrl_value;
842008d6:	69 dd       	MH[FP + 90] = rMAC;
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                   &cfg);
842008d8:	68 f0 d4 20 	r6 = r4 + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842008dc:	4a 08       	r0 = r7 + Null;
842008de:	ff fd 00 f0 	call (m) 0x8ea;
842008e2:	2d e0 
842008e4:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
842008e6:	74 f0 94 20 	r2 = r5 + 148;
842008ea:	83 15       	r1 = FP + 88;
842008ec:	42 08       	r0 = r6 + Null;
842008ee:	0d f0 3f ea 	call (m) $_ahm_initialize_delta_ramp;
842008f2:	10 04       	Null = r0 - Null;
842008f4:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_70;

842008f6 <Lc_ahm_opmsg_set_control_69>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
842008f6:	73 f0 94 20 	r1 = r5 + 148;
842008fa:	4a 08       	r0 = r7 + Null;
842008fc:	05 f0 29 eb 	call (m) Lc_ahm_send_event_message_1;

84200900 <Lc_ahm_opmsg_set_control_70>:
                    p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FF_ID].gain = \
                        (uint8)ctrl_value;
                    break;
                case ANC_HW_MANAGER_CONSTANT_FB_FINE_GAIN_CTRL:
                    p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FB_ID].gain = \
                        (uint8)ctrl_value;
84200900:	a9 d8       	rMAC = M[FP + 84];
84200902:	61 f0 74 8b 	MB[r4 + 372] = rMAC;
                    break;
84200906:	51 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

84200908 <Lc_ahm_opmsg_set_control_71>:

            switch (ctrl_id)
            {
                /* Gain override on fine gains will ramp to the new value */
                case ANC_HW_MANAGER_CONSTANT_FF_FINE_GAIN_CTRL:
                    cfg.nominal_gain = (uint16)ctrl_value;
84200908:	69 dd       	MH[FP + 90] = rMAC;
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                   &cfg);
8420090a:	68 f0 b4 20 	r6 = r4 + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
8420090e:	4a 08       	r0 = r7 + Null;
84200910:	ef fd ff ff 	call (m) 0x8ea;
84200914:	3b ee 
84200916:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84200918:	74 f0 94 20 	r2 = r5 + 148;
8420091c:	83 15       	r1 = FP + 88;
8420091e:	42 08       	r0 = r6 + Null;
84200920:	0d f0 2d e9 	call (m) $_ahm_initialize_delta_ramp;
84200924:	10 04       	Null = r0 - Null;
84200926:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_control_73;

84200928 <Lc_ahm_opmsg_set_control_72>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84200928:	73 f0 94 20 	r1 = r5 + 148;
8420092c:	4a 08       	r0 = r7 + Null;
8420092e:	05 f0 37 e9 	call (m) Lc_ahm_send_event_message_1;

84200932 <Lc_ahm_opmsg_set_control_73>:
            }
            switch (ctrl_id)
            {
                case ANC_HW_MANAGER_CONSTANT_FF_FINE_GAIN_CTRL:
                    p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FF_ID].gain = \
                        (uint8)ctrl_value;
84200932:	a9 d8       	rMAC = M[FP + 84];
84200934:	61 f0 5c 8b 	MB[r4 + 348] = rMAC;
                    break;
84200938:	38 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

8420093a <Lc_ahm_opmsg_set_control_74>:
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                   &cfg);
                break;
                default:
                    /* Zero-index the selected gain ID */
                    sel_override = ctrl_id - ANC_HW_MANAGER_CONSTANT_FF_COARSE_GAIN_CTRL;
8420093a:	73 f3 f6 3b 	r1 = r5 + -10;

                    /* Gain bank is value divided by 2 */
                    sel_bank = sel_override >> 1;
8420093e:	1a 50       	r0 = r1 LSHIFT -1;
                    /* Gain type is value mod 2 */
                    sel_type = sel_override % 2;
84200940:	1b c0       	r1 = r1 AND 0x1;
                    /* Update pointer value */
                    p_sel_bank = (AHM_GAIN*)p_ext_data->p_cur_gain;
84200942:	74 b9       	r2 = M[r4 + 116];
                    p_sel_bank += sel_bank;
84200944:	52 54       	r0 = r0 LSHIFT 2;
84200946:	14 01       	r2 = r0 + r2;
                    p_override = (uint16*)p_sel_bank + (uint16)sel_type;
84200948:	1a 54       	r0 = r1 LSHIFT 1;
8420094a:	14 01       	r2 = r0 + r2;
                    *p_override = (uint16)ctrl_value;
8420094c:	21 8c       	MH[r2 + 0] = rMAC;
            }
            switch (ctrl_id)
8420094e:	72 f3 f6 3b 	r0 = r5 + -10;
84200952:	52 54       	r0 = r0 LSHIFT 2;
84200954:	2c f0 21 f0 	rMAC = M[r0 + 1442024];
84200958:	3a 88 
8420095a:	d9 4c       	jump rMAC;

8420095c <Lc_ahm_opmsg_set_control_75>:
                    p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FB_ID].gain = \
                        (uint8)ctrl_value;
                    break;
                case ANC_HW_MANAGER_CONSTANT_EC_FINE_GAIN_CTRL:
                    p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_EC_ID].gain = \
                        (uint8)ctrl_value;
8420095c:	a9 d8       	rMAC = M[FP + 84];
8420095e:	61 f0 8c 8b 	MB[r4 + 396] = rMAC;
                    break;
84200962:	23 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

84200964 <Lc_ahm_opmsg_set_control_76>:
                case ANC_HW_MANAGER_CONSTANT_FF_COARSE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->ff.coarse = (int16)ctrl_value;
84200964:	a9 d8       	rMAC = M[FP + 84];
84200966:	62 f0 23 88 	r0 = M[r4 + 140];
8420096a:	11 8c       	MH[r0 + 0] = rMAC;
                    break;
8420096c:	1e 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

8420096e <Lc_ahm_opmsg_set_control_77>:
                case ANC_HW_MANAGER_CONSTANT_FB_COARSE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->fb.coarse = (int16)ctrl_value;
8420096e:	a9 d8       	rMAC = M[FP + 84];
84200970:	62 f0 23 88 	r0 = M[r4 + 140];
84200974:	91 8c       	MH[r0 + 4] = rMAC;
                    break;
84200976:	19 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

84200978 <Lc_ahm_opmsg_set_control_78>:
                case ANC_HW_MANAGER_CONSTANT_EC_COARSE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->ec.coarse = (int16)ctrl_value;
84200978:	a9 d8       	rMAC = M[FP + 84];
8420097a:	62 f0 23 88 	r0 = M[r4 + 140];
8420097e:	11 8d       	MH[r0 + 8] = rMAC;
                    break;
84200980:	14 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

84200982 <Lc_ahm_opmsg_set_control_79>:
                case ANC_HW_MANAGER_CONSTANT_RX_FFA_MIX_FINE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->rx_ffa_mix.fine = (uint16)ctrl_value;
84200982:	a9 d8       	rMAC = M[FP + 84];
84200984:	62 f0 23 88 	r0 = M[r4 + 140];
84200988:	d1 8d       	MH[r0 + 14] = rMAC;
                    break;
8420098a:	0f 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

8420098c <Lc_ahm_opmsg_set_control_80>:
                case ANC_HW_MANAGER_CONSTANT_RX_FFA_MIX_COARSE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->rx_ffa_mix.coarse = (int16)ctrl_value;
8420098c:	a9 d8       	rMAC = M[FP + 84];
8420098e:	62 f0 23 88 	r0 = M[r4 + 140];
84200992:	91 8d       	MH[r0 + 12] = rMAC;
                    break;
84200994:	0a 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

84200996 <Lc_ahm_opmsg_set_control_81>:
                case ANC_HW_MANAGER_CONSTANT_RX_FFB_MIX_FINE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->rx_ffb_mix.fine = (uint16)ctrl_value;
84200996:	a9 d8       	rMAC = M[FP + 84];
84200998:	62 f0 23 88 	r0 = M[r4 + 140];
8420099c:	51 9c       	MH[r0 + 18] = rMAC;
                    break;
8420099e:	05 6e       	jump (m) Lc_ahm_opmsg_set_control_83;

842009a0 <Lc_ahm_opmsg_set_control_82>:
                case ANC_HW_MANAGER_CONSTANT_RX_FFB_MIX_COARSE_GAIN_CTRL:
                    p_ext_data->p_nominal_gain->rx_ffb_mix.coarse = (int16)ctrl_value;
842009a0:	a9 d8       	rMAC = M[FP + 84];
842009a2:	62 f0 23 88 	r0 = M[r4 + 140];
842009a6:	11 9c       	MH[r0 + 16] = rMAC;

842009a8 <Lc_ahm_opmsg_set_control_83>:
                    break;
                default:
                    break; /* Shouldn't get here due to if filter above */
            }

            ahm_write_gain_generic(op_data);
842009a8:	4a 08       	r0 = r7 + Null;
842009aa:	05 f0 33 ee 	call (m) Lc_ahm_write_gain_generic_1;
            continue;
842009ae:	ff ff 83 e7 	jump (m) Lc_ahm_opmsg_set_control_5;

842009b2 <Lc_ahm_opmsg_set_control_84>:
    {
        p_ext_data->cur_mode = p_ext_data->qact_mode;
    }
    else
    {
        p_ext_data->cur_mode = p_ext_data->host_mode;
842009b2:	71 b8       	rMAC = M[r4 + 100];
842009b4:	31 be       	M[r4 + 96] = rMAC;

842009b6 <Lc_ahm_opmsg_set_control_85>:
    }

    cps_response_set_result(resp_data, result);
842009b6:	5b d8       	r1 = M[FP + 44];
842009b8:	4a d8       	r0 = M[FP + 36];
842009ba:	ff fd 02 f0 	call (m) 0xf30;
842009be:	37 eb 

    return TRUE;
842009c0:	5a 08       	r0 = r9 + Null;

842009c2 <Lc_ahm_opmsg_set_control_86>:
}
842009c2:	6d 4c       	SP = SP + -76;
842009c4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842009c6:	d8 4c       	rts;

842009c8 <$_ahm_opmsg_get_status>:

bool ahm_opmsg_get_status(OPERATOR_DATA *op_data, void *message_data,
                          unsigned *resp_length,
                          OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842009c8:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842009ca:	59 4c       	SP = SP + 100;
842009cc:	19 09       	r7 = r1 + Null;
842009ce:	26 00       	r4 = r2 + Null;
842009d0:	28 09       	r6 = r3 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842009d2:	ef fd ff ff 	call (m) 0x8ea;
842009d6:	39 e8 
842009d8:	17 00       	r5 = r0 + Null;
    ANC_HW_MANAGER_STATISTICS stats;
    AHM_GAIN_BANK *p_gain;
    ParamType *pparam;

    if(!common_obpm_status_helper(message_data, resp_length, resp_data,
                                  sizeof(ANC_HW_MANAGER_STATISTICS), &resp))
842009da:	81 11       	rMAC = FP + 24;
842009dc:	09 1c       	pushm <rMAC>;
842009de:	05 f0 60 40 	r3 = Null + 96;
842009e2:	44 08       	r2 = r6 + Null;
842009e4:	33 00       	r1 = r4 + Null;
842009e6:	4a 08       	r0 = r7 + Null;
842009e8:	ff fd 02 f0 	call (m) 0xf46;
842009ec:	3f ea 
842009ee:	7f 4c       	SP = SP + -4;
842009f0:	10 04       	Null = r0 - Null;
842009f2:	03 62       	if NE jump (m) Lc_ahm_opmsg_get_status_3;

842009f4 <Lc_ahm_opmsg_get_status_2>:
    {
         return FALSE;
842009f4:	02 00       	r0 = Null + Null;
842009f6:	55 6e       	jump (m) Lc_ahm_opmsg_get_status_7;

842009f8 <Lc_ahm_opmsg_get_status_3>:
    }

    if (resp == NULL)
842009f8:	31 d8       	rMAC = M[FP + 24];
842009fa:	fd 61       	if EQ jump (m) Lc_ahm_opmsg_get_status_2;

842009fc <Lc_ahm_opmsg_get_status_4>:
    {
        return FALSE;
    }

    stats.OFFSET_CUR_MODE = p_ext_data->cur_mode;
842009fc:	39 b8       	rMAC = M[r5 + 96];
842009fe:	39 de       	M[FP + 28] = rMAC;
    stats.OFFSET_OVR_CONTROL = p_ext_data->ovr_control;
84200a00:	f9 b8       	rMAC = M[r5 + 108];
84200a02:	41 de       	M[FP + 32] = rMAC;
    stats.OFFSET_IN_OUT_EAR_CTRL = p_ext_data->in_out_status;
84200a04:	71 f0 af 82 	rMAC = MBU[r5 + 175];
84200a08:	49 de       	M[FP + 36] = rMAC;
    stats.OFFSET_CHANNEL = p_ext_data->config.channel;
84200a0a:	71 f0 a8 80 	rMAC = MBS[r5 + 168];
84200a0e:	51 de       	M[FP + 40] = rMAC;
    stats.OFFSET_FEEDFORWARD_PATH = p_ext_data->config.ff_path;
84200a10:	71 f0 a9 80 	rMAC = MBS[r5 + 169];
84200a14:	61 de       	M[FP + 48] = rMAC;
    stats.OFFSET_FLAGS = p_ext_data->clock_status;
84200a16:	71 f0 ae 82 	rMAC = MBU[r5 + 174];
84200a1a:	71 de       	M[FP + 56] = rMAC;
    stats.OFFSET_AMBIENT_CTRL = p_ext_data->aamb_mode;
84200a1c:	71 f0 cc 92 	rMAC = MBU[r5 + 716];
84200a20:	69 de       	M[FP + 52] = rMAC;

    p_gain = p_ext_data->p_cur_gain;
84200a22:	7e b9       	r4 = M[r5 + 116];
    stats.OFFSET_FF_COARSE_GAIN_CTRL = p_gain->ff.coarse;
84200a24:	31 e4       	rMAC = MHS[r4 + Null];
84200a26:	79 de       	M[FP + 60] = rMAC;
    stats.OFFSET_FF_FINE_GAIN_CTRL = p_gain->ff.fine;
84200a28:	71 86       	rMAC = MHU[r4 + 2];
84200a2a:	81 de       	M[FP + 64] = rMAC;
    stats.OFFSET_FF_GAIN_DB = ahm_calc_gain_db(p_gain->ff.fine,
                                               p_gain->ff.coarse);
84200a2c:	33 e4       	r1 = MHS[r4 + Null];
84200a2e:	72 86       	r0 = MHU[r4 + 2];
84200a30:	15 f0 2f ed 	call (m) $_ahm_calc_gain_db;
84200a34:	8a de       	M[FP + 68] = r0;
    stats.OFFSET_FB_COARSE_GAIN_CTRL = p_gain->fb.coarse;
84200a36:	b1 84       	rMAC = MHS[r4 + 4];
84200a38:	91 de       	M[FP + 72] = rMAC;
    stats.OFFSET_FB_FINE_GAIN_CTRL = p_gain->fb.fine;
84200a3a:	f1 86       	rMAC = MHU[r4 + 6];
84200a3c:	99 de       	M[FP + 76] = rMAC;
    stats.OFFSET_FB_GAIN_DB = ahm_calc_gain_db(p_gain->fb.fine,
                                               p_gain->fb.coarse);
84200a3e:	b3 84       	r1 = MHS[r4 + 4];
84200a40:	f2 86       	r0 = MHU[r4 + 6];
84200a42:	15 f0 3d ec 	call (m) $_ahm_calc_gain_db;
84200a46:	a2 de       	M[FP + 80] = r0;
    stats.OFFSET_EC_COARSE_GAIN_CTRL = p_gain->ec.coarse;
84200a48:	31 85       	rMAC = MHS[r4 + 8];
84200a4a:	a9 de       	M[FP + 84] = rMAC;
    stats.OFFSET_EC_FINE_GAIN_CTRL = p_gain->ec.fine;
84200a4c:	71 87       	rMAC = MHU[r4 + 10];
84200a4e:	b1 de       	M[FP + 88] = rMAC;
    stats.OFFSET_EC_GAIN_DB = ahm_calc_gain_db(p_gain->ec.fine,
                                               p_gain->ec.coarse);
84200a50:	33 85       	r1 = MHS[r4 + 8];
84200a52:	72 87       	r0 = MHU[r4 + 10];
84200a54:	15 f0 2b ec 	call (m) $_ahm_calc_gain_db;
84200a58:	ba de       	M[FP + 92] = r0;
    stats.OFFSET_RX_FFA_MIX_COARSE_GAIN_CTRL = p_gain->rx_ffa_mix.coarse;
84200a5a:	b1 85       	rMAC = MHS[r4 + 12];
84200a5c:	c1 de       	M[FP + 96] = rMAC;
    stats.OFFSET_RX_FFA_MIX_FINE_GAIN_CTRL = p_gain->rx_ffa_mix.fine;
84200a5e:	f1 87       	rMAC = MHU[r4 + 14];
84200a60:	c9 de       	M[FP + 100] = rMAC;
    stats.OFFSET_RX_FFA_MIX_GAIN_DB = ahm_calc_gain_db(
        p_gain->rx_ffa_mix.fine,
        p_gain->rx_ffa_mix.coarse);
84200a62:	b3 85       	r1 = MHS[r4 + 12];
84200a64:	f2 87       	r0 = MHU[r4 + 14];
84200a66:	15 f0 39 eb 	call (m) $_ahm_calc_gain_db;
84200a6a:	d2 de       	M[FP + 104] = r0;
    stats.OFFSET_RX_FFB_MIX_COARSE_GAIN_CTRL = p_gain->rx_ffb_mix.coarse;
84200a6c:	31 94       	rMAC = MHS[r4 + 16];
84200a6e:	d9 de       	M[FP + 108] = rMAC;
    stats.OFFSET_RX_FFB_MIX_FINE_GAIN_CTRL = p_gain->rx_ffb_mix.fine;
84200a70:	71 96       	rMAC = MHU[r4 + 18];
84200a72:	e1 de       	M[FP + 112] = rMAC;
    stats.OFFSET_RX_FFB_MIX_GAIN_DB = ahm_calc_gain_db(
        p_gain->rx_ffb_mix.fine,
        p_gain->rx_ffb_mix.coarse);
84200a74:	33 94       	r1 = MHS[r4 + 16];
84200a76:	72 96       	r0 = MHU[r4 + 18];
84200a78:	15 f0 27 eb 	call (m) $_ahm_calc_gain_db;
84200a7c:	ea de       	M[FP + 116] = r0;

    p_gain = p_ext_data->p_cur_gain1;
84200a7e:	b9 b9       	rMAC = M[r5 + 120];
    stats.OFFSET_FF_FINE_GAIN_CTRL_INST1 = p_gain->ff.fine;
84200a80:	49 86       	rMAC = MHU[rMAC + 2];
84200a82:	f1 de       	M[FP + 120] = rMAC;

    pparam = (ParamType*)(&stats);
    for (i = 0; i < AHM_N_STAT/2; i++)
84200a84:	06 00       	r4 = Null + Null;
84200a86:	c7 11       	r5 = FP + 28;

84200a88 <Lc_ahm_opmsg_get_status_5>:
    {
        resp = cpsPack2Words(pparam[2*i], pparam[2*i+1], resp);
84200a88:	34 d8       	r2 = M[FP + 24];
84200a8a:	7b 88       	r1 = M[r5 + 4];
84200a8c:	3a e8       	r0 = M[r5 + Null];
84200a8e:	ff fd 67 f2 	call (m) 0x4da2c;
84200a92:	3f ec 
84200a94:	32 de       	M[FP + 24] = r0;

    p_gain = p_ext_data->p_cur_gain1;
    stats.OFFSET_FF_FINE_GAIN_CTRL_INST1 = p_gain->ff.fine;

    pparam = (ParamType*)(&stats);
    for (i = 0; i < AHM_N_STAT/2; i++)
84200a96:	76 20       	r4 = r4 + 1;
84200a98:	3f 22       	r5 = r5 + 8;
84200a9a:	30 27       	Null = r4 - 12;
84200a9c:	f6 69       	if LT jump (m) Lc_ahm_opmsg_get_status_5;

84200a9e <Lc_ahm_opmsg_get_status_6>:
    if ((AHM_N_STAT % 2) == 1) /* last one */
    {
        cpsPack1Word(pparam[AHM_N_STAT-1], resp);
    }

    return TRUE;
84200a9e:	42 20       	r0 = Null + 1;

84200aa0 <Lc_ahm_opmsg_get_status_7>:
}
84200aa0:	67 4c       	SP = SP + -100;
84200aa2:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200aa4:	d8 4c       	rts;

84200aa6 <$_ahm_opmsg_set_sample_rate>:

bool ahm_opmsg_set_sample_rate(OPERATOR_DATA *op_data,
                               void *message_data,
                               unsigned *resp_length,
                               OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200aa6:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200aa8:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200aaa:	ef fd ff ff 	call (m) 0x8ea;
84200aae:	21 e2 
84200ab0:	17 00       	r5 = r0 + Null;
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    DEBUG_AHM("OPID: %x, ahm_opmsg_set_sample_rate Fn entry", INT_TO_EXT_OPID(op_data->id));

    p_ext_data->sample_rate = SAMPLE_RATE_FROM_COMMON_OPMSG(message_data);
84200ab2:	f1 88       	rMAC = M[r4 + 12];
84200ab4:	89 c6       	rMAC = rMAC AND 0xffff;
84200ab6:	4a 46       	r0 = rMAC * 25 (int);
84200ab8:	3a bf       	M[r5 + 112] = r0;
    p_ext_data->samples_per_period = \
    ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                p_ext_data->timer_period,
                                p_ext_data->timer_decimation);
84200aba:	76 f0 60 87 	r4 = MHU[r5 + 704];
84200abe:	71 f0 ae 88 	rMAC = M[r5 + 696];
{
    /* sample_rate / 1000 = samples per ms
     * timer_period / 1000 * decimation = period in ms
     * multiply together for samples per period
     */
    unsigned raw_samples = (sample_rate * timer_period) / 1000000;
84200ac2:	52 1a       	r0 = r0 * rMAC (int);
84200ac4:	00 f0 a3 f7 	r1 = Null + 1000000;
84200ac8:	40 42 
84200aca:	ff fd cb f0 	call (m) 0x1a136;
84200ace:	2d e3 
    return raw_samples * (unsigned)decimation;
84200ad0:	b1 1a       	rMAC = r4 * r0 (int);
}
84200ad2:	71 f0 ad 8e 	M[r5 + 692] = rMAC;
    p_ext_data->samples_per_period = \
    ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                p_ext_data->timer_period,
                                p_ext_data->timer_decimation);

    return TRUE;
84200ad6:	42 20       	r0 = Null + 1;

84200ad8 <Lc_ahm_opmsg_set_sample_rate_2>:
}
84200ad8:	f2 48       	popm <FP, r4, r5, rLink>;
84200ada:	d8 4c       	rts;

84200adc <$_ahm_opmsg_set_static_gains>:

bool ahm_opmsg_set_static_gains(OPERATOR_DATA *op_data,
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200adc:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200ade:	16 00       	r4 = r0 + Null;
84200ae0:	1a 09       	r8 = r1 + Null;
84200ae2:	44 de       	M[FP + 32] = r2;
84200ae4:	4d de       	M[FP + 36] = r3;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200ae6:	ef fd ff ff 	call (m) 0x8ea;
84200aea:	25 e0 
84200aec:	17 00       	r5 = r0 + Null;
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    AHM_GAIN_BANK *p_static;
    unsigned *p_resp;
    unsigned msg_id;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
84200aee:	72 88       	r0 = M[r4 + 4];
84200af0:	52 55       	r0 = r0 LSHIFT 6;
84200af2:	40 f0 00 f2 	r6 = r0 OR 0x4000;
84200af6:	58 d8 
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_static_gains Fn entry", ext_op_id);

    unsigned int instance ;
    instance = OPMSG_FIELD_GET(message_data,
                               OPMSG_SET_AHM_STATIC_GAINS,
                               ANC_INSTANCE);
84200af8:	a1 f0 03 88 	rMAC = M[r8 + 12];
84200afc:	1b f7 ff 1f 	r9 = rMAC AND 0xffff;
    if (instance == AHM_ANC_INSTANCE_ANC1_ID)
84200b00:	b0 f0 02 24 	Null = r9 - 2;
84200b04:	04 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_3;

84200b06 <Lc_ahm_opmsg_set_static_gains_2>:
    {
        p_static = p_ext_data->p_static_gain1;   
84200b06:	76 f0 22 88 	r4 = M[r5 + 136];
84200b0a:	0f 6e       	jump (m) Lc_ahm_opmsg_set_static_gains_4;

84200b0c <Lc_ahm_opmsg_set_static_gains_3>:
    }
    else
    {
        /* default writing to the instance 0 gains*/
        p_static = p_ext_data->p_static_gain;
84200b0c:	76 f0 21 88 	r4 = M[r5 + 132];
		/* Reset ramp required and coarse gain change flag */
        p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID] = FALSE;
84200b10:	70 f0 a9 8e 	M[r5 + 676] = Null;
        p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID] = FALSE;
84200b14:	70 f0 aa 8e 	M[r5 + 680] = Null;
        p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID] = FALSE;
84200b18:	70 f0 ab 8e 	M[r5 + 684] = Null;
        p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] = FALSE;
84200b1c:	70 f0 a6 8e 	M[r5 + 664] = Null;
        p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] = FALSE;
84200b20:	70 f0 a7 8e 	M[r5 + 668] = Null;
        p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] = FALSE;
84200b24:	70 f0 a8 8e 	M[r5 + 672] = Null;

84200b28 <Lc_ahm_opmsg_set_static_gains_4>:
    }

    p_static->ff.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, FF_COARSE_STATIC_GAIN);
84200b28:	a1 f0 04 88 	rMAC = M[r8 + 16];
84200b2c:	31 8c       	MH[r4 + 0] = rMAC;
    p_static->ff.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, FF_FINE_STATIC_GAIN);
84200b2e:	a1 f0 05 88 	rMAC = M[r8 + 20];
84200b32:	71 8c       	MH[r4 + 2] = rMAC;
    p_static->fb.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, FB_COARSE_STATIC_GAIN);
84200b34:	a1 f0 06 88 	rMAC = M[r8 + 24];
84200b38:	b1 8c       	MH[r4 + 4] = rMAC;
    p_static->fb.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, FB_FINE_STATIC_GAIN);
84200b3a:	a1 f0 07 88 	rMAC = M[r8 + 28];
84200b3e:	f1 8c       	MH[r4 + 6] = rMAC;
    p_static->ec.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, EC_COARSE_STATIC_GAIN);
84200b40:	a1 f0 08 88 	rMAC = M[r8 + 32];
84200b44:	31 8d       	MH[r4 + 8] = rMAC;
    p_static->ec.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, EC_FINE_STATIC_GAIN);
84200b46:	a1 f0 09 88 	rMAC = M[r8 + 36];
84200b4a:	71 8d       	MH[r4 + 10] = rMAC;
    p_static->rx_ffa_mix.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, RX_FFA_MIX_COARSE_STATIC_GAIN);
84200b4c:	a1 f0 0a 88 	rMAC = M[r8 + 40];
84200b50:	b1 8d       	MH[r4 + 12] = rMAC;
    p_static->rx_ffa_mix.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, RX_FFA_MIX_FINE_STATIC_GAIN);
84200b52:	a1 f0 0b 88 	rMAC = M[r8 + 44];
84200b56:	f1 8d       	MH[r4 + 14] = rMAC;
    p_static->rx_ffb_mix.coarse = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, RX_FFB_MIX_COARSE_STATIC_GAIN);
84200b58:	a1 f0 0c 88 	rMAC = M[r8 + 48];
84200b5c:	31 9c       	MH[r4 + 16] = rMAC;
    p_static->rx_ffb_mix.fine = OPMSG_FIELD_GET(
        message_data, OPMSG_SET_AHM_STATIC_GAINS, RX_FFB_MIX_FINE_STATIC_GAIN);
84200b5e:	a1 f0 0d 88 	rMAC = M[r8 + 52];
84200b62:	71 9c       	MH[r4 + 18] = rMAC;

    if ((p_ext_data->ahm_cap_params.OFFSET_AHM_CONFIG & \
         ANC_HW_MANAGER_CONFIG_AHM_CONFIG_DISABLE_FF_GAIN_ADJUSTMENT) == 0)
84200b64:	79 88       	rMAC = M[r5 + 4];
84200b66:	c9 c0       	rMAC = rMAC AND 0x4;
84200b68:	12 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_8;

84200b6a <Lc_ahm_opmsg_set_static_gains_5>:
    {
        ahm_add_headroom(&p_static->ff, ext_op_id);
84200b6a:	43 08       	r1 = r6 + Null;
84200b6c:	32 00       	r0 = r4 + Null;
84200b6e:	07 f0 3b e5 	call (m) Lc_ahm_add_headroom_1;
        if(p_ext_data->config.ff_path == AHM_ANC_PATH_FFB_ID)
84200b72:	71 f0 a9 80 	rMAC = MBS[r5 + 169];
84200b76:	88 24       	Null = rMAC - 2;
84200b78:	06 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_7;

84200b7a <Lc_ahm_opmsg_set_static_gains_6>:
        {
           ahm_add_headroom(&p_static->rx_ffb_mix, ext_op_id);
84200b7a:	32 28       	r0 = r4 + 16;
84200b7c:	43 08       	r1 = r6 + Null;
84200b7e:	07 f0 2b e5 	call (m) Lc_ahm_add_headroom_1;
84200b82:	05 6e       	jump (m) Lc_ahm_opmsg_set_static_gains_8;

84200b84 <Lc_ahm_opmsg_set_static_gains_7>:
        }
        else
        {
           ahm_add_headroom(&p_static->rx_ffa_mix, ext_op_id);
84200b84:	32 23       	r0 = r4 + 12;
84200b86:	43 08       	r1 = r6 + Null;
84200b88:	07 f0 21 e5 	call (m) Lc_ahm_add_headroom_1;

84200b8c <Lc_ahm_opmsg_set_static_gains_8>:
        }
    }

    L2_DBG_MSG4("OPID: %x, Instance: %d, AHM Set Static Coarse Gain: FF = %hd, FB = %hd",
                ext_op_id, instance, p_static->ff.coarse, p_static->fb.coarse);
84200b8c:	09 f0 34 43 	r7 = Null + 820;
84200b90:	91 f0 00 e0 	rMAC = MBS[r7 + Null];
84200b94:	88 24       	Null = rMAC - 2;
84200b96:	41 68       	if LT jump (m) Lc_ahm_opmsg_set_static_gains_13;

84200b98 <Lc_ahm_opmsg_set_static_gains_9>:
84200b98:	b1 84       	rMAC = MHS[r4 + 4];
84200b9a:	09 1c       	pushm <rMAC>;
84200b9c:	35 e4       	r3 = MHS[r4 + Null];
84200b9e:	55 f1 02 f0 	r0 = Null + 357565453;
84200ba2:	0d 48 
84200ba4:	5c 08       	r2 = r9 + Null;
84200ba6:	43 08       	r1 = r6 + Null;
84200ba8:	ff fd 02 f0 	call (m) 0x1104;
84200bac:	3d ea 
84200bae:	7f 4c       	SP = SP + -4;
    L2_DBG_MSG5("OPID: %x, Instance: %d, AHM Set Static Coarse Gain: EC = %hd, "
                "Rx FFa = %hd, Rx FFb = %hd", ext_op_id, instance,
                p_static->ec.coarse,
                p_static->rx_ffa_mix.coarse,
                p_static->rx_ffb_mix.coarse);
84200bb0:	91 f0 00 e0 	rMAC = MBS[r7 + Null];
84200bb4:	88 24       	Null = rMAC - 2;
84200bb6:	31 68       	if LT jump (m) Lc_ahm_opmsg_set_static_gains_13;

84200bb8 <Lc_ahm_opmsg_set_static_gains_10>:
84200bb8:	31 94       	rMAC = MHS[r4 + 16];
84200bba:	09 1c       	pushm <rMAC>;
84200bbc:	b1 85       	rMAC = MHS[r4 + 12];
84200bbe:	09 1c       	pushm <rMAC>;
84200bc0:	35 85       	r3 = MHS[r4 + 8];
84200bc2:	55 f1 02 f0 	r0 = Null + 357565524;
84200bc6:	54 48 
84200bc8:	5c 08       	r2 = r9 + Null;
84200bca:	43 08       	r1 = r6 + Null;
84200bcc:	ff fd 02 f0 	call (m) 0x1120;
84200bd0:	35 ea 
84200bd2:	7e 4c       	SP = SP + -8;
    L2_DBG_MSG4("OPID: %x, Instance: %d, AHM Set Static Fine Gain: FF = %hu, FB = %hu",
                ext_op_id, instance, p_static->ff.fine, p_static->fb.fine);
84200bd4:	91 f0 00 e0 	rMAC = MBS[r7 + Null];
84200bd8:	88 24       	Null = rMAC - 2;
84200bda:	1f 68       	if LT jump (m) Lc_ahm_opmsg_set_static_gains_13;

84200bdc <Lc_ahm_opmsg_set_static_gains_11>:
84200bdc:	f1 86       	rMAC = MHU[r4 + 6];
84200bde:	09 1c       	pushm <rMAC>;
84200be0:	75 86       	r3 = MHU[r4 + 2];
84200be2:	55 f1 02 f0 	r0 = Null + 357565613;
84200be6:	ad 48 
84200be8:	5c 08       	r2 = r9 + Null;
84200bea:	43 08       	r1 = r6 + Null;
84200bec:	ff fd 02 f0 	call (m) 0x1104;
84200bf0:	39 e8 
84200bf2:	7f 4c       	SP = SP + -4;

    L2_DBG_MSG5("OPID: %x, Instance: %d, AHM Set Static Fine Gain: EC = %hu, "
                "Rx FFa = %hu, Rx FFb = %hu", ext_op_id, instance,
                p_static->ec.fine,
                p_static->rx_ffa_mix.fine,
                p_static->rx_ffb_mix.fine);
84200bf4:	91 f0 00 e0 	rMAC = MBS[r7 + Null];
84200bf8:	88 24       	Null = rMAC - 2;
84200bfa:	0f 68       	if LT jump (m) Lc_ahm_opmsg_set_static_gains_13;

84200bfc <Lc_ahm_opmsg_set_static_gains_12>:
84200bfc:	71 96       	rMAC = MHU[r4 + 18];
84200bfe:	09 1c       	pushm <rMAC>;
84200c00:	f1 87       	rMAC = MHU[r4 + 14];
84200c02:	09 1c       	pushm <rMAC>;
84200c04:	75 87       	r3 = MHU[r4 + 10];
84200c06:	55 f1 02 f0 	r0 = Null + 357565682;
84200c0a:	f2 48 
84200c0c:	5c 08       	r2 = r9 + Null;
84200c0e:	43 08       	r1 = r6 + Null;
84200c10:	ff fd 02 f0 	call (m) 0x1120;
84200c14:	31 e8 
84200c16:	7e 4c       	SP = SP + -8;

84200c18 <Lc_ahm_opmsg_set_static_gains_13>:

    /* Override target gains when static gains are updated */
    p_ext_data->ff_fine_tgt_gain = p_static->ff.fine;
84200c18:	71 86       	rMAC = MHU[r4 + 2];
84200c1a:	71 f0 52 8c 	MH[r5 + 164] = rMAC;
    p_ext_data->fb_fine_tgt_gain = p_static->fb.fine;
84200c1e:	f1 86       	rMAC = MHU[r4 + 6];
84200c20:	71 f0 53 8c 	MH[r5 + 166] = rMAC;

    /* Check for the change in coarse gain and update the coarse_gain_changed flags */
    ahm_check_coarse_gain_change(instance,
                                 &p_ext_data->config,
                                 p_static,
                                 p_ext_data->coarse_gain_changed);
84200c24:	73 f0 a8 20 	r1 = r5 + 168;
84200c28:	35 f0 fc 21 	r3 = r1 + 508;
84200c2c:	34 00       	r2 = r4 + Null;
84200c2e:	5a 08       	r0 = r9 + Null;
84200c30:	07 f0 3b e1 	call (m) Lc_ahm_check_coarse_gain_change_1;

    /* Allow a direct gain update if the sysmode is static without requiring
     * a follow-up gain override
     */
    if (p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_STATIC)
84200c34:	39 b8       	rMAC = M[r5 + 96];
84200c36:	c8 24       	Null = rMAC - 3;
84200c38:	45 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_18;

84200c3a <Lc_ahm_opmsg_set_static_gains_14>:
    {
        if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID && instance == AHM_ANC_INSTANCE_ANC1_ID)
84200c3a:	71 f0 a8 80 	rMAC = MBS[r5 + 168];
84200c3e:	08 25       	Null = rMAC - 4;
84200c40:	23 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_17;

84200c42 <Lc_ahm_opmsg_set_static_gains_15>:
84200c42:	b0 f0 02 24 	Null = r9 - 2;
84200c46:	20 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_17;

84200c48 <Lc_ahm_opmsg_set_static_gains_16>:
        {
            *p_ext_data->p_cur_gain1 = *p_ext_data->p_static_gain1;
84200c48:	78 f0 78 20 	r6 = r5 + 120;
84200c4c:	83 f0 04 88 	r1 = M[r6 + 16];
84200c50:	82 f0 00 e8 	r0 = M[r6 + Null];
84200c54:	04 29       	r2 = Null + 20;
84200c56:	ff fd ca f0 	call (m) 0x1a068;
84200c5a:	33 e0 
            p_ext_data->ahm_fine_nominal1[AHM_ANC_FILTER_FF_ID].gain = \
                (uint8)p_static->ff.fine;
84200c5c:	71 86       	rMAC = MHU[r4 + 2];
84200c5e:	71 f0 a4 8b 	MB[r5 + 420] = rMAC;
            p_ext_data->ahm_fine_nominal1[AHM_ANC_FILTER_FB_ID].gain = \
                (uint8)p_static->fb.fine;
84200c62:	f1 86       	rMAC = MHU[r4 + 6];
84200c64:	71 f0 bc 8b 	MB[r5 + 444] = rMAC;
            p_ext_data->ahm_fine_nominal1[AHM_ANC_FILTER_EC_ID].gain = \
                (uint8)p_static->ec.fine;
84200c68:	71 87       	rMAC = MHU[r4 + 10];
84200c6a:	71 f0 d4 8b 	MB[r5 + 468] = rMAC;

            update_dynamic_nominal_gain(p_ext_data->p_nominal_gain1,
                                        p_ext_data->p_fine_nominal1);
84200c6e:	83 f0 cc 20 	r1 = r6 + 204;
84200c72:	72 f0 24 88 	r0 = M[r5 + 144];
84200c76:	03 f0 2d e7 	call (m) Lc_update_dynamic_nominal_gain_1;
            /* Update static nominal gain. Dynamic nominal gain is updated when
             * SET_CONTROL is called for a mode change.*/
            update_static_nominal_gain(p_static, p_ext_data->p_nominal_gain1);            
84200c7a:	73 f0 24 88 	r1 = M[r5 + 144];
84200c7e:	32 00       	r0 = r4 + Null;
84200c80:	03 f0 33 e7 	call (m) Lc_update_static_nominal_gain_1;
84200c84:	1f 6e       	jump (m) Lc_ahm_opmsg_set_static_gains_18;

84200c86 <Lc_ahm_opmsg_set_static_gains_17>:
        }
        else
        {
            *p_ext_data->p_cur_gain = *p_ext_data->p_static_gain;
84200c86:	78 f0 74 20 	r6 = r5 + 116;
84200c8a:	83 f0 04 88 	r1 = M[r6 + 16];
84200c8e:	82 f0 00 e8 	r0 = M[r6 + Null];
84200c92:	04 29       	r2 = Null + 20;
84200c94:	ff fd c9 f0 	call (m) 0x1a068;
84200c98:	35 ee 
            p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FF_ID].gain = \
                (uint8)p_static->ff.fine;
84200c9a:	71 86       	rMAC = MHU[r4 + 2];
84200c9c:	71 f0 5c 8b 	MB[r5 + 348] = rMAC;
            p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_FB_ID].gain = \
                (uint8)p_static->fb.fine;
84200ca0:	f1 86       	rMAC = MHU[r4 + 6];
84200ca2:	71 f0 74 8b 	MB[r5 + 372] = rMAC;
            p_ext_data->ahm_fine_nominal[AHM_ANC_FILTER_EC_ID].gain = \
                (uint8)p_static->ec.fine;
84200ca6:	71 87       	rMAC = MHU[r4 + 10];
84200ca8:	71 f0 8c 8b 	MB[r5 + 396] = rMAC;

            update_dynamic_nominal_gain(p_ext_data->p_nominal_gain,
                                        p_ext_data->p_fine_nominal);
84200cac:	83 f0 c4 20 	r1 = r6 + 196;
84200cb0:	72 f0 23 88 	r0 = M[r5 + 140];
84200cb4:	03 f0 2f e5 	call (m) Lc_update_dynamic_nominal_gain_1;
            /* Update static nominal gain. Dynamic nominal gain is updated when
             * SET_CONTROL is called for a mode change.*/
            update_static_nominal_gain(p_static, p_ext_data->p_nominal_gain);
84200cb8:	73 f0 23 88 	r1 = M[r5 + 140];
84200cbc:	32 00       	r0 = r4 + Null;
84200cbe:	03 f0 35 e5 	call (m) Lc_update_static_nominal_gain_1;

84200cc2 <Lc_ahm_opmsg_set_static_gains_18>:
    }

    /* Echo the static gains back to the caller. This allows any adjustment
     * to be tracked upstream.
     */
    *resp_length = OPMSG_SET_AHM_STATIC_GAINS_RESP_WORD_SIZE;
84200cc2:	01 23       	rMAC = Null + 12;
84200cc4:	42 d8       	r0 = M[FP + 32];
84200cc6:	11 ee       	M[r0 + Null] = rMAC;

    p_resp = xzpnewn(OPMSG_SET_AHM_STATIC_GAINS_RESP_WORD_SIZE, unsigned);
84200cc8:	c3 20       	r1 = Null + 3;
84200cca:	02 38       	r0 = Null + 48;
84200ccc:	ff fd 31 f0 	call (m) 0x6f8e;
84200cd0:	23 e6 
    if (p_resp == NULL)
84200cd2:	10 04       	Null = r0 - Null;
84200cd4:	03 62       	if NE jump (m) Lc_ahm_opmsg_set_static_gains_20;

84200cd6 <Lc_ahm_opmsg_set_static_gains_19>:
    {
        return FALSE;
84200cd6:	02 00       	r0 = Null + Null;
84200cd8:	20 6e       	jump (m) Lc_ahm_opmsg_set_static_gains_21;

84200cda <Lc_ahm_opmsg_set_static_gains_20>:
    }

    msg_id = OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*)message_data);
84200cda:	a3 f0 02 88 	r1 = M[r8 + 8];

    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_SET_AHM_STATIC_GAINS_RESP,
                               MESSAGE_ID,
                               msg_id);
84200cde:	99 c6       	rMAC = r1 AND 0xffff;
84200ce0:	11 ee       	M[r0 + Null] = rMAC;
84200ce2:	9b 52       	r1 = r1 LSHIFT -16;
84200ce4:	53 8e       	M[r0 + 4] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             ANC_INSTANCE,
                             instance);
84200ce6:	2b f0 01 8e 	M[r0 + 4] = r9;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             FF_COARSE_GAIN,
                             p_static->ff.coarse);
84200cea:	31 e4       	rMAC = MHS[r4 + Null];
84200cec:	91 8e       	M[r0 + 8] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             FF_FINE_GAIN,
                             p_static->ff.fine);
84200cee:	71 86       	rMAC = MHU[r4 + 2];
84200cf0:	d1 8e       	M[r0 + 12] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             FB_COARSE_GAIN,
                             p_static->fb.coarse);
84200cf2:	b1 84       	rMAC = MHS[r4 + 4];
84200cf4:	11 8f       	M[r0 + 16] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             FB_FINE_GAIN,
                             p_static->fb.fine);
84200cf6:	f1 86       	rMAC = MHU[r4 + 6];
84200cf8:	51 8f       	M[r0 + 20] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             EC_COARSE_GAIN,
                             p_static->ec.coarse);
84200cfa:	31 85       	rMAC = MHS[r4 + 8];
84200cfc:	91 8f       	M[r0 + 24] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             EC_FINE_GAIN,
                             p_static->ec.fine);
84200cfe:	71 87       	rMAC = MHU[r4 + 10];
84200d00:	d1 8f       	M[r0 + 28] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             RX_FFA_MIX_COARSE_GAIN,
                             p_static->rx_ffa_mix.coarse);
84200d02:	b1 85       	rMAC = MHS[r4 + 12];
84200d04:	11 9e       	M[r0 + 32] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             RX_FFA_MIX_FINE_GAIN,
                             p_static->rx_ffa_mix.fine);
84200d06:	f1 87       	rMAC = MHU[r4 + 14];
84200d08:	51 9e       	M[r0 + 36] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             RX_FFB_MIX_COARSE_GAIN,
                             p_static->rx_ffb_mix.coarse);
84200d0a:	31 94       	rMAC = MHS[r4 + 16];
84200d0c:	91 9e       	M[r0 + 40] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_SET_AHM_STATIC_GAINS_RESP,
                             RX_FFB_MIX_FINE_GAIN,
                             p_static->rx_ffb_mix.fine);
84200d0e:	71 96       	rMAC = MHU[r4 + 18];
84200d10:	d1 9e       	M[r0 + 44] = rMAC;

    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)p_resp;
84200d12:	49 d8       	rMAC = M[FP + 36];
84200d14:	0a ee       	M[rMAC + Null] = r0;

    return TRUE;
84200d16:	42 20       	r0 = Null + 1;

84200d18 <Lc_ahm_opmsg_set_static_gains_21>:
}
84200d18:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200d1a:	d8 4c       	rts;

84200d1c <$_ahm_opmsg_get_gains>:

bool ahm_opmsg_get_gains(OPERATOR_DATA *op_data,
                         void *message_data,
                         unsigned *resp_length,
                         OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d1c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200d1e:	19 09       	r7 = r1 + Null;
84200d20:	26 00       	r4 = r2 + Null;
84200d22:	2a 09       	r8 = r3 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200d24:	ef fd fd ff 	call (m) 0x8ea;
84200d28:	27 ee 
84200d2a:	17 00       	r5 = r0 + Null;
    AHM_GAIN_BANK *p_gain;
    unsigned msg_id, anc_instance;

    anc_instance = OPMSG_FIELD_GET(message_data,
                                   OPMSG_GET_AHM_GAINS,
                                   ANC_INSTANCE);
84200d2c:	91 f0 03 88 	rMAC = M[r7 + 12];
84200d30:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;
    *resp_length = OPMSG_GET_AHM_GAINS_RESP_WORD_SIZE;
84200d34:	01 23       	rMAC = Null + 12;
84200d36:	31 ee       	M[r4 + Null] = rMAC;

    p_resp = xzpnewn(OPMSG_GET_AHM_GAINS_RESP_WORD_SIZE, unsigned);
84200d38:	c3 20       	r1 = Null + 3;
84200d3a:	02 38       	r0 = Null + 48;
84200d3c:	ff fd 31 f0 	call (m) 0x6f8e;
84200d40:	33 e2 
    if (p_resp == NULL)
84200d42:	10 04       	Null = r0 - Null;
84200d44:	03 62       	if NE jump (m) Lc_ahm_opmsg_get_gains_3;

84200d46 <Lc_ahm_opmsg_get_gains_2>:
    {
        return FALSE;
84200d46:	02 00       	r0 = Null + Null;
84200d48:	29 6e       	jump (m) Lc_ahm_opmsg_get_gains_7;

84200d4a <Lc_ahm_opmsg_get_gains_3>:
    }

    msg_id = OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*)message_data);
84200d4a:	93 f0 02 88 	r1 = M[r7 + 8];

    p_gain = p_ext_data->p_cur_gain;
84200d4e:	79 b9       	rMAC = M[r5 + 116];
    if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID && anc_instance == AHM_ANC_INSTANCE_ANC1_ID)
84200d50:	74 f0 a8 80 	r2 = MBS[r5 + 168];
84200d54:	20 25       	Null = r2 - 4;
84200d56:	05 62       	if NE jump (m) Lc_ahm_opmsg_get_gains_6;

84200d58 <Lc_ahm_opmsg_get_gains_4>:
84200d58:	80 f0 02 24 	Null = r6 - 2;
84200d5c:	02 62       	if NE jump (m) Lc_ahm_opmsg_get_gains_6;

84200d5e <Lc_ahm_opmsg_get_gains_5>:
    {
        p_gain = p_ext_data->p_cur_gain1;
84200d5e:	b9 b9       	rMAC = M[r5 + 120];

84200d60 <Lc_ahm_opmsg_get_gains_6>:
    }
    
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_GET_AHM_GAINS_RESP,
                               MESSAGE_ID,
                               msg_id);
84200d60:	9c c6       	r2 = r1 AND 0xffff;
84200d62:	14 ee       	M[r0 + Null] = r2;
84200d64:	9b 52       	r1 = r1 LSHIFT -16;
84200d66:	53 8e       	M[r0 + 4] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             ANC_INSTANCE,
                             anc_instance);
84200d68:	28 f0 01 8e 	M[r0 + 4] = r6;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             FF_COARSE_GAIN,
                             p_gain->ff.coarse);
84200d6c:	0b e4       	r1 = MHS[rMAC + Null];
84200d6e:	93 8e       	M[r0 + 8] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             FF_FINE_GAIN,
                             p_gain->ff.fine);
84200d70:	4b 86       	r1 = MHU[rMAC + 2];
84200d72:	d3 8e       	M[r0 + 12] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             FB_COARSE_GAIN,
                             p_gain->fb.coarse);
84200d74:	8b 84       	r1 = MHS[rMAC + 4];
84200d76:	13 8f       	M[r0 + 16] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             FB_FINE_GAIN,
                             p_gain->fb.fine);
84200d78:	cb 86       	r1 = MHU[rMAC + 6];
84200d7a:	53 8f       	M[r0 + 20] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             EC_COARSE_GAIN,
                             p_gain->ec.coarse);
84200d7c:	0b 85       	r1 = MHS[rMAC + 8];
84200d7e:	93 8f       	M[r0 + 24] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             EC_FINE_GAIN,
                             p_gain->ec.fine);
84200d80:	4b 87       	r1 = MHU[rMAC + 10];
84200d82:	d3 8f       	M[r0 + 28] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             RX_FFA_MIX_COARSE_GAIN,
                             p_gain->rx_ffa_mix.coarse);
84200d84:	8b 85       	r1 = MHS[rMAC + 12];
84200d86:	13 9e       	M[r0 + 32] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             RX_FFA_MIX_FINE_GAIN,
                             p_gain->rx_ffa_mix.fine);
84200d88:	cb 87       	r1 = MHU[rMAC + 14];
84200d8a:	53 9e       	M[r0 + 36] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             RX_FFB_MIX_COARSE_GAIN,
                             p_gain->rx_ffb_mix.coarse);
84200d8c:	0b 94       	r1 = MHS[rMAC + 16];
84200d8e:	93 9e       	M[r0 + 40] = r1;
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_GET_AHM_GAINS_RESP,
                             RX_FFB_MIX_FINE_GAIN,
                             p_gain->rx_ffb_mix.fine);
84200d90:	49 96       	rMAC = MHU[rMAC + 18];
84200d92:	d1 9e       	M[r0 + 44] = rMAC;

    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)p_resp;
84200d94:	a2 f0 00 ee 	M[r8 + Null] = r0;

    return TRUE;
84200d98:	42 20       	r0 = Null + 1;

84200d9a <Lc_ahm_opmsg_get_gains_7>:
}
84200d9a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200d9c:	d8 4c       	rts;

84200d9e <$_ahm_opmsg_set_target_makeup_gain>:

bool ahm_opmsg_set_target_makeup_gain(OPERATOR_DATA *op_data,
                                      void *message_data,
                                      unsigned *resp_length,
                                      OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d9e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200da0:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200da2:	ef fd fd ff 	call (m) 0x8ea;
84200da6:	29 ea 
84200da8:	17 00       	r5 = r0 + Null;
                                      void *message_data,
                                      unsigned *resp_length,
                                      OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);
    AHM_GAIN_BANK *p_stat = p_ext_data->p_static_gain;
84200daa:	71 f0 21 88 	rMAC = M[r5 + 132];

    p_msg = (OPMSG_SET_TARGET_MAKEUP_GAIN*)message_data;

    tgt_msb = OPMSG_FIELD_GET(p_msg,
                              OPMSG_SET_TARGET_MAKEUP_GAIN,
                              MAKEUP_GAIN);
84200dae:	f2 88       	r0 = M[r4 + 12];
84200db0:	92 c6       	r0 = r0 AND 0xffff;
    tgt_lsb = OPMSG_FIELD_GET_FROM_OFFSET(p_msg,
                                          OPMSG_SET_TARGET_MAKEUP_GAIN,
                                          MAKEUP_GAIN,
                                          1);
84200db2:	33 89       	r1 = M[r4 + 16];
84200db4:	9b c6       	r1 = r1 AND 0xffff;

    p_ext_data->target_makeup_gain = (tgt_msb << 16) | tgt_lsb;
84200db6:	92 56       	r0 = r0 LSHIFT 16;
84200db8:	9b 12       	r1 = r1 OR r0;
84200dba:	73 f0 28 8e 	M[r5 + 160] = r1;

    p_ext_data->ff_fine_tgt_gain = \
        aud_cur_calc_adjusted_gain(p_stat->ff.fine, p_ext_data->target_makeup_gain);
84200dbe:	4a 86       	r0 = MHU[rMAC + 2];
84200dc0:	14 f0 37 e2 	call (m) $_aud_cur_calc_adjusted_gain;
84200dc4:	72 f0 52 8c 	MH[r5 + 164] = r0;

    p_ext_data->set_target_flag = TRUE;
84200dc8:	41 20       	rMAC = Null + 1;
84200dca:	71 f0 b5 8e 	M[r5 + 724] = rMAC;
    return TRUE;
84200dce:	0a 00       	r0 = rMAC + Null;

84200dd0 <Lc_ahm_opmsg_set_target_makeup_gain_2>:
}
84200dd0:	f2 48       	popm <FP, r4, r5, rLink>;
84200dd2:	d8 4c       	rts;

84200dd4 <$_ahm_opmsg_set_fine_target_gain>:

bool ahm_opmsg_set_fine_target_gain(OPERATOR_DATA *op_data,
                                    void *message_data,
                                    unsigned *resp_length,
                                    OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200dd4:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200dd6:	16 00       	r4 = r0 + Null;
84200dd8:	1f 00       	r5 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200dda:	ef fd fd ff 	call (m) 0x8ea;
84200dde:	31 e8 
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_fine_target_gain Fn entry", INT_TO_EXT_OPID(op_data->id));

    p_msg = (OPMSG_SET_FINE_TARGET_GAIN *)message_data;
    filter = OPMSG_FIELD_GET(p_msg,
                             OPMSG_SET_FINE_TARGET_GAIN,
                             FILTER);
84200de0:	f9 88       	rMAC = M[r5 + 12];
84200de2:	8c c6       	r2 = rMAC AND 0xffff;
    tgt_gain = OPMSG_FIELD_GET(p_msg,
                               OPMSG_SET_FINE_TARGET_GAIN,
                               TARGET_GAIN);
84200de4:	39 89       	rMAC = M[r5 + 16];
84200de6:	89 c6       	rMAC = rMAC AND 0xffff;

    switch (filter)
84200de8:	23 00       	r1 = r2 + Null;
84200dea:	06 60       	if EQ jump (m) Lc_ahm_opmsg_set_fine_target_gain_4;

84200dec <Lc_ahm_opmsg_set_fine_target_gain_2>:
84200dec:	58 24       	Null = r1 - 1;
84200dee:	0b 62       	if NE jump (m) Lc_ahm_opmsg_set_fine_target_gain_6;

84200df0 <Lc_ahm_opmsg_set_fine_target_gain_3>:
        case AHM_ANC_FILTER_FF_ID:
            p_ext_data->ff_fine_tgt_gain = tgt_gain;
            p_ext_data->set_target_flag = TRUE;
            break;
        case AHM_ANC_FILTER_FB_ID:
            p_ext_data->fb_fine_tgt_gain = tgt_gain;
84200df0:	21 f0 53 8c 	MH[r0 + 166] = rMAC;
            break;
84200df4:	06 6e       	jump (m) Lc_ahm_opmsg_set_fine_target_gain_5;

84200df6 <Lc_ahm_opmsg_set_fine_target_gain_4>:
                               TARGET_GAIN);

    switch (filter)
    {
        case AHM_ANC_FILTER_FF_ID:
            p_ext_data->ff_fine_tgt_gain = tgt_gain;
84200df6:	21 f0 52 8c 	MH[r0 + 164] = rMAC;
            p_ext_data->set_target_flag = TRUE;
84200dfa:	41 20       	rMAC = Null + 1;
84200dfc:	21 f0 b5 8e 	M[r0 + 724] = rMAC;

84200e00 <Lc_ahm_opmsg_set_fine_target_gain_5>:
        default:
            L2_DBG_MSG2("OPID: %x, AHM Unsupported filter block %d", INT_TO_EXT_OPID(op_data->id), filter);
            return FALSE;
    }

    return TRUE;
84200e00:	42 20       	r0 = Null + 1;
84200e02:	11 6e       	jump (m) Lc_ahm_opmsg_set_fine_target_gain_9;

84200e04 <Lc_ahm_opmsg_set_fine_target_gain_6>:
            break;
        case AHM_ANC_FILTER_FB_ID:
            p_ext_data->fb_fine_tgt_gain = tgt_gain;
            break;
        default:
            L2_DBG_MSG2("OPID: %x, AHM Unsupported filter block %d", INT_TO_EXT_OPID(op_data->id), filter);
84200e04:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200e08:	88 24       	Null = rMAC - 2;
84200e0a:	0c 68       	if LT jump (m) Lc_ahm_opmsg_set_fine_target_gain_8;

84200e0c <Lc_ahm_opmsg_set_fine_target_gain_7>:
84200e0c:	72 88       	r0 = M[r4 + 4];
84200e0e:	52 55       	r0 = r0 LSHIFT 6;
84200e10:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84200e14:	53 d8 
84200e16:	55 f1 02 f0 	r0 = Null + 357566095;
84200e1a:	8f 4a 
84200e1c:	ff fd 01 f0 	call (m) 0x10d6;
84200e20:	3b e5 

84200e22 <Lc_ahm_opmsg_set_fine_target_gain_8>:
            return FALSE;
84200e22:	02 00       	r0 = Null + Null;

84200e24 <Lc_ahm_opmsg_set_fine_target_gain_9>:
    }

    return TRUE;
}
84200e24:	f2 48       	popm <FP, r4, r5, rLink>;
84200e26:	d8 4c       	rts;

84200e28 <$_ahm_opmsg_get_shared_gain_ptr>:

bool ahm_opmsg_get_shared_gain_ptr(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *resp_length,
                                   OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200e28:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200e2a:	42 de       	M[FP + 32] = r0;
84200e2c:	1b 09       	r9 = r1 + Null;
84200e2e:	4c de       	M[FP + 36] = r2;
84200e30:	55 de       	M[FP + 40] = r3;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84200e32:	ef fd fd ff 	call (m) 0x8ea;
84200e36:	39 e5 
84200e38:	16 00       	r4 = r0 + Null;
    AHM_ANC_FILTER anc_filter;
    AHM_ANC_INSTANCE anc_instance;
    bool is_coarse;
    unsigned gc_type_data;
    AHM_GAIN_CONTROL_TYPE gc_type;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
84200e3a:	41 d8       	rMAC = M[FP + 32];
84200e3c:	4a 88       	r0 = M[rMAC + 4];
84200e3e:	52 55       	r0 = r0 LSHIFT 6;
84200e40:	40 f0 00 f2 	r8 = r0 OR 0x4000;
84200e44:	5a d8 
    DEBUG_AHM("OPID: %x, ahm_opmsg_get_shared_gain_ptr Fn entry", ext_op_id);

    /* Only handle fine gains */
    is_coarse_data = OPMSG_FIELD_GET(message_data,
                                     OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                     COARSE);
84200e46:	b1 f0 06 88 	rMAC = M[r9 + 24];
    is_coarse = (bool)is_coarse_data;

    if (is_coarse)
84200e4a:	89 c6       	rMAC = rMAC AND 0xffff;
84200e4c:	0e 60       	if EQ jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_5;

84200e4e <Lc_ahm_opmsg_get_shared_gain_ptr_2>:
    {
        L2_DBG_MSG1("OPID: %x, AHM Shared coarse gain not supported", ext_op_id);
84200e4e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200e52:	88 24       	Null = rMAC - 2;
84200e54:	08 68       	if LT jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_4;

84200e56 <Lc_ahm_opmsg_get_shared_gain_ptr_3>:
84200e56:	55 f1 02 f0 	r0 = Null + 357565801;
84200e5a:	69 49 
84200e5c:	53 08       	r1 = r8 + Null;
84200e5e:	ff fd 01 f0 	call (m) 0x10c2;
84200e62:	25 e3 

84200e64 <Lc_ahm_opmsg_get_shared_gain_ptr_4>:
        return FALSE;
84200e64:	02 00       	r0 = Null + Null;
84200e66:	ec 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_29;

84200e68 <Lc_ahm_opmsg_get_shared_gain_ptr_5>:
    }

    /* Interpret the gain control type */
    gc_type_data = OPMSG_FIELD_GET(message_data,
                                   OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                   CONTROL_TYPE);
84200e68:	b1 f0 07 88 	rMAC = M[r9 + 28];
84200e6c:	89 c6       	rMAC = rMAC AND 0xffff;
    gc_type = (AHM_GAIN_CONTROL_TYPE)gc_type_data;
84200e6e:	ef f1 49 ce 	r7 = SE8 rMAC;

    /* Get the filter to share gains on */
    anc_filter_data = OPMSG_FIELD_GET(message_data,
                                      OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                      FILTER);
84200e72:	b1 f0 05 88 	rMAC = M[r9 + 20];
84200e76:	89 c6       	rMAC = rMAC AND 0xffff;
    anc_filter = (AHM_ANC_FILTER)anc_filter_data;
84200e78:	0f 08       	r5 = SE8 rMAC;

    /* Get the instance to share gains on */
    anc_instance_data = OPMSG_FIELD_GET(message_data,
                                        OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                        CHANNEL);
84200e7a:	b1 f0 08 88 	rMAC = M[r9 + 32];
84200e7e:	89 c6       	rMAC = rMAC AND 0xffff;
    anc_instance = (AHM_ANC_INSTANCE)anc_instance_data;
84200e80:	09 08       	rMAC = SE8 rMAC;
84200e82:	59 de       	M[FP + 44] = rMAC;
84200e84:	0a 00       	r0 = rMAC + Null;


    p_stat_path = &p_ext_data->p_static_gain->ff ;
84200e86:	61 f0 21 88 	rMAC = M[r4 + 132];
84200e8a:	08 09       	r6 = rMAC + Null;
    if (anc_instance == AHM_ANC_INSTANCE_ANC0_ID)
84200e8c:	50 24       	Null = r0 - 1;
84200e8e:	0f 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_12;

84200e90 <Lc_ahm_opmsg_get_shared_gain_ptr_6>:
    {
        if (anc_filter == AHM_ANC_FILTER_FF_ID)
84200e90:	38 04       	Null = r5 - Null;
84200e92:	03 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_8;

84200e94 <Lc_ahm_opmsg_get_shared_gain_ptr_7>:
        {
            p_stat_path = &p_ext_data->p_static_gain->ff;
84200e94:	08 09       	r6 = rMAC + Null;
84200e96:	1b 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200e98 <Lc_ahm_opmsg_get_shared_gain_ptr_8>:
        }
        else if (anc_filter == AHM_ANC_FILTER_FB_ID)
84200e98:	78 24       	Null = r5 - 1;
84200e9a:	04 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_10;

84200e9c <Lc_ahm_opmsg_get_shared_gain_ptr_9>:
        {
            p_stat_path = &p_ext_data->p_static_gain->fb;
84200e9c:	18 f0 04 20 	r6 = rMAC + 4;
84200ea0:	16 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200ea2 <Lc_ahm_opmsg_get_shared_gain_ptr_10>:
        }
        else if (anc_filter == AHM_ANC_FILTER_EC_ID)
84200ea2:	b8 24       	Null = r5 - 2;
84200ea4:	14 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200ea6 <Lc_ahm_opmsg_get_shared_gain_ptr_11>:
        {
            p_stat_path = &p_ext_data->p_static_gain->ec;
84200ea6:	18 f0 08 20 	r6 = rMAC + 8;
84200eaa:	11 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200eac <Lc_ahm_opmsg_get_shared_gain_ptr_12>:
        }
    }
    else if (anc_instance == AHM_ANC_INSTANCE_ANC1_ID)
84200eac:	59 d8       	rMAC = M[FP + 44];
84200eae:	88 24       	Null = rMAC - 2;
84200eb0:	06 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_15;

84200eb2 <Lc_ahm_opmsg_get_shared_gain_ptr_13>:
    {
        if (anc_filter == AHM_ANC_FILTER_FF_ID)
84200eb2:	38 04       	Null = r5 - Null;
84200eb4:	0c 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200eb6 <Lc_ahm_opmsg_get_shared_gain_ptr_14>:
        {
            p_stat_path = &p_ext_data->p_static_gain1->ff;
84200eb6:	68 f0 22 88 	r6 = M[r4 + 136];
84200eba:	09 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_16;

84200ebc <Lc_ahm_opmsg_get_shared_gain_ptr_15>:
        }
    }
    else
    {
        L0_DBG_MSG2("OPID: %x, AHM invalid anc instance %d", ext_op_id, anc_instance);
84200ebc:	55 f1 02 f0 	r0 = Null + 357565848;
84200ec0:	98 49 
84200ec2:	53 08       	r1 = r8 + Null;
84200ec4:	5c d8       	r2 = M[FP + 44];
84200ec6:	ff fd 01 f0 	call (m) 0x10d6;
84200eca:	31 e0 

84200ecc <Lc_ahm_opmsg_get_shared_gain_ptr_16>:
    }
    p_cur_gain = p_ext_data->p_cur_gain;
84200ecc:	71 b9       	rMAC = M[r4 + 116];
84200ece:	61 de       	M[FP + 48] = rMAC;
    p_nominal_gain = p_ext_data->p_nominal_gain;
84200ed0:	61 f0 23 88 	rMAC = M[r4 + 140];
84200ed4:	69 de       	M[FP + 52] = rMAC;
    p_static_gain = p_ext_data->p_static_gain;
84200ed6:	61 f0 21 88 	rMAC = M[r4 + 132];
84200eda:	71 de       	M[FP + 56] = rMAC;

    L2_DBG_MSG2("OPID: %x, AHM link filter block %d", ext_op_id, anc_filter);
84200edc:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200ee0:	88 24       	Null = rMAC - 2;
84200ee2:	09 68       	if LT jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_18;

84200ee4 <Lc_ahm_opmsg_get_shared_gain_ptr_17>:
84200ee4:	55 f1 02 f0 	r0 = Null + 357565886;
84200ee8:	be 49 
84200eea:	3c 00       	r2 = r5 + Null;
84200eec:	53 08       	r1 = r8 + Null;
84200eee:	ff fd 00 f0 	call (m) 0x10d6;
84200ef2:	29 ef 

84200ef4 <Lc_ahm_opmsg_get_shared_gain_ptr_18>:

    switch (gc_type)
84200ef4:	49 08       	rMAC = r7 + Null;
84200ef6:	1b 60       	if EQ jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_22;

84200ef8 <Lc_ahm_opmsg_get_shared_gain_ptr_19>:
84200ef8:	48 24       	Null = rMAC - 1;
84200efa:	5d 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_26;

84200efc <Lc_ahm_opmsg_get_shared_gain_ptr_20>:
            p_gain->gain_current = AHM_DELTA_NOMINAL;
            p_gain->gain_delta = AHM_DELTA_NOMINAL;
            break;
        case AHM_GAIN_CONTROL_TYPE_NOMINAL:
            /* Hand out the client gain address */
            if (anc_instance == AHM_ANC_INSTANCE_ANC0_ID)
84200efc:	59 d8       	rMAC = M[FP + 44];
84200efe:	48 24       	Null = rMAC - 1;
84200f00:	40 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_25;

84200f02 <Lc_ahm_opmsg_get_shared_gain_ptr_21>:
            {
                p_ext_data->client_fine_nominal[anc_filter].gain = (uint8) p_stat_path->fine;
84200f02:	3a 46       	r0 = r5 * 24 (int);
84200f04:	31 00       	rMAC = r4 + Null;
84200f06:	51 00       	rMAC = r0 + rMAC;
84200f08:	82 f0 01 86 	r0 = MHU[r6 + 2];
84200f0c:	12 f0 ec 8b 	MB[rMAC + 492] = r0;
                p_gain = &p_ext_data->client_fine_nominal[anc_filter];
84200f10:	18 f0 e0 21 	r6 = rMAC + 480;
                p_ext_data->p_fine_nominal[anc_filter] = p_gain;
84200f14:	7a 54       	r0 = r5 LSHIFT 2;
84200f16:	31 00       	rMAC = r4 + Null;
84200f18:	51 00       	rMAC = r0 + rMAC;
84200f1a:	18 f0 4e 8e 	M[rMAC + 312] = r6;
                p_ext_data->ahm_nominal_client[anc_filter] = TRUE;
84200f1e:	42 20       	r0 = Null + 1;
84200f20:	12 f0 9c 8e 	M[rMAC + 624] = r0;
                p_static_gain = p_ext_data->p_static_gain;
84200f24:	61 f0 21 88 	rMAC = M[r4 + 132];
84200f28:	71 de       	M[FP + 56] = rMAC;
84200f2a:	11 6e       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_23;

84200f2c <Lc_ahm_opmsg_get_shared_gain_ptr_22>:
    L2_DBG_MSG2("OPID: %x, AHM link filter block %d", ext_op_id, anc_filter);

    switch (gc_type)
    {
        case AHM_GAIN_CONTROL_TYPE_DELTA:
            p_head = &p_ext_data->p_fine_delta_head[anc_filter];
84200f2c:	7a 54       	r0 = r5 LSHIFT 2;
84200f2e:	31 00       	rMAC = r4 + Null;
84200f30:	51 00       	rMAC = r0 + rMAC;
84200f32:	12 f0 14 21 	r0 = rMAC + 276;
            p_gain = ahm_list_fine_gain_add(p_head, ext_op_id);
84200f36:	53 08       	r1 = r8 + Null;
84200f38:	0b f0 31 e6 	call (m) $_ahm_list_fine_gain_add;
84200f3c:	10 09       	r6 = r0 + Null;
            p_gain->gain_current = AHM_DELTA_NOMINAL;
84200f3e:	10 f0 01 f0 	rMAC = Null + 16777216;
84200f42:	00 40 
84200f44:	81 f0 04 8e 	M[r6 + 16] = rMAC;
            p_gain->gain_delta = AHM_DELTA_NOMINAL;
84200f48:	81 f0 00 ee 	M[r6 + Null] = rMAC;

84200f4c <Lc_ahm_opmsg_get_shared_gain_ptr_23>:
        default:
            L2_DBG_MSG2("OPID: %x, AHM invalid gain control type %d", ext_op_id, gc_type);
            return FALSE;
    }

    p_gain->gain_type = gc_type;
84200f4c:	89 f0 0e 8a 	MB[r6 + 14] = r7;

    p_recv_ext_data = OPMSG_FIELD_GET32(message_data,
                                        OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                        P_EXT_DATA);
84200f50:	b1 f0 04 88 	rMAC = M[r9 + 16];
84200f54:	8a c6       	r0 = rMAC AND 0xffff;
84200f56:	92 56       	r0 = r0 LSHIFT 16;
84200f58:	b1 f0 03 88 	rMAC = M[r9 + 12];
84200f5c:	89 c6       	rMAC = rMAC AND 0xffff;
84200f5e:	1f f2 09 c0 	r7 = r0 + rMAC;

    /* Send OPMSG_COMMON_ID_RECV_ANC_HW_MANAGER_PTR in response */
    p_resp = xzpnewn(OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP_WORD_SIZE,
                     unsigned);
84200f62:	c3 20       	r1 = Null + 3;
84200f64:	02 3b       	r0 = Null + 60;
84200f66:	ff fd 30 f0 	call (m) 0x6f8e;
84200f6a:	29 e1 
    if (p_resp == NULL)
84200f6c:	10 04       	Null = r0 - Null;
84200f6e:	30 62       	if NE jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_28;

84200f70 <Lc_ahm_opmsg_get_shared_gain_ptr_24>:
    {
        L0_DBG_MSG1("OPID: %x, AHM failed to create shared gain response", ext_op_id);
84200f70:	55 f1 02 f0 	r0 = Null + 357565964;
84200f74:	0c 4a 
84200f76:	53 08       	r1 = r8 + Null;
84200f78:	ff fd 00 f0 	call (m) 0x10c2;
84200f7c:	2b ea 
84200f7e:	73 6f       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_4;

84200f80 <Lc_ahm_opmsg_get_shared_gain_ptr_25>:
                p_ext_data->ahm_nominal_client[anc_filter] = TRUE;
                p_static_gain = p_ext_data->p_static_gain;
            }
            else
            {
                p_ext_data->client_fine_nominal1[anc_filter].gain = (uint8) p_stat_path->fine;
84200f80:	3a 46       	r0 = r5 * 24 (int);
84200f82:	31 00       	rMAC = r4 + Null;
84200f84:	51 00       	rMAC = r0 + rMAC;
84200f86:	82 f0 01 86 	r0 = MHU[r6 + 2];
84200f8a:	12 f0 34 9a 	MB[rMAC + 564] = r0;
                p_gain = &p_ext_data->client_fine_nominal1[anc_filter];
84200f8e:	18 f0 28 22 	r6 = rMAC + 552;
                p_ext_data->p_fine_nominal1[anc_filter] = p_gain;
84200f92:	7a 54       	r0 = r5 LSHIFT 2;
84200f94:	31 00       	rMAC = r4 + Null;
84200f96:	51 00       	rMAC = r0 + rMAC;
84200f98:	18 f0 51 8e 	M[rMAC + 324] = r6;
                p_ext_data->ahm_nominal_client1[anc_filter] = TRUE;
84200f9c:	42 20       	r0 = Null + 1;
84200f9e:	12 f0 9f 8e 	M[rMAC + 636] = r0;
                p_cur_gain = p_ext_data->p_cur_gain1;
84200fa2:	b1 b9       	rMAC = M[r4 + 120];
84200fa4:	61 de       	M[FP + 48] = rMAC;
                p_nominal_gain = p_ext_data->p_nominal_gain1;
84200fa6:	61 f0 24 88 	rMAC = M[r4 + 144];
84200faa:	69 de       	M[FP + 52] = rMAC;
                p_static_gain =p_ext_data->p_static_gain1;
84200fac:	61 f0 22 88 	rMAC = M[r4 + 136];
84200fb0:	71 de       	M[FP + 56] = rMAC;
84200fb2:	cd 6f       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_23;

84200fb4 <Lc_ahm_opmsg_get_shared_gain_ptr_26>:
            }
            break;
        default:
            L2_DBG_MSG2("OPID: %x, AHM invalid gain control type %d", ext_op_id, gc_type);
84200fb4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84200fb8:	88 24       	Null = rMAC - 2;
84200fba:	55 69       	if LT jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_4;

84200fbc <Lc_ahm_opmsg_get_shared_gain_ptr_27>:
84200fbc:	55 f1 02 f0 	r0 = Null + 357565921;
84200fc0:	e1 49 
84200fc2:	4c 08       	r2 = r7 + Null;
84200fc4:	53 08       	r1 = r8 + Null;
84200fc6:	ff fd 00 f0 	call (m) 0x10d6;
84200fca:	31 e8 
84200fcc:	4c 6f       	jump (m) Lc_ahm_opmsg_get_shared_gain_ptr_4;

84200fce <Lc_ahm_opmsg_get_shared_gain_ptr_28>:
    {
        L0_DBG_MSG1("OPID: %x, AHM failed to create shared gain response", ext_op_id);
        return FALSE;
    }

    *resp_length = OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP_WORD_SIZE;
84200fce:	c1 23       	rMAC = Null + 15;
84200fd0:	4b d8       	r1 = M[FP + 36];
84200fd2:	19 ee       	M[r1 + Null] = rMAC;
    msg_id = OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*)message_data);
84200fd4:	b1 f0 02 88 	rMAC = M[r9 + 8];

    /* Set the message ID */
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                             MESSAGE_ID,
                             msg_id);
84200fd8:	11 ee       	M[r0 + Null] = rMAC;
    /* Set the extra operator data pointer */
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               P_EXT_DATA,
                               p_recv_ext_data);
84200fda:	91 f7 ff 1f 	rMAC = r7 AND 0xffff;
84200fde:	78 f9 d3 c8 	r1 = r7 LSHIFT -16;
84200fe2:	51 8e       	M[r0 + 4] = rMAC;
84200fe4:	93 8e       	M[r0 + 8] = r1;
    /* Set the gains */
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               SHARED_GAIN_PTR,
                               (unsigned)p_gain);
84200fe6:	81 f7 ff 1f 	rMAC = r6 AND 0xffff;
84200fea:	78 f8 d3 c8 	r1 = r6 LSHIFT -16;
84200fee:	d1 8e       	M[r0 + 12] = rMAC;
84200ff0:	13 8f       	M[r0 + 16] = r1;
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               CURRENT_GAINS_PTR,
                               (unsigned)p_cur_gain);
84200ff2:	61 d8       	rMAC = M[FP + 48];
84200ff4:	0b 00       	r1 = rMAC + Null;
84200ff6:	89 c6       	rMAC = rMAC AND 0xffff;
84200ff8:	9b 52       	r1 = r1 LSHIFT -16;
84200ffa:	51 8f       	M[r0 + 20] = rMAC;
84200ffc:	93 8f       	M[r0 + 24] = r1;
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               STATIC_GAINS_PTR,
                               (unsigned)p_static_gain);
84200ffe:	71 d8       	rMAC = M[FP + 56];
84201000:	0b 00       	r1 = rMAC + Null;
84201002:	89 c6       	rMAC = rMAC AND 0xffff;
84201004:	9b 52       	r1 = r1 LSHIFT -16;
84201006:	d1 8f       	M[r0 + 28] = rMAC;
84201008:	13 9e       	M[r0 + 32] = r1;
    OPMSG_CREATION_FIELD_SET32(p_resp,
                               OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                               NOMINAL_GAINS_PTR,
                               (unsigned)p_nominal_gain);
8420100a:	69 d8       	rMAC = M[FP + 52];
8420100c:	0b 00       	r1 = rMAC + Null;
8420100e:	89 c6       	rMAC = rMAC AND 0xffff;
84201010:	9b 52       	r1 = r1 LSHIFT -16;
84201012:	51 9e       	M[r0 + 36] = rMAC;
84201014:	93 9e       	M[r0 + 40] = r1;
    /* Echo the filter type */
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                             FILTER_TYPE,
                             anc_filter);
84201016:	d7 9e       	M[r0 + 44] = r5;
    /* Echo the anc instance */
    OPMSG_CREATION_FIELD_SET(p_resp,
                             OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                             CHANNEL,
                             anc_instance);
84201018:	59 d8       	rMAC = M[FP + 44];
8420101a:	11 9f       	M[r0 + 48] = rMAC;
    OPMSG_CREATION_FIELD_SET32(p_resp,
                              OPMSG_COMMON_MSG_GET_SHARED_GAIN_RESP,
                              AHM_TIMER_PERIOD_US,
                              p_ext_data->timer_period);
8420101c:	61 f0 ae 88 	rMAC = M[r4 + 696];
84201020:	89 c6       	rMAC = rMAC AND 0xffff;
84201022:	51 9f       	M[r0 + 52] = rMAC;
84201024:	63 f0 ae 88 	r1 = M[r4 + 696];
84201028:	9b 52       	r1 = r1 LSHIFT -16;
8420102a:	93 9f       	M[r0 + 56] = r1;

    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)p_resp;
8420102c:	51 d8       	rMAC = M[FP + 40];
8420102e:	0a ee       	M[rMAC + Null] = r0;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84201030:	42 d8       	r0 = M[FP + 32];
84201032:	ef fd fc ff 	call (m) 0x934;
84201036:	23 e8 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
84201038:	41 20       	rMAC = Null + 1;
8420103a:	11 ea       	MB[r0 + Null] = rMAC;

    /* Set reinitialization to make sure the list gets resorted */
    aud_cur_set_reinit(op_data, TRUE);

    return TRUE;
8420103c:	0a 00       	r0 = rMAC + Null;

8420103e <Lc_ahm_opmsg_get_shared_gain_ptr_29>:
}
8420103e:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201040:	d8 4c       	rts;

84201042 <$_ahm_opmsg_free_shared_gain_ptr>:

bool ahm_opmsg_free_shared_gain_ptr(OPERATOR_DATA *op_data,
                                    void *message_data,
                                    unsigned *resp_length,
                                    OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201042:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201044:	16 00       	r4 = r0 + Null;
84201046:	1f 00       	r5 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201048:	ef fd fc ff 	call (m) 0x8ea;
8420104c:	23 e5 
8420104e:	10 09       	r6 = r0 + Null;
    unsigned gc_type_data;
    AHM_GAIN_CONTROL_TYPE gc_type;
    AHM_ANC_INSTANCE anc_instance;

    p_msg = (OPMSG_FREE_AHM_SHARED_GAIN_PTR*)message_data;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
84201050:	72 88       	r0 = M[r4 + 4];
84201052:	52 55       	r0 = r0 LSHIFT 6;
84201054:	40 f0 00 f2 	r4 = r0 OR 0x4000;
84201058:	56 d8 
    DEBUG_AHM("OPID: %x, ahm_opmsg_free_shared_gain_ptr Fn entry", ext_op_id);

    /* Only handle fine gains */
    is_coarse_data = OPMSG_FIELD_GET(p_msg,
                                     OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                                     COARSE);
8420105a:	b9 89       	rMAC = M[r5 + 24];
    is_coarse = (bool)is_coarse_data;

    if (is_coarse)
8420105c:	89 c6       	rMAC = rMAC AND 0xffff;
8420105e:	0e 60       	if EQ jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_5;

84201060 <Lc_ahm_opmsg_free_shared_gain_ptr_2>:
    {
        L2_DBG_MSG1("OPID: %x, AHM Shared coarse gain not supported", ext_op_id);
84201060:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201064:	88 24       	Null = rMAC - 2;
84201066:	08 68       	if LT jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_4;

84201068 <Lc_ahm_opmsg_free_shared_gain_ptr_3>:
84201068:	55 f1 02 f0 	r0 = Null + 357565801;
8420106c:	69 49 
8420106e:	33 00       	r1 = r4 + Null;
84201070:	ff fd 00 f0 	call (m) 0x10c2;
84201074:	33 e2 

84201076 <Lc_ahm_opmsg_free_shared_gain_ptr_4>:
        return FALSE;
84201076:	02 00       	r0 = Null + Null;
84201078:	55 6e       	jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_16;

8420107a <Lc_ahm_opmsg_free_shared_gain_ptr_5>:
    }

    /* Interpret the gain control type */
    gc_type_data = OPMSG_FIELD_GET(message_data,
                                   OPMSG_COMMON_MSG_GET_SHARED_GAIN,
                                   CONTROL_TYPE);
8420107a:	f9 89       	rMAC = M[r5 + 28];
8420107c:	89 c6       	rMAC = rMAC AND 0xffff;
    gc_type = (AHM_GAIN_CONTROL_TYPE)gc_type_data;
8420107e:	ef f1 4a ce 	r8 = SE8 rMAC;

    /* Get the filter to share gains on */
    anc_filter_data = OPMSG_FIELD_GET(p_msg,
                                      OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                                      FILTER);
84201082:	79 89       	rMAC = M[r5 + 20];
84201084:	89 c6       	rMAC = rMAC AND 0xffff;
    anc_filter = (AHM_ANC_FILTER)anc_filter_data;
84201086:	ef f1 49 ce 	r7 = SE8 rMAC;


    /* Get the filter to share gains on */
    anc_instance_data = OPMSG_FIELD_GET(p_msg,
                                        OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                                        CHANNEL);
8420108a:	39 98       	rMAC = M[r5 + 32];
8420108c:	89 c6       	rMAC = rMAC AND 0xffff;
    anc_instance = (AHM_ANC_INSTANCE)anc_instance_data;
8420108e:	ef f1 4b ce 	r9 = SE8 rMAC;
    /* Dynamic control is only available on FF, FB or EC filters */

    L2_DBG_MSG2("OPID: %x, AHM unlink filter block %d", ext_op_id, anc_filter);
84201092:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201096:	88 24       	Null = rMAC - 2;
84201098:	09 68       	if LT jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_7;

8420109a <Lc_ahm_opmsg_free_shared_gain_ptr_6>:
8420109a:	55 f1 02 f0 	r0 = Null + 357566016;
8420109e:	40 4a 
842010a0:	4c 08       	r2 = r7 + Null;
842010a2:	33 00       	r1 = r4 + Null;
842010a4:	ff fd 00 f0 	call (m) 0x10d6;
842010a8:	33 e1 

842010aa <Lc_ahm_opmsg_free_shared_gain_ptr_7>:


    p_gain_data = OPMSG_FIELD_GET(p_msg,
                                  OPMSG_FREE_AHM_SHARED_GAIN_PTR,
                                  SHARED_GAIN_PTR);
842010aa:	f9 88       	rMAC = M[r5 + 12];
842010ac:	8b c6       	r1 = rMAC AND 0xffff;

    p_gain = (AHM_SHARED_FINE_GAIN*)p_gain_data;


    switch (gc_type)
842010ae:	51 08       	rMAC = r8 + Null;
842010b0:	14 60       	if EQ jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_11;

842010b2 <Lc_ahm_opmsg_free_shared_gain_ptr_8>:
842010b2:	48 24       	Null = rMAC - 1;
842010b4:	2a 62       	if NE jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_14;

842010b6 <Lc_ahm_opmsg_free_shared_gain_ptr_9>:
        case AHM_GAIN_CONTROL_TYPE_DELTA:
            p_head = &p_ext_data->p_fine_delta_head[anc_filter];
            ahm_list_fine_gain_remove(p_head, p_gain, ext_op_id);
            break;
        case AHM_GAIN_CONTROL_TYPE_NOMINAL:
            if (anc_instance == AHM_ANC_INSTANCE_ANC0_ID)
842010b6:	b0 f0 01 24 	Null = r9 - 1;
842010ba:	19 62       	if NE jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_13;

842010bc <Lc_ahm_opmsg_free_shared_gain_ptr_10>:
            {
                p_gain = &p_ext_data->ahm_fine_nominal[anc_filter];
842010bc:	0c f9 92 c9 	r0 = r7 * 24 (int);
842010c0:	41 08       	rMAC = r6 + Null;
842010c2:	51 00       	rMAC = r0 + rMAC;
842010c4:	01 f0 50 45 	rMAC = rMAC + 336;
                p_ext_data->p_fine_nominal[anc_filter] = p_gain;
842010c8:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842010cc:	10 0d       	r6 = r0 + r6;
842010ce:	81 f0 4e 8e 	M[r6 + 312] = rMAC;
                p_ext_data->ahm_nominal_client[anc_filter] = FALSE;
842010d2:	80 f0 9c 8e 	M[r6 + 624] = Null;
842010d6:	09 6e       	jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_12;

842010d8 <Lc_ahm_opmsg_free_shared_gain_ptr_11>:


    switch (gc_type)
    {
        case AHM_GAIN_CONTROL_TYPE_DELTA:
            p_head = &p_ext_data->p_fine_delta_head[anc_filter];
842010d8:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842010dc:	10 0d       	r6 = r0 + r6;
842010de:	82 f0 14 21 	r0 = r6 + 276;
            ahm_list_fine_gain_remove(p_head, p_gain, ext_op_id);
842010e2:	34 00       	r2 = r4 + Null;
842010e4:	0a f0 37 ea 	call (m) $_ahm_list_fine_gain_remove;

842010e8 <Lc_ahm_opmsg_free_shared_gain_ptr_12>:
        default:
            L2_DBG_MSG2("OPID: %x, AHM Unsupported control type %d", ext_op_id, gc_type);
            return FALSE;
    }

    return TRUE;
842010e8:	42 20       	r0 = Null + 1;
842010ea:	1c 6e       	jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_16;

842010ec <Lc_ahm_opmsg_free_shared_gain_ptr_13>:
                p_ext_data->p_fine_nominal[anc_filter] = p_gain;
                p_ext_data->ahm_nominal_client[anc_filter] = FALSE;
            }
            else
            {
                p_gain = &p_ext_data->ahm_fine_nominal1[anc_filter];
842010ec:	0c f9 92 c9 	r0 = r7 * 24 (int);
842010f0:	41 08       	rMAC = r6 + Null;
842010f2:	51 00       	rMAC = r0 + rMAC;
842010f4:	01 f0 98 45 	rMAC = rMAC + 408;
                p_ext_data->p_fine_nominal1[anc_filter] = p_gain;
842010f8:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842010fc:	10 0d       	r6 = r0 + r6;
842010fe:	81 f0 51 8e 	M[r6 + 324] = rMAC;
                p_ext_data->ahm_nominal_client1[anc_filter] = FALSE;
84201102:	80 f0 9f 8e 	M[r6 + 636] = Null;
84201106:	f1 6f       	jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_12;

84201108 <Lc_ahm_opmsg_free_shared_gain_ptr_14>:
            }
            break;
        default:
            L2_DBG_MSG2("OPID: %x, AHM Unsupported control type %d", ext_op_id, gc_type);
84201108:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420110c:	88 24       	Null = rMAC - 2;
8420110e:	b4 69       	if LT jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_4;

84201110 <Lc_ahm_opmsg_free_shared_gain_ptr_15>:
84201110:	55 f1 02 f0 	r0 = Null + 357566053;
84201114:	65 4a 
84201116:	54 08       	r2 = r8 + Null;
84201118:	33 00       	r1 = r4 + Null;
8420111a:	ef fd ff ff 	call (m) 0x10d6;
8420111e:	3d ed 
84201120:	ab 6f       	jump (m) Lc_ahm_opmsg_free_shared_gain_ptr_4;

84201122 <Lc_ahm_opmsg_free_shared_gain_ptr_16>:
            return FALSE;
    }

    return TRUE;
}
84201122:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201124:	d8 4c       	rts;

84201126 <$_ahm_opmsg_set_timer_period>:

bool ahm_opmsg_set_timer_period(OPERATOR_DATA *op_data,
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201126:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201128:	10 09       	r6 = r0 + Null;
8420112a:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
8420112c:	ef fd fb ff 	call (m) 0x8ea;
84201130:	3f ed 
84201132:	17 00       	r5 = r0 + Null;
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_timer_period Fn entry", INT_TO_EXT_OPID(op_data->id));

    /* get the timer period */
    timer_period = OPMSG_FIELD_GET(message_data,
                                   OPMSG_AHM_SET_TIMER_PERIOD,
                                   TIMER_PERIOD);
84201134:	f1 88       	rMAC = M[r4 + 12];
84201136:	8c c6       	r2 = rMAC AND 0xffff;

    if ((timer_period < AHM_MIN_TIMER_PERIOD_US) ||
        (timer_period > AHM_MAX_TIMER_PERIOD_US))
84201138:	40 f0 fa 24 	Null = r2 - 250;
8420113c:	05 68       	if LT jump (m) Lc_ahm_opmsg_set_timer_period_3;

8420113e <Lc_ahm_opmsg_set_timer_period_2>:
8420113e:	01 f0 40 f0 	Null = r2 - 20000;
84201142:	20 3e 
84201144:	0f 6c       	if LE jump (m) Lc_ahm_opmsg_set_timer_period_4;

84201146 <Lc_ahm_opmsg_set_timer_period_3>:
    {
        L0_DBG_MSG2("OPID: %x, AHM: timer period %d out of bounds",
                    INT_TO_EXT_OPID(op_data->id), timer_period);
84201146:	82 f0 01 88 	r0 = M[r6 + 4];
8420114a:	52 55       	r0 = r0 LSHIFT 6;
8420114c:	40 f0 00 f2 	r1 = r0 OR 0x4000;
84201150:	53 d8 
84201152:	55 f1 02 f0 	r0 = Null + 357565307;
84201156:	7b 43 
84201158:	ef fd ff ff 	call (m) 0x10d6;
8420115c:	3f eb 
        timer_period = AHM_DEF_TIMER_PERIOD_US;
8420115e:	04 f0 fa 40 	r2 = Null + 250;

84201162 <Lc_ahm_opmsg_set_timer_period_4>:
    }

    p_ext_data->timer_period = timer_period;
84201162:	74 f0 ae 8e 	M[r5 + 696] = r2;

    decimation = (uint16)OPMSG_FIELD_GET(message_data,
                                         OPMSG_AHM_SET_TIMER_PERIOD,
                                         DECIM_FACTOR);
84201166:	31 89       	rMAC = M[r4 + 16];
    if ((decimation < AHM_MIN_TIMER_DECIMATION) ||
        (decimation > AHM_MAX_TIMER_DECIMATION))
84201168:	8e c6       	r4 = rMAC AND 0xffff;
8420116a:	04 60       	if EQ jump (m) Lc_ahm_opmsg_set_timer_period_6;

8420116c <Lc_ahm_opmsg_set_timer_period_5>:
8420116c:	60 f0 64 24 	Null = r4 - 100;
84201170:	0f 6c       	if LE jump (m) Lc_ahm_opmsg_set_timer_period_7;

84201172 <Lc_ahm_opmsg_set_timer_period_6>:
    {
        L0_DBG_MSG2("OPID: %x, AHM: timer decimation %d out of bounds",
                    INT_TO_EXT_OPID(op_data->id), decimation);
84201172:	82 f0 01 88 	r0 = M[r6 + 4];
84201176:	52 55       	r0 = r0 LSHIFT 6;
84201178:	40 f0 00 f2 	r1 = r0 OR 0x4000;
8420117c:	53 d8 
8420117e:	55 f1 02 f0 	r0 = Null + 357565352;
84201182:	a8 43 
84201184:	34 00       	r2 = r4 + Null;
84201186:	ef fd ff ff 	call (m) 0x10d6;
8420118a:	31 ea 
        decimation = AHM_DEF_TIMER_DECIMATION;
8420118c:	06 21       	r4 = Null + 4;

8420118e <Lc_ahm_opmsg_set_timer_period_7>:
    }

    p_ext_data->timer_decimation = decimation;
8420118e:	76 f0 60 8d 	MH[r5 + 704] = r4;

    p_ext_data->samples_per_period = \
        ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                    p_ext_data->timer_period,
                                    p_ext_data->timer_decimation);
84201192:	78 f0 ae 88 	r6 = M[r5 + 696];
84201196:	39 b9       	rMAC = M[r5 + 112];
{
    /* sample_rate / 1000 = samples per ms
     * timer_period / 1000 * decimation = period in ms
     * multiply together for samples per period
     */
    unsigned raw_samples = (sample_rate * timer_period) / 1000000;
84201198:	1f f8 82 c9 	r0 = r6 * rMAC (int);
8420119c:	00 f0 a3 f7 	r1 = Null + 1000000;
842011a0:	40 42 
842011a2:	ff fd c7 f0 	call (m) 0x1a136;
842011a6:	35 ec 
    return raw_samples * (unsigned)decimation;
842011a8:	b1 1a       	rMAC = r4 * r0 (int);
}
842011aa:	71 f0 ad 8e 	M[r5 + 692] = rMAC;
    p_ext_data->samples_per_period = \
        ahm_calc_samples_per_period(p_ext_data->sample_rate,
                                    p_ext_data->timer_period,
                                    p_ext_data->timer_decimation);

    fast_rate = 1000000 / p_ext_data->timer_period;
842011ae:	00 f0 a2 f7 	r0 = Null + 1000000;
842011b2:	40 42 
842011b4:	43 08       	r1 = r6 + Null;
842011b6:	ff fd c7 f0 	call (m) 0x1a136;
842011ba:	21 ec 
    p_ext_data->fast_rate = fast_rate;
842011bc:	72 f0 b1 8e 	M[r5 + 708] = r0;
    p_ext_data->slow_rate = fast_rate / p_ext_data->timer_decimation;
842011c0:	33 00       	r1 = r4 + Null;
842011c2:	ff fd c7 f0 	call (m) 0x1a136;
842011c6:	35 eb 
842011c8:	72 f0 b2 8e 	M[r5 + 712] = r0;

    p_ext_data->timer_counter = 0;
842011cc:	70 f0 61 8d 	MH[r5 + 706] = Null;

    return TRUE;
842011d0:	42 20       	r0 = Null + 1;

842011d2 <Lc_ahm_opmsg_set_timer_period_8>:
}
842011d2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011d4:	d8 4c       	rts;

842011d6 <$_ahm_opmsg_set_iir_filter_coeffs>:
}
bool ahm_opmsg_set_iir_filter_coeffs(OPERATOR_DATA *op_data,
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011d6:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842011d8:	17 00       	r5 = r0 + Null;
842011da:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842011dc:	ef fd fb ff 	call (m) 0x8ea;
842011e0:	2f e8 
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
842011e2:	7b 88       	r1 = M[r5 + 4];
842011e4:	5b 55       	r1 = r1 LSHIFT 6;
842011e6:	40 f0 00 f3 	r1 = r1 OR 0x4000;
842011ea:	53 d8 
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_iir_filter_coeffs Fn entry", ext_op_id);
    unsigned int instance ;

    instance = OPMSG_FIELD_GET(message_data, OPMSG_SET_IIR_FILTER_COEFFS,
                               ANC_INSTANCE);
842011ec:	f1 88       	rMAC = M[r4 + 12];
842011ee:	89 c6       	rMAC = rMAC AND 0xffff;
    if (instance ==  AHM_ANC_INSTANCE_ANC0_ID)
842011f0:	48 24       	Null = rMAC - 1;
842011f2:	10 62       	if NE jump (m) Lc_ahm_opmsg_set_iir_filter_coeffs_3;

842011f4 <Lc_ahm_opmsg_set_iir_filter_coeffs_2>:
    {
        ahm_update_filter_coeffs(p_ext_data->p_prev_iir_filter_inst1, p_ext_data->p_iir_filter_inst1,
                                 p_ext_data->ramp_required, message_data,
                                 p_ext_data->mode,
                                 ext_op_id);
842011f4:	19 1c       	pushm <r1>;
842011f6:	21 f0 68 87 	rMAC = MHU[r0 + 720];
842011fa:	09 1c       	pushm <rMAC>;
842011fc:	24 f0 98 22 	r2 = r0 + 664;
84201200:	23 f0 a2 88 	r1 = M[r0 + 648];
84201204:	22 f0 a4 88 	r0 = M[r0 + 656];
84201208:	35 00       	r3 = r4 + Null;
8420120a:	0a f0 29 e5 	call (m) $_ahm_update_filter_coeffs;
8420120e:	7e 4c       	SP = SP + -8;
84201210:	1c 6e       	jump (m) Lc_ahm_opmsg_set_iir_filter_coeffs_7;

84201212 <Lc_ahm_opmsg_set_iir_filter_coeffs_3>:
    }
    else if (instance == AHM_ANC_INSTANCE_ANC1_ID)
84201212:	88 24       	Null = rMAC - 2;
84201214:	10 62       	if NE jump (m) Lc_ahm_opmsg_set_iir_filter_coeffs_5;

84201216 <Lc_ahm_opmsg_set_iir_filter_coeffs_4>:
    {
        ahm_update_filter_coeffs(p_ext_data->p_prev_iir_filter_inst2, p_ext_data->p_iir_filter_inst2,
                                 p_ext_data->ramp_required, message_data,
                                 p_ext_data->mode,
                                 ext_op_id);
84201216:	19 1c       	pushm <r1>;
84201218:	21 f0 68 87 	rMAC = MHU[r0 + 720];
8420121c:	09 1c       	pushm <rMAC>;
8420121e:	24 f0 98 22 	r2 = r0 + 664;
84201222:	23 f0 a3 88 	r1 = M[r0 + 652];
84201226:	22 f0 a5 88 	r0 = M[r0 + 660];
8420122a:	35 00       	r3 = r4 + Null;
8420122c:	0a f0 27 e4 	call (m) $_ahm_update_filter_coeffs;
84201230:	7e 4c       	SP = SP + -8;
84201232:	0b 6e       	jump (m) Lc_ahm_opmsg_set_iir_filter_coeffs_7;

84201234 <Lc_ahm_opmsg_set_iir_filter_coeffs_5>:

    }
    else
    {
        L2_DBG_MSG1("OPID: %x, Invalid instance type", ext_op_id);
84201234:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201238:	88 24       	Null = rMAC - 2;
8420123a:	07 68       	if LT jump (m) Lc_ahm_opmsg_set_iir_filter_coeffs_7;

8420123c <Lc_ahm_opmsg_set_iir_filter_coeffs_6>:
8420123c:	55 f1 02 f0 	r0 = Null + 357565769;
84201240:	49 49 
84201242:	ef fd ff ff 	call (m) 0x10c2;
84201246:	21 e4 

84201248 <Lc_ahm_opmsg_set_iir_filter_coeffs_7>:
    }

    return TRUE;
84201248:	42 20       	r0 = Null + 1;

8420124a <Lc_ahm_opmsg_set_iir_filter_coeffs_8>:
}
8420124a:	f2 48       	popm <FP, r4, r5, rLink>;
8420124c:	d8 4c       	rts;

8420124e <$_ahm_opmsg_set_zcd_disable>:

bool ahm_opmsg_set_zcd_disable(OPERATOR_DATA *op_data,
                               void *message_data,
                               unsigned *resp_length,
                               OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420124e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201250:	1e 00       	r4 = r1 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201252:	ef fd fb ff 	call (m) 0x8ea;
84201256:	39 e4 
    DEBUG_AHM("OPID: %x, ahm_opmsg_set_zcd_disable Fn entry", INT_TO_EXT_OPID(op_data->id));

    p_msg = (OPMSG_AHM_SET_ZCD_DISABLE *)message_data;
    disable = OPMSG_FIELD_GET(p_msg,
                              OPMSG_AHM_SET_ZCD_DISABLE,
                              DISABLE_ZCD);
84201258:	f1 88       	rMAC = M[r4 + 12];
8420125a:	8b c6       	r1 = rMAC AND 0xffff;

    p_ext_data->disable_zcd = disable;

#ifndef RUNNING_ON_KALSIM
    /* Update ANC HW */
    ahm_set_anc_zcd_enable(!disable, p_ext_data->config.channel);
8420125c:	01 00       	rMAC = Null + Null;
8420125e:	23 f0 b0 8a 	MB[r0 + 176] = r1;
84201262:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84201266:	23 f0 a8 80 	r1 = MBS[r0 + 168];
8420126a:	0a 00       	r0 = rMAC + Null;
8420126c:	db 4e       	call (m) Lc_ahm_set_anc_zcd_enable_1;
#endif

    return TRUE;
8420126e:	42 20       	r0 = Null + 1;

84201270 <Lc_ahm_opmsg_set_zcd_disable_2>:
}
84201270:	f1 48       	popm <FP, r4, rLink>;
84201272:	d8 4c       	rts;

84201274 <$_ahm_process_data>:
                                                          ahm_timer_cb,
                                                          (void*)op_data);
}

void ahm_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84201274:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201276:	10 09       	r6 = r0 + Null;
84201278:	1e 00       	r4 = r1 + Null;
    unsigned samples;

    /* Calculate samples available and updated touched terminals */
    samples = aud_cur_calc_samples(op_data, touched);
8420127a:	0f f0 23 ee 	call (m) $_aud_cur_calc_samples;
8420127e:	17 00       	r5 = r0 + Null;

    if (samples > 0)
84201280:	14 60       	if EQ jump (m) Lc_ahm_process_data_6;

84201282 <Lc_ahm_process_data_2>:
    {
        /* Copy any input mic data to output */
        samples = aud_cur_mic_data_transfer(op_data,
                                            samples,
                                            AHM_TERMINAL_SKIP_MASK);
84201282:	04 00       	r2 = Null + Null;
84201284:	3b 00       	r1 = r5 + Null;
84201286:	42 08       	r0 = r6 + Null;
84201288:	10 f0 21 e3 	call (m) $_aud_cur_mic_data_transfer;
8420128c:	17 00       	r5 = r0 + Null;
        /* Reset touched terminals if no data was copied */
        if (samples == 0)
8420128e:	04 62       	if NE jump (m) Lc_ahm_process_data_4;

84201290 <Lc_ahm_process_data_3>:
        {
            touched->sources = 0;
84201290:	30 ee       	M[r4 + Null] = Null;
            touched->sinks = 0;
84201292:	70 8e       	M[r4 + 4] = Null;
84201294:	05 6e       	jump (m) Lc_ahm_process_data_5;

84201296 <Lc_ahm_process_data_4>:
        }
        else
        {
            aud_cur_mic_metadata_transfer(op_data, samples);
84201296:	3b 00       	r1 = r5 + Null;
84201298:	42 08       	r0 = r6 + Null;
8420129a:	10 f0 3f e5 	call (m) $_aud_cur_mic_metadata_transfer;

8420129e <Lc_ahm_process_data_5>:
        }

        ahm_process_function(op_data, samples, FALSE);
8420129e:	04 00       	r2 = Null + Null;
842012a0:	3b 00       	r1 = r5 + Null;
842012a2:	42 08       	r0 = r6 + Null;
842012a4:	04 f0 29 e3 	call (m) Lc_ahm_process_function_1;

842012a8 <Lc_ahm_process_data_6>:
    }
    return;
}
842012a8:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842012aa:	d8 4c       	rts;

842012ac <$_ahm_timer_cb>:
        }
    }
}

void ahm_timer_cb(void *p_data)
{
842012ac:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842012ae:	17 00       	r5 = r0 + Null;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842012b0:	ef fd fb ff 	call (m) 0x8ea;
842012b4:	3b e1 
842012b6:	16 00       	r4 = r0 + Null;
    TIME next_fire_time;

    /* Run a minimal calculation every time. Every <decimation> times run the
     * full processing routine.
     */
    if (p_ext_data->timer_counter <= 0)
842012b8:	61 f0 61 85 	rMAC = MHS[r4 + 706];
842012bc:	08 24       	Null = rMAC - 0;
842012be:	0d 6a       	if GT jump (m) Lc_ahm_timer_cb_3;

842012c0 <Lc_ahm_timer_cb_2>:
    {
        p_ext_data->timer_counter = (int16)(p_ext_data->timer_decimation - 1);
842012c0:	61 f0 60 87 	rMAC = MHU[r4 + 704];
842012c4:	49 24       	rMAC = rMAC - 1;
842012c6:	61 f0 61 8d 	MH[r4 + 706] = rMAC;
        ahm_process_function(op_data,
                             p_ext_data->samples_per_period,
                             FALSE);
842012ca:	63 f0 ad 88 	r1 = M[r4 + 692];
842012ce:	04 00       	r2 = Null + Null;
842012d0:	3a 00       	r0 = r5 + Null;
842012d2:	04 f0 3b e1 	call (m) Lc_ahm_process_function_1;
842012d6:	0a 6e       	jump (m) Lc_ahm_timer_cb_4;

842012d8 <Lc_ahm_timer_cb_3>:
    }
    else
    {
        p_ext_data->timer_counter -= 1;
842012d8:	49 24       	rMAC = rMAC - 1;
842012da:	61 f0 61 8d 	MH[r4 + 706] = rMAC;
        ahm_process_function(op_data,
                             p_ext_data->samples_per_period,
                             TRUE);
842012de:	44 20       	r2 = Null + 1;
842012e0:	63 f0 ad 88 	r1 = M[r4 + 692];
842012e4:	3a 00       	r0 = r5 + Null;
842012e6:	04 f0 27 e1 	call (m) Lc_ahm_process_function_1;

842012ea <Lc_ahm_timer_cb_4>:
    }

        /* Next Timer Event */
        next_fire_time = p_ext_data->timer_period;
842012ea:	69 f0 ae 88 	r7 = M[r4 + 696];
        p_ext_data->timer_id = timer_schedule_bg_event_in(next_fire_time,
                                                          ahm_timer_cb,
                                                          (void*)op_data);
842012ee:	42 f0 08 f0 	r6 = Null + 69210797;
842012f2:	ad 62 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    /* Convert time_in to be absolute time */
    TIME event_time = time_add(time_get_time(), time_in);
842012f4:	ff fd 2a f0 	call (m) 0x679c;
842012f8:	29 e5 
842012fa:	4a 0c       	r0 = r7 + r0;

    /* earliest and latest time is the same */
    return create_add_casual_event(
                event_time, event_time, TimerEventFunction, data_pointer);
842012fc:	3d 00       	r3 = r5 + Null;
842012fe:	44 08       	r2 = r6 + Null;
84201300:	13 00       	r1 = r0 + Null;
84201302:	ff fd 2a f0 	call (m) 0x6820;
84201306:	3f e8 
}
84201308:	62 f0 af 8e 	M[r4 + 700] = r0;

8420130c <Lc_ahm_timer_cb_5>:
}
8420130c:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420130e:	d8 4c       	rts;

84201310 <Lc_interpret_fine_gain_1>:
 */
static uint16 interpret_fine_gain(unsigned *p_param,
                                  uint16 static_gain,
                                  uint16 current_gain,
                                  EXT_OP_ID ext_op_id)
{
84201310:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
    FINE_GAIN_PARAM *p_param_value = (FINE_GAIN_PARAM*)p_param;
    uint16 round_factor = 0;
84201312:	06 00       	r4 = Null + Null;
    uint16 gain;
    int16 shift;
    uint8 gain_type = (uint8)(p_param_value->gain_type & AHM_GAIN_SHIFT_MASK);
84201314:	d1 82       	rMAC = MBU[r0 + 3];

    if (gain_type == AHM_GAIN_ABSOLUTE)
84201316:	17 f0 c0 00 	r5 = rMAC AND 0xc0;
8420131a:	03 62       	if NE jump (m) Lc_interpret_fine_gain_3;

8420131c <Lc_interpret_fine_gain_2>:
    {
        return (uint16)p_param_value->absolute;
8420131c:	12 e2       	r0 = MBU[r0 + Null];
8420131e:	20 6e       	jump (m) Lc_interpret_fine_gain_11;

84201320 <Lc_interpret_fine_gain_3>:
    }
    else
    {
        switch (gain_type)
84201320:	70 f0 40 24 	Null = r5 - 64;
84201324:	06 60       	if EQ jump (m) Lc_interpret_fine_gain_6;

84201326 <Lc_interpret_fine_gain_4>:
84201326:	70 f0 80 24 	Null = r5 - 128;
8420132a:	11 62       	if NE jump (m) Lc_interpret_fine_gain_10;

8420132c <Lc_interpret_fine_gain_5>:
                gain = current_gain;
                shift = p_param_value->shift_current;
                break;
            case AHM_GAIN_SHIFT_STATIC:
                gain = static_gain;
                shift = p_param_value->shift_static;
8420132c:	51 80       	rMAC = MBS[r0 + 1];
                break;
8420132e:	03 6e       	jump (m) Lc_interpret_fine_gain_7;

84201330 <Lc_interpret_fine_gain_6>:
    else
    {
        switch (gain_type)
        {
            case AHM_GAIN_SHIFT_CURRENT:
                gain = current_gain;
84201330:	23 00       	r1 = r2 + Null;
                shift = p_param_value->shift_current;
84201332:	91 80       	rMAC = MBS[r0 + 2];

84201334 <Lc_interpret_fine_gain_7>:
                            ext_op_id, p_param_value->gain_type);
                return FALSE;
        }
    }
    /* Apply rounding only for right shift */
    if (shift < 0)
84201334:	08 04       	Null = rMAC - Null;
84201336:	05 f0 8f e0 	if POS jump (m) Lc_interpret_fine_gain_9;

8420133a <Lc_interpret_fine_gain_8>:
    {
        /* The shift value is negative, hence negating it again */
        round_factor = (uint16)(1 << (0 - shift - 1));
8420133a:	42 04       	r0 = Null - rMAC;
8420133c:	52 24       	r0 = r0 - 1;
8420133e:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
84201342:	96 c6       	r4 = r0 AND 0xffff;

84201344 <Lc_interpret_fine_gain_9>:
    }
    return (uint16)((gain + round_factor) << shift);
84201344:	9a 01       	r0 = r1 + r4;
84201346:	52 16       	r0 = r0 LSHIFT rMAC;
84201348:	92 c6       	r0 = r0 AND 0xffff;
8420134a:	0a 6e       	jump (m) Lc_interpret_fine_gain_11;

8420134c <Lc_interpret_fine_gain_10>:
                gain = static_gain;
                shift = p_param_value->shift_static;
                break;
            default:
                L0_DBG_MSG2("OPID: %x, AANC gain type invalid: %u",
                            ext_op_id, p_param_value->gain_type);
8420134c:	55 f1 02 f0 	r0 = Null + 357564416;
84201350:	00 40 
84201352:	0c 00       	r2 = rMAC + Null;
84201354:	2b 00       	r1 = r3 + Null;
84201356:	ef fd fe ff 	call (m) 0x10d6;
8420135a:	21 ec 
                return FALSE;
8420135c:	02 00       	r0 = Null + Null;

8420135e <Lc_interpret_fine_gain_11>:
    {
        /* The shift value is negative, hence negating it again */
        round_factor = (uint16)(1 << (0 - shift - 1));
    }
    return (uint16)((gain + round_factor) << shift);
}
8420135e:	f2 48       	popm <FP, r4, r5, rLink>;
84201360:	d8 4c       	rts;

84201362 <Lc_update_dynamic_nominal_gain_1>:
    AHM_GAIN *p_path;
    int i;

    p_path = &p_nominal->ff;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201362:	1c 71       	r10 = Null + 3;
84201364:	06 4c       	do (m) Lc__loop0;

84201366 <Lc_update_dynamic_nominal_gain_2>:
    {
        p_path->fine = p_fine_nominal[i]->gain;
84201366:	19 e8       	rMAC = M[r1 + Null];
84201368:	09 93       	rMAC = MBU[rMAC + 12];
8420136a:	51 8c       	MH[r0 + 2] = rMAC;
        p_path++;
8420136c:	12 21       	r0 = r0 + 4;
8420136e:	1b 21       	r1 = r1 + 4;

84201370 <Lc__loop0>:
    AHM_GAIN *p_path;
    int i;

    p_path = &p_nominal->ff;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201370:	d8 4c       	rts;

84201372 <Lc_update_static_nominal_gain_1>:
 * \return unsigned  Samples per timer period.
 */
static void update_static_nominal_gain(AHM_GAIN_BANK *p_static,
                                       AHM_GAIN_BANK *p_nominal)
{
    p_nominal->ff.coarse = p_static->ff.coarse;
84201372:	11 e4       	rMAC = MHS[r0 + Null];
84201374:	19 ec       	MH[r1 + Null] = rMAC;
    p_nominal->fb.coarse = p_static->fb.coarse;
84201376:	91 84       	rMAC = MHS[r0 + 4];
84201378:	99 8c       	MH[r1 + 4] = rMAC;
    p_nominal->ec.coarse = p_static->ec.coarse;
8420137a:	11 85       	rMAC = MHS[r0 + 8];
8420137c:	19 8d       	MH[r1 + 8] = rMAC;
    p_nominal->rx_ffa_mix = p_static->rx_ffa_mix;
8420137e:	91 87       	rMAC = MHU[r0 + 12];
84201380:	d4 87       	r2 = MHU[r0 + 14];
84201382:	99 8d       	MH[r1 + 12] = rMAC;
84201384:	dc 8d       	MH[r1 + 14] = r2;
    p_nominal->rx_ffb_mix = p_static->rx_ffb_mix;
84201386:	11 96       	rMAC = MHU[r0 + 16];
84201388:	54 96       	r2 = MHU[r0 + 18];
8420138a:	19 9c       	MH[r1 + 16] = rMAC;
8420138c:	5c 9c       	MH[r1 + 18] = r2;

8420138e <Lc_update_static_nominal_gain_2>:

    return;
8420138e:	d8 4c       	rts;

84201390 <Lc_update_coarse_gain_1>:
 * \param  stat Pointer to static gain

 */
static void update_coarse_gain(AHM_GAIN_BANK *cur, AHM_GAIN_BANK *stat)
{
    cur->ff.coarse  = stat->ff.coarse;
84201390:	19 e4       	rMAC = MHS[r1 + Null];
84201392:	11 ec       	MH[r0 + Null] = rMAC;
    cur->fb.coarse  = stat->fb.coarse;
84201394:	99 84       	rMAC = MHS[r1 + 4];
84201396:	91 8c       	MH[r0 + 4] = rMAC;
    cur->ec.coarse  = stat->ec.coarse;
84201398:	19 85       	rMAC = MHS[r1 + 8];
8420139a:	11 8d       	MH[r0 + 8] = rMAC;
    cur->rx_ffa_mix.coarse = stat->rx_ffa_mix.coarse;
8420139c:	99 85       	rMAC = MHS[r1 + 12];
8420139e:	91 8d       	MH[r0 + 12] = rMAC;
    cur->rx_ffb_mix.coarse = stat->rx_ffb_mix.coarse;
842013a0:	19 94       	rMAC = MHS[r1 + 16];
842013a2:	11 9c       	MH[r0 + 16] = rMAC;

842013a4 <Lc_update_coarse_gain_2>:
842013a4:	d8 4c       	rts;

842013a6 <Lc_reinit_nominal_gain_1>:
 *
 * This function reinitialize the nominal gain with the static gain
 * \param p_ext_data Pointer to AHM operator data
 */
static void reinit_nominal_gain(AHM_OP_DATA *p_ext_data)
{
842013a6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842013a8:	17 00       	r5 = r0 + Null;
    AHM_GAIN_BANK *p_stat, *p_stat1;
    AHM_GAIN *p_path, *p_path1;
    p_stat = p_ext_data->p_static_gain;
842013aa:	72 f0 21 88 	r0 = M[r5 + 132];
    p_stat1 = p_ext_data->p_static_gain1;
842013ae:	76 f0 22 88 	r4 = M[r5 + 136];
    int i;
    /* Update nominal gains */
    p_path = &p_stat->ff;
842013b2:	11 00       	rMAC = r0 + Null;
    p_path1 = &p_stat1->ff;
842013b4:	33 00       	r1 = r4 + Null;
842013b6:	74 f0 5c 21 	r2 = r5 + 348;
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842013ba:	1c 71       	r10 = Null + 3;
842013bc:	09 4c       	do (m) Lc__loop1;

842013be <Lc_reinit_nominal_gain_2>:
    {
        p_ext_data->ahm_fine_nominal[i].gain = (uint8)p_path->fine;
842013be:	4d 86       	r3 = MHU[rMAC + 2];
842013c0:	25 8a       	MB[r2 + 0] = r3;
        p_ext_data->ahm_fine_nominal1[i].gain = (uint8)p_path1->fine;
842013c2:	5d 86       	r3 = MHU[r1 + 2];
842013c4:	45 f0 48 8a 	MB[r2 + 72] = r3;
        p_path++;
842013c8:	09 21       	rMAC = rMAC + 4;
        p_path1++;
842013ca:	1b 21       	r1 = r1 + 4;
842013cc:	24 2a       	r2 = r2 + 24;

842013ce <Lc__loop1>:
    p_stat1 = p_ext_data->p_static_gain1;
    int i;
    /* Update nominal gains */
    p_path = &p_stat->ff;
    p_path1 = &p_stat1->ff;
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842013ce:	75 f0 38 21 	r3 = r5 + 312;
        p_ext_data->ahm_fine_nominal1[i].gain = (uint8)p_path1->fine;
        p_path++;
        p_path1++;
    }
 
    p_path = &p_ext_data->p_nominal_gain->ff;
842013d2:	71 f0 23 88 	rMAC = M[r5 + 140];
    p_path1 = &p_ext_data->p_nominal_gain1->ff;
842013d6:	73 f0 24 88 	r1 = M[r5 + 144];
842013da:	2c 00       	r2 = r3 + Null;
842013dc:	2d 2a       	r3 = r3 + 24;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842013de:	1c 71       	r10 = Null + 3;
842013e0:	18 4c       	do (m) Lc__loop2;

842013e2 <Lc_reinit_nominal_gain_4>:
    {
        if (p_ext_data->ramp_required[i] || p_ext_data->coarse_gain_changed[i])
842013e2:	40 f0 58 88 	Null = M[r2 + 352];
842013e6:	04 62       	if NE jump (m) Lc_reinit_nominal_gain_6;

842013e8 <Lc_reinit_nominal_gain_5>:
842013e8:	40 f0 5b 88 	Null = M[r2 + 364];
842013ec:	0e 60       	if EQ jump (m) Lc_reinit_nominal_gain_7;

842013ee <Lc_reinit_nominal_gain_6>:
        {
            p_ext_data->p_fine_nominal[i] = &p_ext_data->ahm_fine_nominal[i];
842013ee:	25 ee       	M[r2 + Null] = r3;
            p_ext_data->p_fine_nominal1[i] = &p_ext_data->ahm_fine_nominal1[i];
842013f0:	58 f0 48 20 	r6 = r3 + 72;
842013f4:	48 f0 03 8e 	M[r2 + 12] = r6;

            p_path->fine = p_ext_data->ahm_fine_nominal[i].gain;
842013f8:	58 f0 0c 82 	r6 = MBU[r3 + 12];
842013fc:	18 f0 01 8c 	MH[rMAC + 2] = r6;
            p_path1->fine = p_ext_data->ahm_fine_nominal1[i].gain;
84201400:	58 f0 54 82 	r6 = MBU[r3 + 84];
84201404:	38 f0 01 8c 	MH[r1 + 2] = r6;

84201408 <Lc_reinit_nominal_gain_7>:
        }
        p_path++;
84201408:	09 21       	rMAC = rMAC + 4;
        p_path1++;
8420140a:	1b 21       	r1 = r1 + 4;
8420140c:	24 21       	r2 = r2 + 4;
8420140e:	2d 2a       	r3 = r3 + 24;

84201410 <Lc__loop2>:
    }
 
    p_path = &p_ext_data->p_nominal_gain->ff;
    p_path1 = &p_ext_data->p_nominal_gain1->ff;

    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201410:	73 f0 23 88 	r1 = M[r5 + 140];
84201414:	af 4f       	call (m) Lc_update_static_nominal_gain_1;
        p_path++;
        p_path1++;
    }

    update_static_nominal_gain(p_stat, p_ext_data->p_nominal_gain);
    update_static_nominal_gain(p_stat1, p_ext_data->p_nominal_gain1);
84201416:	73 f0 24 88 	r1 = M[r5 + 144];
8420141a:	32 00       	r0 = r4 + Null;
8420141c:	ab 4f       	call (m) Lc_update_static_nominal_gain_1;

8420141e <Lc_reinit_nominal_gain_9>:
}
8420141e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201420:	d8 4c       	rts;

84201422 <Lc_ahm_set_anc_zcd_enable_1>:
 * \param  channel ANC Instance channel (Inst0, Inst1 or both)
 *
 * \return void
 */
static void ahm_set_anc_zcd_enable(bool enable, AHM_ANC_INSTANCE channel)
{
84201422:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201424:	19 00       	rMAC = r1 + Null;
    unsigned control_value;

    if (enable)
    {
        control_value = AHM_ANC_CONTROL_ZCD_ENABLE;
84201426:	20 f0 03 f0 	r1 = Null + 33554944;
8420142a:	00 42 
8420142c:	20 f0 06 f0 	r4 = Null + 33554432;
84201430:	00 40 
84201432:	10 04       	Null = r0 - Null;
84201434:	01 f3 06 c0 	if NE r4 = r1 + Null;
    {
        control_value = AHM_ANC_CONTROL_ZCD_DISABLE;
    }

    if ((channel == AHM_ANC_INSTANCE_BOTH_ID) ||
        (channel == AHM_ANC_INSTANCE_DUAL_ID))
84201438:	c8 24       	Null = rMAC - 3;
8420143a:	03 60       	if EQ jump (m) Lc_ahm_set_anc_zcd_enable_3;

8420143c <Lc_ahm_set_anc_zcd_enable_2>:
8420143c:	08 25       	Null = rMAC - 4;
8420143e:	0c 62       	if NE jump (m) Lc_ahm_set_anc_zcd_enable_4;

84201440 <Lc_ahm_set_anc_zcd_enable_3>:
    {
        stream_anc_set_anc_control(AHM_ANC_INSTANCE_ANC0_ID, control_value);
84201440:	42 20       	r0 = Null + 1;
84201442:	33 00       	r1 = r4 + Null;
84201444:	ff fd 5d f0 	call (m) 0xcfe4;
84201448:	21 ed 
        stream_anc_set_anc_control(AHM_ANC_INSTANCE_ANC1_ID, control_value);
8420144a:	82 20       	r0 = Null + 2;
8420144c:	33 00       	r1 = r4 + Null;
8420144e:	ff fd 5d f0 	call (m) 0xcfe4;
84201452:	37 ec 
84201454:	06 6e       	jump (m) Lc_ahm_set_anc_zcd_enable_5;

84201456 <Lc_ahm_set_anc_zcd_enable_4>:
    }
    else
    {
        stream_anc_set_anc_control(channel, control_value);
84201456:	33 00       	r1 = r4 + Null;
84201458:	0a 00       	r0 = rMAC + Null;
8420145a:	ff fd 5d f0 	call (m) 0xcfe4;
8420145e:	2b ec 

84201460 <Lc_ahm_set_anc_zcd_enable_5>:
    }
}
84201460:	f1 48       	popm <FP, r4, rLink>;
84201462:	d8 4c       	rts;

84201464 <Lc_ahm_send_event_message_1>:
 *
 * \return - TRUE if successful
 */
static bool ahm_send_event_message(OPERATOR_DATA *op_data,
                                   AHM_EVENT_MSG *p_evt_msg)
{
84201464:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201466:	16 00       	r4 = r0 + Null;
84201468:	18 09       	r6 = r1 + Null;
    unsigned *p_msg;
    OPMSG_REPLY_ID msg_id;

    msg_id = OPMSG_REPLY_ID_AHM_EVENT_TRIGGER;
    msg_size = OPMSG_UNSOLICITED_AHM_EVENT_TRIGGER_WORD_SIZE;
    p_evt_msg->ext_op_id = INT_TO_EXT_OPID(op_data->id);
8420146a:	72 88       	r0 = M[r4 + 4];
8420146c:	52 55       	r0 = r0 LSHIFT 6;
8420146e:	40 f0 00 f2 	rMAC = r0 OR 0x4000;
84201472:	51 d8 
84201474:	81 f0 02 8e 	M[r6 + 8] = rMAC;
    p_msg = xzpnewn(msg_size, unsigned);
84201478:	c3 20       	r1 = Null + 3;
8420147a:	02 2a       	r0 = Null + 24;
8420147c:	ff fd 2d f0 	call (m) 0x6f8e;
84201480:	33 e8 
84201482:	17 00       	r5 = r0 + Null;
    if (p_msg == NULL)
84201484:	0f 62       	if NE jump (m) Lc_ahm_send_event_message_5;

84201486 <Lc_ahm_send_event_message_2>:
    {
        L2_DBG_MSG1("OPID: %x, Failed to create AHM message payload", p_evt_msg->ext_op_id);
84201486:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420148a:	88 24       	Null = rMAC - 2;
8420148c:	09 68       	if LT jump (m) Lc_ahm_send_event_message_4;

8420148e <Lc_ahm_send_event_message_3>:
8420148e:	83 f0 02 88 	r1 = M[r6 + 8];
84201492:	55 f1 02 f0 	r0 = Null + 357564453;
84201496:	25 40 
84201498:	ef fd fe ff 	call (m) 0x10c2;
8420149c:	2b e1 

8420149e <Lc_ahm_send_event_message_4>:
        return FALSE;
8420149e:	02 00       	r0 = Null + Null;
842014a0:	23 6e       	jump (m) Lc_ahm_send_event_message_6;

842014a2 <Lc_ahm_send_event_message_5>:
    }

    OPMSG_CREATION_FIELD_SET(p_msg,
                             OPMSG_UNSOLICITED_AHM_EVENT_TRIGGER,
                             ID,
                             p_evt_msg->id);
842014a2:	81 f0 00 e6 	rMAC = MHU[r6 + Null];
842014a6:	39 ee       	M[r5 + Null] = rMAC;
    OPMSG_CREATION_FIELD_SET(p_msg,
                             OPMSG_UNSOLICITED_AHM_EVENT_TRIGGER,
                             TYPE,
                             p_evt_msg->type);
842014a8:	81 f0 01 86 	rMAC = MHU[r6 + 2];
842014ac:	79 8e       	M[r5 + 4] = rMAC;
    OPMSG_CREATION_FIELD_SET32(p_msg,
                               OPMSG_UNSOLICITED_AHM_EVENT_TRIGGER,
                               PAYLOAD,
                               p_evt_msg->payload);
842014ae:	81 f0 01 88 	rMAC = M[r6 + 4];
842014b2:	89 c6       	rMAC = rMAC AND 0xffff;
842014b4:	b9 8e       	M[r5 + 8] = rMAC;
842014b6:	82 f0 01 88 	r0 = M[r6 + 4];
842014ba:	92 52       	r0 = r0 LSHIFT -16;
842014bc:	fa 8e       	M[r5 + 12] = r0;
    OPMSG_CREATION_FIELD_SET32(p_msg,
                               OPMSG_UNSOLICITED_AHM_EVENT_TRIGGER,
                               OPID,
                               p_evt_msg->ext_op_id);
842014be:	81 f0 02 88 	rMAC = M[r6 + 8];
842014c2:	89 c6       	rMAC = rMAC AND 0xffff;
842014c4:	39 8f       	M[r5 + 16] = rMAC;
842014c6:	82 f0 02 88 	r0 = M[r6 + 8];
842014ca:	92 52       	r0 = r0 LSHIFT -16;
842014cc:	7a 8f       	M[r5 + 20] = r0;
    common_send_unsolicited_message(op_data, (unsigned)msg_id, msg_size,
                                    p_msg);
842014ce:	84 21       	r2 = Null + 6;
842014d0:	43 23       	r1 = Null + 13;
842014d2:	3d 00       	r3 = r5 + Null;
842014d4:	32 00       	r0 = r4 + Null;
842014d6:	ef fd fa ff 	call (m) 0x970;
842014da:	3b e4 

    pdelete(p_msg);
842014dc:	3a 00       	r0 = r5 + Null;
842014de:	ff fd 2d f0 	call (m) 0x6fbe;
842014e2:	21 e7 
    return TRUE;
842014e4:	42 20       	r0 = Null + 1;

842014e6 <Lc_ahm_send_event_message_6>:
}
842014e6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842014e8:	d8 4c       	rts;

842014ea <Lc_configure_ramp_up_1>:
static void configure_ramp_up(AHM_RAMP_CONFIG *cfg,AHM_OP_DATA *p_ext_data)
{
    AHM_GAIN *p_nominal_path;
    int i;

    cfg[AHM_ANC_FILTER_FF_ID].target = p_ext_data->ff_fine_tgt_gain;
842014ea:	31 f0 52 86 	rMAC = MHU[r1 + 164];
842014ee:	11 ec       	MH[r0 + Null] = rMAC;
    if(p_ext_data->set_target_flag)
842014f0:	30 f0 b5 88 	Null = M[r1 + 724];
842014f4:	03 60       	if EQ jump (m) Lc_configure_ramp_up_3;

842014f6 <Lc_configure_ramp_up_2>:
    {
        p_ext_data->set_target_flag = FALSE;
842014f6:	30 f0 b5 8e 	M[r1 + 724] = Null;

842014fa <Lc_configure_ramp_up_3>:
    }

    cfg[AHM_ANC_FILTER_FB_ID].target =p_ext_data->fb_fine_tgt_gain;
842014fa:	31 f0 53 86 	rMAC = MHU[r1 + 166];
842014fe:	91 9c       	MH[r0 + 20] = rMAC;
    cfg[AHM_ANC_FILTER_EC_ID].target =p_ext_data->p_static_gain->ec.fine;
84201500:	31 f0 21 88 	rMAC = M[r1 + 132];
84201504:	49 87       	rMAC = MHU[rMAC + 10];
84201506:	11 ad       	MH[r0 + 40] = rMAC;

    p_nominal_path = &p_ext_data->p_nominal_gain->ff;
84201508:	31 f0 23 88 	rMAC = M[r1 + 140];
8420150c:	92 20       	r0 = r0 + 2;

    for ( i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420150e:	1c 71       	r10 = Null + 3;
84201510:	0d 4c       	do (m) Lc__loop3;

84201512 <Lc_configure_ramp_up_4>:
    {
        cfg[i].nominal_gain = p_nominal_path->fine;
84201512:	4c 86       	r2 = MHU[rMAC + 2];
84201514:	14 ec       	MH[r0 + Null] = r2;
        cfg[i].slow_rate    = p_ext_data->slow_rate;
84201516:	34 f0 b2 88 	r2 = M[r1 + 712];
8420151a:	05 f2 54 cd 	M[r0 + 10] = r2;
        cfg[i].fast_rate    = p_ext_data->fast_rate;
8420151e:	34 f0 b1 88 	r2 = M[r1 + 708];
84201522:	07 f2 54 cd 	M[r0 + 14] = r2;
        p_nominal_path++;
84201526:	09 21       	rMAC = rMAC + 4;
84201528:	12 29       	r0 = r0 + 20;

8420152a <Lc__loop3>:
    cfg[AHM_ANC_FILTER_FB_ID].target =p_ext_data->fb_fine_tgt_gain;
    cfg[AHM_ANC_FILTER_EC_ID].target =p_ext_data->p_static_gain->ec.fine;

    p_nominal_path = &p_ext_data->p_nominal_gain->ff;

    for ( i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420152a:	d8 4c       	rts;

8420152c <Lc_configure_ramp_down_1>:
 * \return void
 */
static void configure_ramp_down(AHM_RAMP_CONFIG *cfg, AHM_OP_DATA *p_ext_data,
                                uint16 trigger_mode)
{
    cfg->target = 0;
8420152c:	10 ec       	MH[r0 + Null] = Null;
    cfg-> delay=  0;
8420152e:	50 8e       	M[r0 + 4] = Null;

    if (trigger_mode == ANC_HW_MANAGER_TRIGGER_SIMILAR)
84201530:	60 24       	Null = r2 - 1;
84201532:	04 62       	if NE jump (m) Lc_configure_ramp_down_3;

84201534 <Lc_configure_ramp_down_2>:
    {
        cfg->duration = \
            p_ext_data->ahm_cap_params.OFFSET_FAST_RAMP_DOWN_DURATION;
84201534:	59 a8       	rMAC = M[r1 + 68];
84201536:	91 8e       	M[r0 + 8] = rMAC;
84201538:	05 6e       	jump (m) Lc_configure_ramp_down_5;

8420153a <Lc_configure_ramp_down_3>:
    }
    else if (trigger_mode == ANC_HW_MANAGER_TRIGGER_DIFFERENT)
8420153a:	a0 24       	Null = r2 - 2;
8420153c:	03 62       	if NE jump (m) Lc_configure_ramp_down_5;

8420153e <Lc_configure_ramp_down_4>:
    {
        cfg->duration = \
            p_ext_data->ahm_cap_params.OFFSET_SLOW_RAMP_DOWN_DURATION;
8420153e:	19 a9       	rMAC = M[r1 + 80];
84201540:	91 8e       	M[r0 + 8] = rMAC;

84201542 <Lc_configure_ramp_down_5>:
    }
    cfg->fast_rate    =   p_ext_data->fast_rate;
84201542:	31 f0 b1 88 	rMAC = M[r1 + 708];
84201546:	11 8f       	M[r0 + 16] = rMAC;
    cfg->slow_rate    =   p_ext_data->slow_rate;
84201548:	31 f0 b2 88 	rMAC = M[r1 + 712];
8420154c:	d1 8e       	M[r0 + 12] = rMAC;
    cfg->nominal_gain =   p_ext_data->p_nominal_gain->ff.fine;
8420154e:	31 f0 23 88 	rMAC = M[r1 + 140];
84201552:	49 86       	rMAC = MHU[rMAC + 2];
84201554:	51 8c       	MH[r0 + 2] = rMAC;

84201556 <Lc_configure_ramp_down_6>:
84201556:	d8 4c       	rts;

84201558 <Lc_configure_ramp_slow_delay_duration_1>:
 *
 * \return void
 */
static void configure_ramp_slow_delay_duration(AHM_RAMP_CONFIG *cfg,
                                               AHM_OP_DATA *p_ext_data)
{
84201558:	11 21       	rMAC = r0 + 4;
    for ( int i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420155a:	1c 71       	r10 = Null + 3;
8420155c:	06 4c       	do (m) Lc__loop4;

8420155e <Lc_configure_ramp_slow_delay_duration_2>:
    {
        cfg[i].delay       =  \
            p_ext_data->ahm_cap_params.OFFSET_SLOW_MODE_DELAY_DURATION;
8420155e:	9a a9       	r0 = M[r1 + 88];
84201560:	0a ee       	M[rMAC + Null] = r0;
        cfg[i].duration    =  \
            p_ext_data->ahm_cap_params.OFFSET_SLOW_RAMP_UP_DURATION;
84201562:	5a a9       	r0 = M[r1 + 84];
84201564:	4a 8e       	M[rMAC + 4] = r0;
84201566:	09 29       	rMAC = rMAC + 20;

84201568 <Lc__loop4>:
 * \return void
 */
static void configure_ramp_slow_delay_duration(AHM_RAMP_CONFIG *cfg,
                                               AHM_OP_DATA *p_ext_data)
{
    for ( int i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201568:	d8 4c       	rts;

8420156a <Lc_configure_ramp_fast_delay_duration_1>:
 *
 * \return void
 */
static void configure_ramp_fast_delay_duration(AHM_RAMP_CONFIG *cfg,
                                               AHM_OP_DATA *p_ext_data )
{
8420156a:	11 21       	rMAC = r0 + 4;
    for ( int i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420156c:	1c 71       	r10 = Null + 3;
8420156e:	06 4c       	do (m) Lc__loop5;

84201570 <Lc_configure_ramp_fast_delay_duration_2>:
    {
            cfg[i].delay       =  \
                p_ext_data->ahm_cap_params.OFFSET_FAST_MODE_DELAY_DURATION;
84201570:	da a8       	r0 = M[r1 + 76];
84201572:	0a ee       	M[rMAC + Null] = r0;
            cfg[i].duration    =  \
                p_ext_data->ahm_cap_params.OFFSET_FAST_RAMP_UP_DURATION;
84201574:	9a a8       	r0 = M[r1 + 72];
84201576:	4a 8e       	M[rMAC + 4] = r0;
84201578:	09 29       	rMAC = rMAC + 20;

8420157a <Lc__loop5>:
 * \return void
 */
static void configure_ramp_fast_delay_duration(AHM_RAMP_CONFIG *cfg,
                                               AHM_OP_DATA *p_ext_data )
{
    for ( int i=0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420157a:	d8 4c       	rts;

8420157c <Lc_ahm_write_gain_generic_1>:

    return TRUE;
}
#else
static bool ahm_write_gain_generic(OPERATOR_DATA *op_data)
{
8420157c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
8420157e:	ef fd f9 ff 	call (m) 0x8ea;
84201582:	2d eb 
84201584:	16 00       	r4 = r0 + Null;
#else
static bool ahm_write_gain_generic(OPERATOR_DATA *op_data)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (p_ext_data->config.channel == AHM_ANC_INSTANCE_ANC1_ID)
84201586:	61 f0 a8 80 	rMAC = MBS[r4 + 168];
8420158a:	88 24       	Null = rMAC - 2;
8420158c:	09 62       	if NE jump (m) Lc_ahm_write_gain_generic_3;

8420158e <Lc_ahm_write_gain_generic_2>:
    {
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain1,
                       p_ext_data->p_prev_gain1);
8420158e:	64 f0 20 88 	r2 = M[r4 + 128];
84201592:	b3 b9       	r1 = M[r4 + 120];
84201594:	62 f0 a8 20 	r0 = r4 + 168;
84201598:	06 f0 33 e3 	call (m) $_ahm_write_gain;
8420159c:	32 6e       	jump (m) Lc_ahm_write_gain_generic_10;

8420159e <Lc_ahm_write_gain_generic_3>:
        stream_anc_update_background_gains(p_ext_data->config.channel);
    }

    else if (p_ext_data->config.channel == AHM_ANC_INSTANCE_BOTH_ID)
8420159e:	c8 24       	Null = rMAC - 3;
842015a0:	08 62       	if NE jump (m) Lc_ahm_write_gain_generic_5;

842015a2 <Lc_ahm_write_gain_generic_4>:
    {
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
842015a2:	f4 b9       	r2 = M[r4 + 124];
842015a4:	73 b9       	r1 = M[r4 + 116];
842015a6:	62 f0 a8 20 	r0 = r4 + 168;
842015aa:	06 f0 21 e3 	call (m) $_ahm_write_gain;
842015ae:	19 6e       	jump (m) Lc_ahm_write_gain_generic_7;

842015b0 <Lc_ahm_write_gain_generic_5>:
        stream_anc_update_background_gains(AHM_ANC_INSTANCE_ANC0_ID);
        stream_anc_update_background_gains(AHM_ANC_INSTANCE_ANC1_ID);
    }

    else if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
842015b0:	08 25       	Null = rMAC - 4;
842015b2:	21 62       	if NE jump (m) Lc_ahm_write_gain_generic_9;

842015b4 <Lc_ahm_write_gain_generic_6>:
    { 
        p_ext_data->config.channel = AHM_ANC_INSTANCE_ANC0_ID;
842015b4:	41 20       	rMAC = Null + 1;
842015b6:	61 f0 a8 8a 	MB[r4 + 168] = rMAC;
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
842015ba:	f4 b9       	r2 = M[r4 + 124];
842015bc:	73 b9       	r1 = M[r4 + 116];
842015be:	62 f0 a8 20 	r0 = r4 + 168;
842015c2:	06 f0 29 e2 	call (m) $_ahm_write_gain;
        p_ext_data->config.channel = AHM_ANC_INSTANCE_ANC1_ID;
842015c6:	81 20       	rMAC = Null + 2;
842015c8:	61 f0 a8 8a 	MB[r4 + 168] = rMAC;
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain1,
                       p_ext_data->p_prev_gain1);
842015cc:	64 f0 20 88 	r2 = M[r4 + 128];
842015d0:	b3 b9       	r1 = M[r4 + 120];
842015d2:	62 f0 a8 20 	r0 = r4 + 168;
842015d6:	06 f0 35 e1 	call (m) $_ahm_write_gain;
        /* restoring the actual channel */
        p_ext_data->config.channel = AHM_ANC_INSTANCE_DUAL_ID;
842015da:	01 21       	rMAC = Null + 4;
842015dc:	61 f0 a8 8a 	MB[r4 + 168] = rMAC;

842015e0 <Lc_ahm_write_gain_generic_7>:
    else if (p_ext_data->config.channel == AHM_ANC_INSTANCE_BOTH_ID)
    {
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
        stream_anc_update_background_gains(AHM_ANC_INSTANCE_ANC0_ID);
842015e0:	42 20       	r0 = Null + 1;
842015e2:	ff fd 5b f0 	call (m) 0xcdbe;
842015e6:	3d ee 
        stream_anc_update_background_gains(AHM_ANC_INSTANCE_ANC1_ID);
842015e8:	82 20       	r0 = Null + 2;
842015ea:	ff fd 5b f0 	call (m) 0xcdbe;
842015ee:	35 ee 

842015f0 <Lc_ahm_write_gain_generic_8>:
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
        stream_anc_update_background_gains(p_ext_data->config.channel);
    }
    return TRUE;
842015f0:	42 20       	r0 = Null + 1;
842015f2:	0d 6e       	jump (m) Lc_ahm_write_gain_generic_11;

842015f4 <Lc_ahm_write_gain_generic_9>:
    else
    {
        /* default instance as 0 for backward compatinbility*/
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
842015f4:	f4 b9       	r2 = M[r4 + 124];
842015f6:	73 b9       	r1 = M[r4 + 116];
842015f8:	62 f0 a8 20 	r0 = r4 + 168;
842015fc:	06 f0 2f e0 	call (m) $_ahm_write_gain;

84201600 <Lc_ahm_write_gain_generic_10>:
    if (p_ext_data->config.channel == AHM_ANC_INSTANCE_ANC1_ID)
    {
        ahm_write_gain(&p_ext_data->config,
                       p_ext_data->p_cur_gain1,
                       p_ext_data->p_prev_gain1);
        stream_anc_update_background_gains(p_ext_data->config.channel);
84201600:	62 f0 a8 80 	r0 = MBS[r4 + 168];
84201604:	ff fd 5b f0 	call (m) 0xcdbe;
84201608:	3b ed 
8420160a:	f3 6f       	jump (m) Lc_ahm_write_gain_generic_8;

8420160c <Lc_ahm_write_gain_generic_11>:
                       p_ext_data->p_cur_gain,
                       p_ext_data->p_prev_gain);
        stream_anc_update_background_gains(p_ext_data->config.channel);
    }
    return TRUE;
}
8420160c:	f1 48       	popm <FP, r4, rLink>;
8420160e:	d8 4c       	rts;

84201610 <Lc_ahm_set_mode_1>:
 *
 */
static void ahm_set_mode(OPERATOR_DATA *op_data,
                         AHM_OP_DATA *p_ext_data,
                         unsigned ctrl_value)
{
84201610:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201612:	59 4c       	SP = SP + 100;
84201614:	42 de       	M[FP + 32] = r0;
84201616:	11 00       	rMAC = r0 + Null;
84201618:	4b de       	M[FP + 36] = r1;
8420161a:	54 de       	M[FP + 40] = r2;
    ANC_HW_MANAGER_PARAMETERS *p_params;
    AHM_GAIN *p_path, *p_path1, *p_stat_path;
    int i;

    AHM_RAMP_CONFIG cfg[AHM_NUM_DYNAMIC_FILTERS];
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
8420161c:	4a 88       	r0 = M[rMAC + 4];
8420161e:	52 55       	r0 = r0 LSHIFT 6;
84201620:	40 f0 00 f2 	rMAC = r0 OR 0x4000;
84201624:	51 d8 
84201626:	59 de       	M[FP + 44] = rMAC;
84201628:	19 00       	rMAC = r1 + Null;

    p_params = &p_ext_data->ahm_cap_params;
8420162a:	1a f0 04 20 	r8 = rMAC + 4;
    if (p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_QUIET)
8420162e:	09 b8       	rMAC = M[rMAC + 96];
84201630:	08 25       	Null = rMAC - 4;
84201632:	08 62       	if NE jump (m) Lc_ahm_set_mode_3;

84201634 <Lc_ahm_set_mode_2>:
    {
        fb_dur = p_params->OFFSET_QUIET_FB_RAMP_DURATION;
84201634:	a1 f0 05 88 	rMAC = M[r8 + 20];
84201638:	61 de       	M[FP + 48] = rMAC;
        ff_dur = p_params->OFFSET_QUIET_FF_RAMP_DURATION;
8420163a:	a1 f0 04 88 	rMAC = M[r8 + 16];
8420163e:	69 de       	M[FP + 52] = rMAC;
84201640:	10 6e       	jump (m) Lc_ahm_set_mode_6;

84201642 <Lc_ahm_set_mode_3>:
    }
    else if(p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_WINDY)
84201642:	48 25       	Null = rMAC - 5;
84201644:	08 62       	if NE jump (m) Lc_ahm_set_mode_5;

84201646 <Lc_ahm_set_mode_4>:
    {
        fb_dur = p_params->OFFSET_WINDY_FB_RAMP_DURATION;
84201646:	a1 f0 07 88 	rMAC = M[r8 + 28];
8420164a:	61 de       	M[FP + 48] = rMAC;
        ff_dur = p_params->OFFSET_WINDY_FF_RAMP_DURATION;
8420164c:	a1 f0 06 88 	rMAC = M[r8 + 24];
84201650:	69 de       	M[FP + 52] = rMAC;
84201652:	07 6e       	jump (m) Lc_ahm_set_mode_6;

84201654 <Lc_ahm_set_mode_5>:
    }
    else
    {
        fb_dur = p_params->OFFSET_FB_RAMP_DURATION;
84201654:	a1 f0 09 88 	rMAC = M[r8 + 36];
84201658:	61 de       	M[FP + 48] = rMAC;
        ff_dur = p_params->OFFSET_FF_RAMP_DURATION;
8420165a:	a1 f0 08 88 	rMAC = M[r8 + 32];
8420165e:	69 de       	M[FP + 52] = rMAC;

84201660 <Lc_ahm_set_mode_6>:
    }
    fb_dly = p_ext_data->ahm_cap_params.OFFSET_FB_RAMP_DELAY_TIMER;
84201660:	49 d8       	rMAC = M[FP + 36];
84201662:	c9 98       	rMAC = M[rMAC + 44];
84201664:	71 de       	M[FP + 56] = rMAC;

    p_cur = p_ext_data->p_cur_gain;
84201666:	49 d8       	rMAC = M[FP + 36];
84201668:	19 f0 1d 88 	r7 = M[rMAC + 116];
    p_cur1 = p_ext_data->p_cur_gain1;
8420166c:	8f b9       	r5 = M[rMAC + 120];

    p_stat = p_ext_data->p_static_gain;
8420166e:	18 f0 21 88 	r6 = M[rMAC + 132];
    p_stat1 = p_ext_data->p_static_gain1;
84201672:	0b 00       	r1 = rMAC + Null;
84201674:	16 f0 22 88 	r4 = M[rMAC + 136];
    ff_dly = 0;
84201678:	78 de       	M[FP + 60] = Null;
    ff_tgt = 0;
8420167a:	80 de       	M[FP + 64] = Null;
    fb_tgt = 0;
8420167c:	03 09       	r9 = Null + Null;

    /* Update nominal gains */
    p_path = &p_stat->ff;
8420167e:	41 08       	rMAC = r6 + Null;
    p_path1 = &p_stat1->ff;
84201680:	32 00       	r0 = r4 + Null;
84201682:	03 f0 5c 45 	r1 = r1 + 348;
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201686:	1c 71       	r10 = Null + 3;
84201688:	09 4c       	do (m) Lc__loop6;

8420168a <Lc_ahm_set_mode_7>:
    {
        p_ext_data->ahm_fine_nominal[i].gain = (uint8)p_path->fine;
8420168a:	4c 86       	r2 = MHU[rMAC + 2];
8420168c:	1c 8a       	MB[r1 + 0] = r2;
        p_ext_data->ahm_fine_nominal1[i].gain = (uint8)p_path1->fine;
8420168e:	54 86       	r2 = MHU[r0 + 2];
84201690:	34 f0 48 8a 	MB[r1 + 72] = r2;
        p_path++;
84201694:	09 21       	rMAC = rMAC + 4;
        p_path1++;
84201696:	12 21       	r0 = r0 + 4;
84201698:	1b 2a       	r1 = r1 + 24;

8420169a <Lc__loop6>:
    fb_tgt = 0;

    /* Update nominal gains */
    p_path = &p_stat->ff;
    p_path1 = &p_stat1->ff;
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
8420169a:	49 d8       	rMAC = M[FP + 36];
8420169c:	13 f0 38 21 	r1 = rMAC + 312;
842016a0:	12 f0 23 88 	r0 = M[rMAC + 140];
842016a4:	fe ff 3f e5 	call (m) Lc_update_dynamic_nominal_gain_1;
    }

    update_dynamic_nominal_gain(p_ext_data->p_nominal_gain,
                                p_ext_data->p_fine_nominal);
    update_dynamic_nominal_gain(p_ext_data->p_nominal_gain1,
                                p_ext_data->p_fine_nominal1);
842016a8:	49 d8       	rMAC = M[FP + 36];
842016aa:	13 f0 44 21 	r1 = rMAC + 324;
842016ae:	12 f0 24 88 	r0 = M[rMAC + 144];
842016b2:	fe ff 31 e5 	call (m) Lc_update_dynamic_nominal_gain_1;

    update_static_nominal_gain(p_stat, p_ext_data->p_nominal_gain);
842016b6:	49 d8       	rMAC = M[FP + 36];
842016b8:	13 f0 23 88 	r1 = M[rMAC + 140];
842016bc:	42 08       	r0 = r6 + Null;
842016be:	fe ff 35 e5 	call (m) Lc_update_static_nominal_gain_1;
    update_static_nominal_gain(p_stat1, p_ext_data->p_nominal_gain1);
842016c2:	49 d8       	rMAC = M[FP + 36];
842016c4:	13 f0 24 88 	r1 = M[rMAC + 144];
842016c8:	32 00       	r0 = r4 + Null;
842016ca:	fe ff 29 e5 	call (m) Lc_update_static_nominal_gain_1;

    switch (ctrl_value)
842016ce:	51 d8       	rMAC = M[FP + 40];
842016d0:	00 f0 d3 e6 	if EQ jump (m) Lc__loop9;

842016d4 <Lc_ahm_set_mode_9>:
842016d4:	51 d8       	rMAC = M[FP + 40];
842016d6:	48 24       	Null = rMAC - 1;
842016d8:	8d 60       	if EQ jump (m) Lc_ahm_set_mode_20;

842016da <Lc_ahm_set_mode_10>:
842016da:	51 d8       	rMAC = M[FP + 40];
842016dc:	88 24       	Null = rMAC - 2;
842016de:	93 60       	if EQ jump (m) Lc_ahm_set_mode_21;

842016e0 <Lc_ahm_set_mode_11>:
842016e0:	51 d8       	rMAC = M[FP + 40];
842016e2:	c8 24       	Null = rMAC - 3;
842016e4:	d2 60       	if EQ jump (m) Lc_ahm_set_mode_25;

842016e6 <Lc_ahm_set_mode_12>:
842016e6:	51 d8       	rMAC = M[FP + 40];
842016e8:	08 25       	Null = rMAC - 4;
842016ea:	00 f0 85 e4 	if EQ jump (m) Lc_ahm_set_mode_26;

842016ee <Lc_ahm_set_mode_13>:
842016ee:	51 d8       	rMAC = M[FP + 40];
842016f0:	48 25       	Null = rMAC - 5;
842016f2:	47 62       	if NE jump (m) Lc_ahm_set_mode_15;

842016f4 <Lc_ahm_set_mode_14>:
            fb_dly = 0;
            break;
        case ANC_HW_MANAGER_SYSMODE_WINDY:
            /* Ramp FF and FB fine gains to target values */

            p_cur->rx_ffa_mix = p_stat->rx_ffa_mix;
842016f4:	81 f0 06 86 	rMAC = MHU[r6 + 12];
842016f8:	82 f0 07 86 	r0 = MHU[r6 + 14];
842016fc:	91 f0 06 8c 	MH[r7 + 12] = rMAC;
84201700:	92 f0 07 8c 	MH[r7 + 14] = r0;
            p_cur->rx_ffb_mix = p_stat->rx_ffb_mix;
84201704:	81 f0 08 86 	rMAC = MHU[r6 + 16];
84201708:	82 f0 09 86 	r0 = MHU[r6 + 18];
8420170c:	91 f0 08 8c 	MH[r7 + 16] = rMAC;
84201710:	92 f0 09 8c 	MH[r7 + 18] = r0;
            p_cur->ff.coarse = p_stat->ff.coarse;
84201714:	81 f0 00 e4 	rMAC = MHS[r6 + Null];
84201718:	91 f0 00 ec 	MH[r7 + Null] = rMAC;
            p_cur->fb.coarse = p_stat->fb.coarse;
8420171c:	81 f0 02 84 	rMAC = MHS[r6 + 4];
84201720:	91 f0 02 8c 	MH[r7 + 4] = rMAC;
            p_cur->ec.coarse = p_stat->ec.coarse;
84201724:	81 f0 04 84 	rMAC = MHS[r6 + 8];
84201728:	91 f0 04 8c 	MH[r7 + 8] = rMAC;

            p_cur1->rx_ffa_mix = p_stat1->rx_ffa_mix;
8420172c:	b1 87       	rMAC = MHU[r4 + 12];
8420172e:	f2 87       	r0 = MHU[r4 + 14];
84201730:	b9 8d       	MH[r5 + 12] = rMAC;
84201732:	fa 8d       	MH[r5 + 14] = r0;
            p_cur1->rx_ffb_mix = p_stat1->rx_ffb_mix;
84201734:	31 96       	rMAC = MHU[r4 + 16];
84201736:	72 96       	r0 = MHU[r4 + 18];
84201738:	39 9c       	MH[r5 + 16] = rMAC;
8420173a:	7a 9c       	MH[r5 + 18] = r0;
            p_cur1->ff.coarse = p_stat1->ff.coarse;
8420173c:	31 e4       	rMAC = MHS[r4 + Null];
8420173e:	39 ec       	MH[r5 + Null] = rMAC;
            p_cur1->fb.coarse = p_stat1->fb.coarse;
84201740:	b1 84       	rMAC = MHS[r4 + 4];
84201742:	b9 8c       	MH[r5 + 4] = rMAC;
            p_cur1->ec.coarse = p_stat1->ec.coarse;
84201744:	31 85       	rMAC = MHS[r4 + 8];
84201746:	39 8d       	MH[r5 + 8] = rMAC;

            fb_dur = p_params->OFFSET_WINDY_FB_RAMP_DURATION;
84201748:	a1 f0 07 88 	rMAC = M[r8 + 28];
8420174c:	61 de       	M[FP + 48] = rMAC;
            ff_dur = p_params->OFFSET_WINDY_FF_RAMP_DURATION;
8420174e:	a1 f0 06 88 	rMAC = M[r8 + 24];
84201752:	69 de       	M[FP + 52] = rMAC;

            p_param_value = &p_params->OFFSET_WINDY_MODE_FF_FINE_GAIN;
84201754:	a2 f0 38 20 	r0 = r8 + 56;
            ff_tgt = interpret_fine_gain(p_param_value,
                                         p_stat->ff.fine,
                                         p_cur->ff.fine,
                                         ext_op_id);
84201758:	94 f0 01 86 	r2 = MHU[r7 + 2];
8420175c:	83 f0 01 86 	r1 = MHU[r6 + 2];
84201760:	5d d8       	r3 = M[FP + 44];
84201762:	fd ff 2f ed 	call (m) Lc_interpret_fine_gain_1;
84201766:	82 de       	M[FP + 64] = r0;
            p_param_value = &p_params->OFFSET_WINDY_MODE_FB_FINE_GAIN;
84201768:	a2 f0 3c 20 	r0 = r8 + 60;
            fb_tgt = interpret_fine_gain(p_param_value,
                                         p_stat->fb.fine,
                                         p_cur->fb.fine,
                                         ext_op_id);
8420176c:	94 f0 03 86 	r2 = MHU[r7 + 6];
84201770:	83 f0 03 86 	r1 = MHU[r6 + 6];
84201774:	5d d8       	r3 = M[FP + 44];
84201776:	fd ff 3b ec 	call (m) Lc_interpret_fine_gain_1;
8420177a:	13 09       	r9 = r0 + Null;
            fb_dly = 0;
8420177c:	70 de       	M[FP + 56] = Null;
            ff_dly = 0;
8420177e:	78 de       	M[FP + 60] = Null;

84201780 <Lc_ahm_set_mode_15>:
            break;
        default:
            break;
    }
    /* Dummy Print to get past compiler warnings */
    L5_DBG_MSG2("OPID: %x, FF ramp delayed by %p", ext_op_id, ff_dly);
84201780:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201784:	48 25       	Null = rMAC - 5;
84201786:	09 68       	if LT jump (m) Lc_ahm_set_mode_17;

84201788 <Lc_ahm_set_mode_16>:
84201788:	55 f1 02 f0 	r0 = Null + 357565190;
8420178c:	06 43 
8420178e:	7c d8       	r2 = M[FP + 60];
84201790:	5b d8       	r1 = M[FP + 44];
84201792:	ef fd fc ff 	call (m) 0x10d6;
84201796:	25 ea 

84201798 <Lc_ahm_set_mode_17>:
    /* Store configurations */
    cfg[AHM_ANC_FILTER_FF_ID].target = ff_tgt;
84201798:	81 d8       	rMAC = M[FP + 64];
8420179a:	21 dd       	MH[FP + 72] = rMAC;
    cfg[AHM_ANC_FILTER_FF_ID].delay = ff_dly;
8420179c:	79 d8       	rMAC = M[FP + 60];
8420179e:	99 de       	M[FP + 76] = rMAC;
    cfg[AHM_ANC_FILTER_FF_ID].duration = ff_dur;
842017a0:	69 d8       	rMAC = M[FP + 52];
842017a2:	a1 de       	M[FP + 80] = rMAC;


    cfg[AHM_ANC_FILTER_FB_ID].target = fb_tgt;
842017a4:	eb f0 2e 8c 	MH[FP + 92] = r9;
    cfg[AHM_ANC_FILTER_FB_ID].delay = fb_dly;
842017a8:	71 d8       	rMAC = M[FP + 56];
842017aa:	c1 de       	M[FP + 96] = rMAC;
    cfg[AHM_ANC_FILTER_FB_ID].duration = fb_dur;
842017ac:	61 d8       	rMAC = M[FP + 48];
842017ae:	c9 de       	M[FP + 100] = rMAC;


    cfg[AHM_ANC_FILTER_EC_ID].target = p_ext_data->p_static_gain->ec.fine;
842017b0:	49 d8       	rMAC = M[FP + 36];
842017b2:	11 f0 21 88 	rMAC = M[rMAC + 132];
842017b6:	49 87       	rMAC = MHU[rMAC + 10];
842017b8:	e1 f0 38 8c 	MH[FP + 112] = rMAC;
    cfg[AHM_ANC_FILTER_EC_ID].delay = 0;
842017bc:	e8 de       	M[FP + 116] = Null;
    cfg[AHM_ANC_FILTER_EC_ID].duration = 0;
842017be:	f0 de       	M[FP + 120] = Null;
842017c0:	41 15       	rMAC = FP + 84;



     for (i=0; i < AHM_NUM_DYNAMIC_FILTERS;i++ )
842017c2:	1c 71       	r10 = Null + 3;
842017c4:	0a 4c       	do (m) Lc__loop7;

842017c6 <Lc_ahm_set_mode_18>:
    {
        cfg[i].slow_rate = p_ext_data->slow_rate;
842017c6:	4a d8       	r0 = M[FP + 36];
842017c8:	22 f0 b2 88 	r0 = M[r0 + 712];
842017cc:	0a ee       	M[rMAC + Null] = r0;
        cfg[i].fast_rate = p_ext_data->fast_rate;
842017ce:	4a d8       	r0 = M[FP + 36];
842017d0:	22 f0 b1 88 	r0 = M[r0 + 708];
842017d4:	4a 8e       	M[rMAC + 4] = r0;
842017d6:	09 29       	rMAC = rMAC + 20;

842017d8 <Lc__loop7>:
    cfg[AHM_ANC_FILTER_EC_ID].delay = 0;
    cfg[AHM_ANC_FILTER_EC_ID].duration = 0;



     for (i=0; i < AHM_NUM_DYNAMIC_FILTERS;i++ )
842017d8:	49 d8       	rMAC = M[FP + 36];
842017da:	11 f0 23 88 	rMAC = M[rMAC + 140];
842017de:	89 de       	M[FP + 68] = rMAC;
        cfg[i].fast_rate = p_ext_data->fast_rate;
    }


    p_path = &p_ext_data->p_nominal_gain->ff;
    p_stat_path = &p_ext_data->p_static_gain->ff;
842017e0:	49 d8       	rMAC = M[FP + 36];
842017e2:	1b f0 21 88 	r9 = M[rMAC + 132];

    /* Setup ramp nominal gain values and initialize ramps */
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842017e6:	02 09       	r8 = Null + Null;
842017e8:	e6 f0 4a 20 	r4 = FP + 74;
842017ec:	19 f0 b4 20 	r7 = rMAC + 180;
842017f0:	e6 6e       	jump (m) Lc_ahm_set_mode_31;

842017f2 <Lc_ahm_set_mode_20>:
        case ANC_HW_MANAGER_SYSMODE_STANDBY:
            /* No effect on gains */
            return;
        case ANC_HW_MANAGER_SYSMODE_MUTE_ANC:
            /* Ramp FF and FB fine gains to 0  */
            ff_tgt = 0;
842017f2:	80 de       	M[FP + 64] = Null;
            ff_dur = p_ext_data->ahm_cap_params.OFFSET_MUTE_RAMP_DURATION;
842017f4:	49 d8       	rMAC = M[FP + 36];
842017f6:	09 89       	rMAC = M[rMAC + 16];
842017f8:	69 de       	M[FP + 52] = rMAC;
            fb_tgt = 0;
842017fa:	03 09       	r9 = Null + Null;
            ff_dly = 0;
842017fc:	78 de       	M[FP + 60] = Null;
            fb_dly = 0;
842017fe:	70 de       	M[FP + 56] = Null;
            fb_dur = p_ext_data->ahm_cap_params.OFFSET_MUTE_RAMP_DURATION;
84201800:	61 de       	M[FP + 48] = rMAC;
            break;
84201802:	bf 6f       	jump (m) Lc_ahm_set_mode_15;

84201804 <Lc_ahm_set_mode_21>:
        case ANC_HW_MANAGER_SYSMODE_FULL:
            /* Ramp FF and FB fine gains to target gain values. Set other gains
             * to static values.
             */

            p_cur->rx_ffa_mix = p_stat->rx_ffa_mix;
84201804:	81 f0 06 86 	rMAC = MHU[r6 + 12];
84201808:	82 f0 07 86 	r0 = MHU[r6 + 14];
8420180c:	91 f0 06 8c 	MH[r7 + 12] = rMAC;
84201810:	92 f0 07 8c 	MH[r7 + 14] = r0;
            p_cur->rx_ffb_mix = p_stat->rx_ffb_mix;
84201814:	81 f0 08 86 	rMAC = MHU[r6 + 16];
84201818:	82 f0 09 86 	r0 = MHU[r6 + 18];
8420181c:	91 f0 08 8c 	MH[r7 + 16] = rMAC;
84201820:	92 f0 09 8c 	MH[r7 + 18] = r0;
            p_cur->ff.coarse = p_stat->ff.coarse;
84201824:	81 f0 00 e4 	rMAC = MHS[r6 + Null];
84201828:	91 f0 00 ec 	MH[r7 + Null] = rMAC;
            p_cur->fb.coarse = p_stat->fb.coarse;
8420182c:	81 f0 02 84 	rMAC = MHS[r6 + 4];
84201830:	91 f0 02 8c 	MH[r7 + 4] = rMAC;
            p_cur->ec.coarse = p_stat->ec.coarse;
84201834:	81 f0 04 84 	rMAC = MHS[r6 + 8];
84201838:	91 f0 04 8c 	MH[r7 + 8] = rMAC;

            p_cur1->rx_ffa_mix = p_stat1->rx_ffa_mix;
8420183c:	b1 87       	rMAC = MHU[r4 + 12];
8420183e:	f2 87       	r0 = MHU[r4 + 14];
84201840:	b9 8d       	MH[r5 + 12] = rMAC;
84201842:	fa 8d       	MH[r5 + 14] = r0;
            p_cur1->rx_ffb_mix = p_stat1->rx_ffb_mix;
84201844:	31 96       	rMAC = MHU[r4 + 16];
84201846:	72 96       	r0 = MHU[r4 + 18];
84201848:	39 9c       	MH[r5 + 16] = rMAC;
8420184a:	7a 9c       	MH[r5 + 18] = r0;
            p_cur1->ff.coarse = p_stat1->ff.coarse;
8420184c:	31 e4       	rMAC = MHS[r4 + Null];
8420184e:	39 ec       	MH[r5 + Null] = rMAC;
            p_cur1->fb.coarse = p_stat1->fb.coarse;
84201850:	b1 84       	rMAC = MHS[r4 + 4];
84201852:	b9 8c       	MH[r5 + 4] = rMAC;
            p_cur1->ec.coarse = p_stat1->ec.coarse;
84201854:	31 85       	rMAC = MHS[r4 + 8];
84201856:	39 8d       	MH[r5 + 8] = rMAC;

            ff_dly = p_ext_data->ahm_cap_params.OFFSET_START_MODE_DELAY_DURATION;
84201858:	49 d8       	rMAC = M[FP + 36];
8420185a:	c9 a9       	rMAC = M[rMAC + 92];
8420185c:	79 de       	M[FP + 60] = rMAC;

            if(p_ext_data->set_target_flag)
8420185e:	49 d8       	rMAC = M[FP + 36];
84201860:	10 f0 b5 88 	Null = M[rMAC + 724];
84201864:	09 60       	if EQ jump (m) Lc_ahm_set_mode_23;

84201866 <Lc_ahm_set_mode_22>:
            {
                ff_tgt = p_ext_data->ff_fine_tgt_gain;
84201866:	49 d8       	rMAC = M[FP + 36];
84201868:	11 f0 52 86 	rMAC = MHU[rMAC + 164];
8420186c:	81 de       	M[FP + 64] = rMAC;
                p_ext_data->set_target_flag = FALSE;
8420186e:	49 d8       	rMAC = M[FP + 36];
84201870:	10 f0 b5 8e 	M[rMAC + 724] = Null;
84201874:	06 6e       	jump (m) Lc_ahm_set_mode_24;

84201876 <Lc_ahm_set_mode_23>:
            }
            else
            {
                ff_tgt = p_ext_data->p_nominal_gain->ff.fine;
84201876:	49 d8       	rMAC = M[FP + 36];
84201878:	11 f0 23 88 	rMAC = M[rMAC + 140];
8420187c:	49 86       	rMAC = MHU[rMAC + 2];
8420187e:	81 de       	M[FP + 64] = rMAC;

84201880 <Lc_ahm_set_mode_24>:
            }

            fb_tgt = p_ext_data->fb_fine_tgt_gain;
84201880:	49 d8       	rMAC = M[FP + 36];
84201882:	1b f0 53 86 	r9 = MHU[rMAC + 166];
            break;
84201886:	7d 6f       	jump (m) Lc_ahm_set_mode_15;

84201888 <Lc_ahm_set_mode_25>:
        case ANC_HW_MANAGER_SYSMODE_STATIC:
            /* Ramp FF and FB fine gains to static values. Set other gains to
             * static values.
             */

            p_cur->rx_ffa_mix = p_stat->rx_ffa_mix;
84201888:	81 f0 06 86 	rMAC = MHU[r6 + 12];
8420188c:	82 f0 07 86 	r0 = MHU[r6 + 14];
84201890:	91 f0 06 8c 	MH[r7 + 12] = rMAC;
84201894:	92 f0 07 8c 	MH[r7 + 14] = r0;
            p_cur->rx_ffb_mix = p_stat->rx_ffb_mix;
84201898:	81 f0 08 86 	rMAC = MHU[r6 + 16];
8420189c:	82 f0 09 86 	r0 = MHU[r6 + 18];
842018a0:	91 f0 08 8c 	MH[r7 + 16] = rMAC;
842018a4:	92 f0 09 8c 	MH[r7 + 18] = r0;
            p_cur->ff.coarse = p_stat->ff.coarse;
842018a8:	81 f0 00 e4 	rMAC = MHS[r6 + Null];
842018ac:	91 f0 00 ec 	MH[r7 + Null] = rMAC;
            p_cur->fb.coarse = p_stat->fb.coarse;
842018b0:	81 f0 02 84 	rMAC = MHS[r6 + 4];
842018b4:	91 f0 02 8c 	MH[r7 + 4] = rMAC;
            p_cur->ec.coarse = p_stat->ec.coarse;
842018b8:	81 f0 04 84 	rMAC = MHS[r6 + 8];
842018bc:	91 f0 04 8c 	MH[r7 + 8] = rMAC;

            p_cur1->rx_ffa_mix = p_stat1->rx_ffa_mix;
842018c0:	b1 87       	rMAC = MHU[r4 + 12];
842018c2:	f2 87       	r0 = MHU[r4 + 14];
842018c4:	b9 8d       	MH[r5 + 12] = rMAC;
842018c6:	fa 8d       	MH[r5 + 14] = r0;
            p_cur1->rx_ffb_mix = p_stat1->rx_ffb_mix;
842018c8:	31 96       	rMAC = MHU[r4 + 16];
842018ca:	72 96       	r0 = MHU[r4 + 18];
842018cc:	39 9c       	MH[r5 + 16] = rMAC;
842018ce:	7a 9c       	MH[r5 + 18] = r0;
            p_cur1->ff.coarse = p_stat1->ff.coarse;
842018d0:	31 e4       	rMAC = MHS[r4 + Null];
842018d2:	39 ec       	MH[r5 + Null] = rMAC;
            p_cur1->fb.coarse = p_stat1->fb.coarse;
842018d4:	b1 84       	rMAC = MHS[r4 + 4];
842018d6:	b9 8c       	MH[r5 + 4] = rMAC;
            p_cur1->ec.coarse = p_stat1->ec.coarse;
842018d8:	31 85       	rMAC = MHS[r4 + 8];
842018da:	39 8d       	MH[r5 + 8] = rMAC;

            ff_dly = p_ext_data->ahm_cap_params.OFFSET_START_MODE_DELAY_DURATION;
842018dc:	49 d8       	rMAC = M[FP + 36];
842018de:	c9 a9       	rMAC = M[rMAC + 92];
842018e0:	79 de       	M[FP + 60] = rMAC;
            ff_tgt = p_stat->ff.fine;
842018e2:	81 f0 01 86 	rMAC = MHU[r6 + 2];
842018e6:	81 de       	M[FP + 64] = rMAC;
            fb_tgt = p_stat->fb.fine;
842018e8:	8b f0 03 86 	r9 = MHU[r6 + 6];
            break;
842018ec:	4a 6f       	jump (m) Lc_ahm_set_mode_15;

842018ee <Lc_ahm_set_mode_26>:
        case ANC_HW_MANAGER_SYSMODE_QUIET:
            /* Ramp FF and FB fine gains to target values */

            p_cur->rx_ffa_mix = p_stat->rx_ffa_mix;
842018ee:	81 f0 06 86 	rMAC = MHU[r6 + 12];
842018f2:	82 f0 07 86 	r0 = MHU[r6 + 14];
842018f6:	91 f0 06 8c 	MH[r7 + 12] = rMAC;
842018fa:	92 f0 07 8c 	MH[r7 + 14] = r0;
            p_cur->rx_ffb_mix = p_stat->rx_ffb_mix;
842018fe:	81 f0 08 86 	rMAC = MHU[r6 + 16];
84201902:	82 f0 09 86 	r0 = MHU[r6 + 18];
84201906:	91 f0 08 8c 	MH[r7 + 16] = rMAC;
8420190a:	92 f0 09 8c 	MH[r7 + 18] = r0;
            p_cur->ff.coarse = p_stat->ff.coarse;
8420190e:	81 f0 00 e4 	rMAC = MHS[r6 + Null];
84201912:	91 f0 00 ec 	MH[r7 + Null] = rMAC;
            p_cur->fb.coarse = p_stat->fb.coarse;
84201916:	81 f0 02 84 	rMAC = MHS[r6 + 4];
8420191a:	91 f0 02 8c 	MH[r7 + 4] = rMAC;
            p_cur->ec.coarse = p_stat->ec.coarse;
8420191e:	81 f0 04 84 	rMAC = MHS[r6 + 8];
84201922:	91 f0 04 8c 	MH[r7 + 8] = rMAC;

            p_cur1->rx_ffa_mix = p_stat1->rx_ffa_mix;
84201926:	b1 87       	rMAC = MHU[r4 + 12];
84201928:	f2 87       	r0 = MHU[r4 + 14];
8420192a:	b9 8d       	MH[r5 + 12] = rMAC;
8420192c:	fa 8d       	MH[r5 + 14] = r0;
            p_cur1->rx_ffb_mix = p_stat1->rx_ffb_mix;
8420192e:	31 96       	rMAC = MHU[r4 + 16];
84201930:	72 96       	r0 = MHU[r4 + 18];
84201932:	39 9c       	MH[r5 + 16] = rMAC;
84201934:	7a 9c       	MH[r5 + 18] = r0;
            p_cur1->ff.coarse = p_stat1->ff.coarse;
84201936:	31 e4       	rMAC = MHS[r4 + Null];
84201938:	39 ec       	MH[r5 + Null] = rMAC;
            p_cur1->fb.coarse = p_stat1->fb.coarse;
8420193a:	b1 84       	rMAC = MHS[r4 + 4];
8420193c:	b9 8c       	MH[r5 + 4] = rMAC;
            p_cur1->ec.coarse = p_stat1->ec.coarse;
8420193e:	31 85       	rMAC = MHS[r4 + 8];
84201940:	39 8d       	MH[r5 + 8] = rMAC;


            ff_dly = 0;
84201942:	78 de       	M[FP + 60] = Null;

            fb_dur = p_params->OFFSET_QUIET_FB_RAMP_DURATION;
84201944:	a1 f0 05 88 	rMAC = M[r8 + 20];
84201948:	61 de       	M[FP + 48] = rMAC;
            ff_dur = p_params->OFFSET_QUIET_FF_RAMP_DURATION;
8420194a:	a1 f0 04 88 	rMAC = M[r8 + 16];
8420194e:	69 de       	M[FP + 52] = rMAC;

            p_param_value = &p_params->OFFSET_QUIET_MODE_FF_FINE_GAIN;
84201950:	a2 f0 30 20 	r0 = r8 + 48;
            ff_tgt = interpret_fine_gain(p_param_value,
                                         p_stat->ff.fine,
                                         p_cur->ff.fine,
                                         ext_op_id);
84201954:	94 f0 01 86 	r2 = MHU[r7 + 2];
84201958:	83 f0 01 86 	r1 = MHU[r6 + 2];
8420195c:	5d d8       	r3 = M[FP + 44];
8420195e:	fc ff 33 ed 	call (m) Lc_interpret_fine_gain_1;
84201962:	82 de       	M[FP + 64] = r0;
            p_param_value = &p_params->OFFSET_QUIET_MODE_FB_FINE_GAIN;
84201964:	a2 f0 34 20 	r0 = r8 + 52;
            fb_tgt = interpret_fine_gain(p_param_value,
                                         p_stat->fb.fine,
                                         p_cur->fb.fine,
                                         ext_op_id);
84201968:	94 f0 03 86 	r2 = MHU[r7 + 6];
8420196c:	83 f0 03 86 	r1 = MHU[r6 + 6];
84201970:	5d d8       	r3 = M[FP + 44];
84201972:	fc ff 3f ec 	call (m) Lc_interpret_fine_gain_1;
84201976:	13 09       	r9 = r0 + Null;
            fb_dly = 0;
84201978:	70 de       	M[FP + 56] = Null;
            break;
8420197a:	03 6f       	jump (m) Lc_ahm_set_mode_15;

8420197c <Lc_ahm_set_mode_27>:
        {
            cfg[i].nominal_gain = p_stat_path->fine;
        }
        else
        {
            cfg[i].nominal_gain = p_path->fine;
8420197c:	31 ec       	MH[r4 + Null] = rMAC;

8420197e <Lc_ahm_set_mode_28>:
        }

        ahm_init_delta_ramp_and_notify(op_data,
                                       &p_ext_data->fine_ramp[i],
                                       &cfg[i]);
8420197e:	68 f0 02 24 	r6 = r4 - 2;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201982:	42 d8       	r0 = M[FP + 32];
84201984:	ef fd f7 ff 	call (m) 0x8ea;
84201988:	27 eb 
8420198a:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
8420198c:	74 f0 94 20 	r2 = r5 + 148;
84201990:	43 08       	r1 = r6 + Null;
84201992:	4a 08       	r0 = r7 + Null;
84201994:	05 f0 39 e5 	call (m) $_ahm_initialize_delta_ramp;
84201998:	10 04       	Null = r0 - Null;
8420199a:	06 60       	if EQ jump (m) Lc_ahm_set_mode_30;

8420199c <Lc_ahm_set_mode_29>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420199c:	73 f0 94 20 	r1 = r5 + 148;
842019a0:	42 d8       	r0 = M[FP + 32];
842019a2:	fd ff 23 e6 	call (m) Lc_ahm_send_event_message_1;

842019a6 <Lc_ahm_set_mode_30>:

        ahm_init_delta_ramp_and_notify(op_data,
                                       &p_ext_data->fine_ramp[i],
                                       &cfg[i]);

        p_path++;
842019a6:	89 d8       	rMAC = M[FP + 68];
842019a8:	09 21       	rMAC = rMAC + 4;
842019aa:	89 de       	M[FP + 68] = rMAC;
        p_stat_path++;
842019ac:	23 75       	r9 = r9 + 4;

    p_path = &p_ext_data->p_nominal_gain->ff;
    p_stat_path = &p_ext_data->p_static_gain->ff;

    /* Setup ramp nominal gain values and initialize ramps */
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842019ae:	0a 75       	r8 = r8 + 1;
842019b0:	36 29       	r4 = r4 + 20;
842019b2:	09 f0 20 44 	r7 = r7 + 32;
842019b6:	a0 f0 03 24 	Null = r8 - 3;
842019ba:	08 66       	if GE jump (m) Lc_ahm_set_mode_33;

842019bc <Lc_ahm_set_mode_31>:
    {
        if (p_path->fine == 0)
842019bc:	89 d8       	rMAC = M[FP + 68];
842019be:	49 86       	rMAC = MHU[rMAC + 2];
842019c0:	de 63       	if NE jump (m) Lc_ahm_set_mode_27;

842019c2 <Lc_ahm_set_mode_32>:
        {
            cfg[i].nominal_gain = p_stat_path->fine;
842019c2:	b1 f0 01 86 	rMAC = MHU[r9 + 2];
842019c6:	31 ec       	MH[r4 + Null] = rMAC;
842019c8:	db 6f       	jump (m) Lc_ahm_set_mode_28;

842019ca <Lc_ahm_set_mode_33>:

    /* Update nominal gain source. Standby is included because this is what
     * is sent during a disable override from QACT.
     */
    if (ctrl_value == ANC_HW_MANAGER_SYSMODE_FULL ||
        ctrl_value == ANC_HW_MANAGER_SYSMODE_STANDBY)
842019ca:	51 d8       	rMAC = M[FP + 40];
842019cc:	88 24       	Null = rMAC - 2;
842019ce:	1d 62       	if NE jump (m) Lc_ahm_set_mode_43;

842019d0 <Lc_ahm_set_mode_34>:
842019d0:	49 d8       	rMAC = M[FP + 36];
842019d2:	12 f0 38 21 	r0 = rMAC + 312;
842019d6:	11 00       	rMAC = r0 + Null;
842019d8:	12 2a       	r0 = r0 + 24;
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
842019da:	1c 71       	r10 = Null + 3;
842019dc:	15 4c       	do (m) Lc__loop8;

842019de <Lc_ahm_set_mode_35>:
        {
            if (p_ext_data->ahm_nominal_client[i])
842019de:	10 f0 4e 88 	Null = M[rMAC + 312];
842019e2:	05 60       	if EQ jump (m) Lc_ahm_set_mode_37;

842019e4 <Lc_ahm_set_mode_36>:
            {
                p_ext_data->p_fine_nominal[i] = \
                    &p_ext_data->client_fine_nominal[i];
842019e4:	23 f0 90 20 	r1 = r0 + 144;
842019e8:	0b ee       	M[rMAC + Null] = r1;
842019ea:	02 6e       	jump (m) Lc_ahm_set_mode_38;

842019ec <Lc_ahm_set_mode_37>:
            }
            else
            {
                p_ext_data->p_fine_nominal[i] = \
                    &p_ext_data->ahm_fine_nominal[i];
842019ec:	0a ee       	M[rMAC + Null] = r0;

842019ee <Lc_ahm_set_mode_38>:
            }

            if (p_ext_data->ahm_nominal_client1[i])
842019ee:	10 f0 51 88 	Null = M[rMAC + 324];
842019f2:	05 60       	if EQ jump (m) Lc_ahm_set_mode_40;

842019f4 <Lc_ahm_set_mode_39>:
            {
                p_ext_data->p_fine_nominal1[i] = \
                    &p_ext_data->client_fine_nominal1[i];
842019f4:	23 f0 d8 20 	r1 = r0 + 216;
842019f8:	cb 8e       	M[rMAC + 12] = r1;
842019fa:	04 6e       	jump (m) Lc_ahm_set_mode_41;

842019fc <Lc_ahm_set_mode_40>:
            }
            else
            {
                p_ext_data->p_fine_nominal1[i] = \
                    &p_ext_data->ahm_fine_nominal1[i];
842019fc:	23 f0 48 20 	r1 = r0 + 72;
84201a00:	cb 8e       	M[rMAC + 12] = r1;

84201a02 <Lc_ahm_set_mode_41>:
84201a02:	09 21       	rMAC = rMAC + 4;
84201a04:	12 2a       	r0 = r0 + 24;

84201a06 <Lc__loop8>:
     * is sent during a disable override from QACT.
     */
    if (ctrl_value == ANC_HW_MANAGER_SYSMODE_FULL ||
        ctrl_value == ANC_HW_MANAGER_SYSMODE_STANDBY)
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201a06:	0e 6e       	jump (m) Lc__loop9;

84201a08 <Lc_ahm_set_mode_43>:
84201a08:	49 d8       	rMAC = M[FP + 36];
84201a0a:	12 f0 38 21 	r0 = rMAC + 312;
84201a0e:	11 00       	rMAC = r0 + Null;
84201a10:	12 2a       	r0 = r0 + 24;
            }
        }
    }
    else
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201a12:	1c 71       	r10 = Null + 3;
84201a14:	07 4c       	do (m) Lc__loop9;

84201a16 <Lc_ahm_set_mode_44>:
        {
            p_ext_data->p_fine_nominal[i] = &p_ext_data->ahm_fine_nominal[i];
84201a16:	0a ee       	M[rMAC + Null] = r0;
            p_ext_data->p_fine_nominal1[i] = &p_ext_data->ahm_fine_nominal1[i];
84201a18:	23 f0 48 20 	r1 = r0 + 72;
84201a1c:	cb 8e       	M[rMAC + 12] = r1;
84201a1e:	12 2a       	r0 = r0 + 24;
84201a20:	09 21       	rMAC = rMAC + 4;

84201a22 <Lc__loop9>:
            }
        }
    }
    else
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201a22:	67 4c       	SP = SP + -100;
84201a24:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201a26:	d8 4c       	rts;

84201a28 <Lc_ahm_add_headroom_1>:
 * \param p_gain Pointer to the AHM_GAIN value to update
 *
 * \return  Nothing
 */
static void ahm_add_headroom(AHM_GAIN *p_gain, EXT_OP_ID ext_op_id)
{
84201a28:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201a2a:	16 00       	r4 = r0 + Null;
    int16 coarse_gain;
    uint16 fine_gain;

    coarse_gain = p_gain->coarse;
84201a2c:	37 e4       	r5 = MHS[r4 + Null];
    fine_gain = p_gain->fine;
84201a2e:	68 f0 01 86 	r6 = MHU[r4 + 2];
    /* Add headroom for adaptivity. If the fine gain is too large, decrease
    * it by 6dB and increment the coarse gain to compensate.
    */
    if (fine_gain > AHM_FF_FINE_MAX_THRESHOLD)
84201a32:	80 f0 80 24 	Null = r6 - 128;
84201a36:	09 6c       	if LE jump (m) Lc_ahm_add_headroom_3;

84201a38 <Lc_ahm_add_headroom_2>:
    {
        fine_gain = (uint16)(fine_gain + 1) >> 1;
84201a38:	81 f0 01 20 	rMAC = r6 + 1;
84201a3c:	8a c6       	r0 = rMAC AND 0xffff;
84201a3e:	7f f2 18 d9 	r6 = r0 ASHIFT -1;
        coarse_gain++;
84201a42:	79 20       	rMAC = r5 + 1;
84201a44:	0f 0c       	r5 = SE16 rMAC;
84201a46:	0d 6e       	jump (m) Lc_ahm_add_headroom_5;

84201a48 <Lc_ahm_add_headroom_3>:
    }
    else if (fine_gain < AHM_FF_FINE_MIN_THRESHOLD)
84201a48:	80 f0 40 24 	Null = r6 - 64;
84201a4c:	0a 66       	if GE jump (m) Lc_ahm_add_headroom_5;

84201a4e <Lc_ahm_add_headroom_4>:
    {
        L0_DBG_MSG3("OPID: %x, AHM static fine gain too low: %hu (< %hu)",
                    ext_op_id, fine_gain, AHM_FF_FINE_MIN_THRESHOLD);
84201a4e:	05 f0 40 40 	r3 = Null + 64;
84201a52:	55 f1 02 f0 	r0 = Null + 357565401;
84201a56:	d9 43 
84201a58:	44 08       	r2 = r6 + Null;
84201a5a:	ef fd fb ff 	call (m) 0x10ec;
84201a5e:	33 e4 

84201a60 <Lc_ahm_add_headroom_5>:
    }
    p_gain->coarse = coarse_gain;
84201a60:	37 ec       	MH[r4 + Null] = r5;
    p_gain->fine = fine_gain;
84201a62:	68 f0 01 8c 	MH[r4 + 2] = r6;

84201a66 <Lc_ahm_add_headroom_6>:

    return;
84201a66:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201a68:	d8 4c       	rts;

84201a6a <Lc_ahm_check_coarse_gain_change_1>:

static void ahm_check_coarse_gain_change(unsigned instance,
                                         AHM_ANC_CONFIG *p_config,
                                         AHM_GAIN_BANK *p_static_gains,
                                         bool *cfg)
{
84201a6a:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84201a6c:	10 09       	r6 = r0 + Null;
84201a6e:	1e 00       	r4 = r1 + Null;
84201a70:	21 09       	r7 = r2 + Null;
84201a72:	2f 00       	r5 = r3 + Null;

    uint16 ff_coarse=0, fb_coarse=0, ec_coarse=0;
84201a74:	60 dc       	MH[FP + 24] = Null;
84201a76:	70 dc       	MH[FP + 28] = Null;
84201a78:	80 dc       	MH[FP + 32] = Null;

#ifndef RUNNING_ON_KALSIM
    stream_anc_get_anc_coarse_gain((STREAM_ANC_INSTANCE) instance,
                                  (STREAM_ANC_PATH) p_config->ff_path,
                                  (uint16 *)&ff_coarse);
84201a7a:	84 11       	r2 = FP + 24;
84201a7c:	73 80       	r1 = MBS[r4 + 1];
84201a7e:	ef f8 42 ce 	r0 = SE8 r6;
84201a82:	ff fd 5a f0 	call (m) 0xce84;
84201a86:	23 e0 
    stream_anc_get_anc_coarse_gain((STREAM_ANC_INSTANCE) instance,
                                  (STREAM_ANC_PATH) p_config->fb_path,
                                  (uint16 *)&fb_coarse);
84201a88:	c4 11       	r2 = FP + 28;
84201a8a:	b3 80       	r1 = MBS[r4 + 2];
84201a8c:	ef f8 42 ce 	r0 = SE8 r6;
84201a90:	ff fd 59 f0 	call (m) 0xce84;
84201a94:	35 ef 
    stream_anc_get_anc_coarse_gain((STREAM_ANC_INSTANCE) instance,
                                  (STREAM_ANC_PATH) AHM_ANC_PATH_FB_ID,
                                  (uint16 *)&ec_coarse);
84201a96:	04 12       	r2 = FP + 32;
84201a98:	c3 20       	r1 = Null + 3;
84201a9a:	ef f8 42 ce 	r0 = SE8 r6;
84201a9e:	ff fd 59 f0 	call (m) 0xce84;
84201aa2:	27 ef 
#endif

    /* comparing the least significant 4 bits only */
    if((p_static_gains->ff.coarse & AHM_COARSE_GAIN_MASK) != ff_coarse)
84201aa4:	91 f0 00 e4 	rMAC = MHS[r7 + Null];
84201aa8:	62 d6       	r0 = MHU[FP + 24];
84201aaa:	89 c1       	rMAC = rMAC AND 0xf;
84201aac:	88 04       	Null = rMAC - r0;
84201aae:	03 60       	if EQ jump (m) Lc_ahm_check_coarse_gain_change_3;

84201ab0 <Lc_ahm_check_coarse_gain_change_2>:
    {
        cfg[AHM_ANC_FILTER_FF_ID] = TRUE;
84201ab0:	41 20       	rMAC = Null + 1;
84201ab2:	39 ee       	M[r5 + Null] = rMAC;

84201ab4 <Lc_ahm_check_coarse_gain_change_3>:
    }
    if((p_static_gains->fb.coarse & AHM_COARSE_GAIN_MASK) != fb_coarse)
84201ab4:	91 f0 02 84 	rMAC = MHS[r7 + 4];
84201ab8:	72 d6       	r0 = MHU[FP + 28];
84201aba:	89 c1       	rMAC = rMAC AND 0xf;
84201abc:	88 04       	Null = rMAC - r0;
84201abe:	03 60       	if EQ jump (m) Lc_ahm_check_coarse_gain_change_5;

84201ac0 <Lc_ahm_check_coarse_gain_change_4>:
    {
        cfg[AHM_ANC_FILTER_FB_ID] = TRUE;
84201ac0:	41 20       	rMAC = Null + 1;
84201ac2:	79 8e       	M[r5 + 4] = rMAC;

84201ac4 <Lc_ahm_check_coarse_gain_change_5>:
    }
    if((p_static_gains->ec.coarse & AHM_COARSE_GAIN_MASK) != ec_coarse)
84201ac4:	91 f0 04 84 	rMAC = MHS[r7 + 8];
84201ac8:	82 d6       	r0 = MHU[FP + 32];
84201aca:	89 c1       	rMAC = rMAC AND 0xf;
84201acc:	88 04       	Null = rMAC - r0;
84201ace:	03 60       	if EQ jump (m) Lc_ahm_check_coarse_gain_change_7;

84201ad0 <Lc_ahm_check_coarse_gain_change_6>:
    {
        cfg[AHM_ANC_FILTER_EC_ID] = TRUE;
84201ad0:	41 20       	rMAC = Null + 1;
84201ad2:	b9 8e       	M[r5 + 8] = rMAC;

84201ad4 <Lc_ahm_check_coarse_gain_change_7>:
    }
}
84201ad4:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84201ad6:	d8 4c       	rts;

84201ad8 <Lc_ahm_check_small_step_ramp_feasible_1>:

static bool ahm_check_small_step_ramp_feasible(int delta_gain, uint16 nominal_gain)
{
    uint16 upd_gain;

    upd_gain = (uint16)(((delta_gain >> AHM_DELTA_GAIN_SHIFT) * nominal_gain) >> AHM_DELTA_PRECISION);
84201ad8:	d2 59       	r0 = r0 ASHIFT -8;
84201ada:	d2 1a       	r0 = r0 * r1 (int);
84201adc:	92 5a       	r0 = r0 ASHIFT -16;
84201ade:	91 c6       	rMAC = r0 AND 0xffff;

    if(upd_gain < 10U && (nominal_gain > 0))
84201ae0:	88 26       	Null = rMAC - 10;
84201ae2:	02 f0 8f e0 	if C jump (m) Lc_ahm_check_small_step_ramp_feasible_3;

84201ae6 <Lc_ahm_check_small_step_ramp_feasible_2>:
    {
        return TRUE;
84201ae6:	02 00       	r0 = Null + Null;
84201ae8:	18 04       	Null = r1 - Null;
84201aea:	21 f0 42 ce 	if NE r0 = Null + 1;
84201aee:	02 6e       	jump (m) Lc_ahm_check_small_step_ramp_feasible_4;

84201af0 <Lc_ahm_check_small_step_ramp_feasible_3>:
    }
    else
    {
        return FALSE;
84201af0:	02 00       	r0 = Null + Null;

84201af2 <Lc_ahm_check_small_step_ramp_feasible_4>:
84201af2:	d8 4c       	rts;

84201af4 <Lc_ahm_get_small_step_value_1>:
 * \return  normalized gain
 *
 */

static uint32 ahm_get_small_step_value(uint16 nominal_gain, uint16 step)
{
84201af4:	c8 1c       	pushm <FP(=SP), rLink>;
84201af6:	11 00       	rMAC = r0 + Null;
    uint32 nominal_gain_step =0;
84201af8:	02 00       	r0 = Null + Null;

    if(nominal_gain > 0)
84201afa:	08 04       	Null = rMAC - Null;
84201afc:	06 60       	if EQ jump (m) Lc_ahm_get_small_step_value_3;

84201afe <Lc_ahm_get_small_step_value_2>:
    {
        nominal_gain_step = (uint32)(step << AHM_DIV_PRECISION)/(nominal_gain);
84201afe:	5a 57       	r0 = r1 LSHIFT 24;
84201b00:	0b 00       	r1 = rMAC + Null;
84201b02:	ff fd c3 f0 	call (m) 0x1a136;
84201b06:	35 e1 

84201b08 <Lc_ahm_get_small_step_value_3>:
    }

    return nominal_gain_step;
84201b08:	c8 48       	popm <FP, rLink>;
84201b0a:	d8 4c       	rts;

84201b0c <Lc_ahm_process_function_1>:
 *
 */
static void ahm_process_function(OPERATOR_DATA *op_data,
                                 unsigned samples,
                                 bool run_minimal)
{
84201b0c:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201b0e:	4c f3 10 cf 	SP = SP + 152;
84201b12:	42 de       	M[FP + 32] = r0;
84201b14:	4c de       	M[FP + 36] = r2;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201b16:	ef fd f6 ff 	call (m) 0x8ea;
84201b1a:	35 ee 
84201b1c:	52 de       	M[FP + 40] = r0;
    AHM_GAIN *p_cur_filter, *p_nominal_filter;
    AHM_GAIN_BANK *p_cur_gain1, *p_nominal1;
    AHM_GAIN *p_cur_filter1, *p_nominal_filter1;
    int tc, i;
    int cur_delta, nom_delta;
    EXT_OP_ID ext_op_id = INT_TO_EXT_OPID(op_data->id);
84201b1e:	41 d8       	rMAC = M[FP + 32];
84201b20:	4a 88       	r0 = M[rMAC + 4];
84201b22:	52 55       	r0 = r0 LSHIFT 6;
84201b24:	40 f0 00 f2 	rMAC = r0 OR 0x4000;
84201b28:	51 d8 
84201b2a:	59 de       	M[FP + 44] = rMAC;
    uint16 nominal_gain, upd_gain;
    int min_delta;
    bool gain_update, delta_changed, any_delta_changed = FALSE;
84201b2c:	60 de       	M[FP + 48] = Null;
    AHM_RAMP_CONFIG cfg[AHM_NUM_DYNAMIC_FILTERS];
    p_nominal = p_ext_data->p_nominal_gain;
84201b2e:	51 d8       	rMAC = M[FP + 40];
84201b30:	17 f0 23 88 	r5 = M[rMAC + 140];
{
    AHM_GAIN_BANK *p_static_gain;
    unsigned rxmix_gain_diff;

    /* Standby mode does no gain updates or calculations */
    if (p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_STANDBY)
84201b34:	08 b8       	Null = M[rMAC + 96];
84201b36:	00 f0 cd ed 	if EQ jump (m) Lc_ahm_process_function_122;

84201b3a <Lc_ahm_process_function_2>:
    }

    /* Out of ear does no gain updates or calculations */
    if (!p_ext_data->in_out_status &&
        ((p_ext_data->ahm_cap_params.OFFSET_AHM_CONFIG & \
            ANC_HW_MANAGER_CONFIG_AHM_CONFIG_DISABLE_EAR_CHECK) == 0))
84201b3a:	51 d8       	rMAC = M[FP + 40];
84201b3c:	11 f0 af 82 	rMAC = MBU[rMAC + 175];
84201b40:	06 62       	if NE jump (m) Lc_ahm_process_function_4;

84201b42 <Lc_ahm_process_function_3>:
84201b42:	51 d8       	rMAC = M[FP + 40];
84201b44:	49 88       	rMAC = M[rMAC + 4];
84201b46:	49 c0       	rMAC = rMAC AND 0x2;
84201b48:	00 f0 bb ed 	if EQ jump (m) Lc_ahm_process_function_122;

84201b4c <Lc_ahm_process_function_4>:
    }

    /* Clock check failure does no gain updates or calculations */
#ifndef RUNNING_ON_KALSIM
    if (p_ext_data->ahm_cap_params.OFFSET_AHM_CONFIG & \
        ANC_HW_MANAGER_CONFIG_AHM_CONFIG_DISABLE_ANC_CLOCK_CHECK)
84201b4c:	51 d8       	rMAC = M[FP + 40];
84201b4e:	49 88       	rMAC = M[rMAC + 4];
84201b50:	09 c0       	rMAC = rMAC AND 0x1;
84201b52:	00 f0 85 ed 	if EQ jump (m) Lc_ahm_process_function_118;

84201b56 <Lc_ahm_process_function_5>:
    {
        p_ext_data->clock_status = TRUE;
84201b56:	41 20       	rMAC = Null + 1;
84201b58:	52 d8       	r0 = M[FP + 40];
84201b5a:	21 f0 ae 8a 	MB[r0 + 174] = rMAC;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84201b5e:	42 d8       	r0 = M[FP + 32];
84201b60:	ef fd f6 ff 	call (m) 0x934;
84201b64:	35 ee 
        }
    }
#endif

    /* Reinitialize picks up the latest parameter values */
    if (aud_cur_get_reinit(op_data))
84201b66:	11 e2       	rMAC = MBU[r0 + Null];
84201b68:	16 60       	if EQ jump (m) Lc_ahm_process_function_7;

84201b6a <Lc_ahm_process_function_6>:
84201b6a:	42 d8       	r0 = M[FP + 32];
84201b6c:	ef fd f6 ff 	call (m) 0x934;
84201b70:	29 ee 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
84201b72:	10 ea       	MB[r0 + Null] = Null;
    {
        aud_cur_set_reinit(op_data, FALSE);

        /* Compute feedforward rxmix static gain fine difference in dB w.r.to
            feedforward static fine gain */
        p_static_gain = p_ext_data->p_static_gain;
84201b74:	51 d8       	rMAC = M[FP + 40];
84201b76:	11 f0 21 88 	rMAC = M[rMAC + 132];
        /* Calculate gain diff in dB (Q12.20) */
        rxmix_gain_diff = \
            ahm_get_gain_difference_db(p_static_gain->rx_ffb_mix.fine,
                                       0,
                                       p_static_gain->ff.fine,
                                       0);
84201b7a:	4c 86       	r2 = MHU[rMAC + 2];
84201b7c:	4a 96       	r0 = MHU[rMAC + 18];
84201b7e:	05 00       	r3 = Null + Null;
84201b80:	03 00       	r1 = Null + Null;
84201b82:	04 f0 29 e4 	call (m) $_ahm_get_gain_difference_db;
        /* Convert from dB to log2 format (Q12.20) */
        rxmix_gain_diff = ahm_convert_db_to_log2(rxmix_gain_diff);
84201b86:	0d f0 23 e4 	call (m) $_ahm_convert_db_to_log2;
        /* Convert to Q2.30 and cache it */
        p_ext_data->rxmix_gain_diff = \
            rxmix_gain_diff << AHM_Q12_TO_Q2_LSHIFT_AMT;
84201b8a:	05 f2 d2 c8 	r0 = r0 LSHIFT 10;
84201b8e:	51 d8       	rMAC = M[FP + 40];
84201b90:	12 f0 ac 8e 	M[rMAC + 688] = r0;

84201b94 <Lc_ahm_process_function_7>:
    if (!ahm_check_and_initialize(op_data, p_ext_data))
    {
        return;
    }
    /* Update nominal gain */
    if(p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_FULL)
84201b94:	51 d8       	rMAC = M[FP + 40];
84201b96:	09 b8       	rMAC = M[rMAC + 96];
84201b98:	88 24       	Null = rMAC - 2;
84201b9a:	14 62       	if NE jump (m) Lc_ahm_process_function_10;

84201b9c <Lc_ahm_process_function_8>:
    {
        update_dynamic_nominal_gain(p_ext_data->p_nominal_gain,
                                    p_ext_data->p_fine_nominal);
84201b9c:	51 d8       	rMAC = M[FP + 40];
84201b9e:	13 f0 38 21 	r1 = rMAC + 312;
84201ba2:	12 f0 23 88 	r0 = M[rMAC + 140];
84201ba6:	fb ff 3d ed 	call (m) Lc_update_dynamic_nominal_gain_1;
        if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201baa:	51 d8       	rMAC = M[FP + 40];
84201bac:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201bb0:	08 25       	Null = rMAC - 4;
84201bb2:	08 62       	if NE jump (m) Lc_ahm_process_function_10;

84201bb4 <Lc_ahm_process_function_9>:
        {
            update_dynamic_nominal_gain(p_ext_data->p_nominal_gain1,
                                        p_ext_data->p_fine_nominal1);
84201bb4:	51 d8       	rMAC = M[FP + 40];
84201bb6:	13 f0 44 21 	r1 = rMAC + 324;
84201bba:	12 f0 24 88 	r0 = M[rMAC + 144];
84201bbe:	fb ff 25 ed 	call (m) Lc_update_dynamic_nominal_gain_1;

84201bc2 <Lc_ahm_process_function_10>:
        }
    }

    if ((!run_minimal) && (p_ext_data->cur_mode != ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION))
84201bc2:	49 d8       	rMAC = M[FP + 36];
84201bc4:	28 62       	if NE jump (m) Lc_ahm_process_function_17;

84201bc6 <Lc_ahm_process_function_11>:
84201bc6:	51 d8       	rMAC = M[FP + 40];
84201bc8:	09 b8       	rMAC = M[rMAC + 96];
84201bca:	88 25       	Null = rMAC - 6;
84201bcc:	24 60       	if EQ jump (m) Lc_ahm_process_function_17;

84201bce <Lc_ahm_process_function_12>:
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201bce:	02 09       	r8 = Null + Null;
84201bd0:	51 d8       	rMAC = M[FP + 40];
84201bd2:	79 f0 02 20 	r7 = r5 + 2;
84201bd6:	16 f0 b4 20 	r4 = rMAC + 180;

84201bda <Lc_ahm_process_function_13>:
        {
            /* Process the gain ramp state machine */
            if (p_ext_data->fine_ramp[i].state != AHM_RAMP_IDLE)
84201bda:	31 91       	rMAC = MBS[r4 + 12];
84201bdc:	08 25       	Null = rMAC - 4;
84201bde:	15 60       	if EQ jump (m) Lc_ahm_process_function_16;

84201be0 <Lc_ahm_process_function_14>:
            {
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[i], p_nominal_filter[i].fine);
84201be0:	98 f0 00 e6 	r6 = MHU[r7 + Null];
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201be4:	42 d8       	r0 = M[FP + 32];
84201be6:	ef fd f6 ff 	call (m) 0x8ea;
84201bea:	25 e8 
84201bec:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
84201bee:	73 f0 94 20 	r1 = r5 + 148;
84201bf2:	44 08       	r2 = r6 + Null;
84201bf4:	32 00       	r0 = r4 + Null;
84201bf6:	04 f0 3f ea 	call (m) $_ahm_process_delta_ramp;
84201bfa:	10 04       	Null = r0 - Null;
84201bfc:	06 60       	if EQ jump (m) Lc_ahm_process_function_16;

84201bfe <Lc_ahm_process_function_15>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84201bfe:	73 f0 94 20 	r1 = r5 + 148;
84201c02:	42 d8       	r0 = M[FP + 32];
84201c04:	fc ff 21 e3 	call (m) Lc_ahm_send_event_message_1;

84201c08 <Lc_ahm_process_function_16>:
        }
    }

    if ((!run_minimal) && (p_ext_data->cur_mode != ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION))
    {
        for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201c08:	0a 75       	r8 = r8 + 1;
84201c0a:	36 30       	r4 = r4 + 32;
84201c0c:	21 75       	r7 = r7 + 4;
84201c0e:	a0 f0 03 24 	Null = r8 - 3;
84201c12:	e4 69       	if LT jump (m) Lc_ahm_process_function_13;

84201c14 <Lc_ahm_process_function_17>:
            }
        }
    }

    /* Iterate through dynamic paths */
    p_cur_gain  = p_ext_data->p_cur_gain;
84201c14:	51 d8       	rMAC = M[FP + 40];
84201c16:	49 b9       	rMAC = M[rMAC + 116];
84201c18:	69 de       	M[FP + 52] = rMAC;
    p_stat_gain = p_ext_data->p_static_gain;
84201c1a:	51 d8       	rMAC = M[FP + 40];
84201c1c:	11 f0 21 88 	rMAC = M[rMAC + 132];
84201c20:	71 de       	M[FP + 56] = rMAC;
    p_cur_filter = &p_cur_gain->ff;
    p_nominal = p_ext_data->p_nominal_gain;
84201c22:	51 d8       	rMAC = M[FP + 40];
84201c24:	12 f0 23 88 	r0 = M[rMAC + 140];
    p_nominal_filter = &p_nominal->ff;
    gain_update = FALSE;
84201c28:	78 de       	M[FP + 60] = Null;

    /* Initialization with channel 0 gains */
    p_cur_gain1 = p_ext_data->p_cur_gain;
84201c2a:	69 d8       	rMAC = M[FP + 52];
84201c2c:	81 de       	M[FP + 64] = rMAC;
    p_cur_filter1 = &p_cur_gain->ff;
84201c2e:	89 de       	M[FP + 68] = rMAC;
    p_nominal1 = p_ext_data->p_nominal_gain;
    p_nominal_filter1 = &p_nominal->ff;
84201c30:	92 de       	M[FP + 72] = r0;

    if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201c32:	51 d8       	rMAC = M[FP + 40];
84201c34:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201c38:	08 25       	Null = rMAC - 4;
84201c3a:	09 62       	if NE jump (m) Lc_ahm_process_function_19;

84201c3c <Lc_ahm_process_function_18>:
    {
        p_cur_gain1 = p_ext_data->p_cur_gain1;
84201c3c:	51 d8       	rMAC = M[FP + 40];
84201c3e:	89 b9       	rMAC = M[rMAC + 120];
84201c40:	81 de       	M[FP + 64] = rMAC;
        p_cur_filter1 = &p_cur_gain1->ff;
84201c42:	89 de       	M[FP + 68] = rMAC;
        p_nominal1 = p_ext_data->p_nominal_gain1;
84201c44:	51 d8       	rMAC = M[FP + 40];
84201c46:	11 f0 24 88 	rMAC = M[rMAC + 144];
        p_nominal_filter1 = &p_nominal1->ff;
84201c4a:	91 de       	M[FP + 72] = rMAC;

84201c4c <Lc_ahm_process_function_19>:
84201c4c:	41 20       	rMAC = Null + 1;
84201c4e:	99 de       	M[FP + 76] = rMAC;
    /* Iterate through dynamic paths */
    p_cur_gain  = p_ext_data->p_cur_gain;
    p_stat_gain = p_ext_data->p_static_gain;
    p_cur_filter = &p_cur_gain->ff;
    p_nominal = p_ext_data->p_nominal_gain;
    p_nominal_filter = &p_nominal->ff;
84201c50:	a2 de       	M[FP + 80] = r0;
    }

    /* Iterate through dynamic paths */
    p_cur_gain  = p_ext_data->p_cur_gain;
    p_stat_gain = p_ext_data->p_static_gain;
    p_cur_filter = &p_cur_gain->ff;
84201c52:	69 d8       	rMAC = M[FP + 52];
84201c54:	a9 de       	M[FP + 84] = rMAC;
        p_cur_gain1 = p_ext_data->p_cur_gain1;
        p_cur_filter1 = &p_cur_gain1->ff;
        p_nominal1 = p_ext_data->p_nominal_gain1;
        p_nominal_filter1 = &p_nominal1->ff;
    }
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201c56:	b0 de       	M[FP + 88] = Null;
84201c58:	51 d8       	rMAC = M[FP + 40];
84201c5a:	01 f0 38 45 	rMAC = rMAC + 312;
84201c5e:	b9 de       	M[FP + 92] = rMAC;

84201c60 <Lc_ahm_process_function_20>:
    {
        /* First gain priority are delta gains from the timer task */
        min_delta = AHM_DELTA_MAX;
84201c60:	f0 f7 0a f0 	r8 = Null + 2130706432;
84201c64:	00 40 
        delta_changed = FALSE;
84201c66:	c0 de       	M[FP + 96] = Null;
        p_node = p_ext_data->p_fine_delta_head[i];
84201c68:	b9 d8       	rMAC = M[FP + 92];
84201c6a:	1b f3 f7 b9 	r9 = M[rMAC + -36];
84201c6e:	0f 6e       	jump (m) Lc_ahm_process_function_25;

84201c70 <Lc_ahm_process_function_21>:
                }
                else
                {
                        /* TC is Q1.31, gain delta is Q8.24 */
                        /* positive ramp and negative ramp using algorithm*/
                        p_fine_gain->gain_current += frac_mult(tc, cur_delta);
84201c70:	cb d8       	r1 = M[FP + 100];
84201c72:	4a 08       	r0 = r7 + Null;
84201c74:	31 89       	rMAC = M[r4 + 16];
84201c76:	2f f3 42 c9 	r0 = r1 * r0 (frac);
84201c7a:	51 00       	rMAC = r0 + rMAC;
84201c7c:	31 8f       	M[r4 + 16] = rMAC;

84201c7e <Lc_ahm_process_function_22>:
                 }

                if (p_fine_gain->gain_current < min_delta)
84201c7e:	31 89       	rMAC = M[r4 + 16];
84201c80:	af f1 00 c2 	Null = rMAC - r8;
84201c84:	02 66       	if GE jump (m) Lc_ahm_process_function_24;

84201c86 <Lc_ahm_process_function_23>:
                {
                    min_delta = p_fine_gain->gain_current;
84201c86:	0a 09       	r8 = rMAC + Null;

84201c88 <Lc_ahm_process_function_24>:
                }
            }
            p_node = p_node->p_next;
84201c88:	bb f0 00 e8 	r9 = M[r9 + Null];

84201c8c <Lc_ahm_process_function_25>:
    {
        /* First gain priority are delta gains from the timer task */
        min_delta = AHM_DELTA_MAX;
        delta_changed = FALSE;
        p_node = p_ext_data->p_fine_delta_head[i];
        while (p_node != NULL)
84201c8c:	0f fb 00 c2 	Null = r9 - Null;
84201c90:	39 60       	if EQ jump (m) Lc_ahm_process_function_36;

84201c92 <Lc_ahm_process_function_26>:
        {
            p_fine_gain = &p_node->data;
84201c92:	b6 f0 04 20 	r4 = r9 + 4;
            tc = p_fine_gain->tc_release;
84201c96:	b1 88       	rMAC = M[r4 + 8];
84201c98:	c9 de       	M[FP + 100] = rMAC;

            if (p_fine_gain->gain_delta != AHM_DELTA_NOMINAL)
84201c9a:	31 e8       	rMAC = M[r4 + Null];
84201c9c:	00 f4 10 f0 	Null = rMAC - 16777216;
84201ca0:	00 24 
84201ca2:	f3 61       	if EQ jump (m) Lc_ahm_process_function_24;

84201ca4 <Lc_ahm_process_function_27>:
            {
                delta_changed = TRUE;
84201ca4:	42 20       	r0 = Null + 1;
84201ca6:	c2 de       	M[FP + 96] = r0;
                any_delta_changed = TRUE;
84201ca8:	62 de       	M[FP + 48] = r0;
                /* Attack is considered to be a gain reduction, i.e. nominal
                 * operating condition is 1.0 and attack would be to reduce
                 * the gain to protect against a given condition.
                 */
                if (p_fine_gain->gain_delta < p_fine_gain->gain_current)
84201caa:	37 89       	r5 = M[r4 + 16];
84201cac:	c8 05       	Null = rMAC - r5;
84201cae:	03 66       	if GE jump (m) Lc_ahm_process_function_29;

84201cb0 <Lc_ahm_process_function_28>:
                {
                    tc = p_fine_gain->tc_attack;
84201cb0:	72 88       	r0 = M[r4 + 4];
84201cb2:	ca de       	M[FP + 100] = r0;

84201cb4 <Lc_ahm_process_function_29>:
                }

                cur_delta = p_fine_gain->gain_delta - p_fine_gain->gain_current;
84201cb4:	7f f1 09 c2 	r7 = rMAC - r5;
                //TODO -move this code to ahm_ramp
                if (( (p_fine_gain ==p_ext_data->p_fine_delta_ramp[AHM_ANC_FILTER_FF_ID])||
                    (p_fine_gain ==p_ext_data->p_fine_delta_ramp[AHM_ANC_FILTER_FB_ID]) ||
                    (p_fine_gain ==p_ext_data->p_fine_delta_ramp[AHM_ANC_FILTER_EC_ID])) &&
                    (cur_delta > 0) &&
                   (ahm_check_small_step_ramp_feasible(p_fine_gain->gain_current, p_nominal_filter->fine)) )
84201cb8:	51 d8       	rMAC = M[FP + 40];
84201cba:	11 f0 4b 88 	rMAC = M[rMAC + 300];
84201cbe:	70 04       	Null = r4 - rMAC;
84201cc0:	0b 60       	if EQ jump (m) Lc_ahm_process_function_32;

84201cc2 <Lc_ahm_process_function_30>:
84201cc2:	51 d8       	rMAC = M[FP + 40];
84201cc4:	11 f0 4c 88 	rMAC = M[rMAC + 304];
84201cc8:	70 04       	Null = r4 - rMAC;
84201cca:	06 60       	if EQ jump (m) Lc_ahm_process_function_32;

84201ccc <Lc_ahm_process_function_31>:
84201ccc:	51 d8       	rMAC = M[FP + 40];
84201cce:	11 f0 4d 88 	rMAC = M[rMAC + 308];
84201cd2:	70 04       	Null = r4 - rMAC;
84201cd4:	ce 63       	if NE jump (m) Lc_ahm_process_function_21;

84201cd6 <Lc_ahm_process_function_32>:
84201cd6:	90 f0 00 24 	Null = r7 - 0;
84201cda:	cb 6d       	if LE jump (m) Lc_ahm_process_function_21;

84201cdc <Lc_ahm_process_function_33>:
84201cdc:	a1 d8       	rMAC = M[FP + 80];
84201cde:	18 f0 01 86 	r6 = MHU[rMAC + 2];
84201ce2:	43 08       	r1 = r6 + Null;
84201ce4:	3a 00       	r0 = r5 + Null;
84201ce6:	fe ff 33 ef 	call (m) Lc_ahm_check_small_step_ramp_feasible_1;
84201cea:	10 04       	Null = r0 - Null;
84201cec:	c2 61       	if EQ jump (m) Lc_ahm_process_function_21;

84201cee <Lc_ahm_process_function_34>:
                {

                    /* postivie delta i.e., ramp up and small step ramp required */
                    p_fine_gain->gain_current += ahm_get_small_step_value(p_nominal_filter->fine, 1U); /* increment smaller steps */
84201cee:	43 20       	r1 = Null + 1;
84201cf0:	42 08       	r0 = r6 + Null;
84201cf2:	01 4f       	call (m) Lc_ahm_get_small_step_value_1;
84201cf4:	d1 01       	rMAC = r0 + r5;
84201cf6:	31 8f       	M[r4 + 16] = rMAC;
                    if (p_fine_gain->gain_current < min_delta)
84201cf8:	af f1 00 c2 	Null = rMAC - r8;
84201cfc:	c6 67       	if GE jump (m) Lc_ahm_process_function_24;

84201cfe <Lc_ahm_process_function_35>:
                        {
                           min_delta = p_fine_gain->gain_current;
84201cfe:	0a 09       	r8 = rMAC + Null;
84201d00:	bf 6f       	jump (m) Lc_ahm_process_function_22;

84201d02 <Lc_ahm_process_function_36>:
            }
            p_node = p_node->p_next;
        }

        /* Delta gain has been calculated and is applied */
        if (delta_changed)
84201d02:	c1 d8       	rMAC = M[FP + 96];
84201d04:	22 60       	if EQ jump (m) Lc_ahm_process_function_39;

84201d06 <Lc_ahm_process_function_37>:
        {
            nominal_gain = p_nominal_filter->fine;
84201d06:	a1 d8       	rMAC = M[FP + 80];
84201d08:	49 86       	rMAC = MHU[rMAC + 2];
            /* Calculate adjusted gain */
            nom_delta = ((min_delta >> AHM_DELTA_GAIN_SHIFT) * nominal_gain);
84201d0a:	7c fa 13 c9 	r1 = r8 ASHIFT -8;
84201d0e:	ca 1a       	r0 = rMAC * r1 (int);
            nom_delta += AHM_DELTA_ROUNDING;
84201d10:	42 f0 00 44 	r0 = r0 + 32768;
            upd_gain = (uint16)(nom_delta >> AHM_DELTA_PRECISION);
84201d14:	92 5a       	r0 = r0 ASHIFT -16;
84201d16:	91 c6       	rMAC = r0 AND 0xffff;
            p_cur_filter->fine = upd_gain;
84201d18:	aa d8       	r0 = M[FP + 84];
84201d1a:	51 8c       	MH[r0 + 2] = rMAC;

            /* Set the nominal flag on this path to FALSE */
            p_ext_data->p_fine_nominal[i]->using_nominal = FALSE;
84201d1c:	b9 d8       	rMAC = M[FP + 92];
84201d1e:	09 e8       	rMAC = M[rMAC + Null];
84201d20:	08 ab       	MB[rMAC + 20] = Null;
            gain_update = TRUE;
84201d22:	41 20       	rMAC = Null + 1;
84201d24:	79 de       	M[FP + 60] = rMAC;
            
            if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201d26:	51 d8       	rMAC = M[FP + 40];
84201d28:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201d2c:	08 25       	Null = rMAC - 4;
84201d2e:	0d 62       	if NE jump (m) Lc_ahm_process_function_39;

84201d30 <Lc_ahm_process_function_38>:
            {
                nominal_gain = p_nominal_filter1->fine;
84201d30:	91 d8       	rMAC = M[FP + 72];
84201d32:	49 86       	rMAC = MHU[rMAC + 2];
                /* Calculate adjusted gain */
                nom_delta = ((min_delta >> AHM_DELTA_GAIN_SHIFT) * nominal_gain);
84201d34:	ca 1a       	r0 = rMAC * r1 (int);
                nom_delta += AHM_DELTA_ROUNDING;
84201d36:	42 f0 00 44 	r0 = r0 + 32768;
                upd_gain = (uint16)(nom_delta >> AHM_DELTA_PRECISION);
84201d3a:	92 5a       	r0 = r0 ASHIFT -16;
84201d3c:	91 c6       	rMAC = r0 AND 0xffff;
                p_cur_filter1->fine = upd_gain;
84201d3e:	8a d8       	r0 = M[FP + 68];
84201d40:	51 8c       	MH[r0 + 2] = rMAC;

                /* Set the nominal flag on this path to FALSE */
                p_ext_data->p_fine_nominal1[i]->using_nominal = FALSE;
84201d42:	b9 d8       	rMAC = M[FP + 92];
84201d44:	c9 88       	rMAC = M[rMAC + 12];
84201d46:	08 ab       	MB[rMAC + 20] = Null;

84201d48 <Lc_ahm_process_function_39>:
            }
        }
        /* Minimal run of the process function exits the loop early */
        if (run_minimal)
84201d48:	49 d8       	rMAC = M[FP + 36];
84201d4a:	1d 62       	if NE jump (m) Lc_ahm_process_function_46;

84201d4c <Lc_ahm_process_function_40>:
            p_cur_filter1++;
            continue;
        }

        /* Second gain priority is nominal gain */
        p_fine_gain = p_ext_data->p_fine_nominal[i];
84201d4c:	b9 d8       	rMAC = M[FP + 92];
84201d4e:	09 e8       	rMAC = M[rMAC + Null];
        if (!gain_update)
84201d50:	7a d8       	r0 = M[FP + 60];
84201d52:	08 62       	if NE jump (m) Lc_ahm_process_function_42;

84201d54 <Lc_ahm_process_function_41>:
        {
            p_cur_filter->fine = p_nominal_filter->fine;
84201d54:	a2 d8       	r0 = M[FP + 80];
84201d56:	ab d8       	r1 = M[FP + 84];
84201d58:	52 86       	r0 = MHU[r0 + 2];
84201d5a:	5a 8c       	MH[r1 + 2] = r0;
            p_fine_gain->using_nominal = TRUE;
84201d5c:	9a d8       	r0 = M[FP + 76];
84201d5e:	0a ab       	MB[rMAC + 20] = r0;
84201d60:	02 6e       	jump (m) Lc_ahm_process_function_43;

84201d62 <Lc_ahm_process_function_42>:
        }
        else
        {
            p_fine_gain->using_nominal = FALSE;
84201d62:	08 ab       	MB[rMAC + 20] = Null;

84201d64 <Lc_ahm_process_function_43>:
        }
        p_nominal_filter++;
        p_cur_filter++;

        if (p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201d64:	51 d8       	rMAC = M[FP + 40];
84201d66:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201d6a:	08 25       	Null = rMAC - 4;
84201d6c:	12 62       	if NE jump (m) Lc_ahm_process_function_47;

84201d6e <Lc_ahm_process_function_44>:
        {
            /* Second gain priority is nominal gain */
            p_fine_gain1 = p_ext_data->p_fine_nominal1[i];
84201d6e:	b9 d8       	rMAC = M[FP + 92];
84201d70:	c9 88       	rMAC = M[rMAC + 12];
            if (!gain_update)
84201d72:	7a d8       	r0 = M[FP + 60];
84201d74:	01 f0 e3 e4 	if NE jump (m) Lc_ahm_process_function_83;

84201d78 <Lc_ahm_process_function_45>:
            {
                p_cur_filter1->fine = p_nominal_filter1->fine;
84201d78:	92 d8       	r0 = M[FP + 72];
84201d7a:	8b d8       	r1 = M[FP + 68];
84201d7c:	52 86       	r0 = MHU[r0 + 2];
84201d7e:	5a 8c       	MH[r1 + 2] = r0;
                p_fine_gain1->using_nominal = TRUE;
84201d80:	9a d8       	r0 = M[FP + 76];
84201d82:	0a ab       	MB[rMAC + 20] = r0;

84201d84 <Lc_ahm_process_function_46>:
        /* Minimal run of the process function exits the loop early */
        if (run_minimal)
        {
            p_nominal_filter++;
            p_cur_filter++;
            p_nominal_filter1++;
84201d84:	91 d8       	rMAC = M[FP + 72];
84201d86:	09 21       	rMAC = rMAC + 4;
84201d88:	91 de       	M[FP + 72] = rMAC;
            p_cur_filter1++;
84201d8a:	89 d8       	rMAC = M[FP + 68];
84201d8c:	09 21       	rMAC = rMAC + 4;
84201d8e:	89 de       	M[FP + 68] = rMAC;

84201d90 <Lc_ahm_process_function_47>:
            }
        }
        /* Minimal run of the process function exits the loop early */
        if (run_minimal)
        {
            p_nominal_filter++;
84201d90:	a1 d8       	rMAC = M[FP + 80];
84201d92:	09 21       	rMAC = rMAC + 4;
84201d94:	a1 de       	M[FP + 80] = rMAC;
            p_cur_filter++;
84201d96:	a9 d8       	rMAC = M[FP + 84];
84201d98:	09 21       	rMAC = rMAC + 4;
84201d9a:	a9 de       	M[FP + 84] = rMAC;
        p_cur_gain1 = p_ext_data->p_cur_gain1;
        p_cur_filter1 = &p_cur_gain1->ff;
        p_nominal1 = p_ext_data->p_nominal_gain1;
        p_nominal_filter1 = &p_nominal1->ff;
    }
    for (i = 0; i < AHM_NUM_DYNAMIC_FILTERS; i++)
84201d9c:	b1 d8       	rMAC = M[FP + 88];
84201d9e:	49 20       	rMAC = rMAC + 1;
84201da0:	b1 de       	M[FP + 88] = rMAC;
84201da2:	b9 d8       	rMAC = M[FP + 92];
84201da4:	09 21       	rMAC = rMAC + 4;
84201da6:	b9 de       	M[FP + 92] = rMAC;
84201da8:	b1 d8       	rMAC = M[FP + 88];
84201daa:	c8 24       	Null = rMAC - 3;
84201dac:	5a 69       	if LT jump (m) Lc_ahm_process_function_20;

84201dae <Lc_ahm_process_function_48>:
    }

    /* Compute current FF rxmix gain corrosponding to current FF gain if
        we are in hybrid adaptive ambient mode */
    if((p_ext_data->aamb_mode == ANC_HW_MANAGER_AMBIENT_CTRL_AAMB) &&
        (p_ext_data->anc_clock_check_value == AHM_HYBRID_ENABLE))
84201dae:	51 d8       	rMAC = M[FP + 40];
84201db0:	11 f0 cc 92 	rMAC = MBU[rMAC + 716];
84201db4:	48 24       	Null = rMAC - 1;
84201db6:	0f 62       	if NE jump (m) Lc_ahm_process_function_51;

84201db8 <Lc_ahm_process_function_49>:
84201db8:	51 d8       	rMAC = M[FP + 40];
84201dba:	11 f0 56 86 	rMAC = MHU[rMAC + 172];
84201dbe:	c8 27       	Null = rMAC - 15;
84201dc0:	0a 62       	if NE jump (m) Lc_ahm_process_function_51;

84201dc2 <Lc_ahm_process_function_50>:
    {
        p_cur_gain->rx_ffb_mix.fine = \
            aud_cur_calc_adjusted_gain(p_cur_gain->ff.fine,
                                       p_ext_data->rxmix_gain_diff);
84201dc2:	51 d8       	rMAC = M[FP + 40];
84201dc4:	13 f0 ac 88 	r1 = M[rMAC + 688];
84201dc8:	69 d8       	rMAC = M[FP + 52];
84201dca:	4a 86       	r0 = MHU[rMAC + 2];
84201dcc:	0c f0 2b e2 	call (m) $_aud_cur_calc_adjusted_gain;
84201dd0:	69 d8       	rMAC = M[FP + 52];
84201dd2:	4a 9c       	MH[rMAC + 18] = r0;

84201dd4 <Lc_ahm_process_function_51>:
#ifdef RUNNING_ON_KALSIM
        /* Unused variable */
        (void)any_delta_changed;
#else
    /* Update gains */
    if (p_ext_data->disable_zcd)
84201dd4:	51 d8       	rMAC = M[FP + 40];
84201dd6:	11 f0 b0 82 	rMAC = MBU[rMAC + 176];
84201dda:	0a 60       	if EQ jump (m) Lc_ahm_process_function_53;

84201ddc <Lc_ahm_process_function_52>:
    {
        /* Disable ZCD only if delta gains have changed. Else enable ZCD */
        ahm_set_anc_zcd_enable(!any_delta_changed, p_ext_data->config.channel);
84201ddc:	02 00       	r0 = Null + Null;
84201dde:	61 d8       	rMAC = M[FP + 48];
84201de0:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201de4:	51 d8       	rMAC = M[FP + 40];
84201de6:	13 f0 a8 80 	r1 = MBS[rMAC + 168];
84201dea:	fb ff 39 e1 	call (m) Lc_ahm_set_anc_zcd_enable_1;

84201dee <Lc_ahm_process_function_53>:
    }
#endif

    ahm_write_gain_generic(op_data);
84201dee:	42 d8       	r0 = M[FP + 32];
84201df0:	fb ff 2d ec 	call (m) Lc_ahm_write_gain_generic_1;

    if (p_ext_data->trigger_mode == AHM_TRIGGER_START)
84201df4:	51 d8       	rMAC = M[FP + 40];
84201df6:	11 f0 cd 90 	rMAC = MBS[rMAC + 717];
84201dfa:	48 24       	Null = rMAC - 1;
84201dfc:	28 62       	if NE jump (m) Lc_ahm_process_function_56;

84201dfe <Lc_ahm_process_function_54>:
    {

        #ifndef RUNNING_ON_KALSIM
            stream_anc_update_background_iir_coeffs(STREAM_ANC_INSTANCE_ANC0_MASK);
84201dfe:	42 20       	r0 = Null + 1;
84201e00:	ff fd 57 f0 	call (m) 0xcce8;
84201e04:	29 e7 
            stream_anc_update_background_iir_coeffs(STREAM_ANC_INSTANCE_ANC1_MASK);
84201e06:	82 20       	r0 = Null + 2;
84201e08:	ff fd 57 f0 	call (m) 0xcce8;
84201e0c:	21 e7 
        #endif
        DEBUG_AHM("OPID: %x, Copy from foreground to background IIR filters for both ANC Instances!",
                  ext_op_id);
        msg.id =AHM_EVENT_ID_FILTER_TRANSITION;
84201e0e:	81 21       	rMAC = Null + 6;
84201e10:	e1 f0 56 8c 	MH[FP + 172] = rMAC;
        msg.type = AHM_EVENT_TYPE_CLEAR;
84201e14:	41 20       	rMAC = Null + 1;
84201e16:	e1 f0 57 8c 	MH[FP + 174] = rMAC;
        msg.payload = 0;
84201e1a:	60 df       	M[FP + 176] = Null;
        msg.ext_op_id = ext_op_id;
84201e1c:	59 d8       	rMAC = M[FP + 44];
84201e1e:	69 df       	M[FP + 180] = rMAC;
        ahm_send_event_message(op_data,&msg);
84201e20:	c3 1a       	r1 = FP + 172;
84201e22:	42 d8       	r0 = M[FP + 32];
84201e24:	fb ff 21 e2 	call (m) Lc_ahm_send_event_message_1;
        p_ext_data->trigger_mode = 0;
84201e28:	51 d8       	rMAC = M[FP + 40];
84201e2a:	10 f0 cd 9a 	MB[rMAC + 717] = Null;

        update_coarse_gain(p_cur_gain, p_stat_gain);
84201e2e:	73 d8       	r1 = M[FP + 56];
84201e30:	6a d8       	r0 = M[FP + 52];
84201e32:	fa ff 3f ea 	call (m) Lc_update_coarse_gain_1;
        if(p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201e36:	51 d8       	rMAC = M[FP + 40];
84201e38:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201e3c:	08 25       	Null = rMAC - 4;
84201e3e:	07 62       	if NE jump (m) Lc_ahm_process_function_56;

84201e40 <Lc_ahm_process_function_55>:
        {
            update_coarse_gain(p_cur_gain1, p_ext_data->p_static_gain1);
84201e40:	51 d8       	rMAC = M[FP + 40];
84201e42:	13 f0 22 88 	r1 = M[rMAC + 136];
84201e46:	82 d8       	r0 = M[FP + 64];
84201e48:	fa ff 29 ea 	call (m) Lc_update_coarse_gain_1;

84201e4c <Lc_ahm_process_function_56>:
        }
    }

    /* Check for a filter transition */
    if ( (p_ext_data->cur_mode == ANC_HW_MANAGER_SYSMODE_FILTER_TRANSITION) )
84201e4c:	51 d8       	rMAC = M[FP + 40];
84201e4e:	09 b8       	rMAC = M[rMAC + 96];
84201e50:	88 25       	Null = rMAC - 6;
84201e52:	01 f0 b1 e7 	if NE jump (m) Lc_ahm_process_function_122;

84201e56 <Lc_ahm_process_function_57>:
    {
        p_nominal = p_ext_data->p_nominal_gain;
84201e56:	51 d8       	rMAC = M[FP + 40];
84201e58:	19 f0 23 88 	r7 = M[rMAC + 140];
        if (p_ext_data->ramp_status == AHM_RAMP_DOWN)
84201e5c:	11 f0 ce 90 	rMAC = MBS[rMAC + 718];
84201e60:	48 24       	Null = rMAC - 1;
84201e62:	01 f0 bf e4 	if NE jump (m) Lc_ahm_process_function_99;

84201e66 <Lc_ahm_process_function_58>:
        {

            L4_DBG_MSG1("OPID: %x, Waiting for relevant ramping down to finish in Filter Transition Mode",
                        ext_op_id);
84201e66:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84201e6a:	08 25       	Null = rMAC - 4;
84201e6c:	08 68       	if LT jump (m) Lc_ahm_process_function_60;

84201e6e <Lc_ahm_process_function_59>:
84201e6e:	55 f1 02 f0 	r0 = Null + 357566137;
84201e72:	b9 4a 
84201e74:	5b d8       	r1 = M[FP + 44];
84201e76:	ef fd f9 ff 	call (m) 0x10c2;
84201e7a:	2d e2 

84201e7c <Lc_ahm_process_function_60>:
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID])
84201e7c:	51 d8       	rMAC = M[FP + 40];
84201e7e:	10 f0 a6 88 	Null = M[rMAC + 664];
84201e82:	05 62       	if NE jump (m) Lc_ahm_process_function_62;

84201e84 <Lc_ahm_process_function_61>:
84201e84:	51 d8       	rMAC = M[FP + 40];
84201e86:	10 f0 a9 88 	Null = M[rMAC + 676];
84201e8a:	18 60       	if EQ jump (m) Lc_ahm_process_function_64;

84201e8c <Lc_ahm_process_function_62>:
            {

                p_nominal_filter = &p_nominal->ff;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                               p_nominal_filter->fine);
84201e8c:	98 f0 01 86 	r6 = MHU[r7 + 2];
84201e90:	51 d8       	rMAC = M[FP + 40];
84201e92:	16 f0 b4 20 	r4 = rMAC + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201e96:	42 d8       	r0 = M[FP + 32];
84201e98:	ef fd f5 ff 	call (m) 0x8ea;
84201e9c:	33 e2 
84201e9e:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
84201ea0:	73 f0 94 20 	r1 = r5 + 148;
84201ea4:	44 08       	r2 = r6 + Null;
84201ea6:	32 00       	r0 = r4 + Null;
84201ea8:	03 f0 2d e5 	call (m) $_ahm_process_delta_ramp;
84201eac:	10 04       	Null = r0 - Null;
84201eae:	06 60       	if EQ jump (m) Lc_ahm_process_function_64;

84201eb0 <Lc_ahm_process_function_63>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84201eb0:	73 f0 94 20 	r1 = r5 + 148;
84201eb4:	42 d8       	r0 = M[FP + 32];
84201eb6:	fa ff 2f ed 	call (m) Lc_ahm_send_event_message_1;

84201eba <Lc_ahm_process_function_64>:
                p_nominal_filter = &p_nominal->ff;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                               p_nominal_filter->fine);
            }
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID])
84201eba:	51 d8       	rMAC = M[FP + 40];
84201ebc:	10 f0 a7 88 	Null = M[rMAC + 668];
84201ec0:	05 62       	if NE jump (m) Lc_ahm_process_function_66;

84201ec2 <Lc_ahm_process_function_65>:
84201ec2:	51 d8       	rMAC = M[FP + 40];
84201ec4:	10 f0 aa 88 	Null = M[rMAC + 680];
84201ec8:	1a 60       	if EQ jump (m) Lc_ahm_process_function_68;

84201eca <Lc_ahm_process_function_66>:
            {
                p_nominal_filter = &p_nominal->fb ;
84201eca:	91 f0 04 20 	rMAC = r7 + 4;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                               p_nominal_filter->fine);
84201ece:	18 f0 01 86 	r6 = MHU[rMAC + 2];
84201ed2:	51 d8       	rMAC = M[FP + 40];
84201ed4:	16 f0 d4 20 	r4 = rMAC + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201ed8:	42 d8       	r0 = M[FP + 32];
84201eda:	ef fd f5 ff 	call (m) 0x8ea;
84201ede:	31 e0 
84201ee0:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
84201ee2:	73 f0 94 20 	r1 = r5 + 148;
84201ee6:	44 08       	r2 = r6 + Null;
84201ee8:	32 00       	r0 = r4 + Null;
84201eea:	03 f0 2b e3 	call (m) $_ahm_process_delta_ramp;
84201eee:	10 04       	Null = r0 - Null;
84201ef0:	06 60       	if EQ jump (m) Lc_ahm_process_function_68;

84201ef2 <Lc_ahm_process_function_67>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84201ef2:	73 f0 94 20 	r1 = r5 + 148;
84201ef6:	42 d8       	r0 = M[FP + 32];
84201ef8:	fa ff 2d eb 	call (m) Lc_ahm_send_event_message_1;

84201efc <Lc_ahm_process_function_68>:
                p_nominal_filter = &p_nominal->fb ;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                               p_nominal_filter->fine);
            }
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID])
84201efc:	51 d8       	rMAC = M[FP + 40];
84201efe:	10 f0 a8 88 	Null = M[rMAC + 672];
84201f02:	05 62       	if NE jump (m) Lc_ahm_process_function_70;

84201f04 <Lc_ahm_process_function_69>:
84201f04:	51 d8       	rMAC = M[FP + 40];
84201f06:	10 f0 ab 88 	Null = M[rMAC + 684];
84201f0a:	1a 60       	if EQ jump (m) Lc_ahm_process_function_72;

84201f0c <Lc_ahm_process_function_70>:
            {
                p_nominal_filter = &p_nominal->ec ;
84201f0c:	91 f0 08 20 	rMAC = r7 + 8;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                p_nominal_filter->fine);
84201f10:	18 f0 01 86 	r6 = MHU[rMAC + 2];
84201f14:	51 d8       	rMAC = M[FP + 40];
84201f16:	16 f0 f4 20 	r4 = rMAC + 244;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201f1a:	42 d8       	r0 = M[FP + 32];
84201f1c:	ef fd f4 ff 	call (m) 0x8ea;
84201f20:	2f ee 
84201f22:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
84201f24:	73 f0 94 20 	r1 = r5 + 148;
84201f28:	44 08       	r2 = r6 + Null;
84201f2a:	32 00       	r0 = r4 + Null;
84201f2c:	03 f0 29 e1 	call (m) $_ahm_process_delta_ramp;
84201f30:	10 04       	Null = r0 - Null;
84201f32:	06 60       	if EQ jump (m) Lc_ahm_process_function_72;

84201f34 <Lc_ahm_process_function_71>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84201f34:	73 f0 94 20 	r1 = r5 + 148;
84201f38:	42 d8       	r0 = M[FP + 32];
84201f3a:	fa ff 2b e9 	call (m) Lc_ahm_send_event_message_1;

84201f3e <Lc_ahm_process_function_72>:
                                                p_nominal_filter->fine);
            }
            /* wait for ramping down to complete */
            if ( (p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID]).state == AHM_RAMP_IDLE &&
                 (p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID]).state == AHM_RAMP_IDLE &&
                 (p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID]).state == AHM_RAMP_IDLE )
84201f3e:	51 d8       	rMAC = M[FP + 40];
84201f40:	11 f0 c0 80 	rMAC = MBS[rMAC + 192];
84201f44:	08 25       	Null = rMAC - 4;
84201f46:	01 f0 bd e5 	if NE jump (m) Lc_ahm_process_function_122;

84201f4a <Lc_ahm_process_function_73>:
84201f4a:	51 d8       	rMAC = M[FP + 40];
84201f4c:	11 f0 e0 80 	rMAC = MBS[rMAC + 224];
84201f50:	08 25       	Null = rMAC - 4;
84201f52:	01 f0 b1 e5 	if NE jump (m) Lc_ahm_process_function_122;

84201f56 <Lc_ahm_process_function_74>:
84201f56:	51 d8       	rMAC = M[FP + 40];
84201f58:	11 f0 00 81 	rMAC = MBS[rMAC + 256];
84201f5c:	08 25       	Null = rMAC - 4;
84201f5e:	01 f0 a5 e5 	if NE jump (m) Lc_ahm_process_function_122;

84201f62 <Lc_ahm_process_function_75>:
            {
                #ifndef RUNNING_ON_KALSIM
                    if(p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID])
84201f62:	51 d8       	rMAC = M[FP + 40];
84201f64:	10 f0 a6 88 	Null = M[rMAC + 664];
84201f68:	09 62       	if NE jump (m) Lc_ahm_process_function_78;

84201f6a <Lc_ahm_process_function_76>:
84201f6a:	51 d8       	rMAC = M[FP + 40];
84201f6c:	10 f0 a7 88 	Null = M[rMAC + 668];
84201f70:	05 62       	if NE jump (m) Lc_ahm_process_function_78;

84201f72 <Lc_ahm_process_function_77>:
84201f72:	51 d8       	rMAC = M[FP + 40];
84201f74:	10 f0 a8 88 	Null = M[rMAC + 672];
84201f78:	09 60       	if EQ jump (m) Lc_ahm_process_function_79;

84201f7a <Lc_ahm_process_function_78>:
                    {
                       /* Apply the ANC HW Foreground filters to the background now */
                       DEBUG_AHM("OPID: %x, Ramp down complete. Copy foreground filter to background filter for both ANC instances",
                                 ext_op_id);
                       stream_anc_update_background_iir_coeffs(STREAM_ANC_INSTANCE_ANC0_MASK);
84201f7a:	42 20       	r0 = Null + 1;
84201f7c:	ff fd 56 f0 	call (m) 0xcce8;
84201f80:	2d eb 
                       stream_anc_update_background_iir_coeffs(STREAM_ANC_INSTANCE_ANC1_MASK);
84201f82:	82 20       	r0 = Null + 2;
84201f84:	ff fd 56 f0 	call (m) 0xcce8;
84201f88:	25 eb 

84201f8a <Lc_ahm_process_function_79>:
                    }
                #endif

                reinit_nominal_gain(p_ext_data);
84201f8a:	52 d8       	r0 = M[FP + 40];
84201f8c:	fa ff 3b e0 	call (m) Lc_reinit_nominal_gain_1;
                update_coarse_gain(p_cur_gain, p_stat_gain);
84201f90:	73 d8       	r1 = M[FP + 56];
84201f92:	6a d8       	r0 = M[FP + 52];
84201f94:	f9 ff 3d ef 	call (m) Lc_update_coarse_gain_1;
                if(p_ext_data->config.channel == AHM_ANC_INSTANCE_DUAL_ID)
84201f98:	51 d8       	rMAC = M[FP + 40];
84201f9a:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
84201f9e:	08 25       	Null = rMAC - 4;
84201fa0:	07 62       	if NE jump (m) Lc_ahm_process_function_81;

84201fa2 <Lc_ahm_process_function_80>:
                {
                    update_coarse_gain(p_cur_gain1, p_ext_data->p_static_gain1);
84201fa2:	51 d8       	rMAC = M[FP + 40];
84201fa4:	13 f0 22 88 	r1 = M[rMAC + 136];
84201fa8:	82 d8       	r0 = M[FP + 64];
84201faa:	f9 ff 27 ef 	call (m) Lc_update_coarse_gain_1;

84201fae <Lc_ahm_process_function_81>:
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84201fae:	42 d8       	r0 = M[FP + 32];
84201fb0:	ef fd f4 ff 	call (m) 0x934;
84201fb4:	25 ec 
}

inline void aud_cur_set_reinit(OPERATOR_DATA *op_data, bool state)
{
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->re_init_flag = state;
84201fb6:	41 20       	rMAC = Null + 1;
84201fb8:	11 ea       	MB[r0 + Null] = rMAC;
                }
                aud_cur_set_reinit(op_data, TRUE);
                configure_ramp_up(cfg,p_ext_data);
84201fba:	02 17       	r0 = FP + 112;
84201fbc:	53 d8       	r1 = M[FP + 40];
84201fbe:	fa ff 2d e9 	call (m) Lc_configure_ramp_up_1;

                if ( p_ext_data->trigger_mode == AHM_TRIGGER_DIFFERENT)
84201fc2:	51 d8       	rMAC = M[FP + 40];
84201fc4:	11 f0 cd 90 	rMAC = MBS[rMAC + 717];
84201fc8:	c8 24       	Null = rMAC - 3;
84201fca:	09 62       	if NE jump (m) Lc_ahm_process_function_84;

84201fcc <Lc_ahm_process_function_82>:
                {
                    configure_ramp_slow_delay_duration(cfg,p_ext_data);
84201fcc:	02 17       	r0 = FP + 112;
84201fce:	53 d8       	r1 = M[FP + 40];
84201fd0:	fa ff 29 ec 	call (m) Lc_configure_ramp_slow_delay_duration_1;
84201fd4:	0a 6e       	jump (m) Lc_ahm_process_function_86;

84201fd6 <Lc_ahm_process_function_83>:
                p_cur_filter1->fine = p_nominal_filter1->fine;
                p_fine_gain1->using_nominal = TRUE;
            }
            else
            {
                p_fine_gain1->using_nominal = FALSE;
84201fd6:	08 ab       	MB[rMAC + 20] = Null;
84201fd8:	ff ff ad eb 	jump (m) Lc_ahm_process_function_46;

84201fdc <Lc_ahm_process_function_84>:

                if ( p_ext_data->trigger_mode == AHM_TRIGGER_DIFFERENT)
                {
                    configure_ramp_slow_delay_duration(cfg,p_ext_data);
                }
                else if (p_ext_data->trigger_mode == AHM_TRIGGER_SIMILAR)
84201fdc:	88 24       	Null = rMAC - 2;
84201fde:	05 62       	if NE jump (m) Lc_ahm_process_function_86;

84201fe0 <Lc_ahm_process_function_85>:
                {
                    configure_ramp_fast_delay_duration(cfg,p_ext_data);
84201fe0:	02 17       	r0 = FP + 112;
84201fe2:	53 d8       	r1 = M[FP + 40];
84201fe4:	fa ff 27 ec 	call (m) Lc_configure_ramp_fast_delay_duration_1;

84201fe8 <Lc_ahm_process_function_86>:
                }

                if (p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID])
84201fe8:	51 d8       	rMAC = M[FP + 40];
84201fea:	10 f0 a6 88 	Null = M[rMAC + 664];
84201fee:	05 62       	if NE jump (m) Lc_ahm_process_function_88;

84201ff0 <Lc_ahm_process_function_87>:
84201ff0:	51 d8       	rMAC = M[FP + 40];
84201ff2:	10 f0 a9 88 	Null = M[rMAC + 676];
84201ff6:	16 60       	if EQ jump (m) Lc_ahm_process_function_90;

84201ff8 <Lc_ahm_process_function_88>:
                {
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                   &cfg[AHM_ANC_FILTER_FF_ID]);
84201ff8:	51 d8       	rMAC = M[FP + 40];
84201ffa:	16 f0 b4 20 	r4 = rMAC + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84201ffe:	42 d8       	r0 = M[FP + 32];
84202000:	ef fd f4 ff 	call (m) 0x8ea;
84202004:	2b e7 
84202006:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84202008:	74 f0 94 20 	r2 = r5 + 148;
8420200c:	03 17       	r1 = FP + 112;
8420200e:	32 00       	r0 = r4 + Null;
84202010:	02 f0 3d e1 	call (m) $_ahm_initialize_delta_ramp;
84202014:	10 04       	Null = r0 - Null;
84202016:	06 60       	if EQ jump (m) Lc_ahm_process_function_90;

84202018 <Lc_ahm_process_function_89>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84202018:	73 f0 94 20 	r1 = r5 + 148;
8420201c:	42 d8       	r0 = M[FP + 32];
8420201e:	fa ff 27 e2 	call (m) Lc_ahm_send_event_message_1;

84202022 <Lc_ahm_process_function_90>:
                {
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                                   &cfg[AHM_ANC_FILTER_FF_ID]);
                }
                if (p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID])
84202022:	51 d8       	rMAC = M[FP + 40];
84202024:	10 f0 a7 88 	Null = M[rMAC + 668];
84202028:	05 62       	if NE jump (m) Lc_ahm_process_function_92;

8420202a <Lc_ahm_process_function_91>:
8420202a:	51 d8       	rMAC = M[FP + 40];
8420202c:	10 f0 aa 88 	Null = M[rMAC + 680];
84202030:	16 60       	if EQ jump (m) Lc_ahm_process_function_94;

84202032 <Lc_ahm_process_function_92>:
                {
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                   &cfg[AHM_ANC_FILTER_FB_ID]);
84202032:	51 d8       	rMAC = M[FP + 40];
84202034:	16 f0 d4 20 	r4 = rMAC + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84202038:	42 d8       	r0 = M[FP + 32];
8420203a:	ef fd f4 ff 	call (m) 0x8ea;
8420203e:	31 e5 
84202040:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
84202042:	74 f0 94 20 	r2 = r5 + 148;
84202046:	43 18       	r1 = FP + 132;
84202048:	32 00       	r0 = r4 + Null;
8420204a:	02 f0 23 e0 	call (m) $_ahm_initialize_delta_ramp;
8420204e:	10 04       	Null = r0 - Null;
84202050:	06 60       	if EQ jump (m) Lc_ahm_process_function_94;

84202052 <Lc_ahm_process_function_93>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
84202052:	73 f0 94 20 	r1 = r5 + 148;
84202056:	42 d8       	r0 = M[FP + 32];
84202058:	fa ff 2d e0 	call (m) Lc_ahm_send_event_message_1;

8420205c <Lc_ahm_process_function_94>:
                {
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID],
                                                   &cfg[AHM_ANC_FILTER_FB_ID]);
                }
                if (p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID])
8420205c:	51 d8       	rMAC = M[FP + 40];
8420205e:	10 f0 a8 88 	Null = M[rMAC + 672];
84202062:	05 62       	if NE jump (m) Lc_ahm_process_function_96;

84202064 <Lc_ahm_process_function_95>:
84202064:	51 d8       	rMAC = M[FP + 40];
84202066:	10 f0 ab 88 	Null = M[rMAC + 684];
8420206a:	16 60       	if EQ jump (m) Lc_ahm_process_function_98;

8420206c <Lc_ahm_process_function_96>:
                {
                    ahm_init_delta_ramp_and_notify(op_data,
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                   &cfg[AHM_ANC_FILTER_EC_ID]);
8420206c:	51 d8       	rMAC = M[FP + 40];
8420206e:	16 f0 f4 20 	r4 = rMAC + 244;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84202072:	42 d8       	r0 = M[FP + 32];
84202074:	ef fd f4 ff 	call (m) 0x8ea;
84202078:	37 e3 
8420207a:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  AHM_RAMP_CONFIG *p_cfg)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_initialize_delta_ramp(p_ramp, p_cfg, &p_ext_data->event_msg))
8420207c:	74 f0 94 20 	r2 = r5 + 148;
84202080:	83 19       	r1 = FP + 152;
84202082:	32 00       	r0 = r4 + Null;
84202084:	01 f0 29 ee 	call (m) $_ahm_initialize_delta_ramp;
84202088:	10 04       	Null = r0 - Null;
8420208a:	06 60       	if EQ jump (m) Lc_ahm_process_function_98;

8420208c <Lc_ahm_process_function_97>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420208c:	73 f0 94 20 	r1 = r5 + 148;
84202090:	42 d8       	r0 = M[FP + 32];
84202092:	f9 ff 33 ee 	call (m) Lc_ahm_send_event_message_1;

84202096 <Lc_ahm_process_function_98>:
                                                   &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                                   &cfg[AHM_ANC_FILTER_EC_ID]);
                }
                DEBUG_AHM("OPID: %x, Relevant ramps are initialized for ramp up in Filter Transiton Mode",
                          ext_op_id);
                p_ext_data->ramp_status = AHM_RAMP_UP;
84202096:	81 20       	rMAC = Null + 2;
84202098:	52 d8       	r0 = M[FP + 40];
8420209a:	21 f0 ce 9a 	MB[r0 + 718] = rMAC;
8420209e:	b2 6e       	jump (m) Lc_ahm_process_function_122;

842020a0 <Lc_ahm_process_function_99>:
            }
        }
        else if (p_ext_data->ramp_status == AHM_RAMP_UP)
842020a0:	88 24       	Null = rMAC - 2;
842020a2:	b0 62       	if NE jump (m) Lc_ahm_process_function_122;

842020a4 <Lc_ahm_process_function_100>:
        {
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID])
842020a4:	51 d8       	rMAC = M[FP + 40];
842020a6:	10 f0 a6 88 	Null = M[rMAC + 664];
842020aa:	05 62       	if NE jump (m) Lc_ahm_process_function_102;

842020ac <Lc_ahm_process_function_101>:
842020ac:	51 d8       	rMAC = M[FP + 40];
842020ae:	10 f0 a9 88 	Null = M[rMAC + 676];
842020b2:	18 60       	if EQ jump (m) Lc_ahm_process_function_104;

842020b4 <Lc_ahm_process_function_102>:
            {
                p_nominal_filter = &p_nominal->ff;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                               p_nominal_filter->fine);
842020b4:	98 f0 01 86 	r6 = MHU[r7 + 2];
842020b8:	51 d8       	rMAC = M[FP + 40];
842020ba:	16 f0 b4 20 	r4 = rMAC + 180;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
842020be:	42 d8       	r0 = M[FP + 32];
842020c0:	ef fd f4 ff 	call (m) 0x8ea;
842020c4:	2b e1 
842020c6:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
842020c8:	73 f0 94 20 	r1 = r5 + 148;
842020cc:	44 08       	r2 = r6 + Null;
842020ce:	32 00       	r0 = r4 + Null;
842020d0:	02 f0 25 e4 	call (m) $_ahm_process_delta_ramp;
842020d4:	10 04       	Null = r0 - Null;
842020d6:	06 60       	if EQ jump (m) Lc_ahm_process_function_104;

842020d8 <Lc_ahm_process_function_103>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
842020d8:	73 f0 94 20 	r1 = r5 + 148;
842020dc:	42 d8       	r0 = M[FP + 32];
842020de:	f9 ff 27 ec 	call (m) Lc_ahm_send_event_message_1;

842020e2 <Lc_ahm_process_function_104>:
                p_nominal_filter = &p_nominal->ff;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID],
                                               p_nominal_filter->fine);
            }
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID])
842020e2:	51 d8       	rMAC = M[FP + 40];
842020e4:	10 f0 a7 88 	Null = M[rMAC + 668];
842020e8:	05 62       	if NE jump (m) Lc_ahm_process_function_106;

842020ea <Lc_ahm_process_function_105>:
842020ea:	51 d8       	rMAC = M[FP + 40];
842020ec:	10 f0 aa 88 	Null = M[rMAC + 680];
842020f0:	1a 60       	if EQ jump (m) Lc_ahm_process_function_108;

842020f2 <Lc_ahm_process_function_106>:
            {
                p_nominal_filter = &p_nominal->fb ;
842020f2:	91 f0 04 20 	rMAC = r7 + 4;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID] ,
                                               p_nominal_filter->fine);
842020f6:	18 f0 01 86 	r6 = MHU[rMAC + 2];
842020fa:	51 d8       	rMAC = M[FP + 40];
842020fc:	16 f0 d4 20 	r4 = rMAC + 212;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84202100:	42 d8       	r0 = M[FP + 32];
84202102:	ef fd f3 ff 	call (m) 0x8ea;
84202106:	29 ef 
84202108:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
8420210a:	73 f0 94 20 	r1 = r5 + 148;
8420210e:	44 08       	r2 = r6 + Null;
84202110:	32 00       	r0 = r4 + Null;
84202112:	02 f0 23 e2 	call (m) $_ahm_process_delta_ramp;
84202116:	10 04       	Null = r0 - Null;
84202118:	06 60       	if EQ jump (m) Lc_ahm_process_function_108;

8420211a <Lc_ahm_process_function_107>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420211a:	73 f0 94 20 	r1 = r5 + 148;
8420211e:	42 d8       	r0 = M[FP + 32];
84202120:	f9 ff 25 ea 	call (m) Lc_ahm_send_event_message_1;

84202124 <Lc_ahm_process_function_108>:
                p_nominal_filter = &p_nominal->fb ;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID] ,
                                               p_nominal_filter->fine);
            }
            if (p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] || p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID])
84202124:	51 d8       	rMAC = M[FP + 40];
84202126:	10 f0 a8 88 	Null = M[rMAC + 672];
8420212a:	05 62       	if NE jump (m) Lc_ahm_process_function_110;

8420212c <Lc_ahm_process_function_109>:
8420212c:	51 d8       	rMAC = M[FP + 40];
8420212e:	10 f0 ab 88 	Null = M[rMAC + 684];
84202132:	1a 60       	if EQ jump (m) Lc_ahm_process_function_112;

84202134 <Lc_ahm_process_function_110>:
            {
                p_nominal_filter = &p_nominal->ec ;
84202134:	91 f0 08 20 	rMAC = r7 + 8;
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                               p_nominal_filter->fine);
84202138:	18 f0 01 86 	r6 = MHU[rMAC + 2];
8420213c:	51 d8       	rMAC = M[FP + 40];
8420213e:	16 f0 f4 20 	r4 = rMAC + 244;
 *
 * \return  Pointer to extra operator data AHM_OP_DATA.
 */
static inline AHM_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AHM_OP_DATA *) base_op_get_instance_data(op_data);
84202142:	42 d8       	r0 = M[FP + 32];
84202144:	ef fd f3 ff 	call (m) 0x8ea;
84202148:	27 ed 
8420214a:	17 00       	r5 = r0 + Null;
                                                  AHM_DELTA_RAMP *p_ramp,
                                                  uint16 nominal_gain)
{
    AHM_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (ahm_process_delta_ramp(p_ramp, &p_ext_data->event_msg, nominal_gain))
8420214c:	73 f0 94 20 	r1 = r5 + 148;
84202150:	44 08       	r2 = r6 + Null;
84202152:	32 00       	r0 = r4 + Null;
84202154:	02 f0 21 e0 	call (m) $_ahm_process_delta_ramp;
84202158:	10 04       	Null = r0 - Null;
8420215a:	06 60       	if EQ jump (m) Lc_ahm_process_function_112;

8420215c <Lc_ahm_process_function_111>:
    {
        ahm_send_event_message(op_data, &p_ext_data->event_msg);
8420215c:	73 f0 94 20 	r1 = r5 + 148;
84202160:	42 d8       	r0 = M[FP + 32];
84202162:	f9 ff 23 e8 	call (m) Lc_ahm_send_event_message_1;

84202166 <Lc_ahm_process_function_112>:
                ahm_proc_delta_ramp_and_notify(op_data,
                                               &p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID],
                                               p_nominal_filter->fine);
            }
            L4_DBG_MSG1("OPID: %x, All relevant ramps processing for ramp up started in Filter Switch Mode",
                        ext_op_id);
84202166:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420216a:	08 25       	Null = rMAC - 4;
8420216c:	08 68       	if LT jump (m) Lc_ahm_process_function_114;

8420216e <Lc_ahm_process_function_113>:
8420216e:	55 f1 02 f0 	r0 = Null + 357566217;
84202172:	09 4b 
84202174:	5b d8       	r1 = M[FP + 44];
84202176:	ef fd f7 ff 	call (m) 0x10c2;
8420217a:	2d ea 

8420217c <Lc_ahm_process_function_114>:
            if ( (p_ext_data->fine_ramp[AHM_ANC_FILTER_FF_ID]).state == AHM_RAMP_IDLE &&
                             (p_ext_data->fine_ramp[AHM_ANC_FILTER_FB_ID]).state == AHM_RAMP_IDLE &&
                             (p_ext_data->fine_ramp[AHM_ANC_FILTER_EC_ID]).state == AHM_RAMP_IDLE )
8420217c:	51 d8       	rMAC = M[FP + 40];
8420217e:	11 f0 c0 80 	rMAC = MBS[rMAC + 192];
84202182:	08 25       	Null = rMAC - 4;
84202184:	3f 62       	if NE jump (m) Lc_ahm_process_function_122;

84202186 <Lc_ahm_process_function_115>:
84202186:	51 d8       	rMAC = M[FP + 40];
84202188:	11 f0 e0 80 	rMAC = MBS[rMAC + 224];
8420218c:	08 25       	Null = rMAC - 4;
8420218e:	3a 62       	if NE jump (m) Lc_ahm_process_function_122;

84202190 <Lc_ahm_process_function_116>:
84202190:	51 d8       	rMAC = M[FP + 40];
84202192:	11 f0 00 81 	rMAC = MBS[rMAC + 256];
84202196:	08 25       	Null = rMAC - 4;
84202198:	35 62       	if NE jump (m) Lc_ahm_process_function_122;

8420219a <Lc_ahm_process_function_117>:
            {
                DEBUG_AHM("OPID: %x, All Relevant Ramps for Ramp up Complete in Filter Switch Mode",
                          ext_op_id);
                /* Reset ramp required and coarse gain change flag */
                p_ext_data->ramp_required[AHM_ANC_FILTER_FF_ID] = FALSE;
8420219a:	51 d8       	rMAC = M[FP + 40];
8420219c:	10 f0 a6 8e 	M[rMAC + 664] = Null;
                p_ext_data->ramp_required[AHM_ANC_FILTER_FB_ID] = FALSE;
842021a0:	10 f0 a7 8e 	M[rMAC + 668] = Null;
                p_ext_data->ramp_required[AHM_ANC_FILTER_EC_ID] = FALSE;
842021a4:	10 f0 a8 8e 	M[rMAC + 672] = Null;
                p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FF_ID] = FALSE;
842021a8:	10 f0 a9 8e 	M[rMAC + 676] = Null;
                p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_FB_ID] = FALSE;
842021ac:	10 f0 aa 8e 	M[rMAC + 680] = Null;
                p_ext_data->coarse_gain_changed[AHM_ANC_FILTER_EC_ID] = FALSE;
842021b0:	10 f0 ab 8e 	M[rMAC + 684] = Null;

                msg.id =AHM_EVENT_ID_FILTER_TRANSITION;
842021b4:	81 21       	rMAC = Null + 6;
842021b6:	e1 f0 56 8c 	MH[FP + 172] = rMAC;
                msg.type = AHM_EVENT_TYPE_CLEAR;
842021ba:	41 20       	rMAC = Null + 1;
842021bc:	e1 f0 57 8c 	MH[FP + 174] = rMAC;
                msg.payload = 0;
842021c0:	60 df       	M[FP + 176] = Null;
                msg.ext_op_id = ext_op_id;
842021c2:	59 d8       	rMAC = M[FP + 44];
842021c4:	69 df       	M[FP + 180] = rMAC;
                ahm_send_event_message(op_data, &msg);
842021c6:	c3 1a       	r1 = FP + 172;
842021c8:	42 d8       	r0 = M[FP + 32];
842021ca:	f9 ff 3b e4 	call (m) Lc_ahm_send_event_message_1;
                p_ext_data->ramp_status = AHM_RAMP_INIT;
842021ce:	51 d8       	rMAC = M[FP + 40];
842021d0:	10 f0 ce 9a 	MB[rMAC + 718] = Null;
842021d4:	17 6e       	jump (m) Lc_ahm_process_function_122;

842021d6 <Lc_ahm_process_function_118>:
    }
    else
    {
        uint16 anc0_enable;
        uint16 anc1_enable;
        uint16 *anc_selected = &anc0_enable;
842021d6:	86 16       	r4 = FP + 104;

        stream_get_anc_enable(&anc0_enable, &anc1_enable);
842021d8:	c3 16       	r1 = FP + 108;
842021da:	82 16       	r0 = FP + 104;
842021dc:	ff fd 55 f0 	call (m) 0xcdd6;
842021e0:	3b ef 

        if (p_ext_data->config.channel == AHM_ANC_INSTANCE_ANC1_ID)
842021e2:	51 d8       	rMAC = M[FP + 40];
842021e4:	11 f0 a8 80 	rMAC = MBS[rMAC + 168];
842021e8:	88 24       	Null = rMAC - 2;
842021ea:	02 62       	if NE jump (m) Lc_ahm_process_function_120;

842021ec <Lc_ahm_process_function_119>:
        {
            anc_selected = &anc1_enable;
842021ec:	c6 16       	r4 = FP + 108;

842021ee <Lc_ahm_process_function_120>:
        }

        if (*anc_selected == p_ext_data->anc_clock_check_value)
842021ee:	31 e6       	rMAC = MHU[r4 + Null];
842021f0:	52 d8       	r0 = M[FP + 40];
842021f2:	22 f0 56 86 	r0 = MHU[r0 + 172];
842021f6:	88 04       	Null = rMAC - r0;
842021f8:	f0 ff df e2 	if EQ jump (m) Lc_ahm_process_function_5;

842021fc <Lc_ahm_process_function_121>:
        {
            p_ext_data->clock_status = TRUE;
        }
        else
        {
            p_ext_data->clock_status = FALSE;
842021fc:	51 d8       	rMAC = M[FP + 40];
842021fe:	10 f0 ae 8a 	MB[rMAC + 174] = Null;

84202202 <Lc_ahm_process_function_122>:
                ahm_send_event_message(op_data, &msg);
                p_ext_data->ramp_status = AHM_RAMP_INIT;
            }
        }
    }
}
84202202:	b4 f3 10 cf 	SP = SP + -152;
84202206:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202208:	d8 4c       	rts;

8420220a <$_ahm_write_gain>:
8420220a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
 *
 */
bool ahm_write_gain(AHM_ANC_CONFIG *p_config,
                    AHM_GAIN_BANK *p_gains,
                    AHM_GAIN_BANK *p_prev_gains)
{
8420220c:	12 09       	r8 = r0 + Null;
8420220e:	1e 00       	r4 = r1 + Null;
84202210:	27 00       	r5 = r2 + Null;
    AHM_ANC_PATH anc_path;
    AHM_ANC_INSTANCE anc_channel = p_config->channel;
84202212:	a9 f0 00 e0 	r7 = MBS[r8 + Null];

    /* Only update EC and FB gains if in hybrid mode */
    if (p_config->fb_path != AHM_ANC_PATH_NONE_ID)
84202216:	a1 f0 02 80 	rMAC = MBS[r8 + 2];
8420221a:	5d 60       	if EQ jump (m) Lc_ahm_write_gain_18;

8420221c <Lc_ahm_write_gain_2>:
    {
        /* Update EC gain */
        if (p_gains->ec.fine != p_prev_gains->ec.fine)
8420221c:	73 87       	r1 = MHU[r4 + 10];
8420221e:	79 87       	rMAC = MHU[r5 + 10];
84202220:	58 04       	Null = r1 - rMAC;
84202222:	13 60       	if EQ jump (m) Lc_ahm_write_gain_6;

84202224 <Lc_ahm_write_gain_3>:
        {
            L5_DBG_MSG1("EC Fine: %d", p_gains->ec.fine);
84202224:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202228:	48 25       	Null = rMAC - 5;
8420222a:	07 68       	if LT jump (m) Lc_ahm_write_gain_5;

8420222c <Lc_ahm_write_gain_4>:
8420222c:	55 f1 02 f0 	r0 = Null + 357566299;
84202230:	5b 4b 
84202232:	ef fd f7 ff 	call (m) 0x10c2;
84202236:	31 e4 

84202238 <Lc_ahm_write_gain_5>:
            ahm_write_gain_value(p_gains->ec.fine,
                                 AHM_ANC_PATH_FB_ID,
                                 anc_channel,
                                 stream_anc_set_anc_foreground_fine_gain);
84202238:	65 f0 ff 59 	r3 = Null + 52735;
8420223c:	c3 20       	r1 = Null + 3;
8420223e:	72 87       	r0 = MHU[r4 + 10];
84202240:	4c 08       	r2 = r7 + Null;
84202242:	f2 4e       	call (m) Lc_ahm_write_gain_value_1;
            p_prev_gains->ec.fine = p_gains->ec.fine;
84202244:	71 87       	rMAC = MHU[r4 + 10];
84202246:	79 8d       	MH[r5 + 10] = rMAC;

84202248 <Lc_ahm_write_gain_6>:
        }
        if (p_gains->ec.coarse != p_prev_gains->ec.coarse)
84202248:	33 85       	r1 = MHS[r4 + 8];
8420224a:	39 85       	rMAC = MHS[r5 + 8];
8420224c:	58 04       	Null = r1 - rMAC;
8420224e:	14 60       	if EQ jump (m) Lc_ahm_write_gain_10;

84202250 <Lc_ahm_write_gain_7>:
        {
           L5_DBG_MSG1("EC Coarse: %d", p_gains->ec.coarse);
84202250:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202254:	48 25       	Null = rMAC - 5;
84202256:	07 68       	if LT jump (m) Lc_ahm_write_gain_9;

84202258 <Lc_ahm_write_gain_8>:
84202258:	55 f1 02 f0 	r0 = Null + 357566311;
8420225c:	67 4b 
8420225e:	ef fd f7 ff 	call (m) 0x10c2;
84202262:	25 e3 

84202264 <Lc_ahm_write_gain_9>:
           ahm_write_gain_value((uint16)p_gains->ec.coarse,
                                 AHM_ANC_PATH_FB_ID,
                                 anc_channel,
                                 stream_anc_set_anc_coarse_gain);
84202264:	65 f0 09 5a 	r3 = Null + 52745;
84202268:	c3 20       	r1 = Null + 3;
8420226a:	31 85       	rMAC = MHS[r4 + 8];
8420226c:	8a c6       	r0 = rMAC AND 0xffff;
8420226e:	4c 08       	r2 = r7 + Null;
84202270:	db 4e       	call (m) Lc_ahm_write_gain_value_1;
            p_prev_gains->ec.coarse = p_gains->ec.coarse;
84202272:	31 85       	rMAC = MHS[r4 + 8];
84202274:	39 8d       	MH[r5 + 8] = rMAC;

84202276 <Lc_ahm_write_gain_10>:
        }

        /* Update FB gain */
        anc_path = p_config->fb_path;
84202276:	a8 f0 02 80 	r6 = MBS[r8 + 2];
        if (p_gains->fb.fine != p_prev_gains->fb.fine)
8420227a:	f3 86       	r1 = MHU[r4 + 6];
8420227c:	f9 86       	rMAC = MHU[r5 + 6];
8420227e:	58 04       	Null = r1 - rMAC;
84202280:	13 60       	if EQ jump (m) Lc_ahm_write_gain_14;

84202282 <Lc_ahm_write_gain_11>:
        {
            L5_DBG_MSG1("FB Fine: %d", p_gains->fb.fine);
84202282:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202286:	48 25       	Null = rMAC - 5;
84202288:	07 68       	if LT jump (m) Lc_ahm_write_gain_13;

8420228a <Lc_ahm_write_gain_12>:
8420228a:	55 f1 02 f0 	r0 = Null + 357566325;
8420228e:	75 4b 
84202290:	ef fd f7 ff 	call (m) 0x10c2;
84202294:	33 e1 

84202296 <Lc_ahm_write_gain_13>:
            ahm_write_gain_value(p_gains->fb.fine,
                                 anc_path,
                                 anc_channel,
                                 stream_anc_set_anc_foreground_fine_gain);
84202296:	65 f0 ff 59 	r3 = Null + 52735;
8420229a:	f2 86       	r0 = MHU[r4 + 6];
8420229c:	4c 08       	r2 = r7 + Null;
8420229e:	43 08       	r1 = r6 + Null;
842022a0:	c3 4e       	call (m) Lc_ahm_write_gain_value_1;
            p_prev_gains->fb.fine = p_gains->fb.fine;
842022a2:	f1 86       	rMAC = MHU[r4 + 6];
842022a4:	f9 8c       	MH[r5 + 6] = rMAC;

842022a6 <Lc_ahm_write_gain_14>:
        }
        if (p_gains->fb.coarse != p_prev_gains->fb.coarse)
842022a6:	b3 84       	r1 = MHS[r4 + 4];
842022a8:	b9 84       	rMAC = MHS[r5 + 4];
842022aa:	58 04       	Null = r1 - rMAC;
842022ac:	14 60       	if EQ jump (m) Lc_ahm_write_gain_18;

842022ae <Lc_ahm_write_gain_15>:
        {
            L5_DBG_MSG1("FB Coarse: %d", p_gains->fb.coarse);
842022ae:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842022b2:	48 25       	Null = rMAC - 5;
842022b4:	07 68       	if LT jump (m) Lc_ahm_write_gain_17;

842022b6 <Lc_ahm_write_gain_16>:
842022b6:	55 f1 02 f0 	r0 = Null + 357566337;
842022ba:	81 4b 
842022bc:	ef fd f7 ff 	call (m) 0x10c2;
842022c0:	27 e0 

842022c2 <Lc_ahm_write_gain_17>:
            ahm_write_gain_value(p_gains->fb.coarse,
                                 anc_path,
                                 anc_channel,
                                 stream_anc_set_anc_coarse_gain);
842022c2:	65 f0 09 5a 	r3 = Null + 52745;
842022c6:	b1 84       	rMAC = MHS[r4 + 4];
842022c8:	4c 08       	r2 = r7 + Null;
842022ca:	8a c6       	r0 = rMAC AND 0xffff;
842022cc:	43 08       	r1 = r6 + Null;
842022ce:	ac 4e       	call (m) Lc_ahm_write_gain_value_1;
            p_prev_gains->fb.coarse = p_gains->fb.coarse;
842022d0:	b1 84       	rMAC = MHS[r4 + 4];
842022d2:	b9 8c       	MH[r5 + 4] = rMAC;

842022d4 <Lc_ahm_write_gain_18>:
        }
    }

    /* Update FF gain */
    anc_path = p_config->ff_path;
842022d4:	a8 f0 01 80 	r6 = MBS[r8 + 1];
    if (p_gains->ff.fine != p_prev_gains->ff.fine)
842022d8:	73 86       	r1 = MHU[r4 + 2];
842022da:	79 86       	rMAC = MHU[r5 + 2];
842022dc:	58 04       	Null = r1 - rMAC;
842022de:	13 60       	if EQ jump (m) Lc_ahm_write_gain_22;

842022e0 <Lc_ahm_write_gain_19>:
    {
        L5_DBG_MSG1("FF Fine: %d", p_gains->ff.fine);
842022e0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842022e4:	48 25       	Null = rMAC - 5;
842022e6:	07 68       	if LT jump (m) Lc_ahm_write_gain_21;

842022e8 <Lc_ahm_write_gain_20>:
842022e8:	55 f1 02 f0 	r0 = Null + 357566351;
842022ec:	8f 4b 
842022ee:	ef fd f6 ff 	call (m) 0x10c2;
842022f2:	35 ee 

842022f4 <Lc_ahm_write_gain_21>:
        ahm_write_gain_value(p_gains->ff.fine,
                             anc_path,
                             anc_channel,
                             stream_anc_set_anc_foreground_fine_gain);
842022f4:	65 f0 ff 59 	r3 = Null + 52735;
842022f8:	72 86       	r0 = MHU[r4 + 2];
842022fa:	4c 08       	r2 = r7 + Null;
842022fc:	43 08       	r1 = r6 + Null;
842022fe:	94 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->ff.fine = p_gains->ff.fine;
84202300:	71 86       	rMAC = MHU[r4 + 2];
84202302:	79 8c       	MH[r5 + 2] = rMAC;

84202304 <Lc_ahm_write_gain_22>:
    }
    if (p_gains->ff.coarse != p_prev_gains->ff.coarse)
84202304:	33 e4       	r1 = MHS[r4 + Null];
84202306:	39 e4       	rMAC = MHS[r5 + Null];
84202308:	58 04       	Null = r1 - rMAC;
8420230a:	14 60       	if EQ jump (m) Lc_ahm_write_gain_26;

8420230c <Lc_ahm_write_gain_23>:
    {
       L5_DBG_MSG1("FF Coarse: %d", p_gains->ff.coarse);
8420230c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202310:	48 25       	Null = rMAC - 5;
84202312:	07 68       	if LT jump (m) Lc_ahm_write_gain_25;

84202314 <Lc_ahm_write_gain_24>:
84202314:	55 f1 02 f0 	r0 = Null + 357566363;
84202318:	9b 4b 
8420231a:	ef fd f6 ff 	call (m) 0x10c2;
8420231e:	29 ed 

84202320 <Lc_ahm_write_gain_25>:
       ahm_write_gain_value(p_gains->ff.coarse,
                             anc_path,
                             anc_channel,
                             stream_anc_set_anc_coarse_gain);
84202320:	65 f0 09 5a 	r3 = Null + 52745;
84202324:	31 e4       	rMAC = MHS[r4 + Null];
84202326:	4c 08       	r2 = r7 + Null;
84202328:	8a c6       	r0 = rMAC AND 0xffff;
8420232a:	43 08       	r1 = r6 + Null;
8420232c:	7d 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->ff.coarse = p_gains->ff.coarse;
8420232e:	31 e4       	rMAC = MHS[r4 + Null];
84202330:	39 ec       	MH[r5 + Null] = rMAC;

84202332 <Lc_ahm_write_gain_26>:
    }

    if (p_gains->rx_ffa_mix.fine != p_prev_gains->rx_ffa_mix.fine)
84202332:	f3 87       	r1 = MHU[r4 + 14];
84202334:	f9 87       	rMAC = MHU[r5 + 14];
84202336:	58 04       	Null = r1 - rMAC;
84202338:	13 60       	if EQ jump (m) Lc_ahm_write_gain_30;

8420233a <Lc_ahm_write_gain_27>:
    {
        L5_DBG_MSG1("FB RxMix Fine: %d", p_gains->rx_ffa_mix.fine);
8420233a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420233e:	48 25       	Null = rMAC - 5;
84202340:	07 68       	if LT jump (m) Lc_ahm_write_gain_29;

84202342 <Lc_ahm_write_gain_28>:
84202342:	55 f1 02 f0 	r0 = Null + 357566377;
84202346:	a9 4b 
84202348:	ef fd f6 ff 	call (m) 0x10c2;
8420234c:	3b eb 

8420234e <Lc_ahm_write_gain_29>:
        ahm_write_gain_value(p_gains->rx_ffa_mix.fine,
                             AHM_ANC_PATH_FFA_ID,
                             anc_channel,
                             stream_anc_set_anc_rx_mix_foreground_fine_gain);
8420234e:	65 f0 13 5a 	r3 = Null + 52755;
84202352:	43 20       	r1 = Null + 1;
84202354:	f2 87       	r0 = MHU[r4 + 14];
84202356:	4c 08       	r2 = r7 + Null;
84202358:	67 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->rx_ffa_mix.fine = p_gains->rx_ffa_mix.fine;
8420235a:	f1 87       	rMAC = MHU[r4 + 14];
8420235c:	f9 8d       	MH[r5 + 14] = rMAC;

8420235e <Lc_ahm_write_gain_30>:
    }
    if (p_gains->rx_ffa_mix.coarse != p_prev_gains->rx_ffa_mix.coarse)
8420235e:	b3 85       	r1 = MHS[r4 + 12];
84202360:	b9 85       	rMAC = MHS[r5 + 12];
84202362:	58 04       	Null = r1 - rMAC;
84202364:	14 60       	if EQ jump (m) Lc_ahm_write_gain_34;

84202366 <Lc_ahm_write_gain_31>:
    {
        L5_DBG_MSG1("FB RxMix Coarse: %d", p_gains->rx_ffa_mix.coarse);
84202366:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420236a:	48 25       	Null = rMAC - 5;
8420236c:	07 68       	if LT jump (m) Lc_ahm_write_gain_33;

8420236e <Lc_ahm_write_gain_32>:
8420236e:	55 f1 02 f0 	r0 = Null + 357566395;
84202372:	bb 4b 
84202374:	ef fd f6 ff 	call (m) 0x10c2;
84202378:	2f ea 

8420237a <Lc_ahm_write_gain_33>:
        ahm_write_gain_value(p_gains->rx_ffa_mix.coarse,
                             AHM_ANC_PATH_FFA_ID,
                             anc_channel,
                             stream_anc_set_anc_rx_mix_coarse_gain);
8420237a:	65 f0 47 5a 	r3 = Null + 52807;
8420237e:	43 20       	r1 = Null + 1;
84202380:	b1 85       	rMAC = MHS[r4 + 12];
84202382:	8a c6       	r0 = rMAC AND 0xffff;
84202384:	4c 08       	r2 = r7 + Null;
84202386:	50 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->rx_ffa_mix.coarse = p_gains->rx_ffa_mix.coarse;
84202388:	b1 85       	rMAC = MHS[r4 + 12];
8420238a:	b9 8d       	MH[r5 + 12] = rMAC;

8420238c <Lc_ahm_write_gain_34>:
    }
    if (p_gains->rx_ffb_mix.fine != p_prev_gains->rx_ffb_mix.fine)
8420238c:	73 96       	r1 = MHU[r4 + 18];
8420238e:	79 96       	rMAC = MHU[r5 + 18];
84202390:	58 04       	Null = r1 - rMAC;
84202392:	13 60       	if EQ jump (m) Lc_ahm_write_gain_38;

84202394 <Lc_ahm_write_gain_35>:
    {
        L5_DBG_MSG1("FF RxMix Fine: %d", p_gains->rx_ffb_mix.fine);
84202394:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202398:	48 25       	Null = rMAC - 5;
8420239a:	07 68       	if LT jump (m) Lc_ahm_write_gain_37;

8420239c <Lc_ahm_write_gain_36>:
8420239c:	55 f1 02 f0 	r0 = Null + 357566415;
842023a0:	cf 4b 
842023a2:	ef fd f6 ff 	call (m) 0x10c2;
842023a6:	21 e9 

842023a8 <Lc_ahm_write_gain_37>:
        ahm_write_gain_value(p_gains->rx_ffb_mix.fine,
                             AHM_ANC_PATH_FFB_ID,
                             anc_channel,
                             stream_anc_set_anc_rx_mix_foreground_fine_gain);
842023a8:	65 f0 13 5a 	r3 = Null + 52755;
842023ac:	83 20       	r1 = Null + 2;
842023ae:	72 96       	r0 = MHU[r4 + 18];
842023b0:	4c 08       	r2 = r7 + Null;
842023b2:	3a 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->rx_ffb_mix.fine = p_gains->rx_ffb_mix.fine;
842023b4:	71 96       	rMAC = MHU[r4 + 18];
842023b6:	79 9c       	MH[r5 + 18] = rMAC;

842023b8 <Lc_ahm_write_gain_38>:
    }
    if (p_gains->rx_ffb_mix.coarse != p_prev_gains->rx_ffb_mix.coarse)
842023b8:	33 94       	r1 = MHS[r4 + 16];
842023ba:	39 94       	rMAC = MHS[r5 + 16];
842023bc:	58 04       	Null = r1 - rMAC;
842023be:	14 60       	if EQ jump (m) Lc_ahm_write_gain_42;

842023c0 <Lc_ahm_write_gain_39>:
    {
       L5_DBG_MSG1("FF RxMix Coarse: %d", p_gains->rx_ffb_mix.coarse);
842023c0:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842023c4:	48 25       	Null = rMAC - 5;
842023c6:	07 68       	if LT jump (m) Lc_ahm_write_gain_41;

842023c8 <Lc_ahm_write_gain_40>:
842023c8:	55 f1 02 f0 	r0 = Null + 357566433;
842023cc:	e1 4b 
842023ce:	ef fd f6 ff 	call (m) 0x10c2;
842023d2:	35 e7 

842023d4 <Lc_ahm_write_gain_41>:
       ahm_write_gain_value(p_gains->rx_ffb_mix.coarse,
                             AHM_ANC_PATH_FFB_ID,
                             anc_channel,
                             stream_anc_set_anc_rx_mix_coarse_gain);
842023d4:	65 f0 47 5a 	r3 = Null + 52807;
842023d8:	83 20       	r1 = Null + 2;
842023da:	31 94       	rMAC = MHS[r4 + 16];
842023dc:	8a c6       	r0 = rMAC AND 0xffff;
842023de:	4c 08       	r2 = r7 + Null;
842023e0:	23 4e       	call (m) Lc_ahm_write_gain_value_1;
        p_prev_gains->rx_ffb_mix.coarse = p_gains->rx_ffb_mix.coarse;
842023e2:	31 94       	rMAC = MHS[r4 + 16];
842023e4:	39 9c       	MH[r5 + 16] = rMAC;

842023e6 <Lc_ahm_write_gain_42>:
    }
    return TRUE;
842023e6:	42 20       	r0 = Null + 1;

842023e8 <Lc_ahm_write_gain_43>:
}
842023e8:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842023ea:	d8 4c       	rts;

842023ec <$_ahm_initialize_prev_gain>:
#endif /* RUNNING_ON_KALSIM */

void ahm_initialize_prev_gain(AHM_GAIN_BANK *p_prev_gains)
{
    p_prev_gains->ff.fine = AHM_INVALID_FINE_GAIN;
842023ec:	71 f0 ff 7b 	rMAC = Null + 65535;
842023f0:	51 8c       	MH[r0 + 2] = rMAC;
    p_prev_gains->ff.coarse = AHM_INVALID_COARSE_GAIN;
842023f2:	03 f0 00 60 	r1 = Null + 4096;
842023f6:	13 ec       	MH[r0 + Null] = r1;
    p_prev_gains->fb.fine = AHM_INVALID_FINE_GAIN;
842023f8:	d1 8c       	MH[r0 + 6] = rMAC;
    p_prev_gains->fb.coarse = AHM_INVALID_COARSE_GAIN;
842023fa:	93 8c       	MH[r0 + 4] = r1;
    p_prev_gains->ec.fine = AHM_INVALID_FINE_GAIN;
842023fc:	51 8d       	MH[r0 + 10] = rMAC;
    p_prev_gains->ec.coarse = AHM_INVALID_COARSE_GAIN;
842023fe:	13 8d       	MH[r0 + 8] = r1;
    p_prev_gains->rx_ffa_mix.fine = AHM_INVALID_FINE_GAIN;
84202400:	d1 8d       	MH[r0 + 14] = rMAC;
    p_prev_gains->rx_ffa_mix.coarse = AHM_INVALID_COARSE_GAIN;
84202402:	93 8d       	MH[r0 + 12] = r1;
    p_prev_gains->rx_ffb_mix.fine = AHM_INVALID_FINE_GAIN;
84202404:	51 9c       	MH[r0 + 18] = rMAC;
    p_prev_gains->rx_ffb_mix.coarse = AHM_INVALID_COARSE_GAIN;
84202406:	13 9c       	MH[r0 + 16] = r1;

84202408 <Lc_ahm_initialize_prev_gain_2>:

    return;
84202408:	d8 4c       	rts;

8420240a <$_ahm_get_gain_difference_db>:

int ahm_get_gain_difference_db(uint16 fine_gain1,
                               int16 coarse_gain1,
                               uint16 fine_gain2,
                               int16 coarse_gain2)
{
8420240a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420240c:	26 00       	r4 = r2 + Null;
8420240e:	2f 00       	r5 = r3 + Null;
    int gain1_db;
    int gain2_db;
    int gain_diff_db;

    gain1_db = ahm_calc_gain_db(fine_gain1, coarse_gain1);
84202410:	08 f0 2f ee 	call (m) $_ahm_calc_gain_db;
84202414:	10 09       	r6 = r0 + Null;
    gain2_db = ahm_calc_gain_db(fine_gain2, coarse_gain2);
84202416:	3b 00       	r1 = r5 + Null;
84202418:	32 00       	r0 = r4 + Null;
8420241a:	08 f0 25 ee 	call (m) $_ahm_calc_gain_db;
    gain_diff_db = gain1_db - gain2_db;
8420241e:	2f f8 02 c2 	r0 = r6 - r0;

84202422 <Lc_ahm_get_gain_difference_db_2>:

    return gain_diff_db;
84202422:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202424:	d8 4c       	rts;

84202426 <Lc_ahm_write_gain_value_1>:
 */
static void ahm_write_gain_value(uint16 gain,
                                 AHM_ANC_PATH path,
                                 AHM_ANC_INSTANCE channel,
                                 AHM_ANC_GAIN_FN fn)
{
84202426:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84202428:	17 00       	r5 = r0 + Null;
8420242a:	18 09       	r6 = r1 + Null;
8420242c:	2e 00       	r4 = r3 + Null;
8420242e:	22 00       	r0 = r2 + Null;
    if (channel == AHM_ANC_INSTANCE_BOTH_ID)
84202430:	d0 24       	Null = r0 - 3;
84202432:	09 62       	if NE jump (m) Lc_ahm_write_gain_value_3;

84202434 <Lc_ahm_write_gain_value_2>:
    {
        fn(AHM_ANC_INSTANCE_ANC0_ID, path, gain);
84202434:	42 20       	r0 = Null + 1;
84202436:	3c 00       	r2 = r5 + Null;
84202438:	d6 4c       	call r4;
        fn(AHM_ANC_INSTANCE_ANC1_ID, path, gain);
8420243a:	82 20       	r0 = Null + 2;
8420243c:	3c 00       	r2 = r5 + Null;
8420243e:	43 08       	r1 = r6 + Null;
84202440:	d6 4c       	call r4;
84202442:	03 6e       	jump (m) Lc_ahm_write_gain_value_4;

84202444 <Lc_ahm_write_gain_value_3>:
    }
    else
    {
        fn(channel, path, gain);
84202444:	3c 00       	r2 = r5 + Null;
84202446:	d6 4c       	call r4;

84202448 <Lc_ahm_write_gain_value_4>:
    }
}
84202448:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420244a:	d8 4c       	rts;

8420244c <$_ahm_initialize_delta_ramp>:
8420244c:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
}

bool ahm_initialize_delta_ramp(AHM_DELTA_RAMP *p_ramp,
                               AHM_RAMP_CONFIG *p_cfg,
                               AHM_EVENT_MSG *p_msg)
{
8420244e:	16 00       	r4 = r0 + Null;
84202450:	1f 00       	r5 = r1 + Null;
84202452:	22 09       	r8 = r2 + Null;
    int delay_duration;
    uint16 *p_gain;
    uint16 current_gain;
    unsigned nominal_gain, full_gain;

    bool send_message = FALSE;
84202454:	40 de       	M[FP + 32] = Null;

    /* Initialize the gain delta to 0 to set to a known state before
     * reinitializing the ramp.
     */
    p_ramp->p_gain->gain_delta = 0;
84202456:	31 89       	rMAC = M[r4 + 16];
84202458:	08 ee       	M[rMAC + Null] = Null;

    p_gain = p_ramp->p_cur;
8420245a:	6b f0 06 88 	r9 = M[r4 + 24];

    current_gain = *p_gain;
8420245e:	b9 f0 00 e6 	r7 = MHU[r9 + Null];
    nominal_gain = (unsigned)p_cfg->nominal_gain;
84202462:	79 86       	rMAC = MHU[r5 + 2];
84202464:	08 09       	r6 = rMAC + Null;

    /* initialize old normal gain to current nominal gain */
    p_ramp->prev_nominal_gain = p_cfg->nominal_gain;
84202466:	f1 9d       	MH[r4 + 30] = rMAC;


    if (current_gain == 0)
84202468:	0f f9 00 c2 	Null = r7 - Null;
8420246c:	04 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_3;

8420246e <Lc_ahm_initialize_delta_ramp_2>:
    {
        p_ramp->p_gain->gain_current = 0;
8420246e:	31 89       	rMAC = M[r4 + 16];
84202470:	08 8f       	M[rMAC + 16] = Null;
84202472:	09 6e       	jump (m) Lc_ahm_initialize_delta_ramp_4;

84202474 <Lc_ahm_initialize_delta_ramp_3>:
    }
    else
    {
        full_gain = (current_gain << AHM_DIV_PRECISION) / nominal_gain;
84202474:	0c f9 d2 c8 	r0 = r7 LSHIFT 24;
84202478:	43 08       	r1 = r6 + Null;
8420247a:	ff fd be f0 	call (m) 0x1a136;
8420247e:	3d e5 
        p_ramp->p_gain->gain_current = full_gain;
84202480:	31 89       	rMAC = M[r4 + 16];
84202482:	0a 8f       	M[rMAC + 16] = r0;

84202484 <Lc_ahm_initialize_delta_ramp_4>:
    }

    if (p_cfg->target == 0)
84202484:	3a e6       	r0 = MHU[r5 + Null];
84202486:	03 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_6;

84202488 <Lc_ahm_initialize_delta_ramp_5>:
    {
        p_ramp->target = 0;
84202488:	70 8f       	M[r4 + 20] = Null;
8420248a:	0f 6e       	jump (m) Lc_ahm_initialize_delta_ramp_9;

8420248c <Lc_ahm_initialize_delta_ramp_6>:
    }
    else if (p_cfg->target == nominal_gain)
8420248c:	8f f2 00 c2 	Null = r0 - r6;
84202490:	06 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_8;

84202492 <Lc_ahm_initialize_delta_ramp_7>:
    {
        p_ramp->target = AHM_NOMINAL_TARGET;
84202492:	10 f0 01 f0 	rMAC = Null + 16781312;
84202496:	00 60 
84202498:	71 8f       	M[r4 + 20] = rMAC;
8420249a:	07 6e       	jump (m) Lc_ahm_initialize_delta_ramp_9;

8420249c <Lc_ahm_initialize_delta_ramp_8>:
    }
    else
    {
        full_gain = (p_cfg->target << AHM_DIV_PRECISION) / nominal_gain;
8420249c:	52 57       	r0 = r0 LSHIFT 24;
8420249e:	43 08       	r1 = r6 + Null;
842024a0:	ff fd be f0 	call (m) 0x1a136;
842024a4:	37 e4 
        p_ramp->target =  full_gain;
842024a6:	72 8f       	M[r4 + 20] = r0;

842024a8 <Lc_ahm_initialize_delta_ramp_9>:
    }

    p_ramp->tc = ahm_calc_ramp_tc(p_cfg->duration, p_cfg->fast_rate);
842024a8:	3b 89       	r1 = M[r5 + 16];
842024aa:	ba 88       	r0 = M[r5 + 8];
842024ac:	08 f0 2f e6 	call (m) $_ahm_calc_ramp_tc;
842024b0:	b2 8e       	M[r4 + 8] = r0;
    p_ramp->p_gain->tc_attack = p_ramp->tc;
842024b2:	b1 88       	rMAC = M[r4 + 8];
842024b4:	32 89       	r0 = M[r4 + 16];
842024b6:	51 8e       	M[r0 + 4] = rMAC;
    p_ramp->p_gain->tc_release = p_ramp->tc;
842024b8:	b1 88       	rMAC = M[r4 + 8];
842024ba:	32 89       	r0 = M[r4 + 16];
842024bc:	91 8e       	M[r0 + 8] = rMAC;

    /* If the timer and delay are both 0 then immediately set the gain value
     * to the target value.
     */
    if (p_cfg->duration == 0 && p_cfg->delay == 0)
842024be:	b8 88       	Null = M[r5 + 8];
842024c0:	1b 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_15;

842024c2 <Lc_ahm_initialize_delta_ramp_10>:
842024c2:	78 88       	Null = M[r5 + 4];
842024c4:	19 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_15;

842024c6 <Lc_ahm_initialize_delta_ramp_11>:
    {
        /* Update current gain */
        *p_gain = (uint16)p_cfg->target;
842024c6:	39 e6       	rMAC = MHU[r5 + Null];
842024c8:	b1 f0 00 ec 	MH[r9 + Null] = rMAC;
        /* Update ramp gain */
        p_ramp->p_gain->gain = (uint8)p_cfg->target;
842024cc:	39 e6       	rMAC = MHU[r5 + Null];
842024ce:	32 89       	r0 = M[r4 + 16];
842024d0:	11 9b       	MB[r0 + 12] = rMAC;

842024d2 <Lc_ahm_initialize_delta_ramp_12>:
        if (p_ramp->target == AHM_NOMINAL_TARGET)
842024d2:	71 89       	rMAC = M[r4 + 20];
842024d4:	00 f4 10 f1 	Null = rMAC - 16781312;
842024d8:	00 24 
842024da:	05 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_14;

842024dc <Lc_ahm_initialize_delta_ramp_13>:
        {
            p_ramp->target = AHM_DELTA_NOMINAL;
842024dc:	10 f0 01 f0 	rMAC = Null + 16777216;
842024e0:	00 40 
842024e2:	71 8f       	M[r4 + 20] = rMAC;

842024e4 <Lc_ahm_initialize_delta_ramp_14>:
        }
        p_ramp->p_gain->gain_delta = p_ramp->target;
842024e4:	71 89       	rMAC = M[r4 + 20];
842024e6:	32 89       	r0 = M[r4 + 16];
842024e8:	11 ee       	M[r0 + Null] = rMAC;
        p_ramp->p_gain->gain_current = p_ramp->target;
842024ea:	71 89       	rMAC = M[r4 + 20];
842024ec:	32 89       	r0 = M[r4 + 16];
842024ee:	11 8f       	M[r0 + 16] = rMAC;
        p_ramp->state = AHM_RAMP_FINISHED;
842024f0:	c1 20       	rMAC = Null + 3;
842024f2:	31 9b       	MB[r4 + 12] = rMAC;
842024f4:	2d 6e       	jump (m) Lc_ahm_initialize_delta_ramp_21;

842024f6 <Lc_ahm_initialize_delta_ramp_15>:
        return send_message;
    }

    if (p_cfg->target == current_gain)
842024f6:	39 e6       	rMAC = MHU[r5 + Null];
842024f8:	9f f1 00 c2 	Null = rMAC - r7;
842024fc:	eb 61       	if EQ jump (m) Lc_ahm_initialize_delta_ramp_12;

842024fe <Lc_ahm_initialize_delta_ramp_16>:
    }

    /* Calculate the ramp delay in process calls. The process is called at the
     * base kick period.
     */
    delay_duration = (p_cfg->delay * p_cfg->slow_rate) + AHM_DELAY_ROUNDING;
842024fe:	f9 88       	rMAC = M[r5 + 12];
84202500:	7a 88       	r0 = M[r5 + 4];
84202502:	89 1a       	rMAC = rMAC * r0 (int);
84202504:	20 f0 12 f0 	r0 = rMAC + 524288;
84202508:	00 20 
    delay_duration = delay_duration >> AHM_DELAY_PRECISION;
8420250a:	d2 5a       	r0 = r0 ASHIFT -20;
    p_ramp->delay = delay_duration;
8420250c:	32 ee       	M[r4 + Null] = r0;
    p_ramp->counter = delay_duration;

    if (delay_duration == 0)
8420250e:	72 8e       	M[r4 + 4] = r0;
84202510:	10 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_18;

84202512 <Lc_ahm_initialize_delta_ramp_17>:
    {
        p_ramp->p_gain->gain_delta = p_ramp->target;
84202512:	71 89       	rMAC = M[r4 + 20];
84202514:	32 89       	r0 = M[r4 + 16];
84202516:	11 ee       	M[r0 + Null] = rMAC;
        p_ramp->state = AHM_RAMP_RUNNING;
84202518:	81 20       	rMAC = Null + 2;
8420251a:	31 9b       	MB[r4 + 12] = rMAC;
        p_msg->id = p_ramp->path;
8420251c:	b1 97       	rMAC = MHU[r4 + 28];
8420251e:	a1 f0 00 ec 	MH[r8 + Null] = rMAC;
        p_msg->type = AHM_EVENT_TYPE_TRIGGER;
84202522:	a0 f0 01 8c 	MH[r8 + 2] = Null;
        p_msg->payload = 0;
84202526:	a0 f0 01 8e 	M[r8 + 4] = Null;
        send_message = TRUE;
8420252a:	41 20       	rMAC = Null + 1;
8420252c:	41 de       	M[FP + 32] = rMAC;
8420252e:	10 6e       	jump (m) Lc_ahm_initialize_delta_ramp_21;

84202530 <Lc_ahm_initialize_delta_ramp_18>:
    }
    else
    {
        p_ramp->state = AHM_RAMP_WAITING;
84202530:	41 20       	rMAC = Null + 1;
84202532:	31 9b       	MB[r4 + 12] = rMAC;
        /* Don't calculate a gain delta on this path until it's ready */
         if (p_ramp->p_gain->gain_delta == AHM_DELTA_NOMINAL)
84202534:	31 89       	rMAC = M[r4 + 16];
84202536:	0a e8       	r0 = M[rMAC + Null];
84202538:	00 f4 20 f0 	Null = r0 - 16777216;
8420253c:	00 24 
8420253e:	06 62       	if NE jump (m) Lc_ahm_initialize_delta_ramp_20;

84202540 <Lc_ahm_initialize_delta_ramp_19>:
        {
            p_ramp->p_gain->gain_delta = AHM_NOMINAL_TARGET;
84202540:	10 f0 02 f0 	r0 = Null + 16781312;
84202544:	00 60 
84202546:	0a ee       	M[rMAC + Null] = r0;
84202548:	03 6e       	jump (m) Lc_ahm_initialize_delta_ramp_21;

8420254a <Lc_ahm_initialize_delta_ramp_20>:
        }
        else
        {
            p_ramp->p_gain->gain_delta = p_ramp->p_gain->gain_current;
8420254a:	0a 89       	r0 = M[rMAC + 16];
8420254c:	0a ee       	M[rMAC + Null] = r0;

8420254e <Lc_ahm_initialize_delta_ramp_21>:
            p_ramp->target = AHM_DELTA_NOMINAL;
        }
        p_ramp->p_gain->gain_delta = p_ramp->target;
        p_ramp->p_gain->gain_current = p_ramp->target;
        p_ramp->state = AHM_RAMP_FINISHED;
        return send_message;
8420254e:	42 d8       	r0 = M[FP + 32];

84202550 <Lc_ahm_initialize_delta_ramp_22>:
                     ext_op_id, p_ramp->delay, p_ramp->state);
                     p_ramp->p_gain->gain_delta);
       }
    #endif
    return send_message;
}
84202550:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202552:	d8 4c       	rts;

84202554 <$_ahm_process_delta_ramp>:

bool ahm_process_delta_ramp(AHM_DELTA_RAMP *p_ramp,
                            AHM_EVENT_MSG *p_msg, uint16 nominal_gain)
{
84202554:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84202556:	16 00       	r4 = r0 + Null;
84202558:	27 00       	r5 = r2 + Null;
    int *p_delta, cur_gain;
    
    unsigned full_gain, normal_gain ;
    int denormalize_gain;

    bool send_message = FALSE;
8420255a:	00 09       	r6 = Null + Null;


    switch (p_ramp->state)
8420255c:	31 91       	rMAC = MBS[r4 + 12];
8420255e:	11 60       	if EQ jump (m) Lc_ahm_process_delta_ramp_7;

84202560 <Lc_ahm_process_delta_ramp_2>:
84202560:	48 24       	Null = rMAC - 1;
84202562:	11 60       	if EQ jump (m) Lc_ahm_process_delta_ramp_8;

84202564 <Lc_ahm_process_delta_ramp_3>:
84202564:	88 24       	Null = rMAC - 2;
84202566:	1f 60       	if EQ jump (m) Lc_ahm_process_delta_ramp_10;

84202568 <Lc_ahm_process_delta_ramp_4>:
84202568:	c8 24       	Null = rMAC - 3;
8420256a:	09 62       	if NE jump (m) Lc_ahm_process_delta_ramp_6;

8420256c <Lc_ahm_process_delta_ramp_5>:


            }
            break;
        case AHM_RAMP_FINISHED:
            p_msg->id = p_ramp->path;
8420256c:	b1 97       	rMAC = MHU[r4 + 28];
8420256e:	19 ec       	MH[r1 + Null] = rMAC;
            p_msg->type = AHM_EVENT_TYPE_CLEAR;
84202570:	41 20       	rMAC = Null + 1;
84202572:	59 8c       	MH[r1 + 2] = rMAC;
            p_msg->payload = 0;
84202574:	58 8e       	M[r1 + 4] = Null;
            send_message = TRUE;
84202576:	08 09       	r6 = rMAC + Null;
            p_ramp->state = AHM_RAMP_IDLE;
84202578:	01 21       	rMAC = Null + 4;
8420257a:	31 9b       	MB[r4 + 12] = rMAC;

8420257c <Lc_ahm_process_delta_ramp_6>:
            break;
        default: /* Also covers AHM_RAMP_IDLE */
            break;
    }

    return send_message;
8420257c:	42 08       	r0 = r6 + Null;
8420257e:	43 6e       	jump (m) Lc_ahm_process_delta_ramp_15;

84202580 <Lc_ahm_process_delta_ramp_7>:


    switch (p_ramp->state)
    {
        case AHM_RAMP_INITIALIZED:
            p_ramp->state = AHM_RAMP_WAITING;
84202580:	41 20       	rMAC = Null + 1;
84202582:	31 9b       	MB[r4 + 12] = rMAC;

84202584 <Lc_ahm_process_delta_ramp_8>:
        case AHM_RAMP_WAITING:
            p_ramp->counter -= 1;
84202584:	71 88       	rMAC = M[r4 + 4];
84202586:	49 24       	rMAC = rMAC - 1;
84202588:	71 8e       	M[r4 + 4] = rMAC;
            if (p_ramp->counter <= 0)
8420258a:	08 24       	Null = rMAC - 0;
8420258c:	f8 6b       	if GT jump (m) Lc_ahm_process_delta_ramp_6;

8420258e <Lc_ahm_process_delta_ramp_9>:
            {
                p_ramp->p_gain->gain_delta = p_ramp->target;
8420258e:	71 89       	rMAC = M[r4 + 20];
84202590:	32 89       	r0 = M[r4 + 16];
84202592:	11 ee       	M[r0 + Null] = rMAC;
                p_ramp->state = AHM_RAMP_RUNNING;
84202594:	81 20       	rMAC = Null + 2;
84202596:	31 9b       	MB[r4 + 12] = rMAC;
                p_msg->id = p_ramp->path;
84202598:	b1 97       	rMAC = MHU[r4 + 28];
8420259a:	19 ec       	MH[r1 + Null] = rMAC;
                p_msg->type = AHM_EVENT_TYPE_TRIGGER;
8420259c:	58 8c       	MH[r1 + 2] = Null;
                p_msg->payload = 0;
8420259e:	58 8e       	M[r1 + 4] = Null;
                send_message = TRUE;
842025a0:	08 71       	r6 = Null + 1;
842025a2:	ed 6f       	jump (m) Lc_ahm_process_delta_ramp_6;

842025a4 <Lc_ahm_process_delta_ramp_10>:
            }
            break;
        case AHM_RAMP_RUNNING:

            if (p_ramp->prev_nominal_gain != nominal_gain)
842025a4:	f1 97       	rMAC = MHU[r4 + 30];
842025a6:	c8 05       	Null = rMAC - r5;
842025a8:	14 60       	if EQ jump (m) Lc_ahm_process_delta_ramp_12;

842025aa <Lc_ahm_process_delta_ramp_11>:
                               old_nominal_gain =0x%08X,\
                               new_nominal_gain=0x%08X", p_msg->ext_op_id, time_get_time(),
                               p_ramp->path, p_ramp->prev_nominal_gain,
                               nominal_gain);
                #endif
                denormalize_gain = ((p_ramp->p_gain->gain_current >> AHM_DELTA_GAIN_SHIFT)*(p_ramp->prev_nominal_gain));
842025aa:	32 89       	r0 = M[r4 + 16];
842025ac:	29 f0 10 20 	r7 = r0 + 16;
842025b0:	92 f0 00 e8 	r0 = M[r7 + Null];
842025b4:	d2 59       	r0 = r0 ASHIFT -8;
842025b6:	52 1a       	r0 = r0 * rMAC (int);
                denormalize_gain += AHM_DELTA_ROUNDING;
842025b8:	42 f0 00 44 	r0 = r0 + 32768;
                denormalize_gain = (uint16)(denormalize_gain >> AHM_DELTA_PRECISION);
842025bc:	92 5a       	r0 = r0 ASHIFT -16;
842025be:	92 c6       	r0 = r0 AND 0xffff;
                normal_gain = (unsigned) nominal_gain;
842025c0:	3b 00       	r1 = r5 + Null;
                full_gain = (denormalize_gain << AHM_DIV_PRECISION)/normal_gain;
842025c2:	52 57       	r0 = r0 LSHIFT 24;
842025c4:	ff fd bd f0 	call (m) 0x1a136;
842025c8:	33 eb 
                p_ramp->p_gain->gain_current = full_gain;
842025ca:	92 f0 00 ee 	M[r7 + Null] = r0;
                p_ramp->prev_nominal_gain = nominal_gain;
842025ce:	f7 9d       	MH[r4 + 30] = r5;

842025d0 <Lc_ahm_process_delta_ramp_12>:

            }
            p_delta = &p_ramp->p_gain->gain_delta;
842025d0:	31 89       	rMAC = M[r4 + 16];
            cur_gain = p_ramp->p_gain->gain_current;
842025d2:	0a 89       	r0 = M[rMAC + 16];
                L2_DBG_MSG4("OPID: %x, gain_delta=0x%08X, Delta =%d path =%d",
                             p_msg->ext_op_id, p_ramp->p_gain->gain_delta,
                             pl_abs(*p_delta-cur_gain), p_ramp->path);
            }
            #endif
            if (pl_abs(*p_delta - cur_gain) < AHM_RAMP_END_THRESH)
842025d4:	2f f1 02 c3 	r0 = M[rMAC] - r0;
842025d8:	4f f2 42 ce 	r0 = ABS r0;
842025dc:	04 f0 20 f0 	Null = r0 - 65536;
842025e0:	00 24 
842025e2:	f2 ff 9b ef 	if C jump (m) Lc_ahm_process_delta_ramp_6;

842025e6 <Lc_ahm_process_delta_ramp_13>:
            {
                p_ramp->p_gain->gain_current = p_ramp->target;
842025e6:	72 89       	r0 = M[r4 + 20];
842025e8:	33 89       	r1 = M[r4 + 16];
842025ea:	1a 8f       	M[r1 + 16] = r0;
                p_ramp->state = AHM_RAMP_FINISHED;
842025ec:	c2 20       	r0 = Null + 3;
842025ee:	32 9b       	MB[r4 + 12] = r0;

                if (*p_delta == AHM_NOMINAL_TARGET)
842025f0:	0a e8       	r0 = M[rMAC + Null];
842025f2:	00 f4 20 f1 	Null = r0 - 16781312;
842025f6:	00 24 
842025f8:	c2 63       	if NE jump (m) Lc_ahm_process_delta_ramp_6;

842025fa <Lc_ahm_process_delta_ramp_14>:
                {
                    *p_delta = AHM_DELTA_NOMINAL;
842025fa:	10 f0 02 f0 	r0 = Null + 16777216;
842025fe:	00 40 
84202600:	0a ee       	M[rMAC + Null] = r0;
84202602:	bd 6f       	jump (m) Lc_ahm_process_delta_ramp_6;

84202604 <Lc_ahm_process_delta_ramp_15>:
        default: /* Also covers AHM_RAMP_IDLE */
            break;
    }

    return send_message;
}
84202604:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202606:	d8 4c       	rts;

84202608 <$_ahm_list_fine_gain_add>:
84202608:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;

/****************************************************************************
Public Function Definitions
*/
AHM_SHARED_FINE_GAIN* ahm_list_fine_gain_add(AHM_FINE_GAIN_NODE **p_head, EXT_OP_ID ext_op_id)
{
8420260a:	16 00       	r4 = r0 + Null;
8420260c:	1f 00       	r5 = r1 + Null;
    AHM_FINE_GAIN_NODE *p_node;

    /* Create the new node */
    p_node = xzppnew(AHM_FINE_GAIN_NODE, MALLOC_PREFERENCE_SHARED);
8420260e:	43 21       	r1 = Null + 5;
84202610:	02 2b       	r0 = Null + 28;
84202612:	ff fd 24 f0 	call (m) 0x6f8e;
84202616:	3d eb 
    if (p_node == NULL)
84202618:	10 04       	Null = r0 - Null;
8420261a:	0a 62       	if NE jump (m) Lc_ahm_list_fine_gain_add_3;

8420261c <Lc_ahm_list_fine_gain_add_2>:
    {
        L0_DBG_MSG1("OPID: %x, AHM failed to allocate shared gain element", ext_op_id);
8420261c:	55 f1 02 f0 	r0 = Null + 357566453;
84202620:	f5 4b 
84202622:	3b 00       	r1 = r5 + Null;
84202624:	ef fd f5 ff 	call (m) 0x10c2;
84202628:	3f e4 
        return NULL;
8420262a:	02 00       	r0 = Null + Null;
8420262c:	05 6e       	jump (m) Lc_ahm_list_fine_gain_add_4;

8420262e <Lc_ahm_list_fine_gain_add_3>:
    }

    /* Insert the node at the head of the list */
    p_node->p_next = *p_head;
8420262e:	31 e8       	rMAC = M[r4 + Null];
84202630:	11 ee       	M[r0 + Null] = rMAC;
    *p_head = p_node;
84202632:	32 ee       	M[r4 + Null] = r0;

    return &p_node->data;
84202634:	12 21       	r0 = r0 + 4;

84202636 <Lc_ahm_list_fine_gain_add_4>:
}
84202636:	f2 48       	popm <FP, r4, r5, rLink>;
84202638:	d8 4c       	rts;

8420263a <$_ahm_list_fine_gain_remove>:

void ahm_list_fine_gain_remove(AHM_FINE_GAIN_NODE **p_head,
                               AHM_SHARED_FINE_GAIN *p_gain,
                               EXT_OP_ID ext_op_id)
{
8420263a:	c8 1c       	pushm <FP(=SP), rLink>;
8420263c:	21 00       	rMAC = r2 + Null;
    AHM_FINE_GAIN_NODE *p_node, *p_prev_node;

    /* Validate the pointers */
    if (*p_head == NULL || p_gain == NULL)
8420263e:	14 e8       	r2 = M[r0 + Null];
84202640:	03 60       	if EQ jump (m) Lc_ahm_list_fine_gain_remove_3;

84202642 <Lc_ahm_list_fine_gain_remove_2>:
84202642:	18 04       	Null = r1 - Null;
84202644:	0e 62       	if NE jump (m) Lc_ahm_list_fine_gain_remove_5;

84202646 <Lc_ahm_list_fine_gain_remove_3>:
    {
        L2_DBG_MSG3("OPID: %x, AHM failed to remove gain node from list, \
                    p_head = %p, p_gain = %p", ext_op_id, *p_head, p_gain);
84202646:	02 f0 34 91 	r0 = MBS[Null + 0x334];
8420264a:	90 24       	Null = r0 - 2;
8420264c:	23 68       	if LT jump (m) Lc_ahm_list_fine_gain_remove_12;

8420264e <Lc_ahm_list_fine_gain_remove_4>:
8420264e:	55 f1 02 f0 	r0 = Null + 357566506;
84202652:	2a 50 
84202654:	1d 00       	r3 = r1 + Null;
84202656:	0b 00       	r1 = rMAC + Null;
84202658:	ef fd f5 ff 	call (m) 0x10ec;
8420265c:	35 e4 
8420265e:	1a 6e       	jump (m) Lc_ahm_list_fine_gain_remove_12;

84202660 <Lc_ahm_list_fine_gain_remove_5>:

    /* Head node is special cased to ensure that the pointer is stored
     * correctly.
     */
    p_node = *p_head;
    if (&p_node->data == p_gain)
84202660:	21 21       	rMAC = r2 + 4;
84202662:	c8 04       	Null = rMAC - r1;
84202664:	08 62       	if NE jump (m) Lc_ahm_list_fine_gain_remove_7;

84202666 <Lc_ahm_list_fine_gain_remove_6>:
    {
        *p_head = p_node->p_next;
84202666:	21 e8       	rMAC = M[r2 + Null];
84202668:	11 ee       	M[r0 + Null] = rMAC;
        pdelete(p_node);
8420266a:	22 00       	r0 = r2 + Null;
8420266c:	ff fd 24 f0 	call (m) 0x6fbe;
84202670:	33 ea 
84202672:	10 6e       	jump (m) Lc_ahm_list_fine_gain_remove_12;

84202674 <Lc_ahm_list_fine_gain_remove_7>:
        return;
    }

    /* Loop through the nodes looking for the matching node */
    p_prev_node = *p_head;
84202674:	21 00       	rMAC = r2 + Null;
    for(p_node=p_prev_node->p_next; p_node; p_node=p_node->p_next)
84202676:	22 e8       	r0 = M[r2 + Null];
84202678:	03 6e       	jump (m) Lc_ahm_list_fine_gain_remove_9;

8420267a <Lc_ahm_list_fine_gain_remove_8>:
        {
            p_prev_node->p_next = p_node->p_next;
            pdelete(p_node);
            break;
        }
        p_prev_node = p_node;
8420267a:	11 00       	rMAC = r0 + Null;
        return;
    }

    /* Loop through the nodes looking for the matching node */
    p_prev_node = *p_head;
    for(p_node=p_prev_node->p_next; p_node; p_node=p_node->p_next)
8420267c:	12 e8       	r0 = M[r0 + Null];

8420267e <Lc_ahm_list_fine_gain_remove_9>:
8420267e:	10 04       	Null = r0 - Null;
84202680:	09 60       	if EQ jump (m) Lc_ahm_list_fine_gain_remove_12;

84202682 <Lc_ahm_list_fine_gain_remove_10>:
    {
        if (&p_node->data == p_gain)
84202682:	14 21       	r2 = r0 + 4;
84202684:	e0 04       	Null = r2 - r1;
84202686:	fa 63       	if NE jump (m) Lc_ahm_list_fine_gain_remove_8;

84202688 <Lc_ahm_list_fine_gain_remove_11>:
        {
            p_prev_node->p_next = p_node->p_next;
84202688:	13 e8       	r1 = M[r0 + Null];
8420268a:	0b ee       	M[rMAC + Null] = r1;
            pdelete(p_node);
8420268c:	ff fd 24 f0 	call (m) 0x6fbe;
84202690:	33 e9 

84202692 <Lc_ahm_list_fine_gain_remove_12>:
            break;
84202692:	c8 48       	popm <FP, rLink>;
84202694:	d8 4c       	rts;

84202696 <$_ahm_list_destroy>:
        p_prev_node = p_node;
    }
}

void ahm_list_destroy(AHM_FINE_GAIN_NODE **p_head)
{
84202696:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202698:	16 00       	r4 = r0 + Null;
    AHM_FINE_GAIN_NODE *p_node, *p_temp;

    p_node = *p_head;
8420269a:	32 e8       	r0 = M[r4 + Null];

8420269c <Lc_ahm_list_destroy_2>:

    while (p_node != NULL)
8420269c:	10 04       	Null = r0 - Null;
8420269e:	07 60       	if EQ jump (m) Lc_ahm_list_destroy_4;

842026a0 <Lc_ahm_list_destroy_3>:
    {
        p_temp = p_node->p_next;
842026a0:	17 e8       	r5 = M[r0 + Null];
        pdelete(p_node);
842026a2:	ff fd 24 f0 	call (m) 0x6fbe;
842026a6:	3d e8 
        p_node = p_temp;
842026a8:	3a 00       	r0 = r5 + Null;
{
    AHM_FINE_GAIN_NODE *p_node, *p_temp;

    p_node = *p_head;

    while (p_node != NULL)
842026aa:	f9 6f       	jump (m) Lc_ahm_list_destroy_2;

842026ac <Lc_ahm_list_destroy_4>:
        p_temp = p_node->p_next;
        pdelete(p_node);
        p_node = p_temp;
    }

    *p_head = NULL;
842026ac:	30 ee       	M[r4 + Null] = Null;

842026ae <Lc_ahm_list_destroy_5>:
}
842026ae:	f2 48       	popm <FP, r4, r5, rLink>;
842026b0:	d8 4c       	rts;

842026b2 <$_ahm_update_filter_coeffs>:
842026b2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;

void ahm_update_filter_coeffs(AHM_IIR_FILTER_BANK *p_prev_iir, AHM_IIR_FILTER_BANK *p_iir, bool *cfg,
                              OPMSG_AHM_FILTER_COEFFS_MSG *p_msg,
                              uint16 mode,
                              EXT_OP_ID ext_op_id)
{
842026b4:	66 f3 10 cf 	SP = SP + 204;
842026b8:	42 de       	M[FP + 32] = r0;
842026ba:	4b de       	M[FP + 36] = r1;
842026bc:	54 de       	M[FP + 40] = r2;
842026be:	5d de       	M[FP + 44] = r3;
842026c0:	f1 d9       	rMAC = M[FP + -8];
842026c2:	e8 f3 fe b7 	r6 = MHU[FP + -4];
842026c6:	61 de       	M[FP + 48] = rMAC;
    unsigned int num_coeffs_start_offset;
    unsigned msg_id;
    unsigned int i;
    unsigned int j;
    uint32 coeffs[TOTAL_NUM_COEFFS_IIR];
    uint32 coeffs_prev[TOTAL_NUM_COEFFS_IIR] = { 0 };
842026c8:	01 f0 03 f3 	r1 = Null + 1442064;
842026cc:	10 41 
842026ce:	82 1a       	r0 = FP + 168;
842026d0:	44 28       	r2 = Null + 17;
842026d2:	ff fd bc f0 	call (m) 0x1a094;
842026d6:	23 ee 
    unsigned int no_of_taps;
    no_of_taps = TOTAL_NUM_COEFFS_IIR;
    msg_id = OPMGR_GET_OPCMD_MESSAGE_MSG_ID((OPMSG_HEADER*) p_msg);
842026d8:	59 d8       	rMAC = M[FP + 44];
842026da:	8c 88       	r2 = M[rMAC + 8];
    instance = OPMSG_FIELD_GET(p_msg, OPMSG_SET_IIR_FILTER_COEFFS,ANC_INSTANCE);
842026dc:	c9 88       	rMAC = M[rMAC + 12];
842026de:	89 c6       	rMAC = rMAC AND 0xffff;
842026e0:	69 de       	M[FP + 52] = rMAC;
    path = OPMSG_FIELD_GET(p_msg, OPMSG_SET_IIR_FILTER_COEFFS, FILTER);
842026e2:	59 d8       	rMAC = M[FP + 44];
842026e4:	09 89       	rMAC = M[rMAC + 16];
842026e6:	8e c6       	r4 = rMAC AND 0xffff;
    denom_taps = OPMSG_FIELD_GET(p_msg, OPMSG_SET_IIR_FILTER_COEFFS,
                                 QUANTITY_DENOMINATOR_COEFFS);
842026e8:	59 d8       	rMAC = M[FP + 44];
842026ea:	49 89       	rMAC = M[rMAC + 20];
842026ec:	89 c6       	rMAC = rMAC AND 0xffff;
842026ee:	71 de       	M[FP + 56] = rMAC;
    numer_taps = OPMSG_FIELD_GET(p_msg, OPMSG_SET_IIR_FILTER_COEFFS,
                                 QUANTITY_NUMERATOR_COEFFS);
842026f0:	59 d8       	rMAC = M[FP + 44];
842026f2:	89 89       	rMAC = M[rMAC + 24];
842026f4:	89 c6       	rMAC = rMAC AND 0xffff;
842026f6:	79 de       	M[FP + 60] = rMAC;

    L2_DBG_MSG3("OPID: %x, AHM IIR filter coeff payload: msg_id =%d, instance =%d",
                 ext_op_id, msg_id, instance);
842026f8:	07 f0 34 43 	r5 = Null + 820;
842026fc:	39 e0       	rMAC = MBS[r5 + Null];
842026fe:	88 24       	Null = rMAC - 2;
84202700:	18 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_4;

84202702 <Lc_ahm_update_filter_coeffs_2>:
84202702:	55 f1 02 f0 	r0 = Null + 357566603;
84202706:	8b 50 
84202708:	6d d8       	r3 = M[FP + 52];
8420270a:	63 d8       	r1 = M[FP + 48];
8420270c:	ef fd f4 ff 	call (m) 0x10ec;
84202710:	21 ef 
    L2_DBG_MSG4("OPID: %x, AHM IIR filter coeff payload: path = %d, denom_taps =%d,"
                "num_taps=%d", ext_op_id, path, denom_taps, numer_taps);
84202712:	39 e0       	rMAC = MBS[r5 + Null];
84202714:	88 24       	Null = rMAC - 2;
84202716:	0d 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_4;

84202718 <Lc_ahm_update_filter_coeffs_3>:
84202718:	79 d8       	rMAC = M[FP + 60];
8420271a:	09 1c       	pushm <rMAC>;
8420271c:	55 f1 02 f0 	r0 = Null + 357566668;
84202720:	cc 50 
84202722:	34 00       	r2 = r4 + Null;
84202724:	75 d8       	r3 = M[FP + 56];
84202726:	63 d8       	r1 = M[FP + 48];
84202728:	ef fd f4 ff 	call (m) 0x1104;
8420272c:	3d ee 
8420272e:	7f 4c       	SP = SP + -4;

84202730 <Lc_ahm_update_filter_coeffs_4>:
    */
    denom_coeffs_start_offset = DENOM_COEFFS_START_OFFSET;
    /* each of the payload data is 16 bit (MSW,LSW) which is fit into 32 bit */
    /* 2 *denom_taps (2 is because each word is 16 bits) */
    /* The ANC HW assumes that coefficients are in the order [LSW, MSW] */
    num_coeffs_start_offset = denom_coeffs_start_offset + 2 * denom_taps;
84202730:	72 d8       	r0 = M[FP + 56];
84202732:	12 54       	r0 = r0 LSHIFT 1;
84202734:	11 21       	rMAC = r0 + 4;
84202736:	81 de       	M[FP + 64] = rMAC;

    if(mode == AHM_HYBRID_ENABLE)
84202738:	80 f0 0f 24 	Null = r6 - 15;
8420273c:	01 f0 af e9 	if NE jump (m) Lc_ahm_update_filter_coeffs_73;

84202740 <Lc_ahm_update_filter_coeffs_5>:
    {
        switch (path)
84202740:	70 24       	Null = r4 - 1;
84202742:	d0 60       	if EQ jump (m) Lc_ahm_update_filter_coeffs_30;

84202744 <Lc_ahm_update_filter_coeffs_6>:
84202744:	b0 24       	Null = r4 - 2;
84202746:	14 60       	if EQ jump (m) Lc_ahm_update_filter_coeffs_9;

84202748 <Lc_ahm_update_filter_coeffs_7>:
84202748:	f0 24       	Null = r4 - 3;
8420274a:	01 f0 89 e9 	if NE jump (m) Lc_ahm_update_filter_coeffs_71;

8420274e <Lc_ahm_update_filter_coeffs_8>:
                    L5_DBG_MSG1("OPID: %x, Current and previous Filters in FB path are same",
                                ext_op_id);
                }
            break;
            case AHM_ANC_PATH_FB_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
8420274e:	88 de       	M[FP + 68] = Null;
84202750:	02 09       	r8 = Null + Null;
84202752:	59 d8       	rMAC = M[FP + 44];
84202754:	eb f0 64 20 	r9 = FP + 100;
84202758:	e8 f0 a8 20 	r6 = FP + 168;
8420275c:	0f 2b       	r5 = rMAC + 28;
8420275e:	49 d8       	rMAC = M[FP + 36];
84202760:	16 f0 ac 20 	r4 = rMAC + 172;
84202764:	41 d8       	rMAC = M[FP + 32];
84202766:	19 f0 ac 20 	r7 = rMAC + 172;
8420276a:	0f f0 81 e6 	jump (m) Lc_ahm_update_filter_coeffs_51;

8420276e <Lc_ahm_update_filter_coeffs_9>:
    if(mode == AHM_HYBRID_ENABLE)
    {
        switch (path)
        {
            case AHM_ANC_PATH_FFB_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
8420276e:	90 de       	M[FP + 72] = Null;
84202770:	02 09       	r8 = Null + Null;
84202772:	59 d8       	rMAC = M[FP + 44];
84202774:	eb f0 64 20 	r9 = FP + 100;
84202778:	e8 f0 a8 20 	r6 = FP + 168;
8420277c:	0f 2b       	r5 = rMAC + 28;
8420277e:	49 d8       	rMAC = M[FP + 36];
84202780:	0e 31       	r4 = rMAC + 36;
84202782:	41 d8       	rMAC = M[FP + 32];
84202784:	19 f0 24 20 	r7 = rMAC + 36;

84202788 <Lc_ahm_update_filter_coeffs_10>:
84202788:	72 d8       	r0 = M[FP + 56];
8420278a:	91 d8       	rMAC = M[FP + 72];
8420278c:	12 54       	r0 = r0 LSHIFT 1;
8420278e:	88 04       	Null = rMAC - r0;
84202790:	02 f0 c9 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_14;

84202794 <Lc_ahm_update_filter_coeffs_11>:
                {
                    p_iir->ff.p_den[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,denom_coeffs_start_offset + i);
84202794:	3a e8       	r0 = M[r5 + Null];
84202796:	79 88       	rMAC = M[r5 + 4];
84202798:	92 56       	r0 = r0 LSHIFT 16;
8420279a:	89 12       	rMAC = rMAC OR r0;
8420279c:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j] = (p_iir->ff).p_den[j];
8420279e:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
842027a2:	91 f0 00 e8 	rMAC = M[r7 + Null];
842027a6:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_den[j]);
842027aa:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842027ae:	48 25       	Null = rMAC - 5;
842027b0:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_13;

842027b2 <Lc_ahm_update_filter_coeffs_12>:
842027b2:	35 e8       	r3 = M[r4 + Null];
842027b4:	55 f1 02 f0 	r0 = Null + 357566746;
842027b8:	1a 51 
842027ba:	54 08       	r2 = r8 + Null;
842027bc:	63 d8       	r1 = M[FP + 48];
842027be:	ef fd f4 ff 	call (m) 0x10ec;
842027c2:	2f e9 

842027c4 <Lc_ahm_update_filter_coeffs_13>:
    if(mode == AHM_HYBRID_ENABLE)
    {
        switch (path)
        {
            case AHM_ANC_PATH_FFB_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
842027c4:	91 d8       	rMAC = M[FP + 72];
842027c6:	0a 75       	r8 = r8 + 1;
842027c8:	3f 22       	r5 = r5 + 8;
842027ca:	36 21       	r4 = r4 + 4;
842027cc:	23 75       	r9 = r9 + 4;
842027ce:	20 75       	r6 = r6 + 4;
842027d0:	89 20       	rMAC = rMAC + 2;
842027d2:	91 de       	M[FP + 72] = rMAC;
842027d4:	21 75       	r7 = r7 + 4;
842027d6:	d9 6f       	jump (m) Lc_ahm_update_filter_coeffs_10;

842027d8 <Lc_ahm_update_filter_coeffs_14>:
842027d8:	72 d8       	r0 = M[FP + 56];
842027da:	52 54       	r0 = r0 LSHIFT 2;
                    coeffs[j] = (p_iir->ff).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
842027dc:	98 de       	M[FP + 76] = Null;
842027de:	02 09       	r8 = Null + Null;
842027e0:	59 d8       	rMAC = M[FP + 44];
842027e2:	4e d8       	r4 = M[FP + 36];
842027e4:	47 16       	r5 = FP + 100;
842027e6:	e8 f0 a8 20 	r6 = FP + 168;
842027ea:	e9 f0 08 88 	r7 = M[FP + 32];
842027ee:	1b f0 0c 20 	r9 = rMAC + 12;
842027f2:	d7 01       	r5 = r0 + r5;
842027f4:	10 0d       	r6 = r0 + r6;

842027f6 <Lc_ahm_update_filter_coeffs_15>:
842027f6:	7a d8       	r0 = M[FP + 60];
842027f8:	99 d8       	rMAC = M[FP + 76];
842027fa:	12 54       	r0 = r0 LSHIFT 1;
842027fc:	88 04       	Null = rMAC - r0;
842027fe:	02 f0 cf e0 	if C jump (m) Lc_ahm_update_filter_coeffs_19;

84202802 <Lc_ahm_update_filter_coeffs_16>:
                {
                    p_iir->ff.p_num[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,num_coeffs_start_offset + i);
84202802:	82 d8       	r0 = M[FP + 64];
84202804:	59 08       	rMAC = r9 + Null;
84202806:	52 54       	r0 = r0 LSHIFT 2;
84202808:	51 00       	rMAC = r0 + rMAC;
8420280a:	0a e8       	r0 = M[rMAC + Null];
8420280c:	92 56       	r0 = r0 LSHIFT 16;
8420280e:	49 88       	rMAC = M[rMAC + 4];
84202810:	89 12       	rMAC = rMAC OR r0;
84202812:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j + denom_taps] = (p_iir->ff).p_num[j];
84202814:	39 ee       	M[r5 + Null] = rMAC;
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ff).p_num[j];
84202816:	91 f0 00 e8 	rMAC = M[r7 + Null];
8420281a:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFA NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_num[j]);
8420281e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202822:	48 25       	Null = rMAC - 5;
84202824:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_18;

84202826 <Lc_ahm_update_filter_coeffs_17>:
84202826:	35 e8       	r3 = M[r4 + Null];
84202828:	55 f1 02 f0 	r0 = Null + 357566798;
8420282c:	4e 51 
8420282e:	54 08       	r2 = r8 + Null;
84202830:	63 d8       	r1 = M[FP + 48];
84202832:	ef fd f4 ff 	call (m) 0x10ec;
84202836:	3b e5 

84202838 <Lc_ahm_update_filter_coeffs_18>:
                    coeffs[j] = (p_iir->ff).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202838:	99 d8       	rMAC = M[FP + 76];
8420283a:	0a 75       	r8 = r8 + 1;
8420283c:	43 75       	r9 = r9 + 8;
8420283e:	36 21       	r4 = r4 + 4;
84202840:	3f 21       	r5 = r5 + 4;
84202842:	20 75       	r6 = r6 + 4;
84202844:	89 20       	rMAC = rMAC + 2;
84202846:	99 de       	M[FP + 76] = rMAC;
84202848:	21 75       	r7 = r7 + 4;
8420284a:	d6 6f       	jump (m) Lc_ahm_update_filter_coeffs_15;

8420284c <Lc_ahm_update_filter_coeffs_19>:
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ff).p_num[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_num[j]);
                }
        
                if (!check_filters_equal(coeffs_prev, coeffs, no_of_taps))
8420284c:	44 28       	r2 = Null + 17;
8420284e:	43 16       	r1 = FP + 100;
84202850:	82 1a       	r0 = FP + 168;
84202852:	02 f0 39 e8 	call (m) $_check_filters_equal;
84202856:	10 04       	Null = r0 - Null;
84202858:	37 62       	if NE jump (m) Lc_ahm_update_filter_coeffs_28;

8420285a <Lc_ahm_update_filter_coeffs_20>:
                {
                    cfg[AHM_ANC_FILTER_FF_ID] = TRUE;
8420285a:	41 20       	rMAC = Null + 1;
8420285c:	52 d8       	r0 = M[FP + 40];
8420285e:	11 ee       	M[r0 + Null] = rMAC;
                    L5_DBG_MSG1("OPID: %x, Mismatch between cur and prev filters in FF path",
                                ext_op_id);
84202860:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202864:	48 25       	Null = rMAC - 5;
84202866:	08 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_22;

84202868 <Lc_ahm_update_filter_coeffs_21>:
84202868:	55 f1 02 f0 	r0 = Null + 357566850;
8420286c:	82 51 
8420286e:	63 d8       	r1 = M[FP + 48];
84202870:	ef fd f4 ff 	call (m) 0x10c2;
84202874:	33 e2 

84202876 <Lc_ahm_update_filter_coeffs_22>:
                    #ifndef RUNNING_ON_KALSIM
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
84202876:	45 16       	r3 = FP + 100;
84202878:	7a d8       	r0 = M[FP + 60];
8420287a:	71 d8       	rMAC = M[FP + 56];
8420287c:	83 20       	r1 = Null + 2;
8420287e:	54 00       	r2 = r0 + rMAC;
84202880:	69 d8       	rMAC = M[FP + 52];
84202882:	0a 08       	r0 = SE8 rMAC;
84202884:	ff fd 52 f0 	call (m) 0xcc9c;
84202888:	39 e0 
                    #endif

                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
8420288a:	01 00       	rMAC = Null + Null;
8420288c:	42 d8       	r0 = M[FP + 32];
8420288e:	4b d8       	r1 = M[FP + 36];
84202890:	12 31       	r0 = r0 + 36;
84202892:	1b 31       	r1 = r1 + 36;

84202894 <Lc_ahm_update_filter_coeffs_23>:
84202894:	74 d8       	r2 = M[FP + 56];
84202896:	24 54       	r2 = r2 LSHIFT 1;
84202898:	08 05       	Null = rMAC - r2;
8420289a:	02 f0 91 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_25;

8420289e <Lc_ahm_update_filter_coeffs_24>:
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
8420289e:	1c e8       	r2 = M[r1 + Null];
842028a0:	14 ee       	M[r0 + Null] = r2;
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
                    #endif

                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
842028a2:	89 20       	rMAC = rMAC + 2;
842028a4:	12 21       	r0 = r0 + 4;
842028a6:	1b 21       	r1 = r1 + 4;
842028a8:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_23;

842028aa <Lc_ahm_update_filter_coeffs_25>:
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
842028aa:	01 00       	rMAC = Null + Null;
842028ac:	42 d8       	r0 = M[FP + 32];
842028ae:	4b d8       	r1 = M[FP + 36];

842028b0 <Lc_ahm_update_filter_coeffs_26>:
842028b0:	7c d8       	r2 = M[FP + 60];
842028b2:	24 54       	r2 = r2 LSHIFT 1;
842028b4:	08 05       	Null = rMAC - r2;
842028b6:	02 f0 ad e9 	if C jump (m) Lc_ahm_update_filter_coeffs_96;

842028ba <Lc_ahm_update_filter_coeffs_27>:
                    {
                        (p_prev_iir->ff).p_num[j] = (p_iir->ff).p_num[j];
842028ba:	1c e8       	r2 = M[r1 + Null];
842028bc:	14 ee       	M[r0 + Null] = r2;
                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
842028be:	89 20       	rMAC = rMAC + 2;
842028c0:	12 21       	r0 = r0 + 4;
842028c2:	1b 21       	r1 = r1 + 4;
842028c4:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_26;

842028c6 <Lc_ahm_update_filter_coeffs_28>:

                }
                else
                {
                    L5_DBG_MSG1("OPID: %x, Current and previous filters in FF path are same",
                                ext_op_id);
842028c6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842028ca:	48 25       	Null = rMAC - 5;
842028cc:	0b f0 97 e9 	if LT jump (m) Lc_ahm_update_filter_coeffs_96;

842028d0 <Lc_ahm_update_filter_coeffs_29>:
842028d0:	55 f1 02 f0 	r0 = Null + 357566909;
842028d4:	bd 51 
842028d6:	63 d8       	r1 = M[FP + 48];
842028d8:	ef fd f3 ff 	call (m) 0x10c2;
842028dc:	2b ef 
842028de:	0f f0 85 e9 	jump (m) Lc_ahm_update_filter_coeffs_96;

842028e2 <Lc_ahm_update_filter_coeffs_30>:
                }
            break;
            case AHM_ANC_PATH_FFA_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
842028e2:	a0 de       	M[FP + 80] = Null;
842028e4:	02 09       	r8 = Null + Null;
842028e6:	59 d8       	rMAC = M[FP + 44];
842028e8:	eb f0 64 20 	r9 = FP + 100;
842028ec:	e8 f0 a8 20 	r6 = FP + 168;
842028f0:	0f 2b       	r5 = rMAC + 28;
842028f2:	49 d8       	rMAC = M[FP + 36];
842028f4:	16 f0 68 20 	r4 = rMAC + 104;
842028f8:	41 d8       	rMAC = M[FP + 32];
842028fa:	19 f0 68 20 	r7 = rMAC + 104;

842028fe <Lc_ahm_update_filter_coeffs_31>:
842028fe:	72 d8       	r0 = M[FP + 56];
84202900:	a1 d8       	rMAC = M[FP + 80];
84202902:	12 54       	r0 = r0 LSHIFT 1;
84202904:	88 04       	Null = rMAC - r0;
84202906:	02 f0 c9 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_35;

8420290a <Lc_ahm_update_filter_coeffs_32>:
                {
                    p_iir->fb.p_den[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,denom_coeffs_start_offset + i);
8420290a:	3a e8       	r0 = M[r5 + Null];
8420290c:	79 88       	rMAC = M[r5 + 4];
8420290e:	92 56       	r0 = r0 LSHIFT 16;
84202910:	89 12       	rMAC = rMAC OR r0;
84202912:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j] = (p_iir->fb).p_den[j];
84202914:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
                    coeffs_prev[j] = (p_prev_iir->fb).p_den[j];
84202918:	91 f0 00 e8 	rMAC = M[r7 + Null];
8420291c:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFB DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->fb).p_den[j]);
84202920:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202924:	48 25       	Null = rMAC - 5;
84202926:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_34;

84202928 <Lc_ahm_update_filter_coeffs_33>:
84202928:	35 e8       	r3 = M[r4 + Null];
8420292a:	55 f1 02 f0 	r0 = Null + 357566968;
8420292e:	f8 51 
84202930:	54 08       	r2 = r8 + Null;
84202932:	63 d8       	r1 = M[FP + 48];
84202934:	ef fd f3 ff 	call (m) 0x10ec;
84202938:	39 ed 

8420293a <Lc_ahm_update_filter_coeffs_34>:
                    L5_DBG_MSG1("OPID: %x, Current and previous filters in FF path are same",
                                ext_op_id);
                }
            break;
            case AHM_ANC_PATH_FFA_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
8420293a:	a1 d8       	rMAC = M[FP + 80];
8420293c:	0a 75       	r8 = r8 + 1;
8420293e:	3f 22       	r5 = r5 + 8;
84202940:	36 21       	r4 = r4 + 4;
84202942:	23 75       	r9 = r9 + 4;
84202944:	20 75       	r6 = r6 + 4;
84202946:	89 20       	rMAC = rMAC + 2;
84202948:	a1 de       	M[FP + 80] = rMAC;
8420294a:	21 75       	r7 = r7 + 4;
8420294c:	d9 6f       	jump (m) Lc_ahm_update_filter_coeffs_31;

8420294e <Lc_ahm_update_filter_coeffs_35>:
8420294e:	72 d8       	r0 = M[FP + 56];
84202950:	52 54       	r0 = r0 LSHIFT 2;
                    coeffs[j] = (p_iir->fb).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->fb).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFB DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->fb).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202952:	a8 de       	M[FP + 84] = Null;
84202954:	02 09       	r8 = Null + Null;
84202956:	59 d8       	rMAC = M[FP + 44];
84202958:	47 16       	r5 = FP + 100;
8420295a:	e8 f0 a8 20 	r6 = FP + 168;
8420295e:	1b f0 0c 20 	r9 = rMAC + 12;
84202962:	d7 01       	r5 = r0 + r5;
84202964:	10 0d       	r6 = r0 + r6;
84202966:	49 d8       	rMAC = M[FP + 36];
84202968:	16 f0 44 20 	r4 = rMAC + 68;
8420296c:	41 d8       	rMAC = M[FP + 32];
8420296e:	19 f0 44 20 	r7 = rMAC + 68;

84202972 <Lc_ahm_update_filter_coeffs_36>:
84202972:	7a d8       	r0 = M[FP + 60];
84202974:	a9 d8       	rMAC = M[FP + 84];
84202976:	12 54       	r0 = r0 LSHIFT 1;
84202978:	88 04       	Null = rMAC - r0;
8420297a:	02 f0 cf e0 	if C jump (m) Lc_ahm_update_filter_coeffs_40;

8420297e <Lc_ahm_update_filter_coeffs_37>:
                {
                    p_iir->fb.p_num[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,num_coeffs_start_offset + i);
8420297e:	82 d8       	r0 = M[FP + 64];
84202980:	59 08       	rMAC = r9 + Null;
84202982:	52 54       	r0 = r0 LSHIFT 2;
84202984:	51 00       	rMAC = r0 + rMAC;
84202986:	0a e8       	r0 = M[rMAC + Null];
84202988:	92 56       	r0 = r0 LSHIFT 16;
8420298a:	49 88       	rMAC = M[rMAC + 4];
8420298c:	89 12       	rMAC = rMAC OR r0;
8420298e:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j + denom_taps] = (p_iir->fb).p_num[j];
84202990:	39 ee       	M[r5 + Null] = rMAC;
                    coeffs_prev[j + denom_taps] = (p_prev_iir->fb).p_num[j];
84202992:	91 f0 00 e8 	rMAC = M[r7 + Null];
84202996:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFB NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->fb).p_num[j]);
8420299a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420299e:	48 25       	Null = rMAC - 5;
842029a0:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_39;

842029a2 <Lc_ahm_update_filter_coeffs_38>:
842029a2:	35 e8       	r3 = M[r4 + Null];
842029a4:	55 f1 02 f0 	r0 = Null + 357567020;
842029a8:	2c 52 
842029aa:	54 08       	r2 = r8 + Null;
842029ac:	63 d8       	r1 = M[FP + 48];
842029ae:	ef fd f3 ff 	call (m) 0x10ec;
842029b2:	3f e9 

842029b4 <Lc_ahm_update_filter_coeffs_39>:
                    coeffs[j] = (p_iir->fb).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->fb).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFB DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->fb).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
842029b4:	a9 d8       	rMAC = M[FP + 84];
842029b6:	0a 75       	r8 = r8 + 1;
842029b8:	43 75       	r9 = r9 + 8;
842029ba:	36 21       	r4 = r4 + 4;
842029bc:	3f 21       	r5 = r5 + 4;
842029be:	20 75       	r6 = r6 + 4;
842029c0:	89 20       	rMAC = rMAC + 2;
842029c2:	a9 de       	M[FP + 84] = rMAC;
842029c4:	21 75       	r7 = r7 + 4;
842029c6:	d6 6f       	jump (m) Lc_ahm_update_filter_coeffs_36;

842029c8 <Lc_ahm_update_filter_coeffs_40>:
                    coeffs[j + denom_taps] = (p_iir->fb).p_num[j];
                    coeffs_prev[j + denom_taps] = (p_prev_iir->fb).p_num[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFB NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->fb).p_num[j]);
                }
                if (!check_filters_equal(coeffs_prev, coeffs, no_of_taps))
842029c8:	44 28       	r2 = Null + 17;
842029ca:	43 16       	r1 = FP + 100;
842029cc:	82 1a       	r0 = FP + 168;
842029ce:	01 f0 3d ec 	call (m) $_check_filters_equal;
842029d2:	10 04       	Null = r0 - Null;
842029d4:	3d 62       	if NE jump (m) Lc_ahm_update_filter_coeffs_49;

842029d6 <Lc_ahm_update_filter_coeffs_41>:
                {
                    cfg[AHM_ANC_FILTER_FB_ID] = TRUE;
842029d6:	41 20       	rMAC = Null + 1;
842029d8:	52 d8       	r0 = M[FP + 40];
842029da:	51 8e       	M[r0 + 4] = rMAC;
                    L5_DBG_MSG1("OPID: %x, Mismatch between cur and prev filters in FB path",
                                ext_op_id);
842029dc:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842029e0:	48 25       	Null = rMAC - 5;
842029e2:	08 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_43;

842029e4 <Lc_ahm_update_filter_coeffs_42>:
842029e4:	55 f1 02 f0 	r0 = Null + 357567072;
842029e8:	60 52 
842029ea:	63 d8       	r1 = M[FP + 48];
842029ec:	ef fd f3 ff 	call (m) 0x10c2;
842029f0:	37 e6 

842029f2 <Lc_ahm_update_filter_coeffs_43>:
                    #ifndef RUNNING_ON_KALSIM
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
842029f2:	45 16       	r3 = FP + 100;
842029f4:	7a d8       	r0 = M[FP + 60];
842029f6:	71 d8       	rMAC = M[FP + 56];
842029f8:	43 20       	r1 = Null + 1;
842029fa:	54 00       	r2 = r0 + rMAC;
842029fc:	69 d8       	rMAC = M[FP + 52];
842029fe:	0a 08       	r0 = SE8 rMAC;
84202a00:	ff fd 51 f0 	call (m) 0xcc9c;
84202a04:	3d e4 
                    #endif
                    /* copy previous iir fb filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202a06:	01 00       	rMAC = Null + Null;
84202a08:	42 d8       	r0 = M[FP + 32];
84202a0a:	4b d8       	r1 = M[FP + 36];
84202a0c:	02 f0 68 44 	r0 = r0 + 104;
84202a10:	03 f0 68 44 	r1 = r1 + 104;

84202a14 <Lc_ahm_update_filter_coeffs_44>:
84202a14:	74 d8       	r2 = M[FP + 56];
84202a16:	24 54       	r2 = r2 LSHIFT 1;
84202a18:	08 05       	Null = rMAC - r2;
84202a1a:	02 f0 91 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_46;

84202a1e <Lc_ahm_update_filter_coeffs_45>:
                    {
                        (p_prev_iir->fb).p_den[j] = (p_iir->fb).p_den[j];
84202a1e:	1c e8       	r2 = M[r1 + Null];
84202a20:	14 ee       	M[r0 + Null] = r2;
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
                    #endif
                    /* copy previous iir fb filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202a22:	89 20       	rMAC = rMAC + 2;
84202a24:	12 21       	r0 = r0 + 4;
84202a26:	1b 21       	r1 = r1 + 4;
84202a28:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_44;

84202a2a <Lc_ahm_update_filter_coeffs_46>:
                    {
                        (p_prev_iir->fb).p_den[j] = (p_iir->fb).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202a2a:	01 00       	rMAC = Null + Null;
84202a2c:	42 d8       	r0 = M[FP + 32];
84202a2e:	4b d8       	r1 = M[FP + 36];
84202a30:	02 f0 44 44 	r0 = r0 + 68;
84202a34:	03 f0 44 44 	r1 = r1 + 68;

84202a38 <Lc_ahm_update_filter_coeffs_47>:
84202a38:	7c d8       	r2 = M[FP + 60];
84202a3a:	24 54       	r2 = r2 LSHIFT 1;
84202a3c:	08 05       	Null = rMAC - r2;
84202a3e:	02 f0 a5 e6 	if C jump (m) Lc_ahm_update_filter_coeffs_96;

84202a42 <Lc_ahm_update_filter_coeffs_48>:
                    {
                        (p_prev_iir->fb).p_num[j] = (p_iir->fb).p_num[j];
84202a42:	1c e8       	r2 = M[r1 + Null];
84202a44:	14 ee       	M[r0 + Null] = r2;
                    /* copy previous iir fb filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
                    {
                        (p_prev_iir->fb).p_den[j] = (p_iir->fb).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202a46:	89 20       	rMAC = rMAC + 2;
84202a48:	12 21       	r0 = r0 + 4;
84202a4a:	1b 21       	r1 = r1 + 4;
84202a4c:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_47;

84202a4e <Lc_ahm_update_filter_coeffs_49>:
                    }
                }
                else
                {
                    L5_DBG_MSG1("OPID: %x, Current and previous Filters in FB path are same",
                                ext_op_id);
84202a4e:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202a52:	48 25       	Null = rMAC - 5;
84202a54:	0b f0 8f e6 	if LT jump (m) Lc_ahm_update_filter_coeffs_96;

84202a58 <Lc_ahm_update_filter_coeffs_50>:
84202a58:	55 f1 02 f0 	r0 = Null + 357567131;
84202a5c:	9b 52 
84202a5e:	63 d8       	r1 = M[FP + 48];
84202a60:	ef fd f3 ff 	call (m) 0x10c2;
84202a64:	23 e3 
84202a66:	0f f0 fd e5 	jump (m) Lc_ahm_update_filter_coeffs_96;

84202a6a <Lc_ahm_update_filter_coeffs_51>:
                }
            break;
            case AHM_ANC_PATH_FB_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202a6a:	72 d8       	r0 = M[FP + 56];
84202a6c:	89 d8       	rMAC = M[FP + 68];
84202a6e:	12 54       	r0 = r0 LSHIFT 1;
84202a70:	88 04       	Null = rMAC - r0;
84202a72:	02 f0 c9 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_55;

84202a76 <Lc_ahm_update_filter_coeffs_52>:
                {
                    p_iir->ec.p_den[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,denom_coeffs_start_offset + i);
84202a76:	3a e8       	r0 = M[r5 + Null];
84202a78:	79 88       	rMAC = M[r5 + 4];
84202a7a:	92 56       	r0 = r0 LSHIFT 16;
84202a7c:	89 12       	rMAC = rMAC OR r0;
84202a7e:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j] = (p_iir->ec).p_den[j];
84202a80:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
                    coeffs_prev[j] = (p_prev_iir->ec).p_den[j];
84202a84:	91 f0 00 e8 	rMAC = M[r7 + Null];
84202a88:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC EC DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ec).p_den[j]);
84202a8c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202a90:	48 25       	Null = rMAC - 5;
84202a92:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_54;

84202a94 <Lc_ahm_update_filter_coeffs_53>:
84202a94:	35 e8       	r3 = M[r4 + Null];
84202a96:	55 f1 02 f0 	r0 = Null + 357567190;
84202a9a:	d6 52 
84202a9c:	54 08       	r2 = r8 + Null;
84202a9e:	63 d8       	r1 = M[FP + 48];
84202aa0:	ef fd f3 ff 	call (m) 0x10ec;
84202aa4:	2d e2 

84202aa6 <Lc_ahm_update_filter_coeffs_54>:
                    L5_DBG_MSG1("OPID: %x, Current and previous Filters in FB path are same",
                                ext_op_id);
                }
            break;
            case AHM_ANC_PATH_FB_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202aa6:	89 d8       	rMAC = M[FP + 68];
84202aa8:	0a 75       	r8 = r8 + 1;
84202aaa:	3f 22       	r5 = r5 + 8;
84202aac:	36 21       	r4 = r4 + 4;
84202aae:	23 75       	r9 = r9 + 4;
84202ab0:	20 75       	r6 = r6 + 4;
84202ab2:	89 20       	rMAC = rMAC + 2;
84202ab4:	89 de       	M[FP + 68] = rMAC;
84202ab6:	21 75       	r7 = r7 + 4;
84202ab8:	d9 6f       	jump (m) Lc_ahm_update_filter_coeffs_51;

84202aba <Lc_ahm_update_filter_coeffs_55>:
84202aba:	72 d8       	r0 = M[FP + 56];
84202abc:	52 54       	r0 = r0 LSHIFT 2;
                    coeffs[j] = (p_iir->ec).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ec).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC EC DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ec).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202abe:	b0 de       	M[FP + 88] = Null;
84202ac0:	02 09       	r8 = Null + Null;
84202ac2:	59 d8       	rMAC = M[FP + 44];
84202ac4:	47 16       	r5 = FP + 100;
84202ac6:	e8 f0 a8 20 	r6 = FP + 168;
84202aca:	1b f0 0c 20 	r9 = rMAC + 12;
84202ace:	d7 01       	r5 = r0 + r5;
84202ad0:	10 0d       	r6 = r0 + r6;
84202ad2:	49 d8       	rMAC = M[FP + 36];
84202ad4:	16 f0 88 20 	r4 = rMAC + 136;
84202ad8:	41 d8       	rMAC = M[FP + 32];
84202ada:	19 f0 88 20 	r7 = rMAC + 136;

84202ade <Lc_ahm_update_filter_coeffs_56>:
84202ade:	7a d8       	r0 = M[FP + 60];
84202ae0:	b1 d8       	rMAC = M[FP + 88];
84202ae2:	12 54       	r0 = r0 LSHIFT 1;
84202ae4:	88 04       	Null = rMAC - r0;
84202ae6:	02 f0 cf e0 	if C jump (m) Lc_ahm_update_filter_coeffs_60;

84202aea <Lc_ahm_update_filter_coeffs_57>:
                {
                    p_iir->ec.p_num[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,num_coeffs_start_offset + i);
84202aea:	82 d8       	r0 = M[FP + 64];
84202aec:	59 08       	rMAC = r9 + Null;
84202aee:	52 54       	r0 = r0 LSHIFT 2;
84202af0:	51 00       	rMAC = r0 + rMAC;
84202af2:	0a e8       	r0 = M[rMAC + Null];
84202af4:	92 56       	r0 = r0 LSHIFT 16;
84202af6:	49 88       	rMAC = M[rMAC + 4];
84202af8:	89 12       	rMAC = rMAC OR r0;
84202afa:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j + denom_taps] = (p_iir->ec).p_num[j];
84202afc:	39 ee       	M[r5 + Null] = rMAC;
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ec).p_num[j];
84202afe:	91 f0 00 e8 	rMAC = M[r7 + Null];
84202b02:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC EC NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ec).p_num[j]);
84202b06:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202b0a:	48 25       	Null = rMAC - 5;
84202b0c:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_59;

84202b0e <Lc_ahm_update_filter_coeffs_58>:
84202b0e:	35 e8       	r3 = M[r4 + Null];
84202b10:	55 f1 02 f0 	r0 = Null + 357567241;
84202b14:	09 53 
84202b16:	54 08       	r2 = r8 + Null;
84202b18:	63 d8       	r1 = M[FP + 48];
84202b1a:	ef fd f2 ff 	call (m) 0x10ec;
84202b1e:	33 ee 

84202b20 <Lc_ahm_update_filter_coeffs_59>:
                    coeffs[j] = (p_iir->ec).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ec).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC EC DENOM IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ec).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202b20:	b1 d8       	rMAC = M[FP + 88];
84202b22:	0a 75       	r8 = r8 + 1;
84202b24:	43 75       	r9 = r9 + 8;
84202b26:	36 21       	r4 = r4 + 4;
84202b28:	3f 21       	r5 = r5 + 4;
84202b2a:	20 75       	r6 = r6 + 4;
84202b2c:	89 20       	rMAC = rMAC + 2;
84202b2e:	b1 de       	M[FP + 88] = rMAC;
84202b30:	21 75       	r7 = r7 + 4;
84202b32:	d6 6f       	jump (m) Lc_ahm_update_filter_coeffs_56;

84202b34 <Lc_ahm_update_filter_coeffs_60>:
                    coeffs[j + denom_taps] = (p_iir->ec).p_num[j];
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ec).p_num[j];
                    L5_DBG_MSG3("OPID: %x, ANC EC NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ec).p_num[j]);
                }
                if (!check_filters_equal(coeffs_prev, coeffs, no_of_taps))
84202b34:	44 28       	r2 = Null + 17;
84202b36:	43 16       	r1 = FP + 100;
84202b38:	82 1a       	r0 = FP + 168;
84202b3a:	01 f0 31 e1 	call (m) $_check_filters_equal;
84202b3e:	10 04       	Null = r0 - Null;
84202b40:	3d 62       	if NE jump (m) Lc_ahm_update_filter_coeffs_69;

84202b42 <Lc_ahm_update_filter_coeffs_61>:
                {
                    cfg[AHM_ANC_FILTER_EC_ID] = TRUE;
84202b42:	41 20       	rMAC = Null + 1;
84202b44:	52 d8       	r0 = M[FP + 40];
84202b46:	91 8e       	M[r0 + 8] = rMAC;
                    L5_DBG_MSG1("OPID: %x, Mismatch between cur and prev filters in EC path",
                                ext_op_id);
84202b48:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202b4c:	48 25       	Null = rMAC - 5;
84202b4e:	08 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_63;

84202b50 <Lc_ahm_update_filter_coeffs_62>:
84202b50:	55 f1 02 f0 	r0 = Null + 357567292;
84202b54:	3c 53 
84202b56:	63 d8       	r1 = M[FP + 48];
84202b58:	ef fd f2 ff 	call (m) 0x10c2;
84202b5c:	2b eb 

84202b5e <Lc_ahm_update_filter_coeffs_63>:
                    #ifndef RUNNING_ON_KALSIM
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
84202b5e:	45 16       	r3 = FP + 100;
84202b60:	7a d8       	r0 = M[FP + 60];
84202b62:	71 d8       	rMAC = M[FP + 56];
84202b64:	c3 20       	r1 = Null + 3;
84202b66:	54 00       	r2 = r0 + rMAC;
84202b68:	69 d8       	rMAC = M[FP + 52];
84202b6a:	0a 08       	r0 = SE8 rMAC;
84202b6c:	ff fd 50 f0 	call (m) 0xcc9c;
84202b70:	31 e9 
                    #endif
                    /* copy previous iir ec filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202b72:	01 00       	rMAC = Null + Null;
84202b74:	42 d8       	r0 = M[FP + 32];
84202b76:	4b d8       	r1 = M[FP + 36];
84202b78:	02 f0 ac 44 	r0 = r0 + 172;
84202b7c:	03 f0 ac 44 	r1 = r1 + 172;

84202b80 <Lc_ahm_update_filter_coeffs_64>:
84202b80:	74 d8       	r2 = M[FP + 56];
84202b82:	24 54       	r2 = r2 LSHIFT 1;
84202b84:	08 05       	Null = rMAC - r2;
84202b86:	02 f0 91 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_66;

84202b8a <Lc_ahm_update_filter_coeffs_65>:
                    {
                        (p_prev_iir->ec).p_den[j] = (p_iir->ec).p_den[j];
84202b8a:	1c e8       	r2 = M[r1 + Null];
84202b8c:	14 ee       	M[r0 + Null] = r2;
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
                    #endif
                    /* copy previous iir ec filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202b8e:	89 20       	rMAC = rMAC + 2;
84202b90:	12 21       	r0 = r0 + 4;
84202b92:	1b 21       	r1 = r1 + 4;
84202b94:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_64;

84202b96 <Lc_ahm_update_filter_coeffs_66>:
                    {
                        (p_prev_iir->ec).p_den[j] = (p_iir->ec).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202b96:	01 00       	rMAC = Null + Null;
84202b98:	42 d8       	r0 = M[FP + 32];
84202b9a:	4b d8       	r1 = M[FP + 36];
84202b9c:	02 f0 88 44 	r0 = r0 + 136;
84202ba0:	03 f0 88 44 	r1 = r1 + 136;

84202ba4 <Lc_ahm_update_filter_coeffs_67>:
84202ba4:	7c d8       	r2 = M[FP + 60];
84202ba6:	24 54       	r2 = r2 LSHIFT 1;
84202ba8:	08 05       	Null = rMAC - r2;
84202baa:	02 f0 b9 e3 	if C jump (m) Lc_ahm_update_filter_coeffs_96;

84202bae <Lc_ahm_update_filter_coeffs_68>:
                    {
                        (p_prev_iir->ec).p_num[j] = (p_iir->ec).p_num[j];
84202bae:	1c e8       	r2 = M[r1 + Null];
84202bb0:	14 ee       	M[r0 + Null] = r2;
                    /* copy previous iir ec filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
                    {
                        (p_prev_iir->ec).p_den[j] = (p_iir->ec).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202bb2:	89 20       	rMAC = rMAC + 2;
84202bb4:	12 21       	r0 = r0 + 4;
84202bb6:	1b 21       	r1 = r1 + 4;
84202bb8:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_67;

84202bba <Lc_ahm_update_filter_coeffs_69>:
                    }
                }
                else
                {
                    L5_DBG_MSG1("OPID: %x, Current and previous filters in EC path are same",
                                ext_op_id);
84202bba:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202bbe:	48 25       	Null = rMAC - 5;
84202bc0:	d1 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_96;

84202bc2 <Lc_ahm_update_filter_coeffs_70>:
84202bc2:	55 f1 02 f0 	r0 = Null + 357567351;
84202bc6:	77 53 
84202bc8:	63 d8       	r1 = M[FP + 48];
84202bca:	ef fd f2 ff 	call (m) 0x10c2;
84202bce:	39 e7 
84202bd0:	c9 6e       	jump (m) Lc_ahm_update_filter_coeffs_96;

84202bd2 <Lc_ahm_update_filter_coeffs_71>:
                }
            break;
            default:
                L2_DBG_MSG1("OPID: %x, Invalid filter path", ext_op_id);
84202bd2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202bd6:	88 24       	Null = rMAC - 2;
84202bd8:	c5 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_96;

84202bda <Lc_ahm_update_filter_coeffs_72>:
84202bda:	55 f1 02 f0 	r0 = Null + 357567410;
84202bde:	b2 53 
84202be0:	63 d8       	r1 = M[FP + 48];
84202be2:	ef fd f2 ff 	call (m) 0x10c2;
84202be6:	21 e7 
84202be8:	bd 6e       	jump (m) Lc_ahm_update_filter_coeffs_96;

84202bea <Lc_ahm_update_filter_coeffs_73>:
                UNUSED(coeffs);
        }
    }
    else if(mode == AHM_FEEDFORWARD_ENABLE)
84202bea:	80 f0 09 24 	Null = r6 - 9;
84202bee:	af 62       	if NE jump (m) Lc_ahm_update_filter_coeffs_94;

84202bf0 <Lc_ahm_update_filter_coeffs_74>:
    {
        switch (path)
84202bf0:	70 24       	Null = r4 - 1;
84202bf2:	f0 63       	if NE jump (m) Lc_ahm_update_filter_coeffs_71;

84202bf4 <Lc_ahm_update_filter_coeffs_75>:
        {
             case AHM_ANC_PATH_FFA_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202bf4:	b8 de       	M[FP + 92] = Null;
84202bf6:	02 09       	r8 = Null + Null;
84202bf8:	59 d8       	rMAC = M[FP + 44];
84202bfa:	eb f0 64 20 	r9 = FP + 100;
84202bfe:	e8 f0 a8 20 	r6 = FP + 168;
84202c02:	0f 2b       	r5 = rMAC + 28;
84202c04:	49 d8       	rMAC = M[FP + 36];
84202c06:	0e 31       	r4 = rMAC + 36;
84202c08:	41 d8       	rMAC = M[FP + 32];
84202c0a:	19 f0 24 20 	r7 = rMAC + 36;

84202c0e <Lc_ahm_update_filter_coeffs_76>:
84202c0e:	72 d8       	r0 = M[FP + 56];
84202c10:	b9 d8       	rMAC = M[FP + 92];
84202c12:	12 54       	r0 = r0 LSHIFT 1;
84202c14:	88 04       	Null = rMAC - r0;
84202c16:	02 f0 c9 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_80;

84202c1a <Lc_ahm_update_filter_coeffs_77>:
                {
                    p_iir->ff.p_den[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,denom_coeffs_start_offset + i);
84202c1a:	3a e8       	r0 = M[r5 + Null];
84202c1c:	79 88       	rMAC = M[r5 + 4];
84202c1e:	92 56       	r0 = r0 LSHIFT 16;
84202c20:	89 12       	rMAC = rMAC OR r0;
84202c22:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j] = (p_iir->ff).p_den[j];
84202c24:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
84202c28:	91 f0 00 e8 	rMAC = M[r7 + Null];
84202c2c:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                 ext_op_id, j, (p_iir->ff).p_den[j]);
84202c30:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202c34:	48 25       	Null = rMAC - 5;
84202c36:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_79;

84202c38 <Lc_ahm_update_filter_coeffs_78>:
84202c38:	35 e8       	r3 = M[r4 + Null];
84202c3a:	55 f1 02 f0 	r0 = Null + 357566746;
84202c3e:	1a 51 
84202c40:	54 08       	r2 = r8 + Null;
84202c42:	63 d8       	r1 = M[FP + 48];
84202c44:	ef fd f2 ff 	call (m) 0x10ec;
84202c48:	29 e5 

84202c4a <Lc_ahm_update_filter_coeffs_79>:
    else if(mode == AHM_FEEDFORWARD_ENABLE)
    {
        switch (path)
        {
             case AHM_ANC_PATH_FFA_ID:
                for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202c4a:	b9 d8       	rMAC = M[FP + 92];
84202c4c:	0a 75       	r8 = r8 + 1;
84202c4e:	3f 22       	r5 = r5 + 8;
84202c50:	36 21       	r4 = r4 + 4;
84202c52:	23 75       	r9 = r9 + 4;
84202c54:	20 75       	r6 = r6 + 4;
84202c56:	89 20       	rMAC = rMAC + 2;
84202c58:	b9 de       	M[FP + 92] = rMAC;
84202c5a:	21 75       	r7 = r7 + 4;
84202c5c:	d9 6f       	jump (m) Lc_ahm_update_filter_coeffs_76;

84202c5e <Lc_ahm_update_filter_coeffs_80>:
84202c5e:	72 d8       	r0 = M[FP + 56];
84202c60:	52 54       	r0 = r0 LSHIFT 2;
                    coeffs[j] = (p_iir->ff).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                 ext_op_id, j, (p_iir->ff).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202c62:	c0 de       	M[FP + 96] = Null;
84202c64:	02 09       	r8 = Null + Null;
84202c66:	59 d8       	rMAC = M[FP + 44];
84202c68:	4e d8       	r4 = M[FP + 36];
84202c6a:	47 16       	r5 = FP + 100;
84202c6c:	e8 f0 a8 20 	r6 = FP + 168;
84202c70:	e9 f0 08 88 	r7 = M[FP + 32];
84202c74:	1b f0 0c 20 	r9 = rMAC + 12;
84202c78:	d7 01       	r5 = r0 + r5;
84202c7a:	10 0d       	r6 = r0 + r6;

84202c7c <Lc_ahm_update_filter_coeffs_81>:
84202c7c:	7a d8       	r0 = M[FP + 60];
84202c7e:	c1 d8       	rMAC = M[FP + 96];
84202c80:	12 54       	r0 = r0 LSHIFT 1;
84202c82:	88 04       	Null = rMAC - r0;
84202c84:	02 f0 cf e0 	if C jump (m) Lc_ahm_update_filter_coeffs_85;

84202c88 <Lc_ahm_update_filter_coeffs_82>:
                {
                    p_iir->ff.p_num[j] = \
                    OPMSG_AHM_SET_COEFFS32(p_msg,num_coeffs_start_offset + i);
84202c88:	82 d8       	r0 = M[FP + 64];
84202c8a:	59 08       	rMAC = r9 + Null;
84202c8c:	52 54       	r0 = r0 LSHIFT 2;
84202c8e:	51 00       	rMAC = r0 + rMAC;
84202c90:	0a e8       	r0 = M[rMAC + Null];
84202c92:	92 56       	r0 = r0 LSHIFT 16;
84202c94:	49 88       	rMAC = M[rMAC + 4];
84202c96:	89 12       	rMAC = rMAC OR r0;
84202c98:	31 ee       	M[r4 + Null] = rMAC;
                    coeffs[j + denom_taps] = (p_iir->ff).p_num[j];
84202c9a:	39 ee       	M[r5 + Null] = rMAC;
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ff).p_num[j];
84202c9c:	91 f0 00 e8 	rMAC = M[r7 + Null];
84202ca0:	81 f0 00 ee 	M[r6 + Null] = rMAC;
                    L5_DBG_MSG3("OPID: %x, ANC FFA NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_num[j]);
84202ca4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202ca8:	48 25       	Null = rMAC - 5;
84202caa:	0a 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_84;

84202cac <Lc_ahm_update_filter_coeffs_83>:
84202cac:	35 e8       	r3 = M[r4 + Null];
84202cae:	55 f1 02 f0 	r0 = Null + 357566798;
84202cb2:	4e 51 
84202cb4:	54 08       	r2 = r8 + Null;
84202cb6:	63 d8       	r1 = M[FP + 48];
84202cb8:	ef fd f2 ff 	call (m) 0x10ec;
84202cbc:	35 e1 

84202cbe <Lc_ahm_update_filter_coeffs_84>:
                    coeffs[j] = (p_iir->ff).p_den[j];
                    coeffs_prev[j] = (p_prev_iir->ff).p_den[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA DENOM IIR COEFF NUM [%d] = 0x%08X",
                                 ext_op_id, j, (p_iir->ff).p_den[j]);
                }
                for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202cbe:	c1 d8       	rMAC = M[FP + 96];
84202cc0:	0a 75       	r8 = r8 + 1;
84202cc2:	43 75       	r9 = r9 + 8;
84202cc4:	36 21       	r4 = r4 + 4;
84202cc6:	3f 21       	r5 = r5 + 4;
84202cc8:	20 75       	r6 = r6 + 4;
84202cca:	89 20       	rMAC = rMAC + 2;
84202ccc:	c1 de       	M[FP + 96] = rMAC;
84202cce:	21 75       	r7 = r7 + 4;
84202cd0:	d6 6f       	jump (m) Lc_ahm_update_filter_coeffs_81;

84202cd2 <Lc_ahm_update_filter_coeffs_85>:
                    coeffs_prev[j + denom_taps] = (p_prev_iir->ff).p_num[j];
                    L5_DBG_MSG3("OPID: %x, ANC FFA NUMER IIR COEFF NUM [%d] = 0x%08X",
                                ext_op_id, j, (p_iir->ff).p_num[j]);
                }
        
                if (!check_filters_equal(coeffs_prev, coeffs, no_of_taps))
84202cd2:	44 28       	r2 = Null + 17;
84202cd4:	43 16       	r1 = FP + 100;
84202cd6:	82 1a       	r0 = FP + 168;
84202cd8:	49 4e       	call (m) $_check_filters_equal;
84202cda:	10 04       	Null = r0 - Null;
84202cdc:	f1 ff eb e7 	if NE jump (m) Lc_ahm_update_filter_coeffs_28;

84202ce0 <Lc_ahm_update_filter_coeffs_86>:
                {
                    cfg[AHM_ANC_FILTER_FF_ID] = TRUE;
84202ce0:	41 20       	rMAC = Null + 1;
84202ce2:	52 d8       	r0 = M[FP + 40];
84202ce4:	11 ee       	M[r0 + Null] = rMAC;
                    L5_DBG_MSG1("OPID: %x, Mismatch between cur and prev filters in FF path",
                                ext_op_id);
84202ce6:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202cea:	48 25       	Null = rMAC - 5;
84202cec:	08 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_88;

84202cee <Lc_ahm_update_filter_coeffs_87>:
84202cee:	55 f1 02 f0 	r0 = Null + 357566850;
84202cf2:	82 51 
84202cf4:	63 d8       	r1 = M[FP + 48];
84202cf6:	ef fd f1 ff 	call (m) 0x10c2;
84202cfa:	2d ee 

84202cfc <Lc_ahm_update_filter_coeffs_88>:
                    #ifndef RUNNING_ON_KALSIM
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
84202cfc:	45 16       	r3 = FP + 100;
84202cfe:	7a d8       	r0 = M[FP + 60];
84202d00:	71 d8       	rMAC = M[FP + 56];
84202d02:	43 20       	r1 = Null + 1;
84202d04:	54 00       	r2 = r0 + rMAC;
84202d06:	69 d8       	rMAC = M[FP + 52];
84202d08:	0a 08       	r0 = SE8 rMAC;
84202d0a:	ff fd 4f f0 	call (m) 0xcc9c;
84202d0e:	33 ec 
                    #endif
                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202d10:	01 00       	rMAC = Null + Null;
84202d12:	42 d8       	r0 = M[FP + 32];
84202d14:	4b d8       	r1 = M[FP + 36];
84202d16:	12 31       	r0 = r0 + 36;
84202d18:	1b 31       	r1 = r1 + 36;

84202d1a <Lc_ahm_update_filter_coeffs_89>:
84202d1a:	74 d8       	r2 = M[FP + 56];
84202d1c:	24 54       	r2 = r2 LSHIFT 1;
84202d1e:	08 05       	Null = rMAC - r2;
84202d20:	02 f0 91 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_91;

84202d24 <Lc_ahm_update_filter_coeffs_90>:
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
84202d24:	1c e8       	r2 = M[r1 + Null];
84202d26:	14 ee       	M[r0 + Null] = r2;
                        stream_anc_set_anc_iir_foreground_coeffs(
                        (STREAM_ANC_INSTANCE) instance, (STREAM_ANC_PATH) path,
                        denom_taps + numer_taps, coeffs);
                    #endif
                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
84202d28:	89 20       	rMAC = rMAC + 2;
84202d2a:	12 21       	r0 = r0 + 4;
84202d2c:	1b 21       	r1 = r1 + 4;
84202d2e:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_89;

84202d30 <Lc_ahm_update_filter_coeffs_91>:
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202d30:	01 00       	rMAC = Null + Null;
84202d32:	42 d8       	r0 = M[FP + 32];
84202d34:	4b d8       	r1 = M[FP + 36];

84202d36 <Lc_ahm_update_filter_coeffs_92>:
84202d36:	7c d8       	r2 = M[FP + 60];
84202d38:	24 54       	r2 = r2 LSHIFT 1;
84202d3a:	08 05       	Null = rMAC - r2;
84202d3c:	02 f0 a7 e0 	if C jump (m) Lc_ahm_update_filter_coeffs_96;

84202d40 <Lc_ahm_update_filter_coeffs_93>:
                    {
                        (p_prev_iir->ff).p_num[j] = (p_iir->ff).p_num[j];
84202d40:	1c e8       	r2 = M[r1 + Null];
84202d42:	14 ee       	M[r0 + Null] = r2;
                    /* copy previous iir ff filters */
                    for (i = 0, j = 0; i < 2 * denom_taps; i += 2, j += 1)
                    {
                        (p_prev_iir->ff).p_den[j] = (p_iir->ff).p_den[j];
                    }
                    for (i = 0, j = 0; i < 2 * numer_taps; i += 2, j += 1)
84202d44:	89 20       	rMAC = rMAC + 2;
84202d46:	12 21       	r0 = r0 + 4;
84202d48:	1b 21       	r1 = r1 + 4;
84202d4a:	f6 6f       	jump (m) Lc_ahm_update_filter_coeffs_92;

84202d4c <Lc_ahm_update_filter_coeffs_94>:
                UNUSED(coeffs);
        }
    }
    else
    {
        L2_DBG_MSG1("OPID: %x, Unsupported configuration", ext_op_id);
84202d4c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202d50:	88 24       	Null = rMAC - 2;
84202d52:	08 68       	if LT jump (m) Lc_ahm_update_filter_coeffs_96;

84202d54 <Lc_ahm_update_filter_coeffs_95>:
84202d54:	55 f1 02 f0 	r0 = Null + 357567440;
84202d58:	d0 53 
84202d5a:	63 d8       	r1 = M[FP + 48];
84202d5c:	ef fd f1 ff 	call (m) 0x10c2;
84202d60:	27 eb 

84202d62 <Lc_ahm_update_filter_coeffs_96>:
    }
}
84202d62:	9a f3 10 cf 	SP = SP + -204;
84202d66:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202d68:	d8 4c       	rts;

84202d6a <$_check_filters_equal>:
#include "anc_hw_manager_filter.h"


bool check_filters_equal(uint32 *prev, uint32 *cur, uint32 length)
{
    for (int i = 0; i < length; i++)
84202d6a:	01 00       	rMAC = Null + Null;
84202d6c:	04 6e       	jump (m) Lc_check_filters_equal_3;

84202d6e <Lc_check_filters_equal_2>:
84202d6e:	49 20       	rMAC = rMAC + 1;
84202d70:	12 21       	r0 = r0 + 4;
84202d72:	1b 21       	r1 = r1 + 4;

84202d74 <Lc_check_filters_equal_3>:
84202d74:	08 05       	Null = rMAC - r2;
84202d76:	02 f0 91 e0 	if C jump (m) Lc_check_filters_equal_6;

84202d7a <Lc_check_filters_equal_4>:
    {
        if (prev[i] != cur[i])
84202d7a:	15 e8       	r3 = M[r0 + Null];
84202d7c:	3f f5 80 c2 	Null = r3 - M[r1];
84202d80:	f7 61       	if EQ jump (m) Lc_check_filters_equal_2;

84202d82 <Lc_check_filters_equal_5>:
        {
            return FALSE;
84202d82:	02 00       	r0 = Null + Null;
84202d84:	02 6e       	jump (m) Lc_check_filters_equal_7;

84202d86 <Lc_check_filters_equal_6>:
        }
    }
    return TRUE;
84202d86:	42 20       	r0 = Null + 1;

84202d88 <Lc_check_filters_equal_7>:
84202d88:	d8 4c       	rts;

84202d8a <$_ANC_HW_MANAGER_GetDefaults>:
84202d8a:	20 f0 d7 24 	Null = r0 - 215;
   0x000028F6u,			// SLOW_MODE_DELAY_DURATION
   0x000028F6u			// START_MODE_DELAY_DURATION
};

unsigned *ANC_HW_MANAGER_GetDefaults(unsigned capid){
	switch(capid){
84202d8e:	05 60       	if EQ jump (m) Lc_ANC_HW_MANAGER_GetDefaults_3;

84202d90 <Lc_ANC_HW_MANAGER_GetDefaults_2>:
84202d90:	01 f0 20 f0 	Null = r0 - 16568;
84202d94:	b8 24 
84202d96:	05 62       	if NE jump (m) Lc_ANC_HW_MANAGER_GetDefaults_4;

84202d98 <Lc_ANC_HW_MANAGER_GetDefaults_3>:
		case 0x00D7: return defaults_anc_hw_managerANC_HW_MANAGER;
84202d98:	f1 ff 02 f3 	r0 = Null + -15335424;
84202d9c:	00 40 
84202d9e:	02 6e       	jump (m) Lc_ANC_HW_MANAGER_GetDefaults_5;

84202da0 <Lc_ANC_HW_MANAGER_GetDefaults_4>:
		case 0x40B8: return defaults_anc_hw_managerANC_HW_MANAGER;
	}
	return((unsigned *)0);
84202da0:	02 00       	r0 = Null + Null;

84202da2 <Lc_ANC_HW_MANAGER_GetDefaults_5>:
84202da2:	d8 4c       	rts;

84202da4 <$_aud_cur_create>:
84202da4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
}

bool aud_cur_create(OPERATOR_DATA *op_data,
                    unsigned max_sources,
                    unsigned max_sinks)
{
84202da6:	16 00       	r4 = r0 + Null;
84202da8:	1f 00       	r5 = r1 + Null;
84202daa:	20 09       	r6 = r2 + Null;

    unsigned input_size, output_size;
    AUDIO_CURATION_DEF *ptr;

    /* Allocate class data including space for linked lists */
    output_size = max_sources * sizeof(tCbuffer);
84202dac:	3a 47       	r0 = r5 * 28 (int);
    input_size = max_sinks * sizeof(tCbuffer);
84202dae:	0e f8 91 c9 	rMAC = r6 * 28 (int);

    ptr = (AUDIO_CURATION_DEF*)xzpmalloc(sizeof(AUDIO_CURATION_DEF) + \
        input_size + output_size);
84202db2:	c3 20       	r1 = Null + 3;
84202db4:	51 00       	rMAC = r0 + rMAC;
84202db6:	12 f0 64 20 	r0 = rMAC + 100;
84202dba:	ff fd 20 f0 	call (m) 0x6f8e;
84202dbe:	35 ee 
84202dc0:	11 09       	r7 = r0 + Null;

    if (ptr == NULL)
84202dc2:	0d 62       	if NE jump (m) Lc_aud_cur_create_5;

84202dc4 <Lc_aud_cur_create_2>:
    {
          L4_DBG_MSG("base aud cur create: class allocation failed.");
84202dc4:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202dc8:	08 25       	Null = rMAC - 4;
84202dca:	07 68       	if LT jump (m) Lc_aud_cur_create_4;

84202dcc <Lc_aud_cur_create_3>:
84202dcc:	55 f1 02 f0 	r0 = Null + 357567745;
84202dd0:	01 59 
84202dd2:	ef fd f1 ff 	call (m) 0x10b0;
84202dd6:	3f e6 

84202dd8 <Lc_aud_cur_create_4>:
          return FALSE;
84202dd8:	02 00       	r0 = Null + Null;
84202dda:	22 6e       	jump (m) Lc_aud_cur_create_6;

84202ddc <Lc_aud_cur_create_5>:
    }

    ptr->sources.max = (uint16)max_sources;
84202ddc:	97 f0 0a 8c 	MH[r7 + 20] = r5;
    ptr->sinks.max = (uint16)max_sinks;
84202de0:	98 f0 04 8c 	MH[r7 + 8] = r6;

    ptr->sinks.p_buffer_list = (tCbuffer**)&ptr->buffer_data;
84202de4:	91 f0 64 20 	rMAC = r7 + 100;
84202de8:	91 f0 04 8e 	M[r7 + 16] = rMAC;
    ptr->sources.p_buffer_list = ptr->sinks.p_buffer_list + max_sources;
84202dec:	7a 54       	r0 = r5 LSHIFT 2;
84202dee:	51 00       	rMAC = r0 + rMAC;
84202df0:	91 f0 07 8e 	M[r7 + 28] = rMAC;

    ptr->buffer_size = 2 * AUD_CUR_DEFAULT_BLOCK_SIZE;
84202df4:	81 20       	rMAC = Null + 2;
84202df6:	91 f0 08 8e 	M[r7 + 32] = rMAC;
    ptr->block_size  = AUD_CUR_DEFAULT_BLOCK_SIZE;
84202dfa:	41 20       	rMAC = Null + 1;
84202dfc:	91 f0 09 8e 	M[r7 + 36] = rMAC;

    ptr->cap_id = base_op_get_cap_id(op_data);
84202e00:	32 00       	r0 = r4 + Null;
84202e02:	ef fd ed ff 	call (m) 0x8ee;
84202e06:	2d e7 
84202e08:	92 f0 0f 8e 	M[r7 + 60] = r0;

    ptr->re_init_flag = TRUE;
84202e0c:	41 20       	rMAC = Null + 1;
84202e0e:	91 f0 00 ea 	MB[r7 + Null] = rMAC;
 * \return - NONE
 */
static inline void set_class_data(OPERATOR_DATA *op_data,
                                  AUDIO_CURATION_DEF *class_data)
{
    base_op_set_class_ext(op_data, class_data);
84202e12:	4b 08       	r1 = r7 + Null;
84202e14:	32 00       	r0 = r4 + Null;
84202e16:	ef fd ed ff 	call (m) 0x938;
84202e1a:	23 e9 
    ptr->re_init_flag = TRUE;

    /* Save Pointer to channel definition in operator data */
    set_class_data(op_data, ptr);

    return TRUE;
84202e1c:	42 20       	r0 = Null + 1;

84202e1e <Lc_aud_cur_create_6>:
}
84202e1e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202e20:	d8 4c       	rts;

84202e22 <$_aud_cur_destroy>:

void aud_cur_destroy(OPERATOR_DATA *op_data)
{
84202e22:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202e24:	16 00       	r4 = r0 + Null;
 * \return - Pointer to the class data
 */

static inline AUDIO_CURATION_DEF *get_class_data(OPERATOR_DATA *op_data)
{
    return (AUDIO_CURATION_DEF *) base_op_get_class_ext(op_data);
84202e26:	ef fd ed ff 	call (m) 0x934;
84202e2a:	2f e8 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    if (p_class_data == NULL)
84202e2c:	10 04       	Null = r0 - Null;
84202e2e:	09 60       	if EQ jump (m) Lc_aud_cur_destroy_3;

84202e30 <Lc_aud_cur_destroy_2>:
    {
        return;
    }

    pfree(p_class_data);
84202e30:	ff fd 20 f0 	call (m) 0x6fbe;
84202e34:	2f ec 
    set_class_data(op_data, NULL);
84202e36:	03 00       	r1 = Null + Null;
 * \return - NONE
 */
static inline void set_class_data(OPERATOR_DATA *op_data,
                                  AUDIO_CURATION_DEF *class_data)
{
    base_op_set_class_ext(op_data, class_data);
84202e38:	32 00       	r0 = r4 + Null;
84202e3a:	ef fd ed ff 	call (m) 0x938;
84202e3e:	3f e7 

84202e40 <Lc_aud_cur_destroy_3>:
    }

    pfree(p_class_data);
    set_class_data(op_data, NULL);
    return;
}
84202e40:	f1 48       	popm <FP, r4, rLink>;
84202e42:	d8 4c       	rts;

84202e44 <$_aud_cur_connect>:

bool aud_cur_connect(OPERATOR_DATA *op_data,
                     void *message_data,
                     unsigned *response_id,
                     void **response_data)
{
84202e44:	c8 1c       	pushm <FP(=SP), rLink>;
    return aud_cur_connect_common(op_data,
                                  message_data,
                                  response_id,
                                  response_data,
                                  TRUE);
84202e46:	00 f0 51 e0 	push Null + 1;
84202e4a:	02 f0 2b ed 	call (m) Lc_aud_cur_connect_common_1;
84202e4e:	7f 4c       	SP = SP + -4;

84202e50 <Lc_aud_cur_connect_2>:
}
84202e50:	c8 48       	popm <FP, rLink>;
84202e52:	d8 4c       	rts;

84202e54 <$_aud_cur_disconnect>:

bool aud_cur_disconnect(OPERATOR_DATA *op_data,
                        void *message_data,
                        unsigned *response_id,
                        void **response_data)
{
84202e54:	c8 1c       	pushm <FP(=SP), rLink>;
    return aud_cur_connect_common(op_data,
                                  message_data,
                                  response_id,
                                  response_data,
                                  FALSE);
84202e56:	00 f0 30 cf 	push Null;
84202e5a:	02 f0 3b ec 	call (m) Lc_aud_cur_connect_common_1;
84202e5e:	7f 4c       	SP = SP + -4;

84202e60 <Lc_aud_cur_disconnect_2>:
}
84202e60:	c8 48       	popm <FP, rLink>;
84202e62:	d8 4c       	rts;

84202e64 <$_aud_cur_buffer_details>:

bool aud_cur_buffer_details(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *response_id,
                            void **response_data)
{
84202e64:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84202e66:	17 00       	r5 = r0 + Null;
84202e68:	19 09       	r7 = r1 + Null;
84202e6a:	2e 00       	r4 = r3 + Null;
84202e6c:	ef fd ed ff 	call (m) 0x934;
84202e70:	29 e6 
84202e72:	10 09       	r6 = r0 + Null;
    tCbuffer **p_metadata;
    unsigned terminal_id, buffer_size;
    uint16 terminal_num;
    bool is_sink;

    if (!base_op_buffer_details_lite(op_data, response_data))
84202e74:	33 00       	r1 = r4 + Null;
84202e76:	3a 00       	r0 = r5 + Null;
84202e78:	ef fd ec ff 	call (m) 0x842;
84202e7c:	2b ee 
84202e7e:	10 04       	Null = r0 - Null;
84202e80:	03 62       	if NE jump (m) Lc_aud_cur_buffer_details_3;

84202e82 <Lc_aud_cur_buffer_details_2>:
    {
        return FALSE;
84202e82:	02 00       	r0 = Null + Null;
84202e84:	4f 6e       	jump (m) Lc_aud_cur_buffer_details_20;

84202e86 <Lc_aud_cur_buffer_details_3>:
    }

    p_resp = (OP_BUF_DETAILS_RSP*) *response_data;
84202e86:	31 e8       	rMAC = M[r4 + Null];

    /* Make sure the buffer size is at least adequate for the capability */
    buffer_size = p_resp->b.buffer_size;
84202e88:	4f 89       	r5 = M[rMAC + 20];
    if (buffer_size < p_class_data->buffer_size)
84202e8a:	82 f0 08 88 	r0 = M[r6 + 32];
84202e8e:	b8 04       	Null = r5 - r0;
84202e90:	02 f0 87 e0 	if C jump (m) Lc_aud_cur_buffer_details_5;

84202e94 <Lc_aud_cur_buffer_details_4>:
    {
        buffer_size = p_class_data->buffer_size;
84202e94:	17 00       	r5 = r0 + Null;

84202e96 <Lc_aud_cur_buffer_details_5>:
    }

    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84202e96:	95 f0 00 e8 	r3 = M[r7 + Null];
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
84202e9a:	ab c2       	r1 = r3 AND 0x3f;
    is_sink = terminal_id & TERMINAL_SINK_MASK;

    /* Setup the selected terminal */
    if (is_sink)
84202e9c:	40 f0 52 f0 	r0 = r3 AND 0x800000;
84202ea0:	00 00 
84202ea2:	07 60       	if EQ jump (m) Lc_aud_cur_buffer_details_7;

84202ea4 <Lc_aud_cur_buffer_details_6>:
    {
        /* Select source (opposite to the given buffer) */
        p_opposite_terminal = &p_class_data->sources;
84202ea4:	84 f0 14 20 	r2 = r6 + 20;
84202ea8:	22 00       	r0 = r2 + Null;
        p_metadata = p_class_data->metadata_ip;
84202eaa:	04 f0 40 44 	r2 = r2 + 64;
84202eae:	06 6e       	jump (m) Lc_aud_cur_buffer_details_8;

84202eb0 <Lc_aud_cur_buffer_details_7>:
    }
    else
    {
        /* Select sink (opposite to the given buffer) */
        p_opposite_terminal = &p_class_data->sinks;
84202eb0:	84 f0 08 20 	r2 = r6 + 8;
84202eb4:	22 00       	r0 = r2 + Null;
        p_metadata = p_class_data->metadata_op;
84202eb6:	04 f0 54 44 	r2 = r2 + 84;

84202eba <Lc_aud_cur_buffer_details_8>:
    }

    if (p_class_data->in_place_flag)
84202eba:	89 f0 01 82 	r7 = MBU[r6 + 1];
84202ebe:	22 60       	if EQ jump (m) Lc_aud_cur_buffer_details_14;

84202ec0 <Lc_aud_cur_buffer_details_9>:
    {
        /* Make sure the terminal is valid */
        if (terminal_num >= p_opposite_terminal->max)
84202ec0:	29 f0 00 e6 	r7 = MHU[r0 + Null];
84202ec4:	9f f3 00 c2 	Null = r1 - r7;
84202ec8:	10 68       	if LT jump (m) Lc_aud_cur_buffer_details_13;

84202eca <Lc_aud_cur_buffer_details_10>:
        {
            L4_DBG_MSG1("base aud cur details: invalid terminal number %d",
                        terminal_num);
84202eca:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84202ece:	08 25       	Null = rMAC - 4;
84202ed0:	07 68       	if LT jump (m) Lc_aud_cur_buffer_details_12;

84202ed2 <Lc_aud_cur_buffer_details_11>:
84202ed2:	55 f1 02 f0 	r0 = Null + 357567791;
84202ed6:	2f 59 
84202ed8:	ef fd f0 ff 	call (m) 0x10c2;
84202edc:	2b ef 

84202ede <Lc_aud_cur_buffer_details_12>:
84202ede:	01 f0 00 60 	rMAC = Null + 4096;
84202ee2:	32 e8       	r0 = M[r4 + Null];
84202ee4:	51 8e       	M[r0 + 4] = rMAC;
84202ee6:	1d 6e       	jump (m) Lc_aud_cur_buffer_details_19;

84202ee8 <Lc_aud_cur_buffer_details_13>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        /* Setup in-place payload */
        p_resp->runs_in_place = TRUE;
84202ee8:	46 20       	r4 = Null + 1;
84202eea:	ce 9a       	MB[rMAC + 11] = r4;
        p_resp->b.in_place_buff_params.in_place_terminal = \
            SWAP_TERMINAL_DIRECTION(terminal_id);
84202eec:	08 f0 00 f0 	r3 = r3 XOR 0x800000;
84202ef0:	00 f5 95 c8 
84202ef4:	4d 8f       	M[rMAC + 20] = r3;
        p_resp->b.in_place_buff_params.size = buffer_size;
84202ef6:	8f 8f       	M[rMAC + 24] = r5;
 * \return - pointer to the terminal cbuffer
 */
static inline tCbuffer *aud_cur_get_terminal(AUD_CUR_TERMINAL *p_def,
                                             uint16 num)
{
    return p_def->p_buffer_list[num];
84202ef8:	92 88       	r0 = M[r0 + 8];
84202efa:	5d 54       	r3 = r1 LSHIFT 2;
84202efc:	52 e9       	r0 = M[r0 + r3];
}
84202efe:	ca 8f       	M[rMAC + 28] = r0;
84202f00:	03 6e       	jump (m) Lc_aud_cur_buffer_details_15;

84202f02 <Lc_aud_cur_buffer_details_14>:
        p_resp->b.in_place_buff_params.buffer = \
            aud_cur_get_terminal(p_opposite_terminal, terminal_num);
    }
    else
    {
        p_resp->runs_in_place = FALSE;
84202f02:	c8 9a       	MB[rMAC + 11] = Null;
        p_resp->b.buffer_size = buffer_size;
84202f04:	4f 8f       	M[rMAC + 20] = r5;

84202f06 <Lc_aud_cur_buffer_details_15>:
    }

    /* Populate metadata response */
    p_resp->supports_metadata = p_class_data->supports_metadata_flag;
84202f06:	82 f0 02 82 	r0 = MBU[r6 + 2];
84202f0a:	0a 9b       	MB[rMAC + 12] = r0;
    if (p_class_data->supports_metadata_flag)
84202f0c:	82 f0 02 82 	r0 = MBU[r6 + 2];
84202f10:	08 60       	if EQ jump (m) Lc_aud_cur_buffer_details_19;

84202f12 <Lc_aud_cur_buffer_details_16>:
    {
        if (terminal_num == AUD_CUR_PLAYBACK_TERMINAL)
84202f12:	18 04       	Null = r1 - Null;
84202f14:	04 62       	if NE jump (m) Lc_aud_cur_buffer_details_18;

84202f16 <Lc_aud_cur_buffer_details_17>:
        {
            p_resp->metadata_buffer = p_metadata[AUD_CUR_METADATA_PLAYBACK];
84202f16:	22 e8       	r0 = M[r2 + Null];
84202f18:	0a 8f       	M[rMAC + 16] = r0;
84202f1a:	03 6e       	jump (m) Lc_aud_cur_buffer_details_19;

84202f1c <Lc_aud_cur_buffer_details_18>:
        }
        else
        {
            p_resp->metadata_buffer = p_metadata[AUD_CUR_METADATA_MIC];
84202f1c:	62 88       	r0 = M[r2 + 4];
84202f1e:	0a 8f       	M[rMAC + 16] = r0;

84202f20 <Lc_aud_cur_buffer_details_19>:
        }
    }

    return TRUE;
84202f20:	42 20       	r0 = Null + 1;

84202f22 <Lc_aud_cur_buffer_details_20>:
}
84202f22:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202f24:	d8 4c       	rts;

84202f26 <$_aud_cur_start>:

bool aud_cur_start(OPERATOR_DATA *op_data,
                   void *message_data,
                   unsigned *response_id,
                   void **response_data)
{
84202f26:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202f28:	16 00       	r4 = r0 + Null;
84202f2a:	19 09       	r7 = r1 + Null;
84202f2c:	27 00       	r5 = r2 + Null;
84202f2e:	2a 09       	r8 = r3 + Null;
84202f30:	ef fd ed ff 	call (m) 0x934;
84202f34:	25 e0 
84202f36:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    /* Create the response. If there aren't sufficient resources for this fail
     * early.
     */
    if (!base_op_start(op_data, message_data, response_id, response_data))
84202f38:	55 08       	r3 = r8 + Null;
84202f3a:	3c 00       	r2 = r5 + Null;
84202f3c:	4b 08       	r1 = r7 + Null;
84202f3e:	32 00       	r0 = r4 + Null;
84202f40:	ef fd eb ff 	call (m) 0x730;
84202f44:	31 ef 
84202f46:	10 04       	Null = r0 - Null;
84202f48:	03 62       	if NE jump (m) Lc_aud_cur_start_3;

84202f4a <Lc_aud_cur_start_2>:
    {
        return FALSE;
84202f4a:	02 00       	r0 = Null + Null;
84202f4c:	23 6e       	jump (m) Lc_aud_cur_start_11;

84202f4e <Lc_aud_cur_start_3>:
    }

    /* If already running just ack */
    if (opmgr_op_is_running(op_data))
84202f4e:	32 00       	r0 = r4 + Null;
84202f50:	ff fd 16 f0 	call (m) 0x5ca4;
84202f54:	35 ea 
84202f56:	10 04       	Null = r0 - Null;
84202f58:	12 62       	if NE jump (m) Lc_aud_cur_start_7;

84202f5a <Lc_aud_cur_start_4>:
       return TRUE;
    }

    /* Make sure we have valid terminal connections */
    if (!aud_cur_check_valid_terminals(&p_class_data->sinks) ||
        !aud_cur_check_valid_terminals(&p_class_data->sources))
84202f5a:	82 f0 08 20 	r0 = r6 + 8;
84202f5e:	02 f0 27 ef 	call (m) Lc_aud_cur_check_valid_terminals_1;
84202f62:	10 04       	Null = r0 - Null;
84202f64:	07 60       	if EQ jump (m) Lc_aud_cur_start_6;

84202f66 <Lc_aud_cur_start_5>:
84202f66:	82 f0 14 20 	r0 = r6 + 20;
84202f6a:	02 f0 3b ee 	call (m) Lc_aud_cur_check_valid_terminals_1;
84202f6e:	10 04       	Null = r0 - Null;
84202f70:	08 62       	if NE jump (m) Lc_aud_cur_start_8;

84202f72 <Lc_aud_cur_start_6>:
84202f72:	01 f0 00 60 	rMAC = Null + 4096;
84202f76:	a2 f0 00 e8 	r0 = M[r8 + Null];
84202f7a:	51 8e       	M[r0 + 4] = rMAC;

84202f7c <Lc_aud_cur_start_7>:
    }

    /* If already running just ack */
    if (opmgr_op_is_running(op_data))
    {
       return TRUE;
84202f7c:	42 20       	r0 = Null + 1;
84202f7e:	0a 6e       	jump (m) Lc_aud_cur_start_11;

84202f80 <Lc_aud_cur_start_8>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (p_class_data->start_fn != NULL)
84202f80:	81 f0 10 88 	rMAC = M[r6 + 64];
84202f84:	03 60       	if EQ jump (m) Lc_aud_cur_start_10;

84202f86 <Lc_aud_cur_start_9>:
    {
        p_class_data->start_fn(op_data);
84202f86:	32 00       	r0 = r4 + Null;
84202f88:	d1 4c       	call rMAC;

84202f8a <Lc_aud_cur_start_10>:
    }

    /* Reinitialize the operator */
    p_class_data->re_init_flag = TRUE;
84202f8a:	41 20       	rMAC = Null + 1;
84202f8c:	81 f0 00 ea 	MB[r6 + Null] = rMAC;
84202f90:	f6 6f       	jump (m) Lc_aud_cur_start_7;

84202f92 <Lc_aud_cur_start_11>:

    return TRUE;
}
84202f92:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84202f94:	d8 4c       	rts;

84202f96 <$_aud_cur_stop>:

bool aud_cur_stop(OPERATOR_DATA *op_data,
                  void *message_data,
                  unsigned *response_id,
                  void **response_data)
{
84202f96:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202f98:	16 00       	r4 = r0 + Null;
84202f9a:	1a 09       	r8 = r1 + Null;
84202f9c:	27 00       	r5 = r2 + Null;
84202f9e:	29 09       	r7 = r3 + Null;
84202fa0:	ef fd ec ff 	call (m) 0x934;
84202fa4:	35 ec 
84202fa6:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_stop(op_data, message_data, response_id, response_data))
84202fa8:	4d 08       	r3 = r7 + Null;
84202faa:	3c 00       	r2 = r5 + Null;
84202fac:	53 08       	r1 = r8 + Null;
84202fae:	32 00       	r0 = r4 + Null;
84202fb0:	ef fd eb ff 	call (m) 0x73c;
84202fb4:	2d ec 
84202fb6:	10 04       	Null = r0 - Null;
84202fb8:	03 62       	if NE jump (m) Lc_aud_cur_stop_3;

84202fba <Lc_aud_cur_stop_2>:
    {
        return FALSE;
84202fba:	02 00       	r0 = Null + Null;
84202fbc:	07 6e       	jump (m) Lc_aud_cur_stop_6;

84202fbe <Lc_aud_cur_stop_3>:
    }

    if (p_class_data->stop_fn != NULL)
84202fbe:	81 f0 11 88 	rMAC = M[r6 + 68];
84202fc2:	03 60       	if EQ jump (m) Lc_aud_cur_stop_5;

84202fc4 <Lc_aud_cur_stop_4>:
    {
        p_class_data->stop_fn(op_data);
84202fc4:	32 00       	r0 = r4 + Null;
84202fc6:	d1 4c       	call rMAC;

84202fc8 <Lc_aud_cur_stop_5>:
    }

    return TRUE;
84202fc8:	42 20       	r0 = Null + 1;

84202fca <Lc_aud_cur_stop_6>:
}
84202fca:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84202fcc:	d8 4c       	rts;

84202fce <$_aud_cur_reset>:

bool aud_cur_reset(OPERATOR_DATA *op_data,
                   void *message_data,
                   unsigned *response_id,
                   void **response_data)
{
84202fce:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202fd0:	16 00       	r4 = r0 + Null;
84202fd2:	1a 09       	r8 = r1 + Null;
84202fd4:	27 00       	r5 = r2 + Null;
84202fd6:	29 09       	r7 = r3 + Null;
84202fd8:	ef fd ec ff 	call (m) 0x934;
84202fdc:	3d ea 
84202fde:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_reset(op_data, message_data, response_id, response_data))
84202fe0:	4d 08       	r3 = r7 + Null;
84202fe2:	3c 00       	r2 = r5 + Null;
84202fe4:	53 08       	r1 = r8 + Null;
84202fe6:	32 00       	r0 = r4 + Null;
84202fe8:	ef fd eb ff 	call (m) 0x724;
84202fec:	3d e9 
84202fee:	10 04       	Null = r0 - Null;
84202ff0:	03 62       	if NE jump (m) Lc_aud_cur_reset_3;

84202ff2 <Lc_aud_cur_reset_2>:
    {
        return FALSE;
84202ff2:	02 00       	r0 = Null + Null;
84202ff4:	05 6e       	jump (m) Lc_aud_cur_reset_4;

84202ff6 <Lc_aud_cur_reset_3>:
    }

    p_class_data->re_init_flag = TRUE;
84202ff6:	41 20       	rMAC = Null + 1;
84202ff8:	81 f0 00 ea 	MB[r6 + Null] = rMAC;

    return TRUE;
84202ffc:	0a 00       	r0 = rMAC + Null;

84202ffe <Lc_aud_cur_reset_4>:
}
84202ffe:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84203000:	d8 4c       	rts;

84203002 <$_aud_cur_opmsg_set_buffer_size>:

bool aud_cur_opmsg_set_buffer_size(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *resp_length,
                                   OP_OPMSG_RSP_PAYLOAD **response_data)
{
84203002:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84203004:	16 00       	r4 = r0 + Null;
84203006:	1f 00       	r5 = r1 + Null;
84203008:	ef fd ec ff 	call (m) 0x934;
8420300c:	2d e9 
8420300e:	10 09       	r6 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    unsigned buffer_size;

    if (opmgr_op_is_running(op_data))
84203010:	32 00       	r0 = r4 + Null;
84203012:	ff fd 16 f0 	call (m) 0x5ca4;
84203016:	33 e4 
84203018:	10 04       	Null = r0 - Null;
8420301a:	0d 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_buffer_size_5;

8420301c <Lc_aud_cur_opmsg_set_buffer_size_2>:
    {
        L2_DBG_MSG("base aud cur set buffer size failed: operator running");
8420301c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84203020:	88 24       	Null = rMAC - 2;
84203022:	07 68       	if LT jump (m) Lc_aud_cur_opmsg_set_buffer_size_4;

84203024 <Lc_aud_cur_opmsg_set_buffer_size_3>:
84203024:	55 f1 02 f0 	r0 = Null + 357567840;
84203028:	60 59 
8420302a:	ef fd f0 ff 	call (m) 0x10b0;
8420302e:	27 e4 

84203030 <Lc_aud_cur_opmsg_set_buffer_size_4>:
        return FALSE;
84203030:	02 00       	r0 = Null + Null;
84203032:	25 6e       	jump (m) Lc_aud_cur_opmsg_set_buffer_size_13;

84203034 <Lc_aud_cur_opmsg_set_buffer_size_5>:
    }

    if (!p_class_data->dynamic_buffer_size_flag)
84203034:	81 f0 03 82 	rMAC = MBU[r6 + 3];
84203038:	0c 62       	if NE jump (m) Lc_aud_cur_opmsg_set_buffer_size_8;

8420303a <Lc_aud_cur_opmsg_set_buffer_size_6>:
    {
        L2_DBG_MSG("base aud cur set buffer size failed: unsupported");
8420303a:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420303e:	88 24       	Null = rMAC - 2;
84203040:	f8 69       	if LT jump (m) Lc_aud_cur_opmsg_set_buffer_size_4;

84203042 <Lc_aud_cur_opmsg_set_buffer_size_7>:
84203042:	55 f1 02 f0 	r0 = Null + 357567894;
84203046:	96 59 
84203048:	ef fd f0 ff 	call (m) 0x10b0;
8420304c:	29 e3 
8420304e:	f1 6f       	jump (m) Lc_aud_cur_opmsg_set_buffer_size_4;

84203050 <Lc_aud_cur_opmsg_set_buffer_size_8>:
        return FALSE;
    }

    if ((p_class_data->sinks.connected > 0) ||
        (p_class_data->sources.connected > 0))
84203050:	81 f0 07 86 	rMAC = MHU[r6 + 14];
84203054:	04 62       	if NE jump (m) Lc_aud_cur_opmsg_set_buffer_size_10;

84203056 <Lc_aud_cur_opmsg_set_buffer_size_9>:
84203056:	81 f0 0d 86 	rMAC = MHU[r6 + 26];
8420305a:	0c 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_buffer_size_12;

8420305c <Lc_aud_cur_opmsg_set_buffer_size_10>:
    {
        L2_DBG_MSG("base aud cur set buffer size failed: already connected");
8420305c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84203060:	88 24       	Null = rMAC - 2;
84203062:	e7 69       	if LT jump (m) Lc_aud_cur_opmsg_set_buffer_size_4;

84203064 <Lc_aud_cur_opmsg_set_buffer_size_11>:
84203064:	55 f1 02 f0 	r0 = Null + 357567943;
84203068:	c7 59 
8420306a:	ef fd f0 ff 	call (m) 0x10b0;
8420306e:	27 e2 
84203070:	e0 6f       	jump (m) Lc_aud_cur_opmsg_set_buffer_size_4;

84203072 <Lc_aud_cur_opmsg_set_buffer_size_12>:
        return FALSE;
    }

    buffer_size = OPMSG_FIELD_GET(message_data,
                                  OPMSG_COMMON_SET_BUFFER_SIZE,
                                  BUFFER_SIZE);
84203072:	f9 88       	rMAC = M[r5 + 12];
84203074:	8b c6       	r1 = rMAC AND 0xffff;
    aud_cur_set_buffer_size(op_data, buffer_size);
84203076:	32 00       	r0 = r4 + Null;
84203078:	53 4e       	call (m) $_aud_cur_set_buffer_size;

    return TRUE;
8420307a:	42 20       	r0 = Null + 1;

8420307c <Lc_aud_cur_opmsg_set_buffer_size_13>:
}
8420307c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420307e:	d8 4c       	rts;

84203080 <$_aud_cur_get_sched_info>:

bool aud_cur_get_sched_info(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *response_id,
                            void **response_data)
{
84203080:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84203082:	16 00       	r4 = r0 + Null;
84203084:	1a 09       	r8 = r1 + Null;
84203086:	20 09       	r6 = r2 + Null;
84203088:	2f 00       	r5 = r3 + Null;
8420308a:	ef fd ec ff 	call (m) 0x934;
8420308e:	2b e5 
84203090:	11 09       	r7 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84203092:	44 08       	r2 = r6 + Null;
84203094:	53 08       	r1 = r8 + Null;
84203096:	32 00       	r0 = r4 + Null;
84203098:	ef fd eb ff 	call (m) 0x7f6;
8420309c:	3f ea 
    if (resp == NULL)
8420309e:	10 04       	Null = r0 - Null;
842030a0:	09 62       	if NE jump (m) Lc_aud_cur_get_sched_info_3;

842030a2 <Lc_aud_cur_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED,
                                             response_data);
842030a2:	03 f0 00 60 	r1 = Null + 4096;
842030a6:	3c 00       	r2 = r5 + Null;
842030a8:	32 00       	r0 = r4 + Null;
842030aa:	ef fd ec ff 	call (m) 0x8c0;
842030ae:	37 e0 
842030b0:	06 6e       	jump (m) Lc_aud_cur_get_sched_info_4;

842030b2 <Lc_aud_cur_get_sched_info_3>:
    }

    *response_data = resp;
842030b2:	3a ee       	M[r5 + Null] = r0;
    resp->block_size = p_class_data->block_size;
842030b4:	91 f0 09 88 	rMAC = M[r7 + 36];
842030b8:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
842030ba:	42 20       	r0 = Null + 1;

842030bc <Lc_aud_cur_get_sched_info_4>:
}
842030bc:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842030be:	d8 4c       	rts;

842030c0 <$_aud_cur_set_callbacks>:
                           AUD_CUR_START_FN start_fn,
                           AUD_CUR_STOP_FN stop_fn,
                           AUD_CUR_CONNECT_FN connect_fn,
                           AUD_CUR_DISCONNECT_FN disconnect_fn,
                           AUD_CUR_PARAM_UPDATE_FN param_update_fn)
{
842030c0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842030c2:	1e 00       	r4 = r1 + Null;
842030c4:	27 00       	r5 = r2 + Null;
842030c6:	28 09       	r6 = r3 + Null;
842030c8:	ef fd ec ff 	call (m) 0x934;
842030cc:	2d e3 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    p_class_data->start_fn = start_fn;
842030ce:	16 ae       	M[r0 + 64] = r4;
    p_class_data->stop_fn = stop_fn;
842030d0:	57 ae       	M[r0 + 68] = r5;
    p_class_data->connect_fn = connect_fn;
842030d2:	28 f0 12 8e 	M[r0 + 72] = r6;
    p_class_data->disconnect_fn = disconnect_fn;
842030d6:	f9 d9       	rMAC = M[FP + -4];
842030d8:	d1 ae       	M[r0 + 76] = rMAC;
    p_class_data->param_update_fn = param_update_fn;
842030da:	f1 d9       	rMAC = M[FP + -8];
842030dc:	11 af       	M[r0 + 80] = rMAC;

842030de <Lc_aud_cur_set_callbacks_2>:

    return;
842030de:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842030e0:	d8 4c       	rts;

842030e2 <$_aud_cur_set_flags>:

void aud_cur_set_flags(OPERATOR_DATA *op_data,
                       bool in_place,
                       bool supports_metadata,
                       bool dynamic_buffer_size)
{
842030e2:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842030e4:	1e 00       	r4 = r1 + Null;
842030e6:	27 00       	r5 = r2 + Null;
842030e8:	28 09       	r6 = r3 + Null;
842030ea:	ef fd ec ff 	call (m) 0x934;
842030ee:	2b e2 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    p_class_data->in_place_flag = in_place;
842030f0:	56 8a       	MB[r0 + 1] = r4;
    p_class_data->supports_metadata_flag = supports_metadata;
842030f2:	97 8a       	MB[r0 + 2] = r5;
    p_class_data->dynamic_buffer_size_flag = dynamic_buffer_size;
842030f4:	28 f0 03 8a 	MB[r0 + 3] = r6;

842030f8 <Lc_aud_cur_set_flags_2>:

    return;
842030f8:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842030fa:	d8 4c       	rts;

842030fc <$_aud_cur_set_min_terminal_masks>:


void aud_cur_set_min_terminal_masks(OPERATOR_DATA *op_data,
                                    uint16 source_mask,
                                    uint16 sink_mask)
{
842030fc:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842030fe:	1e 00       	r4 = r1 + Null;
84203100:	27 00       	r5 = r2 + Null;
84203102:	ef fd ec ff 	call (m) 0x934;
84203106:	33 e1 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    p_class_data->sources.min_valid_mask = source_mask;
84203108:	d6 9c       	MH[r0 + 22] = r4;
    p_class_data->sinks.min_valid_mask = sink_mask;
8420310a:	57 8d       	MH[r0 + 10] = r5;

8420310c <Lc_aud_cur_set_min_terminal_masks_2>:

    return;
8420310c:	f2 48       	popm <FP, r4, r5, rLink>;
8420310e:	d8 4c       	rts;

84203110 <$_aud_cur_get_cps>:

    return;
}

CPS_PARAM_DEF *aud_cur_get_cps(OPERATOR_DATA *op_data)
{
84203110:	c8 1c       	pushm <FP(=SP), rLink>;
84203112:	ef fd ec ff 	call (m) 0x934;
84203116:	23 e1 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return &p_class_data->param_def;
84203118:	12 32       	r0 = r0 + 40;

8420311a <Lc_aud_cur_get_cps_2>:
}
8420311a:	c8 48       	popm <FP, rLink>;
8420311c:	d8 4c       	rts;

8420311e <$_aud_cur_set_buffer_size>:

    return;
}

void aud_cur_set_buffer_size(OPERATOR_DATA *op_data, unsigned buffer_size)
{
8420311e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84203120:	1e 00       	r4 = r1 + Null;
84203122:	ef fd ec ff 	call (m) 0x934;
84203126:	33 e0 
   AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
   p_class_data->buffer_size  = buffer_size;
84203128:	16 9e       	M[r0 + 32] = r4;

8420312a <Lc_aud_cur_set_buffer_size_2>:
}
8420312a:	f1 48       	popm <FP, r4, rLink>;
8420312c:	d8 4c       	rts;

8420312e <$_aud_cur_opmsg_get_params>:

bool aud_cur_opmsg_get_params(OPERATOR_DATA *op_data,
                              void *message_data,
                              unsigned *resp_length,
                              OP_OPMSG_RSP_PAYLOAD **response_data)
{
8420312e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84203130:	1f 00       	r5 = r1 + Null;
84203132:	26 00       	r4 = r2 + Null;
84203134:	28 09       	r6 = r3 + Null;
84203136:	ef fd eb ff 	call (m) 0x934;
8420313a:	3f ef 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetParameterMsgHandler(&p_class_data->param_def, message_data,
                                     resp_length, response_data);
8420313c:	12 32       	r0 = r0 + 40;
8420313e:	45 08       	r3 = r6 + Null;
84203140:	34 00       	r2 = r4 + Null;
84203142:	3b 00       	r1 = r5 + Null;
84203144:	ef fd ed ff 	call (m) 0xb7c;
84203148:	39 e1 

8420314a <Lc_aud_cur_opmsg_get_params_2>:
}
8420314a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420314c:	d8 4c       	rts;

8420314e <$_aud_cur_opmsg_get_defaults>:

bool aud_cur_opmsg_get_defaults(OPERATOR_DATA *op_data,
                                void *message_data,
                                unsigned *resp_length,
                                OP_OPMSG_RSP_PAYLOAD **response_data)
{
8420314e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84203150:	1f 00       	r5 = r1 + Null;
84203152:	26 00       	r4 = r2 + Null;
84203154:	28 09       	r6 = r3 + Null;
84203156:	ef fd eb ff 	call (m) 0x934;
8420315a:	3f ee 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetDefaultsMsgHandler(&p_class_data->param_def, message_data,
                                    resp_length, response_data);
8420315c:	12 32       	r0 = r0 + 40;
8420315e:	45 08       	r3 = r6 + Null;
84203160:	34 00       	r2 = r4 + Null;
84203162:	3b 00       	r1 = r5 + Null;
84203164:	ef fd ed ff 	call (m) 0xc2c;
84203168:	29 e6 

8420316a <Lc_aud_cur_opmsg_get_defaults_2>:
}
8420316a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420316c:	d8 4c       	rts;

8420316e <$_aud_cur_opmsg_set_params>:

bool aud_cur_opmsg_set_params(OPERATOR_DATA *op_data,
                              void *message_data,
                              unsigned *resp_length,
                              OP_OPMSG_RSP_PAYLOAD **response_data)
{
8420316e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84203170:	11 09       	r7 = r0 + Null;
84203172:	1a 09       	r8 = r1 + Null;
84203174:	27 00       	r5 = r2 + Null;
84203176:	28 09       	r6 = r3 + Null;
84203178:	ef fd eb ff 	call (m) 0x934;
8420317c:	3d ed 
8420317e:	16 00       	r4 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    bool success;

    success = cpsSetParameterMsgHandler(&p_class_data->param_def, message_data,
                                        resp_length, response_data);
84203180:	32 32       	r0 = r4 + 40;
84203182:	45 08       	r3 = r6 + Null;
84203184:	3c 00       	r2 = r5 + Null;
84203186:	53 08       	r1 = r8 + Null;
84203188:	ef fd ed ff 	call (m) 0xd00;
8420318c:	39 eb 
8420318e:	17 00       	r5 = r0 + Null;

    if (success)
84203190:	07 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_params_5;

84203192 <Lc_aud_cur_opmsg_set_params_2>:
    {
        if (p_class_data->param_update_fn != NULL)
84203192:	31 a9       	rMAC = M[r4 + 80];
84203194:	03 60       	if EQ jump (m) Lc_aud_cur_opmsg_set_params_4;

84203196 <Lc_aud_cur_opmsg_set_params_3>:
        {
            p_class_data->param_update_fn(op_data);
84203196:	4a 08       	r0 = r7 + Null;
84203198:	d1 4c       	call rMAC;

8420319a <Lc_aud_cur_opmsg_set_params_4>:
        }
        /* Set re-initialization flag */
        p_class_data->re_init_flag = TRUE;
8420319a:	41 20       	rMAC = Null + 1;
8420319c:	31 ea       	MB[r4 + Null] = rMAC;

8420319e <Lc_aud_cur_opmsg_set_params_5>:
    }

    return success;
8420319e:	3a 00       	r0 = r5 + Null;

842031a0 <Lc_aud_cur_opmsg_set_params_6>:
}
842031a0:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842031a2:	d8 4c       	rts;

842031a4 <$_aud_cur_ups_params>:
                        PERSISTENCE_RANK rank,
                        uint16 length,
                        unsigned* data,
                        STATUS_KYMERA status,
                        uint16 extra_status_info)
{
842031a4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842031a6:	10 09       	r6 = r0 + Null;
842031a8:	2f 00       	r5 = r3 + Null;
842031aa:	ef fd eb ff 	call (m) 0x934;
842031ae:	2b ec 
842031b0:	16 00       	r4 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*)instance_data;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);

    cpsSetParameterFromPsStore(&p_class_data->param_def, length, data, status);
842031b2:	e5 d5       	r3 = MHS[FP + -8];
842031b4:	fc d9       	r2 = M[FP + -4];
842031b6:	32 32       	r0 = r4 + 40;
842031b8:	3b 00       	r1 = r5 + Null;
842031ba:	ef fd ee ff 	call (m) 0xdf6;
842031be:	3d e1 

    if (p_class_data->param_update_fn != NULL)
842031c0:	31 a9       	rMAC = M[r4 + 80];
842031c2:	03 60       	if EQ jump (m) Lc_aud_cur_ups_params_3;

842031c4 <Lc_aud_cur_ups_params_2>:
    {
        p_class_data->param_update_fn(op_data);
842031c4:	42 08       	r0 = r6 + Null;
842031c6:	d1 4c       	call rMAC;

842031c8 <Lc_aud_cur_ups_params_3>:
    }

    /* Set the re-init flag after the parameters are updated. */
    p_class_data->re_init_flag = TRUE;
842031c8:	41 20       	rMAC = Null + 1;
842031ca:	31 ea       	MB[r4 + Null] = rMAC;

    return TRUE;
842031cc:	0a 00       	r0 = rMAC + Null;

842031ce <Lc_aud_cur_ups_params_4>:
}
842031ce:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842031d0:	d8 4c       	rts;

842031d2 <$_aud_cur_opmsg_set_ucid>:

bool aud_cur_opmsg_set_ucid(OPERATOR_DATA *op_data,
                            void *message_data,
                            unsigned *resp_length,
                            OP_OPMSG_RSP_PAYLOAD **response_data)
{
842031d2:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842031d4:	12 09       	r8 = r0 + Null;
842031d6:	19 09       	r7 = r1 + Null;
842031d8:	27 00       	r5 = r2 + Null;
842031da:	28 09       	r6 = r3 + Null;
842031dc:	ef fd eb ff 	call (m) 0x934;
842031e0:	39 ea 
842031e2:	16 00       	r4 = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    PS_KEY_TYPE key;
    bool success;

    success = cpsSetUcidMsgHandler(&p_class_data->param_def, message_data,
                                  resp_length, response_data);
842031e4:	32 32       	r0 = r4 + 40;
842031e6:	45 08       	r3 = r6 + Null;
842031e8:	3c 00       	r2 = r5 + Null;
842031ea:	4b 08       	r1 = r7 + Null;
842031ec:	ef fd ed ff 	call (m) 0xd92;
842031f0:	27 ed 
842031f2:	17 00       	r5 = r0 + Null;
    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(p_class_data->cap_id,
                                         p_class_data->param_def.ucid,
                                         OPMSG_P_STORE_PARAMETER_SUB_ID);
842031f4:	f1 99       	rMAC = M[r4 + 60];
842031f6:	8a c6       	r0 = rMAC AND 0xffff;
842031f8:	92 55       	r0 = r0 LSHIFT 7;
842031fa:	b1 99       	rMAC = M[r4 + 56];
842031fc:	8b c2       	r1 = rMAC AND 0x3f;
842031fe:	1b 54       	r1 = r1 LSHIFT 1;
84203200:	9b 12       	r1 = r1 OR r0;

    ps_entry_read((void*)op_data, key, PERSIST_ANY, aud_cur_ups_params);
84203202:	42 f0 15 f0 	r3 = Null + 69218725;
84203206:	a5 61 
84203208:	04 00       	r2 = Null + Null;
8420320a:	52 08       	r0 = r8 + Null;
8420320c:	ff fd 28 f0 	call (m) 0x8370;
84203210:	25 eb 

    return success;
84203212:	3a 00       	r0 = r5 + Null;

84203214 <Lc_aud_cur_opmsg_set_ucid_2>:
}
84203214:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84203216:	d8 4c       	rts;

84203218 <$_aud_cur_opmsg_get_ps_id>:

bool aud_cur_opmsg_get_ps_id(OPERATOR_DATA *op_data,
                             void *message_data,
                             unsigned *resp_length,
                             OP_OPMSG_RSP_PAYLOAD **response_data)
{
84203218:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420321a:	1f 00       	r5 = r1 + Null;
8420321c:	26 00       	r4 = r2 + Null;
8420321e:	28 09       	r6 = r3 + Null;
84203220:	ef fd eb ff 	call (m) 0x934;
84203224:	35 e8 
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    return cpsGetUcidMsgHandler(&p_class_data->param_def, p_class_data->cap_id,
                                message_data, resp_length, response_data);
84203226:	10 1c       	pushm <r6>;
84203228:	d3 99       	r1 = M[r0 + 60];
8420322a:	35 00       	r3 = r4 + Null;
8420322c:	12 32       	r0 = r0 + 40;
8420322e:	3c 00       	r2 = r5 + Null;
84203230:	ef fd ed ff 	call (m) 0xdb4;
84203234:	25 ec 
84203236:	7f 4c       	SP = SP + -4;

84203238 <Lc_aud_cur_opmsg_get_ps_id_2>:
}
84203238:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420323a:	d8 4c       	rts;

8420323c <$_aud_cur_calc_samples>:
/****************************************************************************
Process Data
*/

unsigned aud_cur_calc_samples(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
8420323c:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420323e:	43 de       	M[FP + 32] = r1;
84203240:	ef fd eb ff 	call (m) 0x934;
84203244:	35 e7 
84203246:	16 00       	r4 = r0 + Null;

    unsigned min_data, min_space, block_size, amount, i, samples;
    tCbuffer **p_inputs, **p_outputs;

    /* If no input terminal connections then do nothing */
    if (p_class_data->sinks.connected == 0)
84203248:	f1 87       	rMAC = MHU[r4 + 14];
8420324a:	03 62       	if NE jump (m) Lc_aud_cur_calc_samples_3;

8420324c <Lc_aud_cur_calc_samples_2>:
    {
        return 0;
8420324c:	02 00       	r0 = Null + Null;
8420324e:	4b 6e       	jump (m) Lc_aud_cur_calc_samples_23;

84203250 <Lc_aud_cur_calc_samples_3>:
    }

    /* Initialize data */
    block_size = p_class_data->block_size;
84203250:	6b f0 09 88 	r9 = M[r4 + 36];

    /* Find the minimum amount of data available in the input buffers */
    min_data = UINT_MAX;
84203254:	0a f0 01 24 	r8 = Null - 1;
    p_inputs = p_class_data->sinks.p_buffer_list;
84203258:	68 f0 04 88 	r6 = M[r4 + 16];

    for (i = 0; i < p_class_data->sinks.max; i++)
8420325c:	07 00       	r5 = Null + Null;

8420325e <Lc_aud_cur_calc_samples_4>:
8420325e:	31 87       	rMAC = MHU[r4 + 8];
84203260:	78 04       	Null = r5 - rMAC;
84203262:	02 f0 a7 e0 	if C jump (m) Lc_aud_cur_calc_samples_10;

84203266 <Lc_aud_cur_calc_samples_5>:
    {
        if (p_inputs[i] != NULL)
84203266:	82 f0 00 e8 	r0 = M[r6 + Null];
8420326a:	0c 60       	if EQ jump (m) Lc_aud_cur_calc_samples_9;

8420326c <Lc_aud_cur_calc_samples_6>:
        {
            amount = cbuffer_calc_amount_data_in_words(p_inputs[i]);
8420326c:	ff fd 54 f2 	call (m) 0x4db5a;
84203270:	2f e7 
            if (amount < min_data)
84203272:	af f2 00 c2 	Null = r0 - r8;
84203276:	02 f0 8d e0 	if C jump (m) Lc_aud_cur_calc_samples_9;

8420327a <Lc_aud_cur_calc_samples_7>:
            {
                /* Need at least one block of data available */
                if (amount < block_size)
8420327a:	bf f2 00 c2 	Null = r0 - r9;
8420327e:	e7 65       	if NC jump (m) Lc_aud_cur_calc_samples_2;

84203280 <Lc_aud_cur_calc_samples_8>:
                {
                    return 0;
                }
                min_data = amount;
84203280:	12 09       	r8 = r0 + Null;

84203282 <Lc_aud_cur_calc_samples_9>:

    /* Find the minimum amount of data available in the input buffers */
    min_data = UINT_MAX;
    p_inputs = p_class_data->sinks.p_buffer_list;

    for (i = 0; i < p_class_data->sinks.max; i++)
84203282:	7f 20       	r5 = r5 + 1;
84203284:	20 75       	r6 = r6 + 4;
84203286:	ec 6f       	jump (m) Lc_aud_cur_calc_samples_4;

84203288 <Lc_aud_cur_calc_samples_10>:
            }
        }
    }

    /* Find the minimum amount of space available at the output buffers */
    min_space = UINT_MAX;
84203288:	47 24       	r5 = Null - 1;
    p_outputs = p_class_data->sources.p_buffer_list;
8420328a:	69 f0 07 88 	r7 = M[r4 + 28];

    if (p_class_data->sources.connected > 0)
8420328e:	71 97       	rMAC = MHU[r4 + 26];
84203290:	17 60       	if EQ jump (m) Lc_aud_cur_calc_samples_18;

84203292 <Lc_aud_cur_calc_samples_11>:
    {
        for (i = 0; i < p_class_data->sources.max; i++)
84203292:	00 09       	r6 = Null + Null;

84203294 <Lc_aud_cur_calc_samples_12>:
84203294:	b1 96       	rMAC = MHU[r4 + 20];
84203296:	1f f8 00 c2 	Null = r6 - rMAC;
8420329a:	02 f0 a5 e0 	if C jump (m) Lc_aud_cur_calc_samples_18;

8420329e <Lc_aud_cur_calc_samples_13>:
        {
            if (p_outputs[i] != NULL)
8420329e:	92 f0 00 e8 	r0 = M[r7 + Null];
842032a2:	0b 60       	if EQ jump (m) Lc_aud_cur_calc_samples_17;

842032a4 <Lc_aud_cur_calc_samples_14>:
            {
                amount = cbuffer_calc_amount_space_in_words(p_outputs[i]);
842032a4:	ff fd 54 f2 	call (m) 0x4db14;
842032a8:	31 e3 
                if (amount < min_space)
842032aa:	d0 05       	Null = r0 - r5;
842032ac:	02 f0 8d e0 	if C jump (m) Lc_aud_cur_calc_samples_17;

842032b0 <Lc_aud_cur_calc_samples_15>:
                {
                    /* Need at least one block of space available */
                    if (amount < block_size)
842032b0:	bf f2 00 c2 	Null = r0 - r9;
842032b4:	cc 65       	if NC jump (m) Lc_aud_cur_calc_samples_2;

842032b6 <Lc_aud_cur_calc_samples_16>:
                    {
                        return 0;
                    }
                    min_space = amount;
842032b6:	17 00       	r5 = r0 + Null;

842032b8 <Lc_aud_cur_calc_samples_17>:
    min_space = UINT_MAX;
    p_outputs = p_class_data->sources.p_buffer_list;

    if (p_class_data->sources.connected > 0)
    {
        for (i = 0; i < p_class_data->sources.max; i++)
842032b8:	08 75       	r6 = r6 + 1;
842032ba:	21 75       	r7 = r7 + 4;
842032bc:	ec 6f       	jump (m) Lc_aud_cur_calc_samples_12;

842032be <Lc_aud_cur_calc_samples_18>:
            }
        }
    }

    /* Update kick flags */
    touched->sources = p_class_data->sources.connected;
842032be:	71 97       	rMAC = MHU[r4 + 26];
842032c0:	42 d8       	r0 = M[FP + 32];
842032c2:	11 ee       	M[r0 + Null] = rMAC;

    /* Samples to process is the smaller of data or space available */
    if (min_data < min_space)
842032c4:	7f fa 00 c2 	Null = r8 - r5;
842032c8:	02 f0 89 e0 	if C jump (m) Lc_aud_cur_calc_samples_20;

842032cc <Lc_aud_cur_calc_samples_19>:
    {
        samples = min_data;
842032cc:	52 08       	r0 = r8 + Null;
842032ce:	02 6e       	jump (m) Lc_aud_cur_calc_samples_21;

842032d0 <Lc_aud_cur_calc_samples_20>:
    }
    else
    {
        samples = min_space;
842032d0:	3a 00       	r0 = r5 + Null;

842032d2 <Lc_aud_cur_calc_samples_21>:
    }

    /* If there is less than a block left then kick backwards */
    if (min_data - samples < block_size)
842032d2:	2f fa 01 c2 	rMAC = r8 - r0;
842032d6:	bf f1 00 c2 	Null = rMAC - r9;
842032da:	02 f0 8b e0 	if C jump (m) Lc_aud_cur_calc_samples_23;

842032de <Lc_aud_cur_calc_samples_22>:
    {
        touched->sinks = p_class_data->sinks.connected;
842032de:	f1 87       	rMAC = MHU[r4 + 14];
842032e0:	43 d8       	r1 = M[FP + 32];
842032e2:	59 8e       	M[r1 + 4] = rMAC;

842032e4 <Lc_aud_cur_calc_samples_23>:
    }

    return samples;
842032e4:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842032e6:	d8 4c       	rts;

842032e8 <$_aud_cur_mic_data_transfer>:
}

unsigned aud_cur_mic_data_transfer(OPERATOR_DATA *op_data,
                                   unsigned amount,
                                   unsigned terminal_skip_mask)
{
842032e8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842032ea:	1a 09       	r8 = r1 + Null;
842032ec:	44 de       	M[FP + 32] = r2;
842032ee:	ef fd eb ff 	call (m) 0x934;
842032f2:	27 e2 
842032f4:	4a de       	M[FP + 36] = r0;
842032f6:	11 00       	rMAC = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    unsigned i, mic_amt, temp_amt;
    tCbuffer **ip_buffers, **op_buffers;

    ip_buffers = p_class_data->sinks.p_buffer_list;
842032f8:	09 89       	rMAC = M[rMAC + 16];
    op_buffers = p_class_data->sources.p_buffer_list;
842032fa:	d2 89       	r0 = M[r0 + 28];

    /* Copy mic stream data */
    mic_amt = amount;
842032fc:	53 09       	r9 = r8 + Null;

    for (i = 1; i < p_class_data->sinks.max; i++)
842032fe:	46 20       	r4 = Null + 1;
84203300:	18 f0 04 20 	r6 = rMAC + 4;
84203304:	17 21       	r5 = r0 + 4;
84203306:	0d 6e       	jump (m) Lc_aud_cur_mic_data_transfer_6;

84203308 <Lc_aud_cur_mic_data_transfer_2>:
                                            ip_buffers[i],
                                            amount);
                }
                else
                {
                    cbuffer_advance_read_ptr(ip_buffers[i], amount);
84203308:	53 08       	r1 = r8 + Null;
8420330a:	ff fd 54 f2 	call (m) 0x4db68;
8420330e:	3f e2 

84203310 <Lc_aud_cur_mic_data_transfer_3>:
                }
                if (temp_amt < mic_amt)
84203310:	bf f9 00 c2 	Null = r7 - r9;
84203314:	02 f0 87 e0 	if C jump (m) Lc_aud_cur_mic_data_transfer_5;

84203318 <Lc_aud_cur_mic_data_transfer_4>:
                {
                    mic_amt = temp_amt;
84203318:	4b 09       	r9 = r7 + Null;

8420331a <Lc_aud_cur_mic_data_transfer_5>:
    op_buffers = p_class_data->sources.p_buffer_list;

    /* Copy mic stream data */
    mic_amt = amount;

    for (i = 1; i < p_class_data->sinks.max; i++)
8420331a:	76 20       	r4 = r4 + 1;
8420331c:	20 75       	r6 = r6 + 4;
8420331e:	3f 21       	r5 = r5 + 4;

84203320 <Lc_aud_cur_mic_data_transfer_6>:
84203320:	49 d8       	rMAC = M[FP + 36];
84203322:	09 87       	rMAC = MHU[rMAC + 8];
84203324:	70 04       	Null = r4 - rMAC;
84203326:	02 f0 ad e0 	if C jump (m) Lc_aud_cur_mic_data_transfer_11;

8420332a <Lc_aud_cur_mic_data_transfer_7>:
    {
        if(!(AUD_CUR_GET_TERMINAL_POS(i) & terminal_skip_mask))
8420332a:	31 00       	rMAC = r4 + Null;
8420332c:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84203330:	41 d8       	rMAC = M[FP + 32];
84203332:	89 10       	rMAC = rMAC AND r0;
84203334:	f3 63       	if NE jump (m) Lc_aud_cur_mic_data_transfer_5;

84203336 <Lc_aud_cur_mic_data_transfer_8>:
        {
            /* Perform copy/advance if terminal number (i) is not in
             * terminal_skip_mask
             */
            temp_amt = amount;
84203336:	51 09       	r7 = r8 + Null;
            if (ip_buffers[i] != NULL)
84203338:	82 f0 00 e8 	r0 = M[r6 + Null];
8420333c:	ef 61       	if EQ jump (m) Lc_aud_cur_mic_data_transfer_5;

8420333e <Lc_aud_cur_mic_data_transfer_9>:
            {
                if (op_buffers[i] != NULL)
8420333e:	39 e8       	rMAC = M[r5 + Null];
84203340:	e4 61       	if EQ jump (m) Lc_aud_cur_mic_data_transfer_2;

84203342 <Lc_aud_cur_mic_data_transfer_10>:
                {
                    temp_amt = cbuffer_copy(op_buffers[i],
                                            ip_buffers[i],
                                            amount);
84203342:	54 08       	r2 = r8 + Null;
84203344:	13 00       	r1 = r0 + Null;
84203346:	0a 00       	r0 = rMAC + Null;
84203348:	ff fd 55 f2 	call (m) 0x4dda4;
8420334c:	3d e2 
8420334e:	11 09       	r7 = r0 + Null;
84203350:	e0 6f       	jump (m) Lc_aud_cur_mic_data_transfer_3;

84203352 <Lc_aud_cur_mic_data_transfer_11>:
                }
            }
        }
    }

    return mic_amt;
84203352:	5a 08       	r0 = r9 + Null;

84203354 <Lc_aud_cur_mic_data_transfer_12>:

}
84203354:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84203356:	d8 4c       	rts;

84203358 <$_aud_cur_mic_metadata_transfer>:

unsigned aud_cur_mic_metadata_transfer(OPERATOR_DATA *op_data, unsigned amount)
{
84203358:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420335a:	1e 00       	r4 = r1 + Null;
8420335c:	ef fd ea ff 	call (m) 0x934;
84203360:	39 ee 
84203362:	11 00       	rMAC = r0 + Null;
    AUDIO_CURATION_DEF *p_class_data = get_class_data(op_data);
    tCbuffer *p_metadata_ip, *p_metadata_op;
    /* Only copy metadata if samples were transferred */
    if (amount > 0)
84203364:	30 04       	Null = r4 - Null;
84203366:	07 60       	if EQ jump (m) Lc_aud_cur_mic_metadata_transfer_3;

84203368 <Lc_aud_cur_mic_metadata_transfer_2>:
    {
        p_metadata_ip = p_class_data->metadata_ip[AUD_CUR_METADATA_MIC];
84203368:	8a a9       	r0 = M[rMAC + 88];
        p_metadata_op = p_class_data->metadata_op[AUD_CUR_METADATA_MIC];
8420336a:	0b b8       	r1 = M[rMAC + 96];

        metadata_strict_transport(p_metadata_ip,
                                  p_metadata_op,
                                  amount * OCTETS_PER_SAMPLE);
8420336c:	74 54       	r2 = r4 LSHIFT 2;
8420336e:	ff fd 8b f0 	call (m) 0x14af0;
84203372:	23 ec 

84203374 <Lc_aud_cur_mic_metadata_transfer_3>:
    }
    return amount;
84203374:	32 00       	r0 = r4 + Null;

84203376 <Lc_aud_cur_mic_metadata_transfer_4>:
}
84203376:	f1 48       	popm <FP, r4, rLink>;
84203378:	d8 4c       	rts;

8420337a <Lc_aud_cur_connect_terminal_1>:
 */
static void aud_cur_connect_terminal(AUD_CUR_TERMINAL *p_def,
                                     uint16 num,
                                     tCbuffer *p_buffer)
{
    p_def->p_buffer_list[num] = p_buffer;
8420337a:	91 88       	rMAC = M[r0 + 8];
8420337c:	5d 54       	r3 = r1 LSHIFT 2;
8420337e:	4c ef       	M[rMAC + r3] = r2;
    p_def->connected |= (uint16)(1 << num);
84203380:	00 f3 93 de 	r1 = 0x1 LSHIFT r1;
84203384:	d1 86       	rMAC = MHU[r0 + 6];
84203386:	c9 12       	rMAC = rMAC OR r1;
84203388:	d1 8c       	MH[r0 + 6] = rMAC;

8420338a <Lc_aud_cur_connect_terminal_2>:
    return;
8420338a:	d8 4c       	rts;

8420338c <Lc_aud_cur_disconnect_terminal_1>:
 * \return - NONE
 */
static void aud_cur_disconnect_terminal(AUD_CUR_TERMINAL *p_def,
                                        uint16 num)
{
    p_def->p_buffer_list[num] = NULL;
8420338c:	91 88       	rMAC = M[r0 + 8];
8420338e:	5c 54       	r2 = r1 LSHIFT 2;
84203390:	08 ef       	M[rMAC + r2] = Null;
    p_def->connected &= (uint16)(~(1 << num));
84203392:	00 f3 93 de 	r1 = 0x1 LSHIFT r1;
84203396:	ff f3 51 d6 	rMAC = -1 - r1;
8420339a:	d3 86       	r1 = MHU[r0 + 6];
8420339c:	c9 10       	rMAC = rMAC AND r1;
8420339e:	d1 8c       	MH[r0 + 6] = rMAC;

842033a0 <Lc_aud_cur_disconnect_terminal_2>:
    return;
842033a0:	d8 4c       	rts;

842033a2 <Lc_aud_cur_connect_metadata_1>:
    unsigned idx;

    /* Select the correct metadata buffer */
    if (num == AUD_CUR_PLAYBACK_TERMINAL)
    {
        idx = AUD_CUR_METADATA_PLAYBACK;
842033a2:	05 00       	r3 = Null + Null;
842033a4:	18 04       	Null = r1 - Null;
842033a6:	21 f0 45 ce 	if NE r3 = Null + 1;
    {
        idx = AUD_CUR_METADATA_MIC;
    }

    /* Populate the metadata buffer */
    if (p_metadata_list[idx] == NULL && buff_has_metadata(p_buffer))
842033aa:	6b 54       	r1 = r3 LSHIFT 2;
842033ac:	9a 00       	r0 = r1 + r0;
842033ae:	11 e8       	rMAC = M[r0 + Null];
842033b0:	04 62       	if NE jump (m) Lc_aud_cur_connect_metadata_4;

842033b2 <Lc_aud_cur_connect_metadata_2>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(const tCbuffer *buff)
{
    if (buff->metadata != NULL)
842033b2:	a1 89       	rMAC = M[r2 + 24];
842033b4:	02 60       	if EQ jump (m) Lc_aud_cur_connect_metadata_4;

842033b6 <Lc_aud_cur_connect_metadata_3>:
    {
            p_metadata_list[idx] = p_buffer;
842033b6:	14 ee       	M[r0 + Null] = r2;

842033b8 <Lc_aud_cur_connect_metadata_4>:
842033b8:	d8 4c       	rts;

842033ba <Lc_aud_cur_disconnect_metadata_1>:
 * \return - None
 */
static void aud_cur_disconnect_metadata(tCbuffer **p_metadata_list,
                                        AUD_CUR_TERMINAL *p_def,
                                        uint16 num)
{
842033ba:	72 1c       	pushm <FP(=SP), r4, r5>;
    int i;
    tCbuffer *p_buffer;
    tCbuffer **p_buffer_list;

    /* Playback metadata only travels on a single terminal */
    if (num == AUD_CUR_PLAYBACK_TERMINAL)
842033bc:	20 04       	Null = r2 - Null;
842033be:	03 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_3;

842033c0 <Lc_aud_cur_disconnect_metadata_2>:
    {
        p_metadata_list[AUD_CUR_METADATA_PLAYBACK] = NULL;
842033c0:	10 ee       	M[r0 + Null] = Null;
842033c2:	17 6e       	jump (m) Lc_aud_cur_disconnect_metadata_11;

842033c4 <Lc_aud_cur_disconnect_metadata_3>:
    }

    /* Look for metadata on another terminal if the terminal being used for
     * metadata is being disconnected.
     */
    p_buffer_list = p_def->p_buffer_list;
842033c4:	99 88       	rMAC = M[r1 + 8];
    if (p_metadata_list[AUD_CUR_METADATA_MIC] == p_buffer_list[num])
842033c6:	55 88       	r3 = M[r0 + 4];
842033c8:	66 54       	r4 = r2 LSHIFT 2;
842033ca:	8e e9       	r4 = M[rMAC + r4];
842033cc:	a8 05       	Null = r3 - r4;
842033ce:	11 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_11;

842033d0 <Lc_aud_cur_disconnect_metadata_4>:
    {
        /* Set the metadata buffer to NULL and populate if a replacement is
         * available.
         */
        p_metadata_list[AUD_CUR_METADATA_MIC] = NULL;
842033d0:	50 8e       	M[r0 + 4] = Null;
842033d2:	1b e6       	r1 = MHU[r1 + Null];

        /* Iterate through microphone terminals */
        for (i = (AUD_CUR_PLAYBACK_TERMINAL + 1); i < p_def->max; i++)
842033d4:	45 20       	r3 = Null + 1;
842033d6:	0e 21       	r4 = rMAC + 4;

842033d8 <Lc_aud_cur_disconnect_metadata_5>:
842033d8:	e8 04       	Null = r3 - r1;
842033da:	0b 66       	if GE jump (m) Lc_aud_cur_disconnect_metadata_11;

842033dc <Lc_aud_cur_disconnect_metadata_6>:
        {
            /* Don't look at the terminal that is being disconnected */
            if (i == num)
842033dc:	28 05       	Null = r3 - r2;
842033de:	05 60       	if EQ jump (m) Lc_aud_cur_disconnect_metadata_9;

842033e0 <Lc_aud_cur_disconnect_metadata_7>:
            {
                continue;
            }
            /* Update the metadata buffer with the new buffer information */
            p_buffer = p_buffer_list[i];
            if (p_buffer != NULL && buff_has_metadata(p_buffer))
842033e0:	31 e8       	rMAC = M[r4 + Null];
842033e2:	03 60       	if EQ jump (m) Lc_aud_cur_disconnect_metadata_9;

842033e4 <Lc_aud_cur_disconnect_metadata_8>:
842033e4:	8f 89       	r5 = M[rMAC + 24];
842033e6:	04 62       	if NE jump (m) Lc_aud_cur_disconnect_metadata_10;

842033e8 <Lc_aud_cur_disconnect_metadata_9>:
         * available.
         */
        p_metadata_list[AUD_CUR_METADATA_MIC] = NULL;

        /* Iterate through microphone terminals */
        for (i = (AUD_CUR_PLAYBACK_TERMINAL + 1); i < p_def->max; i++)
842033e8:	6d 20       	r3 = r3 + 1;
842033ea:	36 21       	r4 = r4 + 4;
842033ec:	f6 6f       	jump (m) Lc_aud_cur_disconnect_metadata_5;

842033ee <Lc_aud_cur_disconnect_metadata_10>:
            }
            /* Update the metadata buffer with the new buffer information */
            p_buffer = p_buffer_list[i];
            if (p_buffer != NULL && buff_has_metadata(p_buffer))
            {
                p_metadata_list[AUD_CUR_METADATA_MIC] = p_buffer;
842033ee:	51 8e       	M[r0 + 4] = rMAC;

842033f0 <Lc_aud_cur_disconnect_metadata_11>:
                break;
842033f0:	72 48       	popm <FP, r4, r5>;
842033f2:	d8 4c       	rts;

842033f4 <Lc_aud_cur_connect_common_1>:
static bool aud_cur_connect_common(OPERATOR_DATA *op_data,
                                   void *message_data,
                                   unsigned *response_id,
                                   void **response_data,
                                   bool connect)
{
842033f4:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842033f6:	42 de       	M[FP + 32] = r0;
842033f8:	19 09       	r7 = r1 + Null;
842033fa:	26 00       	r4 = r2 + Null;
842033fc:	4d de       	M[FP + 36] = r3;
842033fe:	f9 d9       	rMAC = M[FP + -4];
84203400:	51 de       	M[FP + 40] = rMAC;
84203402:	ef fd ea ff 	call (m) 0x934;
84203406:	33 e9 
84203408:	13 09       	r9 = r0 + Null;
    tCbuffer **p_metadata_list;
    AUD_CUR_TERMINAL *p_terminal;

    /* Verify class data and create response */
    if ((p_class_data == NULL) ||
        (!base_op_connect(op_data, message_data, response_id, response_data)))
8420340a:	0a 60       	if EQ jump (m) Lc_aud_cur_connect_common_3;

8420340c <Lc_aud_cur_connect_common_2>:
8420340c:	34 00       	r2 = r4 + Null;
8420340e:	4b 08       	r1 = r7 + Null;
84203410:	4d d8       	r3 = M[FP + 36];
84203412:	42 d8       	r0 = M[FP + 32];
84203414:	ef fd e9 ff 	call (m) 0x7c8;
84203418:	35 ed 
8420341a:	10 04       	Null = r0 - Null;
8420341c:	03 62       	if NE jump (m) Lc_aud_cur_connect_common_4;

8420341e <Lc_aud_cur_connect_common_3>:
    {
        return FALSE;
8420341e:	02 00       	r0 = Null + Null;
84203420:	90 6e       	jump (m) Lc_aud_cur_connect_common_30;

84203422 <Lc_aud_cur_connect_common_4>:
    }

    /* Prevent runtime connection */
    if (opmgr_op_is_running(op_data))
84203422:	42 d8       	r0 = M[FP + 32];
84203424:	ff fd 14 f0 	call (m) 0x5ca4;
84203428:	21 e4 
8420342a:	10 04       	Null = r0 - Null;
8420342c:	06 60       	if EQ jump (m) Lc_aud_cur_connect_common_7;

8420342e <Lc_aud_cur_connect_common_5>:
    {
        /* Exception: allow runtime disconnection if the flag is set */
        if (connect || !p_class_data->runtime_disconnect)
8420342e:	51 d8       	rMAC = M[FP + 40];
84203430:	29 62       	if NE jump (m) Lc_aud_cur_connect_common_13;

84203432 <Lc_aud_cur_connect_common_6>:
84203432:	b1 f0 04 82 	rMAC = MBU[r9 + 4];
84203436:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_13;

84203438 <Lc_aud_cur_connect_common_7>:
            return TRUE;
        }
    }

    /* Get the terminal ID, number, and determine whether sink or source */
    terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84203438:	9a f0 00 e8 	r8 = M[r7 + Null];
    terminal_num = (uint16)(terminal_id & TERMINAL_NUM_MASK);
8420343c:	a7 f0 3f 00 	r5 = r8 AND 0x3f;
    terminal_pos = (uint16)AUD_CUR_GET_TERMINAL_POS(terminal_num);
84203440:	39 00       	rMAC = r5 + Null;
84203442:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84203446:	91 c6       	rMAC = r0 AND 0xffff;
    is_sink = terminal_id & TERMINAL_SINK_MASK;

    /* Setup the selected terminal */
    if (is_sink)
84203448:	40 f0 a3 f0 	r1 = r8 AND 0x800000;
8420344c:	00 00 
8420344e:	07 60       	if EQ jump (m) Lc_aud_cur_connect_common_9;

84203450 <Lc_aud_cur_connect_common_8>:
    {
        p_terminal = &p_class_data->sinks;
84203450:	b3 f0 08 20 	r1 = r9 + 8;
84203454:	1e 00       	r4 = r1 + Null;
        p_metadata_list = p_class_data->metadata_ip;
84203456:	38 f0 4c 20 	r6 = r1 + 76;
8420345a:	06 6e       	jump (m) Lc_aud_cur_connect_common_10;

8420345c <Lc_aud_cur_connect_common_9>:
    }
    else
    {
        p_terminal = &p_class_data->sources;
8420345c:	b3 f0 14 20 	r1 = r9 + 20;
84203460:	1e 00       	r4 = r1 + Null;
        p_metadata_list = p_class_data->metadata_op;
84203462:	38 f0 48 20 	r6 = r1 + 72;

84203466 <Lc_aud_cur_connect_common_10>:
    }

    /* Make sure the terminal is valid */
    if (terminal_num >= p_terminal->max)
84203466:	33 e6       	r1 = MHU[r4 + Null];
84203468:	f8 04       	Null = r5 - r1;
8420346a:	12 68       	if LT jump (m) Lc_aud_cur_connect_common_14;

8420346c <Lc_aud_cur_connect_common_11>:
    {
        L4_DBG_MSG1("base aud cur connect: terminal num %d is out \
                    of max range", terminal_num);
8420346c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84203470:	08 25       	Null = rMAC - 4;
84203472:	08 68       	if LT jump (m) Lc_aud_cur_connect_common_13;

84203474 <Lc_aud_cur_connect_common_12>:
84203474:	55 f1 02 f0 	r0 = Null + 357567476;
84203478:	f4 53 
8420347a:	3b 00       	r1 = r5 + Null;
8420347c:	ef fd ee ff 	call (m) 0x10c2;
84203480:	27 e2 

84203482 <Lc_aud_cur_connect_common_13>:
84203482:	01 f0 00 60 	rMAC = Null + 4096;
84203486:	4a d8       	r0 = M[FP + 36];
84203488:	12 e8       	r0 = M[r0 + Null];
8420348a:	51 8e       	M[r0 + 4] = rMAC;
8420348c:	59 6e       	jump (m) Lc_aud_cur_connect_common_29;

8420348e <Lc_aud_cur_connect_common_14>:
        return TRUE;
    }

    /* Make sure the terminal is not marked as invalid */
    if (p_terminal->max_valid_mask &&
       !(p_terminal->max_valid_mask & terminal_pos))
8420348e:	b3 86       	r1 = MHU[r4 + 4];
84203490:	0f 60       	if EQ jump (m) Lc_aud_cur_connect_common_18;

84203492 <Lc_aud_cur_connect_common_15>:
84203492:	c9 10       	rMAC = rMAC AND r1;
84203494:	0d 62       	if NE jump (m) Lc_aud_cur_connect_common_18;

84203496 <Lc_aud_cur_connect_common_16>:
    {
        L4_DBG_MSG1("base aud cur connect: invalid terminal number %d",
                    terminal_num);
84203496:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420349a:	08 25       	Null = rMAC - 4;
8420349c:	f3 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

8420349e <Lc_aud_cur_connect_common_17>:
8420349e:	55 f1 02 f0 	r0 = Null + 357567554;
842034a2:	42 58 
842034a4:	3b 00       	r1 = r5 + Null;
842034a6:	ef fd ee ff 	call (m) 0x10c2;
842034aa:	3d e0 
842034ac:	eb 6f       	jump (m) Lc_aud_cur_connect_common_13;

842034ae <Lc_aud_cur_connect_common_18>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (connect)
842034ae:	51 d8       	rMAC = M[FP + 40];
842034b0:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_24;

842034b2 <Lc_aud_cur_connect_common_19>:
 * \return - TRUE if the terminal is connected
 */
static inline bool aud_cur_is_terminal_connected(AUD_CUR_TERMINAL *p_def,
                                                 uint16 num)
{
    return (p_def->connected & (1 << num)) > 0;
842034b2:	f1 86       	rMAC = MHU[r4 + 6];
842034b4:	52 10       	r0 = r0 AND rMAC;
842034b6:	01 00       	rMAC = Null + Null;
842034b8:	10 04       	Null = r0 - Null;
842034ba:	2c f0 41 ce 	if GT rMAC = Null + 1;
        return TRUE;
    }

    if (connect)
    {
        if (aud_cur_is_terminal_connected(p_terminal, terminal_num))
842034be:	08 04       	Null = rMAC - Null;
842034c0:	0d 60       	if EQ jump (m) Lc_aud_cur_connect_common_22;

842034c2 <Lc_aud_cur_connect_common_20>:
        {
            L4_DBG_MSG1("base aud cur connect: terminal %d already connected",
                        terminal_num);
842034c2:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
842034c6:	08 25       	Null = rMAC - 4;
842034c8:	dd 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

842034ca <Lc_aud_cur_connect_common_21>:
842034ca:	55 f1 02 f0 	r0 = Null + 357567603;
842034ce:	73 58 
842034d0:	3b 00       	r1 = r5 + Null;
842034d2:	ef fd ed ff 	call (m) 0x10c2;
842034d6:	31 ef 
842034d8:	d5 6f       	jump (m) Lc_aud_cur_connect_common_13;

842034da <Lc_aud_cur_connect_common_22>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        /* Connect the terminal */
        tCbuffer *p_buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842034da:	99 f0 01 88 	r7 = M[r7 + 4];
        aud_cur_connect_terminal(p_terminal, terminal_num, p_buffer);
842034de:	4c 08       	r2 = r7 + Null;
842034e0:	3b 00       	r1 = r5 + Null;
842034e2:	32 00       	r0 = r4 + Null;
842034e4:	4b 4f       	call (m) Lc_aud_cur_connect_terminal_1;
        aud_cur_connect_metadata(p_metadata_list, terminal_num, p_buffer);
842034e6:	4c 08       	r2 = r7 + Null;
842034e8:	3b 00       	r1 = r5 + Null;
842034ea:	42 08       	r0 = r6 + Null;
842034ec:	5b 4f       	call (m) Lc_aud_cur_connect_metadata_1;

        if (p_class_data->connect_fn != NULL)
842034ee:	b1 f0 12 88 	rMAC = M[r9 + 72];
842034f2:	26 60       	if EQ jump (m) Lc_aud_cur_connect_common_29;

842034f4 <Lc_aud_cur_connect_common_23>:
        {
            p_class_data->connect_fn(op_data, terminal_id);
842034f4:	53 08       	r1 = r8 + Null;
842034f6:	42 d8       	r0 = M[FP + 32];
842034f8:	d1 4c       	call rMAC;
842034fa:	22 6e       	jump (m) Lc_aud_cur_connect_common_29;

842034fc <Lc_aud_cur_connect_common_24>:
 * \return - TRUE if the terminal is connected
 */
static inline bool aud_cur_is_terminal_connected(AUD_CUR_TERMINAL *p_def,
                                                 uint16 num)
{
    return (p_def->connected & (1 << num)) > 0;
842034fc:	f1 86       	rMAC = MHU[r4 + 6];
842034fe:	52 10       	r0 = r0 AND rMAC;
84203500:	01 00       	rMAC = Null + Null;
84203502:	10 04       	Null = r0 - Null;
84203504:	2c f0 41 ce 	if GT rMAC = Null + 1;
            p_class_data->connect_fn(op_data, terminal_id);
        }
    }
    else
    {
        if (!aud_cur_is_terminal_connected(p_terminal, terminal_num))
84203508:	08 04       	Null = rMAC - Null;
8420350a:	0d 62       	if NE jump (m) Lc_aud_cur_connect_common_27;

8420350c <Lc_aud_cur_connect_common_25>:
        {
            L4_DBG_MSG1("base aud cur connect: terminal %d not connected",
                        terminal_num);
8420350c:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
84203510:	08 25       	Null = rMAC - 4;
84203512:	b8 69       	if LT jump (m) Lc_aud_cur_connect_common_13;

84203514 <Lc_aud_cur_connect_common_26>:
84203514:	55 f1 02 f0 	r0 = Null + 357567655;
84203518:	a7 58 
8420351a:	3b 00       	r1 = r5 + Null;
8420351c:	ef fd ed ff 	call (m) 0x10c2;
84203520:	27 ed 
84203522:	b0 6f       	jump (m) Lc_aud_cur_connect_common_13;

84203524 <Lc_aud_cur_connect_common_27>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }

        aud_cur_disconnect_metadata(p_metadata_list, p_terminal, terminal_num);
84203524:	3c 00       	r2 = r5 + Null;
84203526:	33 00       	r1 = r4 + Null;
84203528:	42 08       	r0 = r6 + Null;
8420352a:	48 4f       	call (m) Lc_aud_cur_disconnect_metadata_1;
        aud_cur_disconnect_terminal(p_terminal, terminal_num);
8420352c:	3b 00       	r1 = r5 + Null;
8420352e:	32 00       	r0 = r4 + Null;
84203530:	2e 4f       	call (m) Lc_aud_cur_disconnect_terminal_1;

        if (p_class_data->disconnect_fn != NULL)
84203532:	b1 f0 13 88 	rMAC = M[r9 + 76];
84203536:	04 60       	if EQ jump (m) Lc_aud_cur_connect_common_29;

84203538 <Lc_aud_cur_connect_common_28>:
        {
            p_class_data->disconnect_fn(op_data, terminal_id);
84203538:	53 08       	r1 = r8 + Null;
8420353a:	42 d8       	r0 = M[FP + 32];
8420353c:	d1 4c       	call rMAC;

8420353e <Lc_aud_cur_connect_common_29>:
    {
        /* Exception: allow runtime disconnection if the flag is set */
        if (connect || !p_class_data->runtime_disconnect)
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
8420353e:	42 20       	r0 = Null + 1;

84203540 <Lc_aud_cur_connect_common_30>:
        {
            p_class_data->disconnect_fn(op_data, terminal_id);
        }
    }
    return TRUE;
}
84203540:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84203542:	d8 4c       	rts;

84203544 <Lc_aud_cur_check_valid_terminals_1>:
 * \param  p_term           Pointer to the terminal information
 *
 * \return - result TRUE if the terminals are valid
 */
static bool aud_cur_check_valid_terminals(AUD_CUR_TERMINAL *p_term)
{
84203544:	c8 1c       	pushm <FP(=SP), rLink>;
    /* No validity mask to test */
    if (p_term->min_valid_mask == 0)
84203546:	51 86       	rMAC = MHU[r0 + 2];
84203548:	03 62       	if NE jump (m) Lc_aud_cur_check_valid_terminals_3;

8420354a <Lc_aud_cur_check_valid_terminals_2>:
    {
        return TRUE;
8420354a:	42 20       	r0 = Null + 1;
8420354c:	10 6e       	jump (m) Lc_aud_cur_check_valid_terminals_7;

8420354e <Lc_aud_cur_check_valid_terminals_3>:
    }

    /* Connection mask doesn't have at least the valid mask bits */
    if ((p_term->min_valid_mask & p_term->connected) != p_term->min_valid_mask)
8420354e:	d3 86       	r1 = MHU[r0 + 6];
84203550:	5a 10       	r0 = r1 AND rMAC;
84203552:	50 04       	Null = r0 - rMAC;
84203554:	fb 61       	if EQ jump (m) Lc_aud_cur_check_valid_terminals_2;

84203556 <Lc_aud_cur_check_valid_terminals_4>:
    {
        L4_DBG_MSG1("base aud cur start: invalid terminals %hu",
                    p_term->connected);
84203556:	01 f0 34 91 	rMAC = MBS[Null + 0x334];
8420355a:	08 25       	Null = rMAC - 4;
8420355c:	07 68       	if LT jump (m) Lc_aud_cur_check_valid_terminals_6;

8420355e <Lc_aud_cur_check_valid_terminals_5>:
8420355e:	55 f1 02 f0 	r0 = Null + 357567703;
84203562:	d7 58 
84203564:	ef fd ed ff 	call (m) 0x10c2;
84203568:	3f ea 

8420356a <Lc_aud_cur_check_valid_terminals_6>:
        return FALSE;
8420356a:	02 00       	r0 = Null + Null;

8420356c <Lc_aud_cur_check_valid_terminals_7>:
    }

    return TRUE;
}
8420356c:	c8 48       	popm <FP, rLink>;
8420356e:	d8 4c       	rts;

84203570 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_anc_hw_manager_cap_data;
84203570:	01 f0 02 f3 	r0 = Null + 1441792;
84203574:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84203576:	00 f0 4c 5a 	Null = Null + 3660;

8420357a <$_ahm_calc_ramp_tc>:
.MODULE $M.anc_hw_manager_ramp.calc_ramp_tc;
    .CODESEGMENT PM;

$_ahm_calc_ramp_tc:

    PUSH_ALL_C
8420357a:	fc fa 40 e0 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
8420357e:	07 f0 47 e4 	pushm <I0, I1, I2, I4, I5, I6>;
84203582:	70 ff 40 e4 	pushm <M0, M1, M2, L0, L1, L4, L5>;
    // constant corresponding
    // r0: t (seconds, Q7.N)
    // r1: L (frame size)
    // r2: fs (sample rate)

    r2 = r1;
84203586:	1c 00       	r2 = r1 + Null;
    r1 = 1; // Frame size effectively handled via sample rate input
84203588:	43 20       	r1 = Null + 1;

    // calculating alpha based on frame size (r1) and sampling rate (r2)

    // 1/t
    r6 = SIGNDET r0;
8420358a:	0f f2 88 cd 	r6 = SIGNDET r0;
    r0 = r0 ASHIFT r6;
8420358e:	00 f8 32 c9 	r0 = r0 ASHIFT r6;
    rMAC = 0.25;
84203592:	00 f2 01 f0 	rMAC = Null + 536870912;
84203596:	00 40 
    div = rMAC/r0;
84203598:	91 4c       	Div = rMAC / r0;

    // t in Q12.20      (r6 = r6 - 12;)
    // div guard bit    (r6 = r6 + 1;)
    // Q8.24 pow2 input (r6 = r6 - 7;)
    // r6 = r6 + (-12 + 1 - 7)
    r6 = r6 - 18;
8420359a:	88 f0 12 24 	r6 = r6 - 18;

    // 1/t result
    r3 = divResult;
8420359e:	c5 4c       	r3 = DivResult;

    //r2 = fs
    //r1 = L
    r0 = -r1;
842035a0:	c2 04       	r0 = Null - r1;
    rMAC = r0 ASHIFT -1;
842035a2:	7f f2 1e d9 	rMAC = r0 ASHIFT -1 (MI);
    Div = rMAC/r2;
842035a6:	a1 4c       	Div = rMAC / r2;
    //r0 = (-L/fs);
    r0 = divResult;
842035a8:	c2 4c       	r0 = DivResult;

    // -log2(e)/(fs/L)
    r2 = Qfmt_(1.442695040888963, 8);
842035aa:	17 f0 a4 f0 	r2 = Null + 24204406;
842035ae:	76 68 
    r0 = r2 *r0;
842035b0:	2f f4 c2 cc 	r0 = r2 * r0 (SS);
    r0 = r0 ASHIFT 7;
842035b4:	92 5d       	r0 = r0 ASHIFT 7;

    // -log2(e)/(fs/L)*(1/t)

    rMAC = r0 * r3;
842035b6:	5f f2 c1 cc 	rMAC = r0 * r3 (SS);
    r0 = rMAC ASHIFT r6;
842035ba:	8f f1 02 c9 	r0 = rMAC ASHIFT r6;

    // exp(-1/(t*(fs/L)))
    call $math.pow2_taylor;
842035be:	ff fd 67 f4 	call 0x90558;
842035c2:	3a ec 

    // alfa_c = exp(-1/(t*(fs/L)))
    r3 = r0;
842035c4:	15 00       	r3 = r0 + Null;
    // alfa = 1 - exp(-1/(t*(fs/L)))
    r1 = 1.0 - r3;
842035c6:	ff f7 ff ff 	r1 = 2147483647 - r3;
842035ca:	ff f5 53 c6 

    POP_ALL_C
842035ce:	70 ff 60 e4 	popm <M0, M1, M2, L0, L1, L4, L5>;
842035d2:	07 f0 67 e4 	popm <I0, I1, I2, I4, I5, I6>;
842035d6:	fc fa 60 e0 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;

    // Multiply by 4 approximates the true settling time
    r0 = r1 ASHIFT $anc_hw_manager_ramp.AHM_TC_APPROX_SHIFT;
842035da:	5a 5c       	r0 = r1 ASHIFT 2;

    rts;
842035dc:	d8 4c       	rts;

842035de <$_ahm_calc_gain_db>:
.MODULE $M.ahm_gain.calc_gain_db;
    .CODESEGMENT PM;

$_ahm_calc_gain_db:

    pushm <r6, rLink>;
842035de:	90 1c       	pushm <r6, rLink>;

    Null = r0;
842035e0:	10 00       	Null = r0 + Null;
    if Z jump return_early;
842035e2:	0e 60       	if EQ jump (m) $M.ahm_gain.calc_gain_db.return_early;

842035e4 <$M.ahm_gain.calc_gain_db.calc_fine_gain_db>:

calc_fine_gain_db:
    rMAC = r0; // Copy fine gain to rMAC, in Q40.32
842035e4:	11 00       	rMAC = r0 + Null;
    r3 = r1 * $ahm_gain.COARSE_GAIN_TO_DB (int); // Store coarse gain dB value in r3
842035e6:	9d 41       	r3 = r1 * 6 (int);

    // Fine gain measured relative to 128, so needs to be scaled by 2^-7
    // log2_table takes input (rMAC) in Q9.63, so shift rMAC by 63-32-7=24
    rMAC = rMAC ASHIFT $ahm_gain.FINE_GAIN_LOG2_SHIFT_AMT (72bit);
842035e8:	49 5f       	rMAC = rMAC ASHIFT 24 (56bit);
    r3 = r3 ASHIFT $ahm_gain.COARSE_GAIN_DB_SHIFT_AMT; // Coarse gain (dB) in Q12.20
842035ea:	ed 5e       	r3 = r3 ASHIFT 20;

    call $math.log2_table;
842035ec:	ff fd 68 f4 	call 0x9064c;
842035f0:	20 e3 

    // Convert to dB by using multiplying factor of 20/log2(10)
    rMAC = r0 * $ahm_gain.LOG2_TO_DB_CONV_FACTOR;
842035f2:	02 f3 30 fa 	rMAC = r0 * 0.376287494786083698272705078125 (SS);
842035f6:	4a f2 d1 cc 
    r0 = rMAC + r3; // Add coarse gain (dB) and fine gain (dB)
842035fa:	4a 01       	r0 = rMAC + r3;
    jump return_db_gain;
842035fc:	04 6e       	jump (m) $M.ahm_gain.calc_gain_db.return_db_gain;

842035fe <$M.ahm_gain.calc_gain_db.return_early>:

return_early:
    r0 = MININT;
842035fe:	00 f8 02 f0 	r0 = Null + -2147483648;
84203602:	00 40 

84203604 <$M.ahm_gain.calc_gain_db.return_db_gain>:

return_db_gain:
    popm <r6, rLink>;
84203604:	90 48       	popm <r6, rLink>;

    rts;
84203606:	d8 4c       	rts;

84203608 <$_ahm_convert_db_to_log2>:
.MODULE $M.ahm_gain.convert_db_to_log2;
    .CODESEGMENT PM;

$_ahm_convert_db_to_log2:

    rMAC = r0 * $ahm_gain.DB_TO_LOG2_CONV_FACTOR;
84203608:	a8 f2 55 f2 	rMAC = r0 * 8.11018981039524078369140625e-05 (SS);
8420360c:	d1 dc 
    // Q12.20 * Q12.20 = Q24.40
    // Automatically get a left shift by 1 bit for 63 fractional bits (Q23.41)
    // Left shift by 11 recovers to Q12
    rMAC = rMAC ASHIFT 11 (72bit);
8420360e:	05 f1 11 d9 	rMAC = rMAC ASHIFT 11 (56bit);

    r0 = rMAC;
84203612:	0a 00       	r0 = rMAC + Null;
    rts;
84203614:	d8 4c       	rts;

84203616 <$_aud_cur_calc_adjusted_gain>:
84203616:	1b 30       	r1 = r1 + 32;

    // Round makeup gain before converting to Q8.24
    // Formula: gain = (gain + (1 << (shift-1))) >> shift
    r1 = r1 + $aud_cur.MAKEUP_GAIN_TO_Q8_ROUND;
    // Convert makeup gain to Q8.24
    r2 = r1 ASHIFT $aud_cur.MAKEUP_GAIN_TO_Q8;
84203618:	5c 59       	r2 = r1 ASHIFT -6;
    // If makeup gain is 0 then r0 is returned untouched
    if Z jump calc_target_gain_rts;
8420361a:	16 60       	if EQ jump (m) $M.aud_cur.calc_adjusted_gain.calc_target_gain_rts;

    pushm <r6, r7, rLink>;
8420361c:	30 f2 40 e0 	pushm <r6, r7, rLink>;

    rMAC = r0; // Copy fine gain to rMAC, in Q40.32
84203620:	11 00       	rMAC = r0 + Null;
    // Fine gain measured relative to 128, so needs to be scaled by 2^-7
    // log2_table takes input (rMAC) in Q9.63, so shift rMAC by 63-32-7=24
    rMAC = rMAC ASHIFT $aud_cur.FINE_GAIN_LOG2_SHIFT_AMT (72bit);
84203622:	49 5f       	rMAC = rMAC ASHIFT 24 (56bit);

    // log2_table trashes rMAC, r0, r1, r6
    call $math.log2_table;
84203624:	ff fd 68 f4 	call 0x9064c;
84203628:	28 e1 
    // r0 is now log2 in Q8.24

    // Add makeup gain to static gain
    r0 = r0 + r2;
8420362a:	a2 00       	r0 = r2 + r0;

    // subtract (log10) 6dB to make sure the total gain is < 0
    r0 = r0 - $aud_cur.SUBTRACT_1_Q8;
8420362c:	00 f4 22 f0 	r0 = r0 - 16777216;
84203630:	00 24 

    // Convert back to normal value
    call $math.pow2_table;
84203632:	ff fd 67 f4 	call 0x905b4;
84203636:	22 ec 

    // round r0 before converting to gain step value.
    r0 = r0 + $aud_cur.NORMALIZED_TO_GAIN_STEP_ROUND;
84203638:	04 f0 02 f0 	r0 = r0 + 4194304;
8420363c:	00 44 

    // r0 now has the normalized value
    r0 = r0 ASHIFT $aud_cur.NORMALIZED_TO_GAIN_STEP;
8420363e:	74 f2 12 d9 	r0 = r0 ASHIFT -23;

    // Upper bounds check is provided in the pow2_table function and limits
    // the returned value to just less than 2.

    popm <r6, r7, rLink>;
84203642:	30 f2 60 e0 	popm <r6, r7, rLink>;

84203646 <$M.aud_cur.calc_adjusted_gain.calc_target_gain_rts>:
calc_target_gain_rts:

    rts;
84203646:	d8 4c       	rts;
