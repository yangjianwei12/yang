// -----------------------------------------------------------------------------
// Copyright (c) 2023                  Qualcomm Technologies International, Ltd.
//
// Generated by /home/svc-audio-dspsw/kymera_builds/builds/2023/kymera_2312060823/kalimba/kymera/../../util/CommonParameters/DerivationEngine.py
// code v3.5, file //depot/dspsw/maor_rom_v20/util/CommonParameters/DerivationEngine.py, revision 2
// namespace {com.csr.cps.4}UnifiedParameterSchema on 2023-12-06 09:00:32 by svc-audio-dspsw
//
// input from EMPTY
// last change  by  on 
// -----------------------------------------------------------------------------
#ifndef __NOISE_ID_GEN_ASM_H__
#define __NOISE_ID_GEN_ASM_H__

// CodeBase IDs
.CONST $M.NOISE_ID_NOISE_ID_CAP_ID       	0x00EB;
.CONST $M.NOISE_ID_NOISE_ID_ALT_CAP_ID_0       	0x40D1;
.CONST $M.NOISE_ID_NOISE_ID_SAMPLE_RATE       	16000;
.CONST $M.NOISE_ID_NOISE_ID_VERSION_MAJOR       	1;

// Constant Values


// Piecewise Disables
// NOISE_ID_CONFIG bits
.CONST $M.NOISE_ID.CONFIG.NOISE_ID_CONFIG.BYPASS                   		0x00000001;
.CONST $M.NOISE_ID.CONFIG.NOISE_ID_CONFIG.DISABLE_ED               		0x00000002;
.CONST $M.NOISE_ID.CONFIG.NOISE_ID_CONFIG.DISABLE_ED_E_FILTER_CHECK		0x00000004;


// Statistic Block
.CONST $M.NOISE_ID.STATUS.CUR_MODE        		0*ADDR_PER_WORD;
.CONST $M.NOISE_ID.STATUS.OVR_CONTROL     		1*ADDR_PER_WORD;
.CONST $M.NOISE_ID.STATUS.NOISE_ID        		2*ADDR_PER_WORD;
.CONST $M.NOISE_ID.STATUS.LOW_TO_MID_RATIO		3*ADDR_PER_WORD;
.CONST $M.NOISE_ID.STATUS.FLAGS           		4*ADDR_PER_WORD;
.CONST $M.NOISE_ID.STATUS.BLOCK_SIZE           	5;

// System Mode
.CONST $M.NOISE_ID.SYSMODE.STANDBY		0;
.CONST $M.NOISE_ID.SYSMODE.FULL   		2;
.CONST $M.NOISE_ID.SYSMODE.MAX_MODES		3;

// System Control
.CONST $M.NOISE_ID.CONTROL.MODE_OVERRIDE		0x2000;

// Noise ID classification

// Flags
.CONST $M.NOISE_ID.FLAGS.ED		0x00000001;

// Parameter Block
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_NOISE_ID_CONFIG                  		0*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_POWER_RATIO_THRESHOLD            		1*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_FILTER_ATTACK_TIME               		2*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_FILTER_DECAY_TIME                		3*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_NID_HOLD_TIMER                   		4*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_ENVELOPE                      		5*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_RATIO                         		6*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_MIN_SIGNAL                    		7*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_MIN_MAX_ENVELOPE              		8*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_DELTA_TH                      		9*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_HOLD_FRAMES                   		10*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_E_FILTER_MIN_THRESHOLD        		11*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_ED_E_FILTER_MIN_COUNTER_THRESHOLD		12*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_POWER_RATIO_ID0_THRESHOLD        		13*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.OFFSET_POWER_RATIO_ID1_THRESHOLD        		14*ADDR_PER_WORD;
.CONST $M.NOISE_ID.PARAMETERS.STRUCT_SIZE                            		15;


#endif // __NOISE_ID_GEN_ASM_H__
